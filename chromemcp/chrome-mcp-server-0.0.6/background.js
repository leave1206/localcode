var background = function() {
  "use strict";var __defProp2 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __reflectGet = Reflect.get;
var __knownSymbol = (name2, symbol) => (symbol = Symbol[name2]) ? symbol : Symbol.for("Symbol." + name2);
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __pow = Math.pow;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp2(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var __superGet = (cls, obj, key) => __reflectGet(__getProtoOf(cls), key, obj);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};
var __await = function(promise, isYieldStar) {
  this[0] = promise;
  this[1] = isYieldStar;
};
var __yieldStar = (value) => {
  var obj = value[__knownSymbol("asyncIterator")], isAwait = false, method, it = {};
  if (obj == null) {
    obj = value[__knownSymbol("iterator")]();
    method = (k) => it[k] = (x) => obj[k](x);
  } else {
    obj = obj.call(value);
    method = (k) => it[k] = (v) => {
      if (isAwait) {
        isAwait = false;
        if (k === "throw") throw v;
        return v;
      }
      isAwait = true;
      return {
        done: false,
        value: new __await(new Promise((resolve) => {
          var x = obj[k](v);
          if (!(x instanceof Object)) __typeError("Object expected");
          resolve(x);
        }), 1)
      };
    };
  }
  return it[__knownSymbol("iterator")] = () => it, method("next"), "throw" in obj ? method("throw") : it.throw = (x) => {
    throw x;
  }, "return" in obj && method("return"), it;
};

  var _a, _b, _c;
  function _mergeNamespaces(n, m) {
    for (var i = 0; i < m.length; i++) {
      const e = m[i];
      if (typeof e !== "string" && !Array.isArray(e)) {
        for (const k in e) {
          if (k !== "default" && !(k in n)) {
            const d = Object.getOwnPropertyDescriptor(e, k);
            if (d) {
              Object.defineProperty(n, k, d.get ? d : {
                enumerable: true,
                get: () => e[k]
              });
            }
          }
        }
      }
    }
    return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
  }
  function defineBackground(arg) {
    if (arg == null || typeof arg === "function") return { main: arg };
    return arg;
  }
  var NativeMessageType = /* @__PURE__ */ ((NativeMessageType2) => {
    NativeMessageType2["START"] = "start";
    NativeMessageType2["STARTED"] = "started";
    NativeMessageType2["STOP"] = "stop";
    NativeMessageType2["STOPPED"] = "stopped";
    NativeMessageType2["PING"] = "ping";
    NativeMessageType2["PONG"] = "pong";
    NativeMessageType2["ERROR"] = "error";
    NativeMessageType2["PROCESS_DATA"] = "process_data";
    NativeMessageType2["PROCESS_DATA_RESPONSE"] = "process_data_response";
    NativeMessageType2["CALL_TOOL"] = "call_tool";
    NativeMessageType2["CALL_TOOL_RESPONSE"] = "call_tool_response";
    NativeMessageType2["SERVER_STARTED"] = "server_started";
    NativeMessageType2["SERVER_STOPPED"] = "server_stopped";
    NativeMessageType2["ERROR_FROM_NATIVE_HOST"] = "error_from_native_host";
    NativeMessageType2["CONNECT_NATIVE"] = "connectNative";
    NativeMessageType2["PING_NATIVE"] = "ping_native";
    NativeMessageType2["DISCONNECT_NATIVE"] = "disconnect_native";
    return NativeMessageType2;
  })(NativeMessageType || {});
  var TOOL_NAMES = {
    BROWSER: {
      GET_WINDOWS_AND_TABS: "get_windows_and_tabs",
      SEARCH_TABS_CONTENT: "search_tabs_content",
      NAVIGATE: "chrome_navigate",
      SCREENSHOT: "chrome_screenshot",
      CLOSE_TABS: "chrome_close_tabs",
      GO_BACK_OR_FORWARD: "chrome_go_back_or_forward",
      WEB_FETCHER: "chrome_get_web_content",
      CLICK: "chrome_click_element",
      FILL: "chrome_fill_or_select",
      GET_INTERACTIVE_ELEMENTS: "chrome_get_interactive_elements",
      NETWORK_CAPTURE_START: "chrome_network_capture_start",
      NETWORK_CAPTURE_STOP: "chrome_network_capture_stop",
      NETWORK_REQUEST: "chrome_network_request",
      NETWORK_DEBUGGER_START: "chrome_network_debugger_start",
      NETWORK_DEBUGGER_STOP: "chrome_network_debugger_stop",
      KEYBOARD: "chrome_keyboard",
      HISTORY: "chrome_history",
      BOOKMARK_SEARCH: "chrome_bookmark_search",
      BOOKMARK_ADD: "chrome_bookmark_add",
      BOOKMARK_DELETE: "chrome_bookmark_delete",
      INJECT_SCRIPT: "chrome_inject_script",
      SEND_COMMAND_TO_INJECT_SCRIPT: "chrome_send_command_to_inject_script",
      CONSOLE: "chrome_console"
    }
  };
  const BACKGROUND_MESSAGE_TYPES = {
    SWITCH_SEMANTIC_MODEL: "switch_semantic_model",
    GET_MODEL_STATUS: "get_model_status",
    UPDATE_MODEL_STATUS: "update_model_status",
    GET_STORAGE_STATS: "get_storage_stats",
    CLEAR_ALL_DATA: "clear_all_data",
    GET_SERVER_STATUS: "get_server_status",
    REFRESH_SERVER_STATUS: "refresh_server_status",
    SERVER_STATUS_CHANGED: "server_status_changed",
    INITIALIZE_SEMANTIC_ENGINE: "initialize_semantic_engine"
  };
  const OFFSCREEN_MESSAGE_TYPES = {
    SIMILARITY_ENGINE_INIT: "similarityEngineInit",
    SIMILARITY_ENGINE_COMPUTE: "similarityEngineCompute",
    SIMILARITY_ENGINE_BATCH_COMPUTE: "similarityEngineBatchCompute",
    SIMILARITY_ENGINE_STATUS: "similarityEngineStatus"
  };
  const TOOL_MESSAGE_TYPES = {
    // Screenshot related
    SCREENSHOT_PREPARE_PAGE_FOR_CAPTURE: "preparePageForCapture",
    SCREENSHOT_GET_PAGE_DETAILS: "getPageDetails",
    SCREENSHOT_GET_ELEMENT_DETAILS: "getElementDetails",
    SCREENSHOT_SCROLL_PAGE: "scrollPage",
    SCREENSHOT_RESET_PAGE_AFTER_CAPTURE: "resetPageAfterCapture",
    // Web content fetching
    WEB_FETCHER_GET_HTML_CONTENT: "getHtmlContent",
    WEB_FETCHER_GET_TEXT_CONTENT: "getTextContent",
    // User interactions
    CLICK_ELEMENT: "clickElement",
    FILL_ELEMENT: "fillElement",
    SIMULATE_KEYBOARD: "simulateKeyboard",
    // Interactive elements
    GET_INTERACTIVE_ELEMENTS: "getInteractiveElements",
    // Network requests
    NETWORK_SEND_REQUEST: "sendPureNetworkRequest",
    // Semantic similarity engine
    SIMILARITY_ENGINE_INIT: "similarityEngineInit",
    SIMILARITY_ENGINE_COMPUTE_BATCH: "similarityEngineComputeBatch"
  };
  background;
  const NATIVE_HOST = {
    NAME: "com.chromemcp.nativehost",
    DEFAULT_PORT: 12306
  };
  const TIMEOUTS = {
    DEFAULT_WAIT: 1e3,
    KEYBOARD_DELAY: 50
  };
  const LIMITS = {
    MAX_NETWORK_REQUESTS: 100,
    MAX_SEARCH_RESULTS: 50
  };
  const ERROR_MESSAGES = {
    NATIVE_CONNECTION_FAILED: "Failed to connect to native host",
    NATIVE_DISCONNECTED: "Native connection disconnected",
    SERVER_STATUS_LOAD_FAILED: "Failed to load server status",
    SERVER_STATUS_SAVE_FAILED: "Failed to save server status",
    TOOL_EXECUTION_FAILED: "Tool execution failed",
    INVALID_PARAMETERS: "Invalid parameters provided",
    PERMISSION_DENIED: "Permission denied",
    TAB_NOT_FOUND: "Tab not found",
    ELEMENT_NOT_FOUND: "Element not found",
    NETWORK_ERROR: "Network error occurred"
  };
  const SUCCESS_MESSAGES = {
    TOOL_EXECUTED: "Tool executed successfully",
    CONNECTION_ESTABLISHED: "Connection established",
    SERVER_STARTED: "Server started successfully",
    SERVER_STOPPED: "Server stopped successfully"
  };
  const NETWORK_FILTERS = {
    EXCLUDED_DOMAINS: [
      "google-analytics.com",
      "googletagmanager.com",
      "facebook.com",
      "doubleclick.net",
      "googlesyndication.com"
    ]
  };
  const STORAGE_KEYS = {
    SERVER_STATUS: "serverStatus",
    SEMANTIC_MODEL: "semanticModel",
    USER_PREFERENCES: "userPreferences",
    VECTOR_INDEX: "vectorIndex"
  };
  var ExecutionWorld = /* @__PURE__ */ ((ExecutionWorld2) => {
    ExecutionWorld2["ISOLATED"] = "ISOLATED";
    ExecutionWorld2["MAIN"] = "MAIN";
    return ExecutionWorld2;
  })(ExecutionWorld || {});
  background;
  const createErrorResponse = (message2 = "Unknown error, please try again") => {
    return {
      content: [
        {
          type: "text",
          text: message2
        }
      ],
      isError: true
    };
  };
  background;
  const PING_TIMEOUT_MS = 300;
  class BaseBrowserToolExecutor {
    /**
     * Inject content script into tab
     */
    injectContentScript(tabId, files, injectImmediately = false, world = "ISOLATED") {
      return __async(this, null, function* () {
        console.log(`Injecting ${files.join(", ")} into tab ${tabId}`);
        try {
          const response = yield Promise.race([
            chrome.tabs.sendMessage(tabId, { action: `${this.name}_ping` }),
            new Promise(
              (_, reject) => setTimeout(
                () => reject(new Error(`${this.name} Ping action to tab ${tabId} timed out`)),
                PING_TIMEOUT_MS
              )
            )
          ]);
          if (response && response.status === "pong") {
            console.log(
              `pong received for action '${this.name}' in tab ${tabId}. Assuming script is active.`
            );
            return;
          } else {
            console.warn(`Unexpected ping response in tab ${tabId}:`, response);
          }
        } catch (error) {
          console.error(
            `ping content script failed: ${error instanceof Error ? error.message : String(error)}`
          );
        }
        try {
          yield chrome.scripting.executeScript({
            target: { tabId },
            files,
            injectImmediately,
            world
          });
          console.log(`'${files.join(", ")}' injection successful for tab ${tabId}`);
        } catch (injectionError) {
          const errorMessage = injectionError instanceof Error ? injectionError.message : String(injectionError);
          console.error(
            `Content script '${files.join(", ")}' injection failed for tab ${tabId}: ${errorMessage}`
          );
          throw new Error(
            `${ERROR_MESSAGES.TOOL_EXECUTION_FAILED}: Failed to inject content script in tab ${tabId}: ${errorMessage}`
          );
        }
      });
    }
    /**
     * Send message to tab
     */
    sendMessageToTab(tabId, message2) {
      return __async(this, null, function* () {
        try {
          const response = yield chrome.tabs.sendMessage(tabId, message2);
          if (response && response.error) {
            throw new Error(String(response.error));
          }
          return response;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          console.error(
            `Error sending message to tab ${tabId} for action ${(message2 == null ? void 0 : message2.action) || "unknown"}: ${errorMessage}`
          );
          if (error instanceof Error) {
            throw error;
          }
          throw new Error(errorMessage);
        }
      });
    }
  }
  background;
  const DEFAULT_WINDOW_WIDTH = 1280;
  const DEFAULT_WINDOW_HEIGHT = 720;
  class NavigateTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NAVIGATE);
    }
    execute(args) {
      return __async(this, null, function* () {
        const { newWindow = false, width, height, url, refresh = false } = args;
        console.log(
          `Attempting to ${refresh ? "refresh current tab" : `open URL: ${url}`} with options:`,
          args
        );
        try {
          if (refresh) {
            console.log("Refreshing current active tab");
            const [activeTab] = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (!activeTab || !activeTab.id) {
              return createErrorResponse("No active tab found to refresh");
            }
            yield chrome.tabs.reload(activeTab.id);
            console.log(`Refreshed tab ID: ${activeTab.id}`);
            const updatedTab = yield chrome.tabs.get(activeTab.id);
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify({
                    success: true,
                    message: "Successfully refreshed current tab",
                    tabId: updatedTab.id,
                    windowId: updatedTab.windowId,
                    url: updatedTab.url
                  })
                }
              ],
              isError: false
            };
          }
          if (!url) {
            return createErrorResponse("URL parameter is required when refresh is not true");
          }
          console.log(`Checking if URL is already open: ${url}`);
          const allTabs = yield chrome.tabs.query({});
          const tabs = allTabs.filter((tab) => {
            var _a2;
            const tabUrl = ((_a2 = tab.url) == null ? void 0 : _a2.endsWith("/")) ? tab.url.slice(0, -1) : tab.url;
            const targetUrl = url.endsWith("/") ? url.slice(0, -1) : url;
            return tabUrl === targetUrl;
          });
          console.log(`Found ${tabs.length} matching tabs`);
          if (tabs && tabs.length > 0) {
            const existingTab = tabs[0];
            console.log(
              `URL already open in Tab ID: ${existingTab.id}, Window ID: ${existingTab.windowId}`
            );
            if (existingTab.id !== void 0) {
              yield chrome.tabs.update(existingTab.id, { active: true });
              if (existingTab.windowId !== void 0) {
                yield chrome.windows.update(existingTab.windowId, { focused: true });
              }
              console.log(`Activated existing Tab ID: ${existingTab.id}`);
              const updatedTab = yield chrome.tabs.get(existingTab.id);
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify({
                      success: true,
                      message: "Activated existing tab",
                      tabId: updatedTab.id,
                      windowId: updatedTab.windowId,
                      url: updatedTab.url
                    })
                  }
                ],
                isError: false
              };
            }
          }
          const openInNewWindow = newWindow || typeof width === "number" || typeof height === "number";
          if (openInNewWindow) {
            console.log("Opening URL in a new window.");
            const newWindow2 = yield chrome.windows.create({
              url,
              width: typeof width === "number" ? width : DEFAULT_WINDOW_WIDTH,
              height: typeof height === "number" ? height : DEFAULT_WINDOW_HEIGHT,
              focused: true
            });
            if (newWindow2 && newWindow2.id !== void 0) {
              console.log(`URL opened in new Window ID: ${newWindow2.id}`);
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify({
                      success: true,
                      message: "Opened URL in new window",
                      windowId: newWindow2.id,
                      tabs: newWindow2.tabs ? newWindow2.tabs.map((tab) => ({
                        tabId: tab.id,
                        url: tab.url
                      })) : []
                    })
                  }
                ],
                isError: false
              };
            }
          } else {
            console.log("Opening URL in the last active window.");
            const lastFocusedWindow = yield chrome.windows.getLastFocused({ populate: false });
            if (lastFocusedWindow && lastFocusedWindow.id !== void 0) {
              console.log(`Found last focused Window ID: ${lastFocusedWindow.id}`);
              const newTab = yield chrome.tabs.create({
                url,
                windowId: lastFocusedWindow.id,
                active: true
              });
              yield chrome.windows.update(lastFocusedWindow.id, { focused: true });
              console.log(
                `URL opened in new Tab ID: ${newTab.id} in existing Window ID: ${lastFocusedWindow.id}`
              );
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify({
                      success: true,
                      message: "Opened URL in new tab in existing window",
                      tabId: newTab.id,
                      windowId: lastFocusedWindow.id,
                      url: newTab.url
                    })
                  }
                ],
                isError: false
              };
            } else {
              console.warn("No last focused window found, falling back to creating a new window.");
              const fallbackWindow = yield chrome.windows.create({
                url,
                width: DEFAULT_WINDOW_WIDTH,
                height: DEFAULT_WINDOW_HEIGHT,
                focused: true
              });
              if (fallbackWindow && fallbackWindow.id !== void 0) {
                console.log(`URL opened in fallback new Window ID: ${fallbackWindow.id}`);
                return {
                  content: [
                    {
                      type: "text",
                      text: JSON.stringify({
                        success: true,
                        message: "Opened URL in new window",
                        windowId: fallbackWindow.id,
                        tabs: fallbackWindow.tabs ? fallbackWindow.tabs.map((tab) => ({
                          tabId: tab.id,
                          url: tab.url
                        })) : []
                      })
                    }
                  ],
                  isError: false
                };
              }
            }
          }
          return createErrorResponse("Failed to open URL: Unknown error occurred");
        } catch (error) {
          if (chrome.runtime.lastError) {
            console.error(`Chrome API Error: ${chrome.runtime.lastError.message}`, error);
            return createErrorResponse(`Chrome API Error: ${chrome.runtime.lastError.message}`);
          } else {
            console.error("Error in navigate:", error);
            return createErrorResponse(
              `Error navigating to URL: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
      });
    }
  }
  const navigateTool = new NavigateTool();
  class CloseTabsTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.CLOSE_TABS);
    }
    execute(args) {
      return __async(this, null, function* () {
        const { tabIds, url } = args;
        let urlPattern = url;
        console.log(`Attempting to close tabs with options:`, args);
        try {
          if (urlPattern) {
            console.log(`Searching for tabs with URL: ${url}`);
            if (!urlPattern.endsWith("/")) {
              urlPattern += "/*";
            }
            const tabs = yield chrome.tabs.query({ url });
            if (!tabs || tabs.length === 0) {
              console.log(`No tabs found with URL: ${url}`);
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify({
                      success: false,
                      message: `No tabs found with URL: ${url}`,
                      closedCount: 0
                    })
                  }
                ],
                isError: false
              };
            }
            console.log(`Found ${tabs.length} tabs with URL: ${url}`);
            const tabIdsToClose = tabs.map((tab) => tab.id).filter((id) => id !== void 0);
            if (tabIdsToClose.length === 0) {
              return createErrorResponse("Found tabs but could not get their IDs");
            }
            yield chrome.tabs.remove(tabIdsToClose);
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify({
                    success: true,
                    message: `Closed ${tabIdsToClose.length} tabs with URL: ${url}`,
                    closedCount: tabIdsToClose.length,
                    closedTabIds: tabIdsToClose
                  })
                }
              ],
              isError: false
            };
          }
          if (tabIds && tabIds.length > 0) {
            console.log(`Closing tabs with IDs: ${tabIds.join(", ")}`);
            const existingTabs = yield Promise.all(
              tabIds.map((tabId) => __async(null, null, function* () {
                try {
                  return yield chrome.tabs.get(tabId);
                } catch (error) {
                  console.warn(`Tab with ID ${tabId} not found`);
                  return null;
                }
              }))
            );
            const validTabIds = existingTabs.filter((tab) => tab !== null).map((tab) => tab.id).filter((id) => id !== void 0);
            if (validTabIds.length === 0) {
              return {
                content: [
                  {
                    type: "text",
                    text: JSON.stringify({
                      success: false,
                      message: "None of the provided tab IDs exist",
                      closedCount: 0
                    })
                  }
                ],
                isError: false
              };
            }
            yield chrome.tabs.remove(validTabIds);
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify({
                    success: true,
                    message: `Closed ${validTabIds.length} tabs`,
                    closedCount: validTabIds.length,
                    closedTabIds: validTabIds,
                    invalidTabIds: tabIds.filter((id) => !validTabIds.includes(id))
                  })
                }
              ],
              isError: false
            };
          }
          console.log("No tabIds or URL provided, closing active tab");
          const [activeTab] = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!activeTab || !activeTab.id) {
            return createErrorResponse("No active tab found");
          }
          yield chrome.tabs.remove(activeTab.id);
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: "Closed active tab",
                  closedCount: 1,
                  closedTabIds: [activeTab.id]
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in CloseTabsTool.execute:", error);
          return createErrorResponse(
            `Error closing tabs: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const closeTabsTool = new CloseTabsTool();
  class GoBackOrForwardTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.GO_BACK_OR_FORWARD);
    }
    execute(args) {
      return __async(this, null, function* () {
        const { isForward = false } = args;
        console.log(`Attempting to navigate ${isForward ? "forward" : "back"} in browser history`);
        try {
          const [activeTab] = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!activeTab || !activeTab.id) {
            return createErrorResponse("No active tab found");
          }
          if (isForward) {
            yield chrome.tabs.goForward(activeTab.id);
            console.log(`Navigated forward in tab ID: ${activeTab.id}`);
          } else {
            yield chrome.tabs.goBack(activeTab.id);
            console.log(`Navigated back in tab ID: ${activeTab.id}`);
          }
          const updatedTab = yield chrome.tabs.get(activeTab.id);
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: `Successfully navigated ${isForward ? "forward" : "back"} in browser history`,
                  tabId: updatedTab.id,
                  windowId: updatedTab.windowId,
                  url: updatedTab.url
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          if (chrome.runtime.lastError) {
            console.error(`Chrome API Error: ${chrome.runtime.lastError.message}`, error);
            return createErrorResponse(`Chrome API Error: ${chrome.runtime.lastError.message}`);
          } else {
            console.error("Error in GoBackOrForwardTool.execute:", error);
            return createErrorResponse(
              `Error navigating ${isForward ? "forward" : "back"}: ${error instanceof Error ? error.message : String(error)}`
            );
          }
        }
      });
    }
  }
  const goBackOrForwardTool = new GoBackOrForwardTool();
  background;
  class WindowTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.GET_WINDOWS_AND_TABS);
    }
    execute() {
      return __async(this, null, function* () {
        try {
          const windows = yield chrome.windows.getAll({ populate: true });
          let tabCount = 0;
          const structuredWindows = windows.map((window2) => {
            var _a2;
            const tabs = ((_a2 = window2.tabs) == null ? void 0 : _a2.map((tab) => {
              tabCount++;
              return {
                tabId: tab.id || 0,
                url: tab.url || "",
                title: tab.title || "",
                active: tab.active || false
              };
            })) || [];
            return {
              windowId: window2.id || 0,
              tabs
            };
          });
          const result2 = {
            windowCount: windows.length,
            tabCount,
            windows: structuredWindows
          };
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in WindowTool.execute:", error);
          return createErrorResponse(
            `Error getting windows and tabs information: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const windowTool = new WindowTool();
  background;
  class TextChunker {
    constructor() {
      __publicField2(this, "defaultOptions", {
        maxWordsPerChunk: 80,
        overlapSentences: 1,
        minChunkLength: 20,
        includeTitle: true
      });
    }
    chunkText(content, title, options) {
      const opts = __spreadValues(__spreadValues({}, this.defaultOptions), options);
      const chunks = [];
      if (opts.includeTitle && (title == null ? void 0 : title.trim()) && title.trim().length > 5) {
        chunks.push({
          text: title.trim(),
          source: "title",
          index: 0,
          wordCount: title.trim().split(/\s+/).length
        });
      }
      const cleanContent = content.trim();
      if (!cleanContent) {
        return chunks;
      }
      const sentences = this.splitIntoSentences(cleanContent);
      if (sentences.length === 0) {
        return this.fallbackChunking(cleanContent, chunks, opts);
      }
      const hasLongSentences = sentences.some(
        (s) => s.split(/\s+/).length > opts.maxWordsPerChunk
      );
      if (hasLongSentences) {
        return this.mixedChunking(sentences, chunks, opts);
      }
      return this.groupSentencesIntoChunks(sentences, chunks, opts);
    }
    splitIntoSentences(content) {
      const processedContent = content.replace(/([。！？])\s*/g, "$1\n").replace(/([.!?])\s+(?=[A-Z])/g, "$1\n").replace(/([.!?]["'])\s+(?=[A-Z])/g, "$1\n").replace(/([.!?])\s*$/gm, "$1\n").replace(/([。！？][""])\s*/g, "$1\n").replace(/\n\s*\n/g, "\n");
      const sentences = processedContent.split("\n").map((s) => s.trim()).filter((s) => s.length > 15);
      if (sentences.length < 3 && content.length > 500) {
        return this.aggressiveSentenceSplitting(content);
      }
      return sentences;
    }
    aggressiveSentenceSplitting(content) {
      const sentences = content.replace(/([.!?。！？])/g, "$1\n").replace(/([;；:：])/g, "$1\n").replace(/([)）])\s*(?=[\u4e00-\u9fa5A-Z])/g, "$1\n").split("\n").map((s) => s.trim()).filter((s) => s.length > 15);
      const maxWordsPerChunk = 80;
      const finalSentences = [];
      for (const sentence of sentences) {
        const words = sentence.split(/\s+/);
        if (words.length <= maxWordsPerChunk) {
          finalSentences.push(sentence);
        } else {
          const overlapWords = 5;
          for (let i = 0; i < words.length; i += maxWordsPerChunk - overlapWords) {
            const chunkWords = words.slice(i, i + maxWordsPerChunk);
            const chunkText = chunkWords.join(" ");
            if (chunkText.length > 15) {
              finalSentences.push(chunkText);
            }
          }
        }
      }
      return finalSentences;
    }
    /**
     * Group sentences into chunks
     */
    groupSentencesIntoChunks(sentences, existingChunks, options) {
      const chunks = [...existingChunks];
      let chunkIndex = chunks.length;
      let i = 0;
      while (i < sentences.length) {
        let currentChunkText = "";
        let currentWordCount = 0;
        let sentencesUsed = 0;
        while (i + sentencesUsed < sentences.length && currentWordCount < options.maxWordsPerChunk) {
          const sentence = sentences[i + sentencesUsed];
          const sentenceWords = sentence.split(/\s+/).length;
          if (currentWordCount + sentenceWords > options.maxWordsPerChunk && currentWordCount > 0) {
            break;
          }
          currentChunkText += (currentChunkText ? " " : "") + sentence;
          currentWordCount += sentenceWords;
          sentencesUsed++;
        }
        if (currentChunkText.trim().length > options.minChunkLength) {
          chunks.push({
            text: currentChunkText.trim(),
            source: `content_chunk_${chunkIndex}`,
            index: chunkIndex,
            wordCount: currentWordCount
          });
          chunkIndex++;
        }
        i += Math.max(1, sentencesUsed - options.overlapSentences);
      }
      return chunks;
    }
    /**
     * Mixed chunking method (handles long sentences)
     */
    mixedChunking(sentences, existingChunks, options) {
      const chunks = [...existingChunks];
      let chunkIndex = chunks.length;
      for (const sentence of sentences) {
        const sentenceWords = sentence.split(/\s+/).length;
        if (sentenceWords <= options.maxWordsPerChunk) {
          chunks.push({
            text: sentence.trim(),
            source: `sentence_chunk_${chunkIndex}`,
            index: chunkIndex,
            wordCount: sentenceWords
          });
          chunkIndex++;
        } else {
          const words = sentence.split(/\s+/);
          for (let i = 0; i < words.length; i += options.maxWordsPerChunk) {
            const chunkWords = words.slice(i, i + options.maxWordsPerChunk);
            const chunkText = chunkWords.join(" ");
            if (chunkText.length > options.minChunkLength) {
              chunks.push({
                text: chunkText,
                source: `long_sentence_chunk_${chunkIndex}_part_${Math.floor(i / options.maxWordsPerChunk)}`,
                index: chunkIndex,
                wordCount: chunkWords.length
              });
            }
          }
          chunkIndex++;
        }
      }
      return chunks;
    }
    /**
     * Fallback chunking (when sentence splitting fails)
     */
    fallbackChunking(content, existingChunks, options) {
      const chunks = [...existingChunks];
      let chunkIndex = chunks.length;
      const paragraphs = content.split(/\n\s*\n/).filter((p) => p.trim().length > options.minChunkLength);
      if (paragraphs.length > 1) {
        paragraphs.forEach((paragraph, index) => {
          const cleanParagraph = paragraph.trim();
          if (cleanParagraph.length > 0) {
            const words = cleanParagraph.split(/\s+/);
            const maxWordsPerChunk = 150;
            for (let i = 0; i < words.length; i += maxWordsPerChunk) {
              const chunkWords = words.slice(i, i + maxWordsPerChunk);
              const chunkText = chunkWords.join(" ");
              if (chunkText.length > options.minChunkLength) {
                chunks.push({
                  text: chunkText,
                  source: `paragraph_${index}_chunk_${Math.floor(i / maxWordsPerChunk)}`,
                  index: chunkIndex,
                  wordCount: chunkWords.length
                });
                chunkIndex++;
              }
            }
          }
        });
      } else {
        const words = content.trim().split(/\s+/);
        const maxWordsPerChunk = 150;
        for (let i = 0; i < words.length; i += maxWordsPerChunk) {
          const chunkWords = words.slice(i, i + maxWordsPerChunk);
          const chunkText = chunkWords.join(" ");
          if (chunkText.length > options.minChunkLength) {
            chunks.push({
              text: chunkText,
              source: `content_chunk_${Math.floor(i / maxWordsPerChunk)}`,
              index: chunkIndex,
              wordCount: chunkWords.length
            });
            chunkIndex++;
          }
        }
      }
      return chunks;
    }
  }
  background;
  let loadHnswlib, waitForFileSystemInitalized;
  (() => __async(null, null, function* () {
    let library;
    waitForFileSystemInitalized = () => {
      const EmscriptenFileSystemManager = library.EmscriptenFileSystemManager;
      return new Promise((resolve, reject) => {
        let totalWaitTime = 0;
        const checkInterval = 100;
        const maxWaitTime = 4e3;
        const checkInitialization = () => {
          if (EmscriptenFileSystemManager.isInitialized()) {
            resolve();
          } else if (totalWaitTime >= maxWaitTime) {
            reject(new Error("Failed to initialize filesystem"));
          } else {
            totalWaitTime += checkInterval;
            setTimeout(checkInitialization, checkInterval);
          }
        };
        setTimeout(checkInitialization, checkInterval);
      });
    };
    const initializeFileSystemAsync = (inputFsType) => __async(null, null, function* () {
      const fsType = inputFsType == null ? "IDBFS" : inputFsType;
      const EmscriptenFileSystemManager = library.EmscriptenFileSystemManager;
      if (EmscriptenFileSystemManager.isInitialized()) {
        return;
      }
      EmscriptenFileSystemManager.initializeFileSystem(fsType);
      return yield waitForFileSystemInitalized();
    });
    loadHnswlib = (inputFsType) => __async(null, null, function* () {
      try {
        if (typeof hnswlib !== "undefined" && hnswlib !== null) {
          const lib2 = hnswlib();
          if (lib2 != null)
            return lib2;
        }
        if (!library) {
          const temp = yield Promise.resolve().then(() => hnswlib210c0872);
          const factoryFunc = temp.default;
          library = yield factoryFunc();
          yield initializeFileSystemAsync(inputFsType);
          return library;
        }
        return library;
      } catch (err) {
        console.error("----------------------------------------");
        console.error("Error initializing the library:", err);
        throw err;
      }
    });
  }))();
  let globalHnswlib = null;
  let globalHnswlibInitPromise = null;
  let globalHnswlibInitialized = false;
  let syncInProgress = false;
  let pendingSyncPromise = null;
  const DB_NAME = "VectorDatabaseStorage";
  const DB_VERSION = 1;
  const STORE_NAME = "documentMappings";
  class IndexedDBHelper {
    static getDB() {
      return __async(this, null, function* () {
        if (!this.dbPromise) {
          this.dbPromise = new Promise((resolve, reject) => {
            const request = indexedDB.open(DB_NAME, DB_VERSION);
            request.onerror = () => reject(request.error);
            request.onsuccess = () => resolve(request.result);
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              if (!db.objectStoreNames.contains(STORE_NAME)) {
                const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
                store.createIndex("indexFileName", "indexFileName", { unique: false });
              }
            };
          });
        }
        return this.dbPromise;
      });
    }
    static saveData(indexFileName, data) {
      return __async(this, null, function* () {
        const db = yield this.getDB();
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const store = transaction.objectStore(STORE_NAME);
        yield new Promise((resolve, reject) => {
          const request = store.put({
            id: indexFileName,
            indexFileName,
            data,
            timestamp: Date.now()
          });
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      });
    }
    static loadData(indexFileName) {
      return __async(this, null, function* () {
        const db = yield this.getDB();
        const transaction = db.transaction([STORE_NAME], "readonly");
        const store = transaction.objectStore(STORE_NAME);
        return new Promise((resolve, reject) => {
          const request = store.get(indexFileName);
          request.onsuccess = () => {
            const result2 = request.result;
            resolve(result2 ? result2.data : null);
          };
          request.onerror = () => reject(request.error);
        });
      });
    }
    static deleteData(indexFileName) {
      return __async(this, null, function* () {
        const db = yield this.getDB();
        const transaction = db.transaction([STORE_NAME], "readwrite");
        const store = transaction.objectStore(STORE_NAME);
        yield new Promise((resolve, reject) => {
          const request = store.delete(indexFileName);
          request.onsuccess = () => resolve();
          request.onerror = () => reject(request.error);
        });
      });
    }
    /**
     * Clear all IndexedDB data (for complete cleanup during model switching)
     */
    static clearAllData() {
      return __async(this, null, function* () {
        try {
          const db = yield this.getDB();
          const transaction = db.transaction([STORE_NAME], "readwrite");
          const store = transaction.objectStore(STORE_NAME);
          yield new Promise((resolve, reject) => {
            const request = store.clear();
            request.onsuccess = () => {
              console.log("IndexedDBHelper: All data cleared from IndexedDB");
              resolve();
            };
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error("IndexedDBHelper: Failed to clear all data:", error);
          throw error;
        }
      });
    }
    /**
     * Get all stored keys (for debugging)
     */
    static getAllKeys() {
      return __async(this, null, function* () {
        try {
          const db = yield this.getDB();
          const transaction = db.transaction([STORE_NAME], "readonly");
          const store = transaction.objectStore(STORE_NAME);
          return new Promise((resolve, reject) => {
            const request = store.getAllKeys();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error("IndexedDBHelper: Failed to get all keys:", error);
          return [];
        }
      });
    }
  }
  __publicField2(IndexedDBHelper, "dbPromise", null);
  function initializeGlobalHnswlib() {
    return __async(this, null, function* () {
      if (globalHnswlibInitialized && globalHnswlib) {
        return globalHnswlib;
      }
      if (globalHnswlibInitPromise) {
        return globalHnswlibInitPromise;
      }
      globalHnswlibInitPromise = (() => __async(null, null, function* () {
        try {
          console.log("VectorDatabase: Initializing global hnswlib-wasm instance...");
          globalHnswlib = yield loadHnswlib();
          globalHnswlibInitialized = true;
          console.log("VectorDatabase: Global hnswlib-wasm instance initialized successfully");
          return globalHnswlib;
        } catch (error) {
          console.error("VectorDatabase: Failed to initialize global hnswlib-wasm:", error);
          globalHnswlibInitPromise = null;
          throw error;
        }
      }))();
      return globalHnswlibInitPromise;
    });
  }
  class VectorDatabase {
    constructor(config) {
      __publicField2(this, "index", null);
      __publicField2(this, "isInitialized", false);
      __publicField2(this, "isInitializing", false);
      __publicField2(this, "initPromise", null);
      __publicField2(this, "documents", /* @__PURE__ */ new Map());
      __publicField2(this, "tabDocuments", /* @__PURE__ */ new Map());
      __publicField2(this, "nextLabel", 0);
      __publicField2(this, "config");
      this.config = __spreadValues({
        dimension: 384,
        maxElements: 1e5,
        efConstruction: 200,
        M: 48,
        efSearch: 50,
        indexFileName: "tab_content_index.dat",
        enableAutoCleanup: true,
        maxRetentionDays: 30
      }, config);
      console.log("VectorDatabase: Initialized with config:", {
        dimension: this.config.dimension,
        efSearch: this.config.efSearch,
        M: this.config.M,
        efConstruction: this.config.efConstruction,
        enableAutoCleanup: this.config.enableAutoCleanup,
        maxRetentionDays: this.config.maxRetentionDays
      });
    }
    /**
     * Initialize vector database
     */
    initialize() {
      return __async(this, null, function* () {
        if (this.isInitialized) return;
        if (this.isInitializing && this.initPromise) return this.initPromise;
        this.isInitializing = true;
        this.initPromise = this._doInitialize().finally(() => {
          this.isInitializing = false;
        });
        return this.initPromise;
      });
    }
    _doInitialize() {
      return __async(this, null, function* () {
        try {
          console.log("VectorDatabase: Initializing...");
          const hnswlib2 = yield initializeGlobalHnswlib();
          hnswlib2.EmscriptenFileSystemManager.setDebugLogs(true);
          this.index = new hnswlib2.HierarchicalNSW(
            "cosine",
            this.config.dimension,
            this.config.indexFileName
          );
          yield this.syncFileSystem("read");
          const indexExists = hnswlib2.EmscriptenFileSystemManager.checkFileExists(
            this.config.indexFileName
          );
          if (indexExists) {
            console.log("VectorDatabase: Loading existing index...");
            try {
              yield this.index.readIndex(this.config.indexFileName, this.config.maxElements);
              this.index.setEfSearch(this.config.efSearch);
              yield this.loadDocumentMappings();
              if (this.documents.size > 0) {
                const maxLabel = Math.max(...Array.from(this.documents.keys()));
                this.nextLabel = maxLabel + 1;
                console.log(
                  `VectorDatabase: Loaded existing index with ${this.documents.size} documents, next label: ${this.nextLabel}`
                );
              } else {
                const indexCount = this.index.getCurrentCount();
                if (indexCount > 0) {
                  console.warn(
                    `VectorDatabase: Index has ${indexCount} vectors but no document mappings found. This may cause label mismatch.`
                  );
                  this.nextLabel = indexCount;
                } else {
                  this.nextLabel = 0;
                }
                console.log(
                  `VectorDatabase: No document mappings found, starting with next label: ${this.nextLabel}`
                );
              }
            } catch (loadError) {
              console.warn(
                "VectorDatabase: Failed to load existing index, creating new one:",
                loadError
              );
              this.index.initIndex(
                this.config.maxElements,
                this.config.M,
                this.config.efConstruction,
                200
              );
              this.index.setEfSearch(this.config.efSearch);
              this.nextLabel = 0;
            }
          } else {
            console.log("VectorDatabase: Creating new index...");
            this.index.initIndex(
              this.config.maxElements,
              this.config.M,
              this.config.efConstruction,
              200
            );
            this.index.setEfSearch(this.config.efSearch);
            this.nextLabel = 0;
          }
          this.isInitialized = true;
          console.log("VectorDatabase: Initialization completed successfully");
        } catch (error) {
          console.error("VectorDatabase: Initialization failed:", error);
          this.isInitialized = false;
          throw error;
        }
      });
    }
    /**
     * Add document to vector database
     */
    addDocument(tabId, url, title, chunk, embedding) {
      return __async(this, null, function* () {
        var _a2;
        if (!this.isInitialized) {
          yield this.initialize();
        }
        const documentId = this.generateDocumentId(tabId, chunk.index);
        const document2 = {
          id: documentId,
          tabId,
          url,
          title,
          chunk,
          embedding,
          timestamp: Date.now()
        };
        try {
          if (!embedding || embedding.length !== this.config.dimension) {
            const errorMsg = `Invalid embedding dimension: expected ${this.config.dimension}, got ${(embedding == null ? void 0 : embedding.length) || 0}`;
            console.error("VectorDatabase: Dimension mismatch detected!", {
              expectedDimension: this.config.dimension,
              actualDimension: (embedding == null ? void 0 : embedding.length) || 0,
              documentId,
              tabId,
              url,
              title: title.substring(0, 50) + "..."
            });
            console.warn(
              "VectorDatabase: This might be caused by model switching. Consider reinitializing the vector database with the correct dimension."
            );
            throw new Error(errorMsg);
          }
          for (let i = 0; i < embedding.length; i++) {
            if (!isFinite(embedding[i])) {
              throw new Error(`Invalid embedding value at index ${i}: ${embedding[i]}`);
            }
          }
          let cleanEmbedding;
          if (embedding instanceof Float32Array) {
            cleanEmbedding = embedding;
          } else {
            cleanEmbedding = new Float32Array(embedding);
          }
          const label = this.nextLabel++;
          console.log(
            `VectorDatabase: Adding document with label ${label}, embedding dimension: ${embedding.length}`
          );
          console.log(`VectorDatabase: 🔧 DEBUGGING - About to call addPoint with:`, {
            embeddingType: typeof cleanEmbedding,
            isFloat32Array: cleanEmbedding instanceof Float32Array,
            length: cleanEmbedding.length,
            firstFewValues: Array.from(cleanEmbedding.slice(0, 3)),
            label,
            replaceDeleted: false
          });
          let vectorToAdd;
          try {
            if (globalHnswlib && globalHnswlib.VectorFloat) {
              console.log("VectorDatabase: Using VectorFloat constructor");
              vectorToAdd = new globalHnswlib.VectorFloat();
              for (let i = 0; i < cleanEmbedding.length; i++) {
                vectorToAdd.push_back(cleanEmbedding[i]);
              }
            } else {
              console.log("VectorDatabase: Using plain JS array as fallback");
              vectorToAdd = Array.from(cleanEmbedding);
            }
            this.index.addPoint(vectorToAdd, label, false);
            if (vectorToAdd && typeof vectorToAdd.delete === "function") {
              vectorToAdd.delete();
            }
          } catch (vectorError) {
            console.error(
              "VectorDatabase: VectorFloat approach failed, trying alternatives:",
              vectorError
            );
            try {
              console.log("VectorDatabase: Trying Float32Array directly");
              this.index.addPoint(cleanEmbedding, label, false);
            } catch (float32Error) {
              console.error("VectorDatabase: Float32Array approach failed:", float32Error);
              console.log("VectorDatabase: Trying spread operator as last resort");
              this.index.addPoint([...cleanEmbedding], label, false);
            }
          }
          console.log(`VectorDatabase: ✅ Successfully added document with label ${label}`);
          this.documents.set(label, document2);
          if (!this.tabDocuments.has(tabId)) {
            this.tabDocuments.set(tabId, /* @__PURE__ */ new Set());
          }
          this.tabDocuments.get(tabId).add(label);
          yield this.saveIndex();
          yield this.saveDocumentMappings();
          if (this.config.enableAutoCleanup) {
            yield this.checkAndPerformAutoCleanup();
          }
          console.log(`VectorDatabase: Successfully added document ${documentId} with label ${label}`);
          return label;
        } catch (error) {
          console.error("VectorDatabase: Failed to add document:", error);
          console.error("VectorDatabase: Embedding info:", {
            type: typeof embedding,
            constructor: (_a2 = embedding == null ? void 0 : embedding.constructor) == null ? void 0 : _a2.name,
            length: embedding == null ? void 0 : embedding.length,
            isFloat32Array: embedding instanceof Float32Array,
            firstFewValues: embedding ? Array.from(embedding.slice(0, 5)) : null
          });
          throw error;
        }
      });
    }
    /**
     * Search similar documents
     */
    search(queryEmbedding, topK = 10) {
      return __async(this, null, function* () {
        var _a2;
        if (!this.isInitialized) {
          yield this.initialize();
        }
        try {
          if (!queryEmbedding || queryEmbedding.length !== this.config.dimension) {
            throw new Error(
              `Invalid query embedding dimension: expected ${this.config.dimension}, got ${(queryEmbedding == null ? void 0 : queryEmbedding.length) || 0}`
            );
          }
          for (let i = 0; i < queryEmbedding.length; i++) {
            if (!isFinite(queryEmbedding[i])) {
              throw new Error(`Invalid query embedding value at index ${i}: ${queryEmbedding[i]}`);
            }
          }
          console.log(
            `VectorDatabase: Searching with query embedding dimension: ${queryEmbedding.length}, topK: ${topK}`
          );
          const currentCount = this.index.getCurrentCount();
          if (currentCount === 0) {
            console.log("VectorDatabase: Index is empty, returning no results");
            return [];
          }
          console.log(`VectorDatabase: Index contains ${currentCount} vectors`);
          const mappingCount = this.documents.size;
          if (mappingCount === 0 && currentCount > 0) {
            console.warn(
              `VectorDatabase: Index has ${currentCount} vectors but document mapping is empty. Attempting to reload mappings...`
            );
            yield this.loadDocumentMappings();
            if (this.documents.size === 0) {
              console.error(
                "VectorDatabase: Failed to load document mappings. Index and mappings are out of sync."
              );
              return [];
            }
            console.log(
              `VectorDatabase: Successfully reloaded ${this.documents.size} document mappings`
            );
          }
          let queryVector;
          let searchResult;
          try {
            if (globalHnswlib && globalHnswlib.VectorFloat) {
              console.log("VectorDatabase: Using VectorFloat for search query");
              queryVector = new globalHnswlib.VectorFloat();
              for (let i = 0; i < queryEmbedding.length; i++) {
                queryVector.push_back(queryEmbedding[i]);
              }
              searchResult = this.index.searchKnn(queryVector, topK, void 0);
              if (queryVector && typeof queryVector.delete === "function") {
                queryVector.delete();
              }
            } else {
              console.log("VectorDatabase: Using plain JS array for search query");
              const queryArray = Array.from(queryEmbedding);
              searchResult = this.index.searchKnn(queryArray, topK, void 0);
            }
          } catch (vectorError) {
            console.error(
              "VectorDatabase: VectorFloat search failed, trying alternatives:",
              vectorError
            );
            try {
              console.log("VectorDatabase: Trying Float32Array directly for search");
              searchResult = this.index.searchKnn(queryEmbedding, topK, void 0);
            } catch (float32Error) {
              console.error("VectorDatabase: Float32Array search failed:", float32Error);
              console.log("VectorDatabase: Trying spread operator for search as last resort");
              searchResult = this.index.searchKnn([...queryEmbedding], topK, void 0);
            }
          }
          const results = [];
          console.log(`VectorDatabase: Processing ${searchResult.neighbors.length} search neighbors`);
          console.log(`VectorDatabase: Available documents in mapping: ${this.documents.size}`);
          console.log(`VectorDatabase: Index current count: ${this.index.getCurrentCount()}`);
          for (let i = 0; i < searchResult.neighbors.length; i++) {
            const label = searchResult.neighbors[i];
            const distance = searchResult.distances[i];
            const similarity = 1 - distance;
            console.log(
              `VectorDatabase: Processing neighbor ${i}: label=${label}, distance=${distance}, similarity=${similarity}`
            );
            const document2 = this.findDocumentByLabel(label);
            if (document2) {
              console.log(`VectorDatabase: Found document for label ${label}: ${document2.id}`);
              results.push({
                document: document2,
                similarity,
                distance
              });
            } else {
              console.warn(`VectorDatabase: No document found for label ${label}`);
              if (i < 5) {
                console.warn(
                  `VectorDatabase: Available labels (first 20): ${Array.from(this.documents.keys()).slice(0, 20).join(", ")}`
                );
                console.warn(`VectorDatabase: Total available labels: ${this.documents.size}`);
                console.warn(
                  `VectorDatabase: Label type: ${typeof label}, Available label types: ${Array.from(
                    this.documents.keys()
                  ).slice(0, 3).map((k) => typeof k).join(", ")}`
                );
              }
            }
          }
          console.log(
            `VectorDatabase: Found ${results.length} search results out of ${searchResult.neighbors.length} neighbors`
          );
          if (results.length === 0 && searchResult.neighbors.length > 0) {
            console.error(
              "VectorDatabase: Label mismatch detected! Index has vectors but no matching documents found."
            );
            console.error(
              "VectorDatabase: This usually indicates the index and document mappings are out of sync."
            );
            console.error("VectorDatabase: Consider rebuilding the index to fix this issue.");
            const sampleLabels = searchResult.neighbors.slice(0, 5);
            const availableLabels = Array.from(this.documents.keys()).slice(0, 5);
            console.error("VectorDatabase: Sample search labels:", sampleLabels);
            console.error("VectorDatabase: Sample available labels:", availableLabels);
          }
          return results.sort((a, b) => b.similarity - a.similarity);
        } catch (error) {
          console.error("VectorDatabase: Search failed:", error);
          console.error("VectorDatabase: Query embedding info:", {
            type: typeof queryEmbedding,
            constructor: (_a2 = queryEmbedding == null ? void 0 : queryEmbedding.constructor) == null ? void 0 : _a2.name,
            length: queryEmbedding == null ? void 0 : queryEmbedding.length,
            isFloat32Array: queryEmbedding instanceof Float32Array,
            firstFewValues: queryEmbedding ? Array.from(queryEmbedding.slice(0, 5)) : null
          });
          throw error;
        }
      });
    }
    /**
     * Remove all documents for a tab
     */
    removeTabDocuments(tabId) {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          yield this.initialize();
        }
        const documentLabels = this.tabDocuments.get(tabId);
        if (!documentLabels) {
          return;
        }
        try {
          for (const label of documentLabels) {
            this.documents.delete(label);
          }
          this.tabDocuments.delete(tabId);
          yield this.saveDocumentMappings();
          console.log(`VectorDatabase: Removed ${documentLabels.size} documents for tab ${tabId}`);
        } catch (error) {
          console.error("VectorDatabase: Failed to remove tab documents:", error);
          throw error;
        }
      });
    }
    /**
     * Get database statistics
     */
    getStats() {
      return {
        totalDocuments: this.documents.size,
        totalTabs: this.tabDocuments.size,
        indexSize: this.calculateStorageSize(),
        isInitialized: this.isInitialized
      };
    }
    /**
     * Calculate actual storage size (bytes)
     */
    calculateStorageSize() {
      let totalSize = 0;
      try {
        const documentsSize = this.calculateDocumentMappingsSize();
        totalSize += documentsSize;
        const vectorsSize = this.calculateVectorsSize();
        totalSize += vectorsSize;
        const indexStructureSize = this.calculateIndexStructureSize();
        totalSize += indexStructureSize;
        console.log(
          `VectorDatabase: Storage size breakdown - Documents: ${documentsSize}, Vectors: ${vectorsSize}, Index: ${indexStructureSize}, Total: ${totalSize} bytes`
        );
      } catch (error) {
        console.warn("VectorDatabase: Failed to calculate storage size:", error);
        totalSize = this.documents.size * 1024;
      }
      return totalSize;
    }
    /**
     * Calculate document mappings size
     */
    calculateDocumentMappingsSize() {
      let size = 0;
      for (const [label, document2] of this.documents.entries()) {
        size += 8;
        size += this.calculateObjectSize(document2);
      }
      for (const [tabId, labels] of this.tabDocuments.entries()) {
        size += 8;
        size += labels.size * 8 + 32;
      }
      return size;
    }
    /**
     * Calculate vectors data size
     */
    calculateVectorsSize() {
      const documentCount = this.documents.size;
      const dimension = this.config.dimension;
      const vectorSize = dimension * 4;
      return documentCount * vectorSize;
    }
    /**
     * Estimate index structure size
     */
    calculateIndexStructureSize() {
      const documentCount = this.documents.size;
      if (documentCount === 0) return 0;
      const vectorsSize = this.calculateVectorsSize();
      const indexOverhead = Math.floor(vectorsSize * 0.3);
      const graphOverhead = documentCount * 64;
      return indexOverhead + graphOverhead;
    }
    /**
     * Calculate object size (rough estimation)
     */
    calculateObjectSize(obj) {
      let size = 0;
      try {
        const jsonString = JSON.stringify(obj);
        size = jsonString.length * 2;
      } catch (error) {
        size = 512;
      }
      return size;
    }
    /**
     * Clear entire database
     */
    clear() {
      return __async(this, null, function* () {
        console.log("VectorDatabase: Starting complete database clear...");
        try {
          this.documents.clear();
          this.tabDocuments.clear();
          this.nextLabel = 0;
          if (this.isInitialized && this.index) {
            try {
              console.log("VectorDatabase: Clearing HNSW index file from IndexedDB...");
              try {
                if (globalHnswlib && globalHnswlib.EmscriptenFileSystemManager.checkFileExists(this.config.indexFileName)) {
                  console.log(
                    `VectorDatabase: Deleting physical index file: ${this.config.indexFileName}`
                  );
                  globalHnswlib.EmscriptenFileSystemManager.deleteFile(this.config.indexFileName);
                  yield this.syncFileSystem("write");
                  console.log(
                    `VectorDatabase: Physical index file ${this.config.indexFileName} deleted successfully`
                  );
                } else {
                  console.log(
                    `VectorDatabase: Physical index file ${this.config.indexFileName} does not exist or already deleted`
                  );
                }
              } catch (fileError) {
                console.warn(
                  `VectorDatabase: Failed to delete physical index file ${this.config.indexFileName}:`,
                  fileError
                );
              }
              yield this.index.deleteIndex(this.config.indexFileName);
              console.log("VectorDatabase: HNSW index file cleared from IndexedDB");
              console.log("VectorDatabase: Reinitializing empty HNSW index...");
              this.index.initIndex(
                this.config.maxElements,
                this.config.M,
                this.config.efConstruction,
                200
              );
              this.index.setEfSearch(this.config.efSearch);
              yield this.forceSaveIndex();
            } catch (indexError) {
              console.warn("VectorDatabase: Failed to clear HNSW index file:", indexError);
            }
          }
          try {
            console.log("VectorDatabase: Clearing document mappings from IndexedDB...");
            yield IndexedDBHelper.deleteData(this.config.indexFileName);
            console.log("VectorDatabase: Document mappings cleared from IndexedDB");
          } catch (idbError) {
            console.warn(
              "VectorDatabase: Failed to clear document mappings from IndexedDB, trying chrome.storage fallback:",
              idbError
            );
            try {
              const storageKey = `hnswlib_document_mappings_${this.config.indexFileName}`;
              yield chrome.storage.local.remove([storageKey]);
              console.log("VectorDatabase: Chrome storage fallback cleared");
            } catch (storageError) {
              console.warn("VectorDatabase: Failed to clear chrome.storage fallback:", storageError);
            }
          }
          yield this.saveDocumentMappings();
          console.log("VectorDatabase: Complete database clear finished successfully");
        } catch (error) {
          console.error("VectorDatabase: Failed to clear database:", error);
          throw error;
        }
      });
    }
    /**
     * Force save index and sync filesystem
     */
    forceSaveIndex() {
      return __async(this, null, function* () {
        try {
          yield this.index.writeIndex(this.config.indexFileName);
          yield this.syncFileSystem("write");
        } catch (error) {
          console.error("VectorDatabase: Failed to force save index:", error);
        }
      });
    }
    /**
     * Check and perform auto cleanup
     */
    checkAndPerformAutoCleanup() {
      return __async(this, null, function* () {
        try {
          const currentCount = this.documents.size;
          const maxElements = this.config.maxElements;
          console.log(
            `VectorDatabase: Auto cleanup check - current: ${currentCount}, max: ${maxElements}`
          );
          if (currentCount >= maxElements) {
            console.log("VectorDatabase: Document count reached limit, performing cleanup...");
            yield this.performLRUCleanup(Math.floor(maxElements * 0.2));
          }
          if (this.config.maxRetentionDays && this.config.maxRetentionDays > 0) {
            yield this.performTimeBasedCleanup();
          }
        } catch (error) {
          console.error("VectorDatabase: Auto cleanup failed:", error);
        }
      });
    }
    /**
     * Perform LRU-based cleanup (delete oldest documents)
     */
    performLRUCleanup(cleanupCount) {
      return __async(this, null, function* () {
        try {
          console.log(
            `VectorDatabase: Starting LRU cleanup, removing ${cleanupCount} oldest documents`
          );
          const allDocuments = Array.from(this.documents.entries());
          allDocuments.sort((a, b) => a[1].timestamp - b[1].timestamp);
          const documentsToDelete = allDocuments.slice(0, cleanupCount);
          for (const [label, _document] of documentsToDelete) {
            yield this.removeDocumentByLabel(label);
          }
          yield this.saveIndex();
          yield this.saveDocumentMappings();
          console.log(
            `VectorDatabase: LRU cleanup completed, removed ${documentsToDelete.length} documents`
          );
        } catch (error) {
          console.error("VectorDatabase: LRU cleanup failed:", error);
        }
      });
    }
    /**
     * Perform time-based cleanup (delete expired documents)
     */
    performTimeBasedCleanup() {
      return __async(this, null, function* () {
        try {
          const maxRetentionMs = this.config.maxRetentionDays * 24 * 60 * 60 * 1e3;
          const cutoffTime = Date.now() - maxRetentionMs;
          console.log(
            `VectorDatabase: Starting time-based cleanup, removing documents older than ${this.config.maxRetentionDays} days`
          );
          const documentsToDelete = [];
          for (const [label, document2] of this.documents.entries()) {
            if (document2.timestamp < cutoffTime) {
              documentsToDelete.push(label);
            }
          }
          for (const label of documentsToDelete) {
            yield this.removeDocumentByLabel(label);
          }
          if (documentsToDelete.length > 0) {
            yield this.saveIndex();
            yield this.saveDocumentMappings();
          }
          console.log(
            `VectorDatabase: Time-based cleanup completed, removed ${documentsToDelete.length} expired documents`
          );
        } catch (error) {
          console.error("VectorDatabase: Time-based cleanup failed:", error);
        }
      });
    }
    /**
     * Remove single document by label
     */
    removeDocumentByLabel(label) {
      return __async(this, null, function* () {
        try {
          const document2 = this.documents.get(label);
          if (!document2) {
            console.warn(`VectorDatabase: Document with label ${label} not found`);
            return;
          }
          if (this.index) {
            try {
              this.index.markDelete(label);
            } catch (indexError) {
              console.warn(
                `VectorDatabase: Failed to mark delete in index for label ${label}:`,
                indexError
              );
            }
          }
          this.documents.delete(label);
          const tabId = document2.tabId;
          if (this.tabDocuments.has(tabId)) {
            this.tabDocuments.get(tabId).delete(label);
            if (this.tabDocuments.get(tabId).size === 0) {
              this.tabDocuments.delete(tabId);
            }
          }
          console.log(`VectorDatabase: Removed document with label ${label} from tab ${tabId}`);
        } catch (error) {
          console.error(`VectorDatabase: Failed to remove document with label ${label}:`, error);
        }
      });
    }
    // 私有辅助方法
    generateDocumentId(tabId, chunkIndex) {
      return `tab_${tabId}_chunk_${chunkIndex}_${Date.now()}`;
    }
    findDocumentByLabel(label) {
      return this.documents.get(label) || null;
    }
    syncFileSystem(direction) {
      return __async(this, null, function* () {
        try {
          if (!globalHnswlib) {
            return;
          }
          if (syncInProgress && pendingSyncPromise) {
            console.log(`VectorDatabase: Sync already in progress, waiting...`);
            yield pendingSyncPromise;
            return;
          }
          syncInProgress = true;
          pendingSyncPromise = new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
              console.warn(`VectorDatabase: Filesystem sync (${direction}) timeout`);
              syncInProgress = false;
              pendingSyncPromise = null;
              reject(new Error("Sync timeout"));
            }, 5e3);
            try {
              globalHnswlib.EmscriptenFileSystemManager.syncFS(direction === "read", () => {
                clearTimeout(timeout);
                console.log(`VectorDatabase: Filesystem sync (${direction}) completed`);
                syncInProgress = false;
                pendingSyncPromise = null;
                resolve();
              });
            } catch (error) {
              clearTimeout(timeout);
              console.warn(`VectorDatabase: Failed to sync filesystem (${direction}):`, error);
              syncInProgress = false;
              pendingSyncPromise = null;
              reject(error);
            }
          });
          yield pendingSyncPromise;
        } catch (error) {
          console.warn(`VectorDatabase: Failed to sync filesystem (${direction}):`, error);
          syncInProgress = false;
          pendingSyncPromise = null;
        }
      });
    }
    saveIndex() {
      return __async(this, null, function* () {
        try {
          yield this.index.writeIndex(this.config.indexFileName);
          if (this.documents.size % 10 === 0) {
            yield this.syncFileSystem("write");
          }
        } catch (error) {
          console.error("VectorDatabase: Failed to save index:", error);
        }
      });
    }
    saveDocumentMappings() {
      return __async(this, null, function* () {
        try {
          const mappingData = {
            documents: Array.from(this.documents.entries()),
            tabDocuments: Array.from(this.tabDocuments.entries()).map(([tabId, labels]) => [
              tabId,
              Array.from(labels)
            ]),
            nextLabel: this.nextLabel
          };
          try {
            yield IndexedDBHelper.saveData(this.config.indexFileName, mappingData);
            console.log("VectorDatabase: Document mappings saved to IndexedDB");
          } catch (idbError) {
            console.warn(
              "VectorDatabase: Failed to save to IndexedDB, falling back to chrome.storage:",
              idbError
            );
            try {
              const storageKey = `hnswlib_document_mappings_${this.config.indexFileName}`;
              yield chrome.storage.local.set({ [storageKey]: mappingData });
              console.log("VectorDatabase: Document mappings saved to chrome.storage.local (fallback)");
            } catch (storageError) {
              console.error(
                "VectorDatabase: Failed to save to both IndexedDB and chrome.storage:",
                storageError
              );
            }
          }
        } catch (error) {
          console.error("VectorDatabase: Failed to save document mappings:", error);
        }
      });
    }
    loadDocumentMappings() {
      return __async(this, null, function* () {
        try {
          if (!globalHnswlib) {
            return;
          }
          let mappingData = null;
          try {
            mappingData = yield IndexedDBHelper.loadData(this.config.indexFileName);
            if (mappingData) {
              console.log(`VectorDatabase: Loaded document mappings from IndexedDB`);
            }
          } catch (idbError) {
            console.warn(
              "VectorDatabase: Failed to read from IndexedDB, trying chrome.storage:",
              idbError
            );
          }
          if (!mappingData) {
            try {
              const storageKey = `hnswlib_document_mappings_${this.config.indexFileName}`;
              const result2 = yield chrome.storage.local.get([storageKey]);
              mappingData = result2[storageKey];
              if (mappingData) {
                console.log(
                  `VectorDatabase: Loaded document mappings from chrome.storage.local (fallback)`
                );
                try {
                  yield IndexedDBHelper.saveData(this.config.indexFileName, mappingData);
                  console.log("VectorDatabase: Migrated data from chrome.storage to IndexedDB");
                } catch (migrationError) {
                  console.warn("VectorDatabase: Failed to migrate data to IndexedDB:", migrationError);
                }
              }
            } catch (storageError) {
              console.warn("VectorDatabase: Failed to read from chrome.storage.local:", storageError);
            }
          }
          if (mappingData) {
            this.documents.clear();
            for (const [label, doc] of mappingData.documents) {
              this.documents.set(label, doc);
            }
            this.tabDocuments.clear();
            for (const [tabId, labels] of mappingData.tabDocuments) {
              this.tabDocuments.set(tabId, new Set(labels));
            }
            if (mappingData.nextLabel !== void 0) {
              this.nextLabel = mappingData.nextLabel;
            } else if (this.documents.size > 0) {
              const maxLabel = Math.max(...Array.from(this.documents.keys()));
              this.nextLabel = maxLabel + 1;
            } else {
              this.nextLabel = 0;
            }
            console.log(
              `VectorDatabase: Loaded ${this.documents.size} document mappings, next label: ${this.nextLabel}`
            );
          } else {
            console.log("VectorDatabase: No existing document mappings found");
          }
        } catch (error) {
          console.error("VectorDatabase: Failed to load document mappings:", error);
        }
      });
    }
  }
  let globalVectorDatabase = null;
  let currentDimension = null;
  function getGlobalVectorDatabase(config) {
    return __async(this, null, function* () {
      const newDimension = (config == null ? void 0 : config.dimension) || 384;
      if (globalVectorDatabase && currentDimension !== null && currentDimension !== newDimension) {
        console.log(
          `VectorDatabase: Dimension changed from ${currentDimension} to ${newDimension}, recreating instance`
        );
        try {
          yield globalVectorDatabase.clear();
          console.log("VectorDatabase: Successfully cleared old instance for dimension change");
        } catch (error) {
          console.warn("VectorDatabase: Error during cleanup:", error);
        }
        globalVectorDatabase = null;
        currentDimension = null;
      }
      if (!globalVectorDatabase) {
        globalVectorDatabase = new VectorDatabase(config);
        currentDimension = newDimension;
        console.log(
          `VectorDatabase: Created global singleton instance with dimension ${currentDimension}`
        );
      }
      return globalVectorDatabase;
    });
  }
  function clearAllVectorData() {
    return __async(this, null, function* () {
      console.log("VectorDatabase: Starting comprehensive vector data cleanup for model switch...");
      try {
        if (globalVectorDatabase) {
          try {
            yield globalVectorDatabase.clear();
          } catch (error) {
            console.warn("VectorDatabase: Failed to clear global instance:", error);
          }
        }
        try {
          console.log("VectorDatabase: Clearing VectorDatabaseStorage database...");
          yield IndexedDBHelper.clearAllData();
        } catch (error) {
          console.warn("VectorDatabase: Failed to clear VectorDatabaseStorage:", error);
        }
        try {
          console.log("VectorDatabase: Clearing hnswlib-index database and physical files...");
          if (typeof globalHnswlib !== "undefined" && globalHnswlib) {
            const possibleIndexFiles = [
              "tab_content_index.dat",
              "content_index.dat",
              "vector_index.dat"
            ];
            for (const fileName of possibleIndexFiles) {
              try {
                if (globalHnswlib.EmscriptenFileSystemManager.checkFileExists(fileName)) {
                  console.log(`VectorDatabase: Deleting physical index file: ${fileName}`);
                  globalHnswlib.EmscriptenFileSystemManager.deleteFile(fileName);
                  console.log(`VectorDatabase: Physical index file ${fileName} deleted successfully`);
                }
              } catch (fileError) {
                console.log(
                  `VectorDatabase: Physical index file ${fileName} not found or failed to delete:`,
                  fileError
                );
              }
            }
            try {
              yield new Promise((resolve) => {
                const timeout = setTimeout(() => {
                  console.warn("VectorDatabase: Filesystem sync timeout during model switch cleanup");
                  resolve();
                }, 3e3);
                globalHnswlib.EmscriptenFileSystemManager.syncFS(false, () => {
                  clearTimeout(timeout);
                  console.log("VectorDatabase: Filesystem sync completed during model switch cleanup");
                  resolve();
                });
              });
            } catch (syncError) {
              console.warn(
                "VectorDatabase: Failed to sync filesystem during model switch cleanup:",
                syncError
              );
            }
          }
          yield new Promise((resolve) => {
            const deleteRequest = indexedDB.deleteDatabase("/hnswlib-index");
            deleteRequest.onsuccess = () => {
              console.log("VectorDatabase: Successfully deleted /hnswlib-index database");
              resolve();
            };
            deleteRequest.onerror = () => {
              console.warn(
                "VectorDatabase: Failed to delete /hnswlib-index database:",
                deleteRequest.error
              );
              resolve();
            };
            deleteRequest.onblocked = () => {
              console.warn("VectorDatabase: Deletion of /hnswlib-index database was blocked");
              resolve();
            };
          });
        } catch (error) {
          console.warn(
            "VectorDatabase: Failed to clear hnswlib-index database and physical files:",
            error
          );
        }
        try {
          const storageKeys = [
            "hnswlib_document_mappings_tab_content_index.dat",
            "hnswlib_document_mappings_content_index.dat",
            "hnswlib_document_mappings_vector_index.dat"
          ];
          yield chrome.storage.local.remove(storageKeys);
          console.log("VectorDatabase: Chrome storage backup data cleared");
        } catch (error) {
          console.warn("VectorDatabase: Failed to clear chrome.storage backup:", error);
        }
        globalVectorDatabase = null;
        currentDimension = null;
        console.log("VectorDatabase: Comprehensive vector data cleanup completed successfully");
      } catch (error) {
        console.error("VectorDatabase: Comprehensive vector data cleanup failed:", error);
        throw error;
      }
    });
  }
  background;
  const vectorDatabase = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    VectorDatabase,
    clearAllVectorData,
    getGlobalVectorDatabase
  }, Symbol.toStringTag, { value: "Module" }));
  const _OffscreenManager = class _OffscreenManager {
    constructor() {
      __publicField2(this, "isCreated", false);
      __publicField2(this, "isCreating", false);
      __publicField2(this, "createPromise", null);
    }
    /**
     * Get singleton instance
     */
    static getInstance() {
      if (!_OffscreenManager.instance) {
        _OffscreenManager.instance = new _OffscreenManager();
      }
      return _OffscreenManager.instance;
    }
    /**
     * Ensure offscreen document exists
     */
    ensureOffscreenDocument() {
      return __async(this, null, function* () {
        if (this.isCreated) {
          return;
        }
        if (this.isCreating && this.createPromise) {
          return this.createPromise;
        }
        this.isCreating = true;
        this.createPromise = this._doCreateOffscreenDocument().finally(() => {
          this.isCreating = false;
        });
        return this.createPromise;
      });
    }
    _doCreateOffscreenDocument() {
      return __async(this, null, function* () {
        try {
          if (!chrome.offscreen) {
            throw new Error("Offscreen API not available. Chrome 109+ required.");
          }
          const existingContexts = yield chrome.runtime.getContexts({
            contextTypes: ["OFFSCREEN_DOCUMENT"]
          });
          if (existingContexts && existingContexts.length > 0) {
            console.log("OffscreenManager: Offscreen document already exists");
            this.isCreated = true;
            return;
          }
          yield chrome.offscreen.createDocument({
            url: "offscreen.html",
            reasons: ["WORKERS"],
            justification: "Need to run semantic similarity engine with workers"
          });
          this.isCreated = true;
          console.log("OffscreenManager: Offscreen document created successfully");
        } catch (error) {
          console.error("OffscreenManager: Failed to create offscreen document:", error);
          this.isCreated = false;
          throw error;
        }
      });
    }
    /**
     * Check if offscreen document is created
     */
    isOffscreenDocumentCreated() {
      return this.isCreated;
    }
    /**
     * Close offscreen document
     */
    closeOffscreenDocument() {
      return __async(this, null, function* () {
        try {
          if (chrome.offscreen && this.isCreated) {
            yield chrome.offscreen.closeDocument();
            this.isCreated = false;
            console.log("OffscreenManager: Offscreen document closed");
          }
        } catch (error) {
          console.error("OffscreenManager: Failed to close offscreen document:", error);
        }
      });
    }
    /**
     * Reset state (for testing)
     */
    reset() {
      this.isCreated = false;
      this.isCreating = false;
      this.createPromise = null;
    }
  };
  __publicField2(_OffscreenManager, "instance", null);
  let OffscreenManager = _OffscreenManager;
  OffscreenManager.getInstance();
  background;
  function dispatchCallback(progress_callback, data) {
    if (progress_callback) progress_callback(data);
  }
  function reverseDictionary(data) {
    return Object.fromEntries(Object.entries(data).map(([key, value]) => [value, key]));
  }
  const Callable = (
    /** @type {any} */
    class {
      /**
      * Creates a new instance of the Callable class.
      */
      constructor() {
        let closure = function(...args) {
          return closure._call(...args);
        };
        return Object.setPrototypeOf(closure, new.target.prototype);
      }
      /**
       * This method should be implemented in subclasses to provide the
       * functionality of the callable object.
       *
       * @param {any[]} args
       * @throws {Error} If the subclass does not implement the `_call` method.
       */
      _call(...args) {
        throw Error("Must implement _call method in subclass");
      }
    }
  );
  function isTypedArray(val) {
    var _a2, _b2, _c2;
    return ((_c2 = (_b2 = (_a2 = val == null ? void 0 : val.prototype) == null ? void 0 : _a2.__proto__) == null ? void 0 : _b2.constructor) == null ? void 0 : _c2.name) === "TypedArray";
  }
  function isIntegralNumber(x) {
    return Number.isInteger(x) || typeof x === "bigint";
  }
  function exists(x) {
    return x !== void 0 && x !== null;
  }
  function mergeArrays(...arrs) {
    return Array.prototype.concat.apply([], arrs);
  }
  const sharp = {};
  const ONNX_NODE = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: sharp
  }, Symbol.toStringTag, { value: "Module" }));
  function getDefaultExportFromCjs(x) {
    return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
  }
  function getAugmentedNamespace(n) {
    if (Object.prototype.hasOwnProperty.call(n, "__esModule")) return n;
    var f = n.default;
    if (typeof f == "function") {
      var a = function a2() {
        if (this instanceof a2) {
          return Reflect.construct(f, arguments, this.constructor);
        }
        return f.apply(this, arguments);
      };
      a.prototype = f.prototype;
    } else a = {};
    Object.defineProperty(a, "__esModule", { value: true });
    Object.keys(n).forEach(function(k) {
      var d = Object.getOwnPropertyDescriptor(n, k);
      Object.defineProperty(a, k, d.get ? d : {
        enumerable: true,
        get: function() {
          return n[k];
        }
      });
    });
    return a;
  }
  var ortWeb_min$1 = { exports: {} };
  const backends = {};
  const backendsSortedByPriority = [];
  const registerBackend = (name2, backend, priority) => {
    if (backend && typeof backend.init === "function" && typeof backend.createSessionHandler === "function") {
      const currentBackend = backends[name2];
      if (currentBackend === void 0) {
        backends[name2] = { backend, priority };
      } else if (currentBackend.priority > priority) {
        return;
      } else if (currentBackend.priority === priority) {
        if (currentBackend.backend !== backend) {
          throw new Error(`cannot register backend "${name2}" using priority ${priority}`);
        }
      }
      if (priority >= 0) {
        const i = backendsSortedByPriority.indexOf(name2);
        if (i !== -1) {
          backendsSortedByPriority.splice(i, 1);
        }
        for (let i2 = 0; i2 < backendsSortedByPriority.length; i2++) {
          if (backends[backendsSortedByPriority[i2]].priority <= priority) {
            backendsSortedByPriority.splice(i2, 0, name2);
            return;
          }
        }
        backendsSortedByPriority.push(name2);
      }
      return;
    }
    throw new TypeError("not a valid backend");
  };
  const resolveBackend = (backendHints) => __async(null, null, function* () {
    const backendNames = backendHints.length === 0 ? backendsSortedByPriority : backendHints;
    const errors = [];
    for (const backendName of backendNames) {
      const backendInfo = backends[backendName];
      if (backendInfo) {
        if (backendInfo.initialized) {
          return backendInfo.backend;
        } else if (backendInfo.aborted) {
          continue;
        }
        const isInitializing = !!backendInfo.initPromise;
        try {
          if (!isInitializing) {
            backendInfo.initPromise = backendInfo.backend.init();
          }
          yield backendInfo.initPromise;
          backendInfo.initialized = true;
          return backendInfo.backend;
        } catch (e) {
          if (!isInitializing) {
            errors.push({ name: backendName, err: e });
          }
          backendInfo.aborted = true;
        } finally {
          delete backendInfo.initPromise;
        }
      }
    }
    throw new Error(`no available backend found. ERR: ${errors.map((e) => `[${e.name}] ${e.err}`).join(", ")}`);
  });
  class EnvImpl {
    constructor() {
      this.wasm = {};
      this.webgl = {};
      this.logLevelInternal = "warning";
    }
    // TODO standadize the getter and setter convention in env for other fields.
    set logLevel(value) {
      if (value === void 0) {
        return;
      }
      if (typeof value !== "string" || ["verbose", "info", "warning", "error", "fatal"].indexOf(value) === -1) {
        throw new Error(`Unsupported logging level: ${value}`);
      }
      this.logLevelInternal = value;
    }
    get logLevel() {
      return this.logLevelInternal;
    }
  }
  const env$2 = new EnvImpl();
  const isBigInt64ArrayAvailable = typeof BigInt64Array !== "undefined" && typeof BigInt64Array.from === "function";
  const isBigUint64ArrayAvailable = typeof BigUint64Array !== "undefined" && typeof BigUint64Array.from === "function";
  const NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP = /* @__PURE__ */ new Map([
    ["float32", Float32Array],
    ["uint8", Uint8Array],
    ["int8", Int8Array],
    ["uint16", Uint16Array],
    ["int16", Int16Array],
    ["int32", Int32Array],
    ["bool", Uint8Array],
    ["float64", Float64Array],
    ["uint32", Uint32Array]
  ]);
  const NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP = /* @__PURE__ */ new Map([
    [Float32Array, "float32"],
    [Uint8Array, "uint8"],
    [Int8Array, "int8"],
    [Uint16Array, "uint16"],
    [Int16Array, "int16"],
    [Int32Array, "int32"],
    [Float64Array, "float64"],
    [Uint32Array, "uint32"]
  ]);
  if (isBigInt64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("int64", BigInt64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigInt64Array, "int64");
  }
  if (isBigUint64ArrayAvailable) {
    NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.set("uint64", BigUint64Array);
    NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.set(BigUint64Array, "uint64");
  }
  const calculateSize = (dims) => {
    let size = 1;
    for (let i = 0; i < dims.length; i++) {
      const dim = dims[i];
      if (typeof dim !== "number" || !Number.isSafeInteger(dim)) {
        throw new TypeError(`dims[${i}] must be an integer, got: ${dim}`);
      }
      if (dim < 0) {
        throw new RangeError(`dims[${i}] must be a non-negative integer, got: ${dim}`);
      }
      size *= dim;
    }
    return size;
  };
  let Tensor$2 = class Tensor2 {
    constructor(arg0, arg1, arg2) {
      let type;
      let data;
      let dims;
      if (typeof arg0 === "string") {
        type = arg0;
        dims = arg2;
        if (arg0 === "string") {
          if (!Array.isArray(arg1)) {
            throw new TypeError("A string tensor's data must be a string array.");
          }
          data = arg1;
        } else {
          const typedArrayConstructor = NUMERIC_TENSOR_TYPE_TO_TYPEDARRAY_MAP.get(arg0);
          if (typedArrayConstructor === void 0) {
            throw new TypeError(`Unsupported tensor type: ${arg0}.`);
          }
          if (Array.isArray(arg1)) {
            data = typedArrayConstructor.from(arg1);
          } else if (arg1 instanceof typedArrayConstructor) {
            data = arg1;
          } else {
            throw new TypeError(`A ${type} tensor's data must be type of ${typedArrayConstructor}`);
          }
        }
      } else {
        dims = arg1;
        if (Array.isArray(arg0)) {
          if (arg0.length === 0) {
            throw new TypeError("Tensor type cannot be inferred from an empty array.");
          }
          const firstElementType = typeof arg0[0];
          if (firstElementType === "string") {
            type = "string";
            data = arg0;
          } else if (firstElementType === "boolean") {
            type = "bool";
            data = Uint8Array.from(arg0);
          } else {
            throw new TypeError(`Invalid element type of data array: ${firstElementType}.`);
          }
        } else {
          const mappedType = NUMERIC_TENSOR_TYPEDARRAY_TO_TYPE_MAP.get(arg0.constructor);
          if (mappedType === void 0) {
            throw new TypeError(`Unsupported type for tensor data: ${arg0.constructor}.`);
          }
          type = mappedType;
          data = arg0;
        }
      }
      if (dims === void 0) {
        dims = [data.length];
      } else if (!Array.isArray(dims)) {
        throw new TypeError("A tensor's dims must be a number array");
      }
      const size = calculateSize(dims);
      if (size !== data.length) {
        throw new Error(`Tensor's size(${size}) does not match data length(${data.length}).`);
      }
      this.dims = dims;
      this.type = type;
      this.data = data;
      this.size = size;
    }
    // #endregion
    /**
     * Create a new tensor object from image object
     *
     * @param buffer - Extracted image buffer data - assuming RGBA format
     * @param imageFormat - input image configuration - required configurations height, width, format
     * @param tensorFormat - output tensor configuration - Default is RGB format
     */
    static bufferToTensor(buffer, options) {
      if (buffer === void 0) {
        throw new Error("Image buffer must be defined");
      }
      if (options.height === void 0 || options.width === void 0) {
        throw new Error("Image height and width must be defined");
      }
      const { height, width } = options;
      const norm = options.norm;
      let normMean;
      let normBias;
      if (norm === void 0 || norm.mean === void 0) {
        normMean = 255;
      } else {
        normMean = norm.mean;
      }
      if (norm === void 0 || norm.bias === void 0) {
        normBias = 0;
      } else {
        normBias = norm.bias;
      }
      const inputformat = options.bitmapFormat !== void 0 ? options.bitmapFormat : "RGBA";
      const outputformat = options.tensorFormat !== void 0 ? options.tensorFormat !== void 0 ? options.tensorFormat : "RGB" : "RGB";
      const offset = height * width;
      const float32Data = outputformat === "RGBA" ? new Float32Array(offset * 4) : new Float32Array(offset * 3);
      let step = 4, rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
      let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
      if (inputformat === "RGB") {
        step = 3;
        rImagePointer = 0;
        gImagePointer = 1;
        bImagePointer = 2;
        aImagePointer = -1;
      }
      if (outputformat === "RGBA") {
        aTensorPointer = offset * 3;
      } else if (outputformat === "RBG") {
        rTensorPointer = 0;
        bTensorPointer = offset;
        gTensorPointer = offset * 2;
      } else if (outputformat === "BGR") {
        bTensorPointer = 0;
        gTensorPointer = offset;
        rTensorPointer = offset * 2;
      }
      for (let i = 0; i < offset; i++, rImagePointer += step, bImagePointer += step, gImagePointer += step, aImagePointer += step) {
        float32Data[rTensorPointer++] = (buffer[rImagePointer] + normBias) / normMean;
        float32Data[gTensorPointer++] = (buffer[gImagePointer] + normBias) / normMean;
        float32Data[bTensorPointer++] = (buffer[bImagePointer] + normBias) / normMean;
        if (aTensorPointer !== -1 && aImagePointer !== -1) {
          float32Data[aTensorPointer++] = (buffer[aImagePointer] + normBias) / normMean;
        }
      }
      const outputTensor = outputformat === "RGBA" ? new Tensor2("float32", float32Data, [1, 4, height, width]) : new Tensor2("float32", float32Data, [1, 3, height, width]);
      return outputTensor;
    }
    static fromImage(image, options) {
      return __async(this, null, function* () {
        const isHTMLImageEle = typeof HTMLImageElement !== "undefined" && image instanceof HTMLImageElement;
        const isImageDataEle = typeof ImageData !== "undefined" && image instanceof ImageData;
        const isImageBitmap = typeof ImageBitmap !== "undefined" && image instanceof ImageBitmap;
        const isURL = typeof String !== "undefined" && (image instanceof String || typeof image === "string");
        let data;
        let tensorConfig = {};
        if (isHTMLImageEle) {
          const canvas = document.createElement("canvas");
          const pixels2DContext = canvas.getContext("2d");
          if (pixels2DContext != null) {
            let height = image.naturalHeight;
            let width = image.naturalWidth;
            if (options !== void 0 && options.resizedHeight !== void 0 && options.resizedWidth !== void 0) {
              height = options.resizedHeight;
              width = options.resizedWidth;
            }
            if (options !== void 0) {
              tensorConfig = options;
              if (options.tensorFormat !== void 0) {
                throw new Error("Image input config format must be RGBA for HTMLImageElement");
              } else {
                tensorConfig.tensorFormat = "RGBA";
              }
              if (options.height !== void 0 && options.height !== height) {
                throw new Error("Image input config height doesn't match HTMLImageElement height");
              } else {
                tensorConfig.height = height;
              }
              if (options.width !== void 0 && options.width !== width) {
                throw new Error("Image input config width doesn't match HTMLImageElement width");
              } else {
                tensorConfig.width = width;
              }
            } else {
              tensorConfig.tensorFormat = "RGBA";
              tensorConfig.height = height;
              tensorConfig.width = width;
            }
            canvas.width = width;
            canvas.height = height;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isImageDataEle) {
          const format2 = "RGBA";
          let height;
          let width;
          if (options !== void 0 && options.resizedWidth !== void 0 && options.resizedHeight !== void 0) {
            height = options.resizedHeight;
            width = options.resizedWidth;
          } else {
            height = image.height;
            width = image.width;
          }
          if (options !== void 0) {
            tensorConfig = options;
            if (options.bitmapFormat !== void 0 && options.bitmapFormat !== format2) {
              throw new Error("Image input config format must be RGBA for ImageData");
            } else {
              tensorConfig.bitmapFormat = "RGBA";
            }
          } else {
            tensorConfig.bitmapFormat = "RGBA";
          }
          tensorConfig.height = height;
          tensorConfig.width = width;
          if (options !== void 0) {
            const tempCanvas = document.createElement("canvas");
            tempCanvas.width = width;
            tempCanvas.height = height;
            const pixels2DContext = tempCanvas.getContext("2d");
            if (pixels2DContext != null) {
              pixels2DContext.putImageData(image, 0, 0);
              data = pixels2DContext.getImageData(0, 0, width, height).data;
            } else {
              throw new Error("Can not access image data");
            }
          } else {
            data = image.data;
          }
        } else if (isImageBitmap) {
          if (options === void 0) {
            throw new Error("Please provide image config with format for Imagebitmap");
          }
          if (options.bitmapFormat !== void 0) {
            throw new Error("Image input config format must be defined for ImageBitmap");
          }
          const pixels2DContext = document.createElement("canvas").getContext("2d");
          if (pixels2DContext != null) {
            const height = image.height;
            const width = image.width;
            pixels2DContext.drawImage(image, 0, 0, width, height);
            data = pixels2DContext.getImageData(0, 0, width, height).data;
            if (options !== void 0) {
              if (options.height !== void 0 && options.height !== height) {
                throw new Error("Image input config height doesn't match ImageBitmap height");
              } else {
                tensorConfig.height = height;
              }
              if (options.width !== void 0 && options.width !== width) {
                throw new Error("Image input config width doesn't match ImageBitmap width");
              } else {
                tensorConfig.width = width;
              }
            } else {
              tensorConfig.height = height;
              tensorConfig.width = width;
            }
            return Tensor2.bufferToTensor(data, tensorConfig);
          } else {
            throw new Error("Can not access image data");
          }
        } else if (isURL) {
          return new Promise((resolve, reject) => {
            const canvas = document.createElement("canvas");
            const context = canvas.getContext("2d");
            if (!image || !context) {
              return reject();
            }
            const newImage = new Image();
            newImage.crossOrigin = "Anonymous";
            newImage.src = image;
            newImage.onload = () => {
              canvas.width = newImage.width;
              canvas.height = newImage.height;
              context.drawImage(newImage, 0, 0, canvas.width, canvas.height);
              const img = context.getImageData(0, 0, canvas.width, canvas.height);
              if (options !== void 0) {
                if (options.height !== void 0 && options.height !== canvas.height) {
                  throw new Error("Image input config height doesn't match ImageBitmap height");
                } else {
                  tensorConfig.height = canvas.height;
                }
                if (options.width !== void 0 && options.width !== canvas.width) {
                  throw new Error("Image input config width doesn't match ImageBitmap width");
                } else {
                  tensorConfig.width = canvas.width;
                }
              } else {
                tensorConfig.height = canvas.height;
                tensorConfig.width = canvas.width;
              }
              resolve(Tensor2.bufferToTensor(img.data, tensorConfig));
            };
          });
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
        if (data !== void 0) {
          return Tensor2.bufferToTensor(data, tensorConfig);
        } else {
          throw new Error("Input data provided is not supported - aborted tensor creation");
        }
      });
    }
    toImageData(options) {
      var _a2, _b2;
      const pixels2DContext = document.createElement("canvas").getContext("2d");
      let image;
      if (pixels2DContext != null) {
        const width = this.dims[3];
        const height = this.dims[2];
        const channels = this.dims[1];
        const inputformat = options !== void 0 ? options.format !== void 0 ? options.format : "RGB" : "RGB";
        const normMean = options !== void 0 ? ((_a2 = options.norm) === null || _a2 === void 0 ? void 0 : _a2.mean) !== void 0 ? options.norm.mean : 255 : 255;
        const normBias = options !== void 0 ? ((_b2 = options.norm) === null || _b2 === void 0 ? void 0 : _b2.bias) !== void 0 ? options.norm.bias : 0 : 0;
        const offset = height * width;
        if (options !== void 0) {
          if (options.height !== void 0 && options.height !== height) {
            throw new Error("Image output config height doesn't match tensor height");
          }
          if (options.width !== void 0 && options.width !== width) {
            throw new Error("Image output config width doesn't match tensor width");
          }
          if (options.format !== void 0 && (channels === 4 && options.format !== "RGBA") || channels === 3 && (options.format !== "RGB" && options.format !== "BGR")) {
            throw new Error("Tensor format doesn't match input tensor dims");
          }
        }
        const step = 4;
        let rImagePointer = 0, gImagePointer = 1, bImagePointer = 2, aImagePointer = 3;
        let rTensorPointer = 0, gTensorPointer = offset, bTensorPointer = offset * 2, aTensorPointer = -1;
        if (inputformat === "RGBA") {
          rTensorPointer = 0;
          gTensorPointer = offset;
          bTensorPointer = offset * 2;
          aTensorPointer = offset * 3;
        } else if (inputformat === "RGB") {
          rTensorPointer = 0;
          gTensorPointer = offset;
          bTensorPointer = offset * 2;
        } else if (inputformat === "RBG") {
          rTensorPointer = 0;
          bTensorPointer = offset;
          gTensorPointer = offset * 2;
        }
        image = pixels2DContext.createImageData(width, height);
        for (let i = 0; i < height * width; rImagePointer += step, gImagePointer += step, bImagePointer += step, aImagePointer += step, i++) {
          image.data[rImagePointer] = (this.data[rTensorPointer++] - normBias) * normMean;
          image.data[gImagePointer] = (this.data[gTensorPointer++] - normBias) * normMean;
          image.data[bImagePointer] = (this.data[bTensorPointer++] - normBias) * normMean;
          image.data[aImagePointer] = aTensorPointer === -1 ? 255 : (this.data[aTensorPointer++] - normBias) * normMean;
        }
      } else {
        throw new Error("Can not access image data");
      }
      return image;
    }
    // #endregion
    // #region tensor utilities
    reshape(dims) {
      return new Tensor2(this.type, this.data, dims);
    }
  };
  const Tensor$1 = Tensor$2;
  let InferenceSession$2 = class InferenceSession2 {
    constructor(handler) {
      this.handler = handler;
    }
    run(feeds, arg1, arg2) {
      return __async(this, null, function* () {
        const fetches = {};
        let options = {};
        if (typeof feeds !== "object" || feeds === null || feeds instanceof Tensor$1 || Array.isArray(feeds)) {
          throw new TypeError("'feeds' must be an object that use input names as keys and OnnxValue as corresponding values.");
        }
        let isFetchesEmpty = true;
        if (typeof arg1 === "object") {
          if (arg1 === null) {
            throw new TypeError("Unexpected argument[1]: cannot be null.");
          }
          if (arg1 instanceof Tensor$1) {
            throw new TypeError("'fetches' cannot be a Tensor");
          }
          if (Array.isArray(arg1)) {
            if (arg1.length === 0) {
              throw new TypeError("'fetches' cannot be an empty array.");
            }
            isFetchesEmpty = false;
            for (const name2 of arg1) {
              if (typeof name2 !== "string") {
                throw new TypeError("'fetches' must be a string array or an object.");
              }
              if (this.outputNames.indexOf(name2) === -1) {
                throw new RangeError(`'fetches' contains invalid output name: ${name2}.`);
              }
              fetches[name2] = null;
            }
            if (typeof arg2 === "object" && arg2 !== null) {
              options = arg2;
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'options' must be an object.");
            }
          } else {
            let isFetches = false;
            const arg1Keys = Object.getOwnPropertyNames(arg1);
            for (const name2 of this.outputNames) {
              if (arg1Keys.indexOf(name2) !== -1) {
                const v = arg1[name2];
                if (v === null || v instanceof Tensor$1) {
                  isFetches = true;
                  isFetchesEmpty = false;
                  fetches[name2] = v;
                }
              }
            }
            if (isFetches) {
              if (typeof arg2 === "object" && arg2 !== null) {
                options = arg2;
              } else if (typeof arg2 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else {
              options = arg1;
            }
          }
        } else if (typeof arg1 !== "undefined") {
          throw new TypeError("Unexpected argument[1]: must be 'fetches' or 'options'.");
        }
        for (const name2 of this.inputNames) {
          if (typeof feeds[name2] === "undefined") {
            throw new Error(`input '${name2}' is missing in 'feeds'.`);
          }
        }
        if (isFetchesEmpty) {
          for (const name2 of this.outputNames) {
            fetches[name2] = null;
          }
        }
        const results = yield this.handler.run(feeds, fetches, options);
        const returnValue = {};
        for (const key in results) {
          if (Object.hasOwnProperty.call(results, key)) {
            returnValue[key] = new Tensor$1(results[key].type, results[key].data, results[key].dims);
          }
        }
        return returnValue;
      });
    }
    static create(arg0, arg1, arg2, arg3) {
      return __async(this, null, function* () {
        let filePathOrUint8Array;
        let options = {};
        if (typeof arg0 === "string") {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof Uint8Array) {
          filePathOrUint8Array = arg0;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
        } else if (arg0 instanceof ArrayBuffer || typeof SharedArrayBuffer !== "undefined" && arg0 instanceof SharedArrayBuffer) {
          const buffer = arg0;
          let byteOffset = 0;
          let byteLength = arg0.byteLength;
          if (typeof arg1 === "object" && arg1 !== null) {
            options = arg1;
          } else if (typeof arg1 === "number") {
            byteOffset = arg1;
            if (!Number.isSafeInteger(byteOffset)) {
              throw new RangeError("'byteOffset' must be an integer.");
            }
            if (byteOffset < 0 || byteOffset >= buffer.byteLength) {
              throw new RangeError(`'byteOffset' is out of range [0, ${buffer.byteLength}).`);
            }
            byteLength = arg0.byteLength - byteOffset;
            if (typeof arg2 === "number") {
              byteLength = arg2;
              if (!Number.isSafeInteger(byteLength)) {
                throw new RangeError("'byteLength' must be an integer.");
              }
              if (byteLength <= 0 || byteOffset + byteLength > buffer.byteLength) {
                throw new RangeError(`'byteLength' is out of range (0, ${buffer.byteLength - byteOffset}].`);
              }
              if (typeof arg3 === "object" && arg3 !== null) {
                options = arg3;
              } else if (typeof arg3 !== "undefined") {
                throw new TypeError("'options' must be an object.");
              }
            } else if (typeof arg2 !== "undefined") {
              throw new TypeError("'byteLength' must be a number.");
            }
          } else if (typeof arg1 !== "undefined") {
            throw new TypeError("'options' must be an object.");
          }
          filePathOrUint8Array = new Uint8Array(buffer, byteOffset, byteLength);
        } else {
          throw new TypeError("Unexpected argument[0]: must be 'path' or 'buffer'.");
        }
        const eps = options.executionProviders || [];
        const backendHints = eps.map((i) => typeof i === "string" ? i : i.name);
        const backend = yield resolveBackend(backendHints);
        const handler = yield backend.createSessionHandler(filePathOrUint8Array, options);
        return new InferenceSession2(handler);
      });
    }
    startProfiling() {
      this.handler.startProfiling();
    }
    endProfiling() {
      this.handler.endProfiling();
    }
    get inputNames() {
      return this.handler.inputNames;
    }
    get outputNames() {
      return this.handler.outputNames;
    }
  };
  const InferenceSession$1 = InferenceSession$2;
  const lib = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    InferenceSession: InferenceSession$1,
    Tensor: Tensor$1,
    env: env$2,
    registerBackend
  }, Symbol.toStringTag, { value: "Module" }));
  const require$$0 = /* @__PURE__ */ getAugmentedNamespace(lib);
  /*!
  * ONNX Runtime Web v1.14.0
  * Copyright (c) Microsoft Corporation. All rights reserved.
  * Licensed under the MIT License.
  */
  var hasRequiredOrtWeb_min;
  function requireOrtWeb_min() {
    if (hasRequiredOrtWeb_min) return ortWeb_min$1.exports;
    hasRequiredOrtWeb_min = 1;
    (function(module, exports) {
      !function(t, e) {
        module.exports = e(require$$0);
      }(self, (__WEBPACK_EXTERNAL_MODULE__1670__) => (() => {
        var __webpack_modules__ = { 3474: (t, e, n) => {
          var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
            function e2() {
              return $.buffer != C && H($.buffer), F;
            }
            function r2() {
              return $.buffer != C && H($.buffer), N;
            }
            function i() {
              return $.buffer != C && H($.buffer), L;
            }
            function o() {
              return $.buffer != C && H($.buffer), R;
            }
            function a() {
              return $.buffer != C && H($.buffer), j;
            }
            var s, u, c;
            t2 = t2 || {}, s || (s = void 0 !== t2 ? t2 : {}), s.ready = new Promise(function(t3, e3) {
              u = t3, c = e3;
            });
            var l, p, f, d, h, g, b = Object.assign({}, s), m = "./this.program", y = (t3, e3) => {
              throw e3;
            }, _ = "object" == typeof window, v = "function" == typeof importScripts, w = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x = s.ENVIRONMENT_IS_PTHREAD || false, T = "";
            function S(t3) {
              return s.locateFile ? s.locateFile(t3, T) : T + t3;
            }
            if (w) {
              let e3;
              T = v ? n(908).dirname(T) + "/" : "//", g = () => {
                h || (d = n(1384), h = n(908));
              }, l = function(t3, e4) {
                return g(), t3 = h.normalize(t3), d.readFileSync(t3, e4 ? void 0 : "utf8");
              }, f = (t3) => ((t3 = l(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), p = (t3, e4, n2) => {
                g(), t3 = h.normalize(t3), d.readFile(t3, function(t4, r3) {
                  t4 ? n2(t4) : e4(r3.buffer);
                });
              }, 1 < process.argv.length && (m = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
                if (!(t3 instanceof ut)) throw t3;
              }), process.on("unhandledRejection", function(t3) {
                throw t3;
              }), y = (t3, e4) => {
                if (J()) throw process.exitCode = t3, e4;
                e4 instanceof ut || P("exiting due to exception: " + e4), process.exit(t3);
              }, s.inspect = function() {
                return "[Emscripten Module object]";
              };
              try {
                e3 = n(9925);
              } catch (t3) {
                throw console.error('The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?'), t3;
              }
              n.g.Worker = e3.Worker;
            } else (_ || v) && (v ? T = self.location.href : "undefined" != typeof document && document.currentScript && (T = document.currentScript.src), _scriptDir && (T = _scriptDir), T = 0 !== T.indexOf("blob:") ? T.substr(0, T.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", w || (l = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.send(null), e3.responseText;
            }, v && (f = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
            }), p = (t3, e3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            }));
            w && "undefined" == typeof performance && (n.g.performance = n(6953).performance);
            var O = console.log.bind(console), A = console.warn.bind(console);
            w && (g(), O = (t3) => d.writeSync(1, t3 + "\n"), A = (t3) => d.writeSync(2, t3 + "\n"));
            var E, I = s.print || O, P = s.printErr || A;
            Object.assign(s, b), b = null, s.thisProgram && (m = s.thisProgram), s.quit && (y = s.quit), s.wasmBinary && (E = s.wasmBinary);
            var D = s.noExitRuntime || false;
            "object" != typeof WebAssembly && it("no native wasm support detected");
            var $, k, C, F, N, L, R, j, M = false, U = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function V(t3, e3, n2) {
              var r3 = (e3 >>>= 0) + n2;
              for (n2 = e3; t3[n2] && !(n2 >= r3); ) ++n2;
              if (16 < n2 - e3 && t3.buffer && U) return U.decode(t3.buffer instanceof SharedArrayBuffer ? t3.slice(e3, n2) : t3.subarray(e3, n2));
              for (r3 = ""; e3 < n2; ) {
                var i2 = t3[e3++];
                if (128 & i2) {
                  var o2 = 63 & t3[e3++];
                  if (192 == (224 & i2)) r3 += String.fromCharCode((31 & i2) << 6 | o2);
                  else {
                    var a2 = 63 & t3[e3++];
                    65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                  }
                } else r3 += String.fromCharCode(i2);
              }
              return r3;
            }
            function B(t3, e3) {
              return (t3 >>>= 0) ? V(r2(), t3, e3) : "";
            }
            function z(t3, e3, n2, r3) {
              if (!(0 < r3)) return 0;
              var i2 = n2 >>>= 0;
              r3 = n2 + r3 - 1;
              for (var o2 = 0; o2 < t3.length; ++o2) {
                var a2 = t3.charCodeAt(o2);
                if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                  if (n2 >= r3) break;
                  e3[n2++ >>> 0] = a2;
                } else {
                  if (2047 >= a2) {
                    if (n2 + 1 >= r3) break;
                    e3[n2++ >>> 0] = 192 | a2 >> 6;
                  } else {
                    if (65535 >= a2) {
                      if (n2 + 2 >= r3) break;
                      e3[n2++ >>> 0] = 224 | a2 >> 12;
                    } else {
                      if (n2 + 3 >= r3) break;
                      e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                    }
                    e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                  }
                  e3[n2++ >>> 0] = 128 | 63 & a2;
                }
              }
              return e3[n2 >>> 0] = 0, n2 - i2;
            }
            function G(t3) {
              for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                var r3 = t3.charCodeAt(n2);
                127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
              }
              return e3;
            }
            function H(t3) {
              C = t3, s.HEAP8 = F = new Int8Array(t3), s.HEAP16 = new Int16Array(t3), s.HEAP32 = L = new Int32Array(t3), s.HEAPU8 = N = new Uint8Array(t3), s.HEAPU16 = new Uint16Array(t3), s.HEAPU32 = R = new Uint32Array(t3), s.HEAPF32 = new Float32Array(t3), s.HEAPF64 = j = new Float64Array(t3);
            }
            x && (C = s.buffer);
            var W = s.INITIAL_MEMORY || 16777216;
            if (x) $ = s.wasmMemory, C = s.buffer;
            else if (s.wasmMemory) $ = s.wasmMemory;
            else if (!(($ = new WebAssembly.Memory({ initial: W / 65536, maximum: 65536, shared: true })).buffer instanceof SharedArrayBuffer)) throw P("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"), w && console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"), Error("bad memory");
            $ && (C = $.buffer), W = C.byteLength, H(C);
            var q, X = [], Y = [], K = [], Z = [];
            function J() {
              return D || false;
            }
            function Q() {
              var t3 = s.preRun.shift();
              X.unshift(t3);
            }
            var tt, et = 0, rt = null;
            function it(t3) {
              throw x ? postMessage({ cmd: "onAbort", arg: t3 }) : s.onAbort && s.onAbort(t3), P(t3 = "Aborted(" + t3 + ")"), M = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), c(t3), t3;
            }
            function ot() {
              return tt.startsWith("data:application/octet-stream;base64,");
            }
            function at() {
              var t3 = tt;
              try {
                if (t3 == tt && E) return new Uint8Array(E);
                if (f) return f(t3);
                throw "both async and sync fetching of the wasm failed";
              } catch (t4) {
                it(t4);
              }
            }
            tt = "ort-wasm-threaded.wasm", ot() || (tt = S(tt));
            var st = {};
            function ut(t3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
            }
            function ct(t3) {
              (t3 = dt.Vb[t3]) || it(), dt.mc(t3);
            }
            function lt(t3) {
              var e3 = dt.Cc();
              if (!e3) return 6;
              dt.ac.push(e3), dt.Vb[t3.Ub] = e3, e3.Ub = t3.Ub;
              var n2 = { cmd: "run", start_routine: t3.Ic, arg: t3.zc, pthread_ptr: t3.Ub };
              return e3.$b = () => {
                n2.time = performance.now(), e3.postMessage(n2, t3.Nc);
              }, e3.loaded && (e3.$b(), delete e3.$b), 0;
            }
            function pt(t3) {
              if (x) return qt(1, 1, t3);
              J() || (dt.oc(), s.onExit && s.onExit(t3), M = true), y(t3, new ut(t3));
            }
            function ft(t3, e3) {
              if (!e3 && x) throw bt(t3), "unwind";
              J() || x || (me(), ht(K), be(0), re[1].length && ie(1, 10), re[2].length && ie(2, 10), dt.oc()), pt(t3);
            }
            var dt = { Yb: [], ac: [], qc: [], Vb: {}, fc: function() {
              x && dt.Ec();
            }, Pc: function() {
            }, Ec: function() {
              dt.receiveObjectTransfer = dt.Gc, dt.threadInitTLS = dt.pc, dt.setExitStatus = dt.nc, D = false;
            }, nc: function() {
            }, oc: function() {
              for (var t3 of Object.values(dt.Vb)) dt.mc(t3);
              for (t3 of dt.Yb) t3.terminate();
              dt.Yb = [];
            }, mc: function(t3) {
              var e3 = t3.Ub;
              delete dt.Vb[e3], dt.Yb.push(t3), dt.ac.splice(dt.ac.indexOf(t3), 1), t3.Ub = 0, xe(e3);
            }, Gc: function() {
            }, pc: function() {
              dt.qc.forEach((t3) => t3());
            }, Fc: function(t3, e3) {
              t3.onmessage = (n2) => {
                var r3 = (n2 = n2.data).cmd;
                if (t3.Ub && (dt.Bc = t3.Ub), n2.targetThread && n2.targetThread != de()) {
                  var i2 = dt.Vb[n2.Qc];
                  i2 ? i2.postMessage(n2, n2.transferList) : P('Internal error! Worker sent a message "' + r3 + '" to target pthread ' + n2.targetThread + ", but that thread no longer exists!");
                } else "processProxyingQueue" === r3 ? Vt(n2.queue) : "spawnThread" === r3 ? lt(n2) : "cleanupThread" === r3 ? ct(n2.thread) : "killThread" === r3 ? (n2 = n2.thread, r3 = dt.Vb[n2], delete dt.Vb[n2], r3.terminate(), xe(n2), dt.ac.splice(dt.ac.indexOf(r3), 1), r3.Ub = 0) : "cancelThread" === r3 ? dt.Vb[n2.thread].postMessage({ cmd: "cancel" }) : "loaded" === r3 ? (t3.loaded = true, e3 && e3(t3), t3.$b && (t3.$b(), delete t3.$b)) : "print" === r3 ? I("Thread " + n2.threadId + ": " + n2.text) : "printErr" === r3 ? P("Thread " + n2.threadId + ": " + n2.text) : "alert" === r3 ? alert("Thread " + n2.threadId + ": " + n2.text) : "setimmediate" === n2.target ? t3.postMessage(n2) : "onAbort" === r3 ? s.onAbort && s.onAbort(n2.arg) : r3 && P("worker sent an unknown command " + r3);
                dt.Bc = void 0;
              }, t3.onerror = (t4) => {
                throw P("worker sent an error! " + t4.filename + ":" + t4.lineno + ": " + t4.message), t4;
              }, w && (t3.on("message", function(e4) {
                t3.onmessage({ data: e4 });
              }), t3.on("error", function(e4) {
                t3.onerror(e4);
              }), t3.on("detachedExit", function() {
              })), t3.postMessage({ cmd: "load", urlOrBlob: s.mainScriptUrlOrBlob || _scriptDir, wasmMemory: $, wasmModule: k });
            }, yc: function() {
              var t3 = S("ort-wasm-threaded.worker.js");
              dt.Yb.push(new Worker(t3));
            }, Cc: function() {
              return 0 == dt.Yb.length && (dt.yc(), dt.Fc(dt.Yb[0])), dt.Yb.pop();
            } };
            function ht(t3) {
              for (; 0 < t3.length; ) t3.shift()(s);
            }
            function gt(t3) {
              var e3 = Ae();
              return t3 = t3(), Ee(e3), t3;
            }
            function bt(t3) {
              if (x) return qt(2, 0, t3);
              try {
                ft(t3);
              } catch (t4) {
                t4 instanceof ut || "unwind" == t4 || y(1, t4);
              }
            }
            s.PThread = dt, s.establishStackSpace = function() {
              var t3 = de(), e3 = i()[t3 + 44 >> 2 >>> 0];
              t3 = i()[t3 + 48 >> 2 >>> 0], Oe(e3, e3 - t3), Ee(e3);
            };
            var mt = [];
            function yt(t3) {
              var e3 = mt[t3];
              return e3 || (t3 >= mt.length && (mt.length = t3 + 1), mt[t3] = e3 = q.get(t3)), e3;
            }
            s.invokeEntryPoint = function(t3, e3) {
              t3 = yt(t3)(e3), J() ? dt.nc(t3) : Te(t3);
            };
            var _t, vt, wt = [], xt = 0, Tt = 0;
            function St(t3) {
              this.Zb = t3, this.Sb = t3 - 24, this.xc = function(t4) {
                o()[this.Sb + 4 >> 2 >>> 0] = t4;
              }, this.bc = function() {
                return o()[this.Sb + 4 >> 2 >>> 0];
              }, this.wc = function(t4) {
                o()[this.Sb + 8 >> 2 >>> 0] = t4;
              }, this.Dc = function() {
                return o()[this.Sb + 8 >> 2 >>> 0];
              }, this.rc = function() {
                i()[this.Sb >> 2 >>> 0] = 0;
              }, this.hc = function(t4) {
                t4 = t4 ? 1 : 0, e2()[this.Sb + 12 >> 0 >>> 0] = t4;
              }, this.uc = function() {
                return 0 != e2()[this.Sb + 12 >> 0 >>> 0];
              }, this.ic = function(t4) {
                t4 = t4 ? 1 : 0, e2()[this.Sb + 13 >> 0 >>> 0] = t4;
              }, this.kc = function() {
                return 0 != e2()[this.Sb + 13 >> 0 >>> 0];
              }, this.fc = function(t4, e3) {
                this.cc(0), this.xc(t4), this.wc(e3), this.rc(), this.hc(false), this.ic(false);
              }, this.sc = function() {
                Atomics.add(i(), this.Sb >> 2, 1);
              }, this.Hc = function() {
                return 1 === Atomics.sub(i(), this.Sb >> 2, 1);
              }, this.cc = function(t4) {
                o()[this.Sb + 16 >> 2 >>> 0] = t4;
              }, this.tc = function() {
                return o()[this.Sb + 16 >> 2 >>> 0];
              }, this.vc = function() {
                if (De(this.bc())) return o()[this.Zb >> 2 >>> 0];
                var t4 = this.tc();
                return 0 !== t4 ? t4 : this.Zb;
              };
            }
            function Ot(t3) {
              return ge(new St(t3).Sb);
            }
            function At(t3, e3, n2, r3) {
              return x ? qt(3, 1, t3, e3, n2, r3) : Et(t3, e3, n2, r3);
            }
            function Et(t3, e3, n2, r3) {
              if ("undefined" == typeof SharedArrayBuffer) return P("Current environment does not support SharedArrayBuffer, pthreads are not available!"), 6;
              var i2 = [];
              return x && 0 === i2.length ? At(t3, e3, n2, r3) : (t3 = { Ic: n2, Ub: t3, zc: r3, Nc: i2 }, x ? (t3.Oc = "spawnThread", postMessage(t3, i2), 0) : lt(t3));
            }
            function It(t3, e3, n2) {
              return x ? qt(4, 1, t3, e3, n2) : 0;
            }
            function Pt(t3, e3) {
              if (x) return qt(5, 1, t3, e3);
            }
            function Dt(t3, e3) {
              if (x) return qt(6, 1, t3, e3);
            }
            function $t(t3, e3, n2) {
              if (x) return qt(7, 1, t3, e3, n2);
            }
            function kt(t3, e3, n2) {
              return x ? qt(8, 1, t3, e3, n2) : 0;
            }
            function Ct(t3, e3) {
              if (x) return qt(9, 1, t3, e3);
            }
            function Ft(t3, e3, n2) {
              if (x) return qt(10, 1, t3, e3, n2);
            }
            function Nt(t3, e3, n2, r3) {
              if (x) return qt(11, 1, t3, e3, n2, r3);
            }
            function Lt(t3, e3, n2, r3) {
              if (x) return qt(12, 1, t3, e3, n2, r3);
            }
            function Rt(t3, e3, n2, r3) {
              if (x) return qt(13, 1, t3, e3, n2, r3);
            }
            function jt(t3) {
              if (x) return qt(14, 1, t3);
            }
            function Mt(t3, e3) {
              if (x) return qt(15, 1, t3, e3);
            }
            function Ut(t3, e3, n2) {
              if (x) return qt(16, 1, t3, e3, n2);
            }
            function Vt(t3) {
              Atomics.store(i(), t3 >> 2, 1), de() && we(t3), Atomics.compareExchange(i(), t3 >> 2, 1, 0);
            }
            function Bt(t3) {
              return o()[t3 >>> 2] + 4294967296 * i()[t3 + 4 >>> 2];
            }
            function zt(t3, e3, n2, r3, i2, o2) {
              return x ? qt(17, 1, t3, e3, n2, r3, i2, o2) : -52;
            }
            function Gt(t3, e3, n2, r3, i2, o2) {
              if (x) return qt(18, 1, t3, e3, n2, r3, i2, o2);
            }
            function Ht(t3) {
              var n2 = G(t3) + 1, r3 = he(n2);
              return r3 && z(t3, e2(), r3, n2), r3;
            }
            function Wt(t3, e3, n2) {
              function r3(t4) {
                return (t4 = t4.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t4[1] : "GMT";
              }
              if (x) return qt(19, 1, t3, e3, n2);
              var a2 = (/* @__PURE__ */ new Date()).getFullYear(), s2 = new Date(a2, 0, 1), u2 = new Date(a2, 6, 1);
              a2 = s2.getTimezoneOffset();
              var c2 = u2.getTimezoneOffset(), l2 = Math.max(a2, c2);
              i()[t3 >> 2 >>> 0] = 60 * l2, i()[e3 >> 2 >>> 0] = Number(a2 != c2), t3 = r3(s2), e3 = r3(u2), t3 = Ht(t3), e3 = Ht(e3), c2 < a2 ? (o()[n2 >> 2 >>> 0] = t3, o()[n2 + 4 >> 2 >>> 0] = e3) : (o()[n2 >> 2 >>> 0] = e3, o()[n2 + 4 >> 2 >>> 0] = t3);
            }
            function qt(t3, e3) {
              var n2 = arguments.length - 2, r3 = arguments;
              return gt(() => {
                for (var i2 = Ie(8 * n2), o2 = i2 >> 3, s2 = 0; s2 < n2; s2++) {
                  var u2 = r3[2 + s2];
                  a()[o2 + s2 >>> 0] = u2;
                }
                return ve(t3, n2, i2, e3);
              });
            }
            s.executeNotifiedProxyingQueue = Vt, vt = w ? () => {
              var t3 = process.hrtime();
              return 1e3 * t3[0] + t3[1] / 1e6;
            } : x ? () => performance.now() - s.__performance_now_clock_drift : () => performance.now();
            var Xt, Yt = [], Kt = {};
            function Zt() {
              if (!Xt) {
                var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: m || "./this.program" };
                for (t3 in Kt) void 0 === Kt[t3] ? delete e3[t3] : e3[t3] = Kt[t3];
                var n2 = [];
                for (t3 in e3) n2.push(t3 + "=" + e3[t3]);
                Xt = n2;
              }
              return Xt;
            }
            function Jt(t3, n2) {
              if (x) return qt(20, 1, t3, n2);
              var r3 = 0;
              return Zt().forEach(function(i2, a2) {
                var s2 = n2 + r3;
                for (a2 = o()[t3 + 4 * a2 >> 2 >>> 0] = s2, s2 = 0; s2 < i2.length; ++s2) e2()[a2++ >> 0 >>> 0] = i2.charCodeAt(s2);
                e2()[a2 >> 0 >>> 0] = 0, r3 += i2.length + 1;
              }), 0;
            }
            function Qt(t3, e3) {
              if (x) return qt(21, 1, t3, e3);
              var n2 = Zt();
              o()[t3 >> 2 >>> 0] = n2.length;
              var r3 = 0;
              return n2.forEach(function(t4) {
                r3 += t4.length + 1;
              }), o()[e3 >> 2 >>> 0] = r3, 0;
            }
            function te(t3) {
              return x ? qt(22, 1, t3) : 52;
            }
            function ee(t3, e3, n2, r3) {
              return x ? qt(23, 1, t3, e3, n2, r3) : 52;
            }
            function ne(t3, e3, n2, r3, i2) {
              return x ? qt(24, 1, t3, e3, n2, r3, i2) : 70;
            }
            var re = [null, [], []];
            function ie(t3, e3) {
              var n2 = re[t3];
              0 === e3 || 10 === e3 ? ((1 === t3 ? I : P)(V(n2, 0)), n2.length = 0) : n2.push(e3);
            }
            function oe(t3, e3, n2, i2) {
              if (x) return qt(25, 1, t3, e3, n2, i2);
              for (var a2 = 0, s2 = 0; s2 < n2; s2++) {
                var u2 = o()[e3 >> 2 >>> 0], c2 = o()[e3 + 4 >> 2 >>> 0];
                e3 += 8;
                for (var l2 = 0; l2 < c2; l2++) ie(t3, r2()[u2 + l2 >>> 0]);
                a2 += c2;
              }
              return o()[i2 >> 2 >>> 0] = a2, 0;
            }
            var ae = 0;
            function se(t3) {
              return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
            }
            var ue = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ce = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function le(t3, n2, r3, o2) {
              function a2(t4, e3, n3) {
                for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e3; ) t4 = n3[0] + t4;
                return t4;
              }
              function s2(t4, e3) {
                return a2(t4, e3, "0");
              }
              function u2(t4, e3) {
                function n3(t5) {
                  return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                }
                var r4;
                return 0 === (r4 = n3(t4.getFullYear() - e3.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e3.getMonth())) && (r4 = n3(t4.getDate() - e3.getDate())), r4;
              }
              function c2(t4) {
                switch (t4.getDay()) {
                  case 0:
                    return new Date(t4.getFullYear() - 1, 11, 29);
                  case 1:
                    return t4;
                  case 2:
                    return new Date(t4.getFullYear(), 0, 3);
                  case 3:
                    return new Date(t4.getFullYear(), 0, 2);
                  case 4:
                    return new Date(t4.getFullYear(), 0, 1);
                  case 5:
                    return new Date(t4.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(t4.getFullYear() - 1, 11, 30);
                }
              }
              function l2(t4) {
                var e3 = t4.Wb;
                for (t4 = new Date(new Date(t4.Xb + 1900, 0, 1).getTime()); 0 < e3; ) {
                  var n3 = t4.getMonth(), r4 = (se(t4.getFullYear()) ? ue : ce)[n3];
                  if (!(e3 > r4 - t4.getDate())) {
                    t4.setDate(t4.getDate() + e3);
                    break;
                  }
                  e3 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                }
                return n3 = new Date(t4.getFullYear() + 1, 0, 4), e3 = c2(new Date(t4.getFullYear(), 0, 4)), n3 = c2(n3), 0 >= u2(e3, t4) ? 0 >= u2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
              }
              var p2 = i()[o2 + 40 >> 2 >>> 0];
              for (var f2 in o2 = { Lc: i()[o2 >> 2 >>> 0], Kc: i()[o2 + 4 >> 2 >>> 0], dc: i()[o2 + 8 >> 2 >>> 0], jc: i()[o2 + 12 >> 2 >>> 0], ec: i()[o2 + 16 >> 2 >>> 0], Xb: i()[o2 + 20 >> 2 >>> 0], Tb: i()[o2 + 24 >> 2 >>> 0], Wb: i()[o2 + 28 >> 2 >>> 0], Rc: i()[o2 + 32 >> 2 >>> 0], Jc: i()[o2 + 36 >> 2 >>> 0], Mc: p2 ? B(p2) : "" }, r3 = B(r3), p2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) r3 = r3.replace(new RegExp(f2, "g"), p2[f2]);
              var d2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), h2 = "January February March April May June July August September October November December".split(" ");
              for (f2 in p2 = { "%a": function(t4) {
                return d2[t4.Tb].substring(0, 3);
              }, "%A": function(t4) {
                return d2[t4.Tb];
              }, "%b": function(t4) {
                return h2[t4.ec].substring(0, 3);
              }, "%B": function(t4) {
                return h2[t4.ec];
              }, "%C": function(t4) {
                return s2((t4.Xb + 1900) / 100 | 0, 2);
              }, "%d": function(t4) {
                return s2(t4.jc, 2);
              }, "%e": function(t4) {
                return a2(t4.jc, 2, " ");
              }, "%g": function(t4) {
                return l2(t4).toString().substring(2);
              }, "%G": function(t4) {
                return l2(t4);
              }, "%H": function(t4) {
                return s2(t4.dc, 2);
              }, "%I": function(t4) {
                return 0 == (t4 = t4.dc) ? t4 = 12 : 12 < t4 && (t4 -= 12), s2(t4, 2);
              }, "%j": function(t4) {
                for (var e3 = 0, n3 = 0; n3 <= t4.ec - 1; e3 += (se(t4.Xb + 1900) ? ue : ce)[n3++]) ;
                return s2(t4.jc + e3, 3);
              }, "%m": function(t4) {
                return s2(t4.ec + 1, 2);
              }, "%M": function(t4) {
                return s2(t4.Kc, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(t4) {
                return 0 <= t4.dc && 12 > t4.dc ? "AM" : "PM";
              }, "%S": function(t4) {
                return s2(t4.Lc, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(t4) {
                return t4.Tb || 7;
              }, "%U": function(t4) {
                return s2(Math.floor((t4.Wb + 7 - t4.Tb) / 7), 2);
              }, "%V": function(t4) {
                var e3 = Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7);
                if (2 >= (t4.Tb + 371 - t4.Wb - 2) % 7 && e3++, e3) 53 == e3 && (4 == (n3 = (t4.Tb + 371 - t4.Wb) % 7) || 3 == n3 && se(t4.Xb) || (e3 = 1));
                else {
                  e3 = 52;
                  var n3 = (t4.Tb + 7 - t4.Wb - 1) % 7;
                  (4 == n3 || 5 == n3 && se(t4.Xb % 400 - 1)) && e3++;
                }
                return s2(e3, 2);
              }, "%w": function(t4) {
                return t4.Tb;
              }, "%W": function(t4) {
                return s2(Math.floor((t4.Wb + 7 - (t4.Tb + 6) % 7) / 7), 2);
              }, "%y": function(t4) {
                return (t4.Xb + 1900).toString().substring(2);
              }, "%Y": function(t4) {
                return t4.Xb + 1900;
              }, "%z": function(t4) {
                var e3 = 0 <= (t4 = t4.Jc);
                return t4 = Math.abs(t4) / 60, (e3 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
              }, "%Z": function(t4) {
                return t4.Mc;
              }, "%%": function() {
                return "%";
              } }, r3 = r3.replace(/%%/g, "\0\0"), p2) r3.includes(f2) && (r3 = r3.replace(new RegExp(f2, "g"), p2[f2](o2)));
              return f2 = function(t4) {
                var e3 = Array(G(t4) + 1);
                return z(t4, e3, 0, e3.length), e3;
              }(r3 = r3.replace(/\0\0/g, "%")), f2.length > n2 ? 0 : (function(t4, n3) {
                e2().set(t4, n3 >>> 0);
              }(f2, t3), f2.length - 1);
            }
            dt.fc();
            var pe = [null, pt, bt, At, It, Pt, Dt, $t, kt, Ct, Ft, Nt, Lt, Rt, jt, Mt, Ut, zt, Gt, Wt, Jt, Qt, te, ee, ne, oe], fe = { b: function(t3) {
              return he(t3 + 24) + 24;
            }, n: function(t3) {
              return (t3 = new St(t3)).uc() || (t3.hc(true), xt--), t3.ic(false), wt.push(t3), t3.sc(), t3.vc();
            }, ma: function(t3) {
              throw P("Unexpected exception thrown, this is not properly supported - aborting"), M = true, t3;
            }, x: function() {
              Se(0);
              var t3 = wt.pop();
              if (t3.Hc() && !t3.kc()) {
                var e3 = t3.Dc();
                e3 && yt(e3)(t3.Zb), Ot(t3.Zb);
              }
              Tt = 0;
            }, e: function() {
              var t3 = Tt;
              if (!t3) return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2) return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (Pe(o2, n2, e3.Sb + 16)) return ae = o2, t3;
              }
              return ae = n2, t3;
            }, l: function() {
              var t3 = Tt;
              if (!t3) return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2) return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (Pe(o2, n2, e3.Sb + 16)) return ae = o2, t3;
              }
              return ae = n2, t3;
            }, h: function() {
              var t3 = Tt;
              if (!t3) return ae = 0;
              var e3 = new St(t3);
              e3.cc(t3);
              var n2 = e3.bc();
              if (!n2) return ae = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (Pe(o2, n2, e3.Sb + 16)) return ae = o2, t3;
              }
              return ae = n2, t3;
            }, t: Ot, M: function() {
              var t3 = wt.pop();
              t3 || it("no exception to throw");
              var e3 = t3.Zb;
              throw t3.kc() || (wt.push(t3), t3.ic(true), t3.hc(false), xt++), Tt = e3, e3;
            }, c: function(t3, e3, n2) {
              throw new St(t3).fc(e3, n2), Tt = t3, xt++, t3;
            }, pa: function() {
              return xt;
            }, Fa: function(t3) {
              ye(t3, !v, 1, !_), dt.pc();
            }, T: function(t3) {
              x ? postMessage({ cmd: "cleanupThread", thread: t3 }) : ct(t3);
            }, xa: Et, j: function(t3) {
              throw Tt || (Tt = t3), t3;
            }, H: It, Ma: Pt, ua: Dt, wa: $t, oa: kt, Ka: Ct, Ca: Ft, Ja: Nt, V: Lt, va: Rt, sa: jt, La: Mt, ta: Ut, Ta: function() {
            }, X: function() {
              it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ua: function() {
              it("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, W: function() {
              return Date.now();
            }, ya: function() {
              return 2097152;
            }, Oa: function() {
              return true;
            }, za: function(t3, e3, n2, r3) {
              if (t3 == e3) setTimeout(() => Vt(r3));
              else if (x) postMessage({ targetThread: t3, cmd: "processProxyingQueue", queue: r3 });
              else {
                if (!(t3 = dt.Vb[t3])) return;
                t3.postMessage({ cmd: "processProxyingQueue", queue: r3 });
              }
              return 1;
            }, Ea: function() {
              return -1;
            }, Pa: function(t3, e3) {
              t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getUTCSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), t3 = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0, i()[e3 + 28 >> 2 >>> 0] = t3;
            }, Qa: function(t3, e3) {
              t3 = new Date(1e3 * Bt(t3)), i()[e3 >> 2 >>> 0] = t3.getSeconds(), i()[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), i()[e3 + 8 >> 2 >>> 0] = t3.getHours(), i()[e3 + 12 >> 2 >>> 0] = t3.getDate(), i()[e3 + 16 >> 2 >>> 0] = t3.getMonth(), i()[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, i()[e3 + 24 >> 2 >>> 0] = t3.getDay();
              var n2 = new Date(t3.getFullYear(), 0, 1), r3 = (t3.getTime() - n2.getTime()) / 864e5 | 0;
              i()[e3 + 28 >> 2 >>> 0] = r3, i()[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset(), r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset(), t3 = 0 | (r3 != (n2 = n2.getTimezoneOffset()) && t3.getTimezoneOffset() == Math.min(n2, r3)), i()[e3 + 32 >> 2 >>> 0] = t3;
            }, Ra: function(t3) {
              var e3 = new Date(i()[t3 + 20 >> 2 >>> 0] + 1900, i()[t3 + 16 >> 2 >>> 0], i()[t3 + 12 >> 2 >>> 0], i()[t3 + 8 >> 2 >>> 0], i()[t3 + 4 >> 2 >>> 0], i()[t3 >> 2 >>> 0], 0), n2 = i()[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), o2 = new Date(e3.getFullYear(), 0, 1), a2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), s2 = o2.getTimezoneOffset(), u2 = Math.min(s2, a2);
              return 0 > n2 ? i()[t3 + 32 >> 2 >>> 0] = Number(a2 != s2 && u2 == r3) : 0 < n2 != (u2 == r3) && (a2 = Math.max(s2, a2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? u2 : a2) - r3))), i()[t3 + 24 >> 2 >>> 0] = e3.getDay(), n2 = (e3.getTime() - o2.getTime()) / 864e5 | 0, i()[t3 + 28 >> 2 >>> 0] = n2, i()[t3 >> 2 >>> 0] = e3.getSeconds(), i()[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), i()[t3 + 8 >> 2 >>> 0] = e3.getHours(), i()[t3 + 12 >> 2 >>> 0] = e3.getDate(), i()[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
            }, Aa: zt, Ba: Gt, Sa: function t3(e3, n2, r3) {
              t3.Ac || (t3.Ac = true, Wt(e3, n2, r3));
            }, y: function() {
              it("");
            }, U: function() {
              if (!w && !v) {
                var t3 = "Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";
                _t || (_t = {}), _t[t3] || (_t[t3] = 1, w && (t3 = "warning: " + t3), P(t3));
              }
            }, ra: function() {
              return 4294901760;
            }, B: vt, Ia: function(t3, e3, n2) {
              r2().copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
            }, F: function() {
              return w ? n(3993).cpus().length : navigator.hardwareConcurrency;
            }, Da: function(t3, e3, n2) {
              Yt.length = e3, n2 >>= 3;
              for (var r3 = 0; r3 < e3; r3++) Yt[r3] = a()[n2 + r3 >>> 0];
              return (0 > t3 ? st[-t3 - 1] : pe[t3]).apply(null, Yt);
            }, qa: function(t3) {
              var e3 = r2().length;
              if ((t3 >>>= 0) <= e3 || 4294901760 < t3) return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var i2 = e3 * (1 + 0.2 / n2);
                i2 = Math.min(i2, t3 + 100663296);
                var o2 = Math;
                i2 = Math.max(t3, i2), o2 = o2.min.call(o2, 4294901760, i2 + (65536 - i2 % 65536) % 65536);
                t: {
                  try {
                    $.grow(o2 - C.byteLength + 65535 >>> 16), H($.buffer);
                    var a2 = 1;
                    break t;
                  } catch (t4) {
                  }
                  a2 = void 0;
                }
                if (a2) return true;
              }
              return false;
            }, Na: function() {
              throw "unwind";
            }, Ga: Jt, Ha: Qt, J: ft, I: te, S: ee, ga: ne, R: oe, d: function() {
              return ae;
            }, na: function t3(r3, i2) {
              t3.lc || (t3.lc = function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var t4 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(t4), t4[0]);
                }
                if (w) try {
                  var e3 = n(Object(function() {
                    var t5 = new Error("Cannot find module 'crypto'");
                    throw t5.code = "MODULE_NOT_FOUND", t5;
                  }()));
                  return () => e3.randomBytes(1)[0];
                } catch (t5) {
                }
                return () => it("randomDevice");
              }());
              for (var o2 = 0; o2 < i2; o2++) e2()[r3 + o2 >> 0 >>> 0] = t3.lc();
              return 0;
            }, ia: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ja: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, K: function(t3) {
              var e3 = Ae();
              try {
                return yt(t3)();
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, f: function(t3, e3) {
              var n2 = Ae();
              try {
                return yt(t3)(e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, P: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, Q: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, k: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, p: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                return yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, q: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, N: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, s: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, w: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, L: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, E: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Ae();
              try {
                return yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (Ee(f2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                return Me(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, _: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                return ke(t3, e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, Z: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                return Ue(t3, e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ca: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                return Re(t3, e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, $: function(t3) {
              var e3 = Ae();
              try {
                return $e(t3);
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ba: function(t3, e3) {
              var n2 = Ae();
              try {
                return je(t3, e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, Y: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                return Ce(t3, e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, g: function(t3) {
              var e3 = Ae();
              try {
                yt(t3)();
              } catch (t4) {
                if (Ee(e3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, r: function(t3, e3) {
              var n2 = Ae();
              try {
                yt(t3)(e3);
              } catch (t4) {
                if (Ee(n2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, i: function(t3, e3, n2) {
              var r3 = Ae();
              try {
                yt(t3)(e3, n2);
              } catch (t4) {
                if (Ee(r3), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ha: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, m: function(t3, e3, n2, r3) {
              var i2 = Ae();
              try {
                yt(t3)(e3, n2, r3);
              } catch (t4) {
                if (Ee(i2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, v: function(t3, e3, n2, r3, i2) {
              var o2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (Ee(o2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, u: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, O: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (Ee(s2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, A: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ka: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
              var c2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
              } catch (t4) {
                if (Ee(c2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
              var p2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
              } catch (t4) {
                if (Ee(p2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
              var b2 = Ae();
              try {
                yt(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
              } catch (t4) {
                if (Ee(b2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, fa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Ae();
              try {
                Fe(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (Ee(u2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, da: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Ae();
              try {
                Le(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (Ee(f2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, ea: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Ae();
              try {
                Ne(t3, e3, n2, r3, i2, o2);
              } catch (t4) {
                if (Ee(a2), t4 !== t4 + 0) throw t4;
                Se(1, 0);
              }
            }, o: function(t3) {
              return t3;
            }, a: $ || s.wasmMemory, G: function(t3) {
              ae = t3;
            }, la: le, z: function(t3, e3, n2, r3) {
              return le(t3, e3, n2, r3);
            } };
            !function() {
              function t3(t4, e4) {
                s.asm = t4.exports, dt.qc.push(s.asm.sb), q = s.asm.ub, Y.unshift(s.asm.Va), k = e4, x || (et--, s.monitorRunDependencies && s.monitorRunDependencies(et), 0 == et && (rt && (t4 = rt, rt = null, t4())));
              }
              function e3(e4) {
                t3(e4.instance, e4.module);
              }
              function n2(t4) {
                return function() {
                  if (!E && (_ || v)) {
                    if ("function" == typeof fetch && !tt.startsWith("file://")) return fetch(tt, { credentials: "same-origin" }).then(function(t5) {
                      if (!t5.ok) throw "failed to load wasm binary file at '" + tt + "'";
                      return t5.arrayBuffer();
                    }).catch(function() {
                      return at();
                    });
                    if (p) return new Promise(function(t5, e4) {
                      p(tt, function(e5) {
                        t5(new Uint8Array(e5));
                      }, e4);
                    });
                  }
                  return Promise.resolve().then(function() {
                    return at();
                  });
                }().then(function(t5) {
                  return WebAssembly.instantiate(t5, r3);
                }).then(function(t5) {
                  return t5;
                }).then(t4, function(t5) {
                  P("failed to asynchronously prepare wasm: " + t5), it(t5);
                });
              }
              var r3 = { a: fe };
              if (x || (et++, s.monitorRunDependencies && s.monitorRunDependencies(et)), s.instantiateWasm) try {
                return s.instantiateWasm(r3, t3);
              } catch (t4) {
                return P("Module.instantiateWasm callback failed with error: " + t4), false;
              }
              (E || "function" != typeof WebAssembly.instantiateStreaming || ot() || tt.startsWith("file://") || w || "function" != typeof fetch ? n2(e3) : fetch(tt, { credentials: "same-origin" }).then(function(t4) {
                return WebAssembly.instantiateStreaming(t4, r3).then(e3, function(t5) {
                  return P("wasm streaming compile failed: " + t5), P("falling back to ArrayBuffer instantiation"), n2(e3);
                });
              })).catch(c);
            }(), s.___wasm_call_ctors = function() {
              return (s.___wasm_call_ctors = s.asm.Va).apply(null, arguments);
            }, s._OrtInit = function() {
              return (s._OrtInit = s.asm.Wa).apply(null, arguments);
            }, s._OrtCreateSessionOptions = function() {
              return (s._OrtCreateSessionOptions = s.asm.Xa).apply(null, arguments);
            }, s._OrtAppendExecutionProvider = function() {
              return (s._OrtAppendExecutionProvider = s.asm.Ya).apply(null, arguments);
            }, s._OrtAddSessionConfigEntry = function() {
              return (s._OrtAddSessionConfigEntry = s.asm.Za).apply(null, arguments);
            }, s._OrtReleaseSessionOptions = function() {
              return (s._OrtReleaseSessionOptions = s.asm._a).apply(null, arguments);
            }, s._OrtCreateSession = function() {
              return (s._OrtCreateSession = s.asm.$a).apply(null, arguments);
            }, s._OrtReleaseSession = function() {
              return (s._OrtReleaseSession = s.asm.ab).apply(null, arguments);
            }, s._OrtGetInputCount = function() {
              return (s._OrtGetInputCount = s.asm.bb).apply(null, arguments);
            }, s._OrtGetOutputCount = function() {
              return (s._OrtGetOutputCount = s.asm.cb).apply(null, arguments);
            }, s._OrtGetInputName = function() {
              return (s._OrtGetInputName = s.asm.db).apply(null, arguments);
            }, s._OrtGetOutputName = function() {
              return (s._OrtGetOutputName = s.asm.eb).apply(null, arguments);
            }, s._OrtFree = function() {
              return (s._OrtFree = s.asm.fb).apply(null, arguments);
            }, s._OrtCreateTensor = function() {
              return (s._OrtCreateTensor = s.asm.gb).apply(null, arguments);
            }, s._OrtGetTensorData = function() {
              return (s._OrtGetTensorData = s.asm.hb).apply(null, arguments);
            }, s._OrtReleaseTensor = function() {
              return (s._OrtReleaseTensor = s.asm.ib).apply(null, arguments);
            }, s._OrtCreateRunOptions = function() {
              return (s._OrtCreateRunOptions = s.asm.jb).apply(null, arguments);
            }, s._OrtAddRunConfigEntry = function() {
              return (s._OrtAddRunConfigEntry = s.asm.kb).apply(null, arguments);
            }, s._OrtReleaseRunOptions = function() {
              return (s._OrtReleaseRunOptions = s.asm.lb).apply(null, arguments);
            }, s._OrtRun = function() {
              return (s._OrtRun = s.asm.mb).apply(null, arguments);
            }, s._OrtEndProfiling = function() {
              return (s._OrtEndProfiling = s.asm.nb).apply(null, arguments);
            };
            var de = s._pthread_self = function() {
              return (de = s._pthread_self = s.asm.ob).apply(null, arguments);
            }, he = s._malloc = function() {
              return (he = s._malloc = s.asm.pb).apply(null, arguments);
            }, ge = s._free = function() {
              return (ge = s._free = s.asm.qb).apply(null, arguments);
            }, be = s._fflush = function() {
              return (be = s._fflush = s.asm.rb).apply(null, arguments);
            };
            s.__emscripten_tls_init = function() {
              return (s.__emscripten_tls_init = s.asm.sb).apply(null, arguments);
            };
            var me = s.___funcs_on_exit = function() {
              return (me = s.___funcs_on_exit = s.asm.tb).apply(null, arguments);
            }, ye = s.__emscripten_thread_init = function() {
              return (ye = s.__emscripten_thread_init = s.asm.vb).apply(null, arguments);
            };
            s.__emscripten_thread_crashed = function() {
              return (s.__emscripten_thread_crashed = s.asm.wb).apply(null, arguments);
            };
            var _e, ve = s._emscripten_run_in_main_runtime_thread_js = function() {
              return (ve = s._emscripten_run_in_main_runtime_thread_js = s.asm.xb).apply(null, arguments);
            }, we = s.__emscripten_proxy_execute_task_queue = function() {
              return (we = s.__emscripten_proxy_execute_task_queue = s.asm.yb).apply(null, arguments);
            }, xe = s.__emscripten_thread_free_data = function() {
              return (xe = s.__emscripten_thread_free_data = s.asm.zb).apply(null, arguments);
            }, Te = s.__emscripten_thread_exit = function() {
              return (Te = s.__emscripten_thread_exit = s.asm.Ab).apply(null, arguments);
            }, Se = s._setThrew = function() {
              return (Se = s._setThrew = s.asm.Bb).apply(null, arguments);
            }, Oe = s._emscripten_stack_set_limits = function() {
              return (Oe = s._emscripten_stack_set_limits = s.asm.Cb).apply(null, arguments);
            }, Ae = s.stackSave = function() {
              return (Ae = s.stackSave = s.asm.Db).apply(null, arguments);
            }, Ee = s.stackRestore = function() {
              return (Ee = s.stackRestore = s.asm.Eb).apply(null, arguments);
            }, Ie = s.stackAlloc = function() {
              return (Ie = s.stackAlloc = s.asm.Fb).apply(null, arguments);
            }, Pe = s.___cxa_can_catch = function() {
              return (Pe = s.___cxa_can_catch = s.asm.Gb).apply(null, arguments);
            }, De = s.___cxa_is_pointer_type = function() {
              return (De = s.___cxa_is_pointer_type = s.asm.Hb).apply(null, arguments);
            }, $e = s.dynCall_j = function() {
              return ($e = s.dynCall_j = s.asm.Ib).apply(null, arguments);
            }, ke = s.dynCall_iiiiij = function() {
              return (ke = s.dynCall_iiiiij = s.asm.Jb).apply(null, arguments);
            }, Ce = s.dynCall_jii = function() {
              return (Ce = s.dynCall_jii = s.asm.Kb).apply(null, arguments);
            }, Fe = s.dynCall_viiiiij = function() {
              return (Fe = s.dynCall_viiiiij = s.asm.Lb).apply(null, arguments);
            }, Ne = s.dynCall_vjji = function() {
              return (Ne = s.dynCall_vjji = s.asm.Mb).apply(null, arguments);
            }, Le = s.dynCall_viiijjjii = function() {
              return (Le = s.dynCall_viiijjjii = s.asm.Nb).apply(null, arguments);
            }, Re = s.dynCall_iij = function() {
              return (Re = s.dynCall_iij = s.asm.Ob).apply(null, arguments);
            }, je = s.dynCall_ji = function() {
              return (je = s.dynCall_ji = s.asm.Pb).apply(null, arguments);
            }, Me = s.dynCall_iiiiiij = function() {
              return (Me = s.dynCall_iiiiiij = s.asm.Qb).apply(null, arguments);
            }, Ue = s.dynCall_iiij = function() {
              return (Ue = s.dynCall_iiij = s.asm.Rb).apply(null, arguments);
            };
            function Ve() {
              function t3() {
                if (!_e && (_e = true, s.calledRun = true, !M) && (x || ht(Y), u(s), s.onRuntimeInitialized && s.onRuntimeInitialized(), !x)) {
                  if (s.postRun) for ("function" == typeof s.postRun && (s.postRun = [s.postRun]); s.postRun.length; ) {
                    var t4 = s.postRun.shift();
                    Z.unshift(t4);
                  }
                  ht(Z);
                }
              }
              if (!(0 < et)) if (x) u(s), x || ht(Y), postMessage({ cmd: "loaded" });
              else {
                if (s.preRun) for ("function" == typeof s.preRun && (s.preRun = [s.preRun]); s.preRun.length; ) Q();
                ht(X), 0 < et || (s.setStatus ? (s.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    s.setStatus("");
                  }, 1), t3();
                }, 1)) : t3());
              }
            }
            if (s.UTF8ToString = B, s.stringToUTF8 = function(t3, e3, n2) {
              return z(t3, r2(), e3, n2);
            }, s.lengthBytesUTF8 = G, s.keepRuntimeAlive = J, s.wasmMemory = $, s.stackSave = Ae, s.stackRestore = Ee, s.stackAlloc = Ie, s.ExitStatus = ut, s.PThread = dt, rt = function t3() {
              _e || Ve(), _e || (rt = t3);
            }, s.preInit) for ("function" == typeof s.preInit && (s.preInit = [s.preInit]); 0 < s.preInit.length; ) s.preInit.pop()();
            return Ve(), t2.ready;
          });
          t.exports = r;
        }, 932: (t, e, n) => {
          var _scriptDir, r = (_scriptDir = (_scriptDir = "undefined" != typeof document && document.currentScript ? document.currentScript.src : void 0) || "/index.js", function(t2) {
            var e2, r2, i;
            t2 = t2 || {}, e2 || (e2 = void 0 !== t2 ? t2 : {}), e2.ready = new Promise(function(t3, e3) {
              r2 = t3, i = e3;
            });
            var o, a, s, u, c, l, p = Object.assign({}, e2), f = "./this.program", d = (t3, e3) => {
              throw e3;
            }, h = "object" == typeof window, g = "function" == typeof importScripts, b = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, m = "";
            b ? (m = g ? n(908).dirname(m) + "/" : "//", l = () => {
              c || (u = n(1384), c = n(908));
            }, o = function(t3, e3) {
              return l(), t3 = c.normalize(t3), u.readFileSync(t3, e3 ? void 0 : "utf8");
            }, s = (t3) => ((t3 = o(t3, true)).buffer || (t3 = new Uint8Array(t3)), t3), a = (t3, e3, n2) => {
              l(), t3 = c.normalize(t3), u.readFile(t3, function(t4, r3) {
                t4 ? n2(t4) : e3(r3.buffer);
              });
            }, 1 < process.argv.length && (f = process.argv[1].replace(/\\/g, "/")), process.argv.slice(2), process.on("uncaughtException", function(t3) {
              if (!(t3 instanceof K)) throw t3;
            }), process.on("unhandledRejection", function(t3) {
              throw t3;
            }), d = (t3, e3) => {
              if (w || 0 < U) throw process.exitCode = t3, e3;
              e3 instanceof K || v("exiting due to exception: " + e3), process.exit(t3);
            }, e2.inspect = function() {
              return "[Emscripten Module object]";
            }) : (h || g) && (g ? m = self.location.href : "undefined" != typeof document && document.currentScript && (m = document.currentScript.src), _scriptDir && (m = _scriptDir), m = 0 !== m.indexOf("blob:") ? m.substr(0, m.replace(/[?#].*/, "").lastIndexOf("/") + 1) : "", o = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.send(null), e3.responseText;
            }, g && (s = (t3) => {
              var e3 = new XMLHttpRequest();
              return e3.open("GET", t3, false), e3.responseType = "arraybuffer", e3.send(null), new Uint8Array(e3.response);
            }), a = (t3, e3, n2) => {
              var r3 = new XMLHttpRequest();
              r3.open("GET", t3, true), r3.responseType = "arraybuffer", r3.onload = () => {
                200 == r3.status || 0 == r3.status && r3.response ? e3(r3.response) : n2();
              }, r3.onerror = n2, r3.send(null);
            });
            var y, _ = e2.print || console.log.bind(console), v = e2.printErr || console.warn.bind(console);
            Object.assign(e2, p), p = null, e2.thisProgram && (f = e2.thisProgram), e2.quit && (d = e2.quit), e2.wasmBinary && (y = e2.wasmBinary);
            var w = e2.noExitRuntime || false;
            "object" != typeof WebAssembly && W("no native wasm support detected");
            var x, T, S, O, A, E, I = false, P = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
            function D(t3, e3, n2) {
              var r3 = (e3 >>>= 0) + n2;
              for (n2 = e3; t3[n2] && !(n2 >= r3); ) ++n2;
              if (16 < n2 - e3 && t3.buffer && P) return P.decode(t3.subarray(e3, n2));
              for (r3 = ""; e3 < n2; ) {
                var i2 = t3[e3++];
                if (128 & i2) {
                  var o2 = 63 & t3[e3++];
                  if (192 == (224 & i2)) r3 += String.fromCharCode((31 & i2) << 6 | o2);
                  else {
                    var a2 = 63 & t3[e3++];
                    65536 > (i2 = 224 == (240 & i2) ? (15 & i2) << 12 | o2 << 6 | a2 : (7 & i2) << 18 | o2 << 12 | a2 << 6 | 63 & t3[e3++]) ? r3 += String.fromCharCode(i2) : (i2 -= 65536, r3 += String.fromCharCode(55296 | i2 >> 10, 56320 | 1023 & i2));
                  }
                } else r3 += String.fromCharCode(i2);
              }
              return r3;
            }
            function $(t3, e3) {
              return (t3 >>>= 0) ? D(O, t3, e3) : "";
            }
            function k(t3, e3, n2, r3) {
              if (!(0 < r3)) return 0;
              var i2 = n2 >>>= 0;
              r3 = n2 + r3 - 1;
              for (var o2 = 0; o2 < t3.length; ++o2) {
                var a2 = t3.charCodeAt(o2);
                if (55296 <= a2 && 57343 >= a2 && (a2 = 65536 + ((1023 & a2) << 10) | 1023 & t3.charCodeAt(++o2)), 127 >= a2) {
                  if (n2 >= r3) break;
                  e3[n2++ >>> 0] = a2;
                } else {
                  if (2047 >= a2) {
                    if (n2 + 1 >= r3) break;
                    e3[n2++ >>> 0] = 192 | a2 >> 6;
                  } else {
                    if (65535 >= a2) {
                      if (n2 + 2 >= r3) break;
                      e3[n2++ >>> 0] = 224 | a2 >> 12;
                    } else {
                      if (n2 + 3 >= r3) break;
                      e3[n2++ >>> 0] = 240 | a2 >> 18, e3[n2++ >>> 0] = 128 | a2 >> 12 & 63;
                    }
                    e3[n2++ >>> 0] = 128 | a2 >> 6 & 63;
                  }
                  e3[n2++ >>> 0] = 128 | 63 & a2;
                }
              }
              return e3[n2 >>> 0] = 0, n2 - i2;
            }
            function C(t3) {
              for (var e3 = 0, n2 = 0; n2 < t3.length; ++n2) {
                var r3 = t3.charCodeAt(n2);
                127 >= r3 ? e3++ : 2047 >= r3 ? e3 += 2 : 55296 <= r3 && 57343 >= r3 ? (e3 += 4, ++n2) : e3 += 3;
              }
              return e3;
            }
            function F() {
              var t3 = x.buffer;
              T = t3, e2.HEAP8 = S = new Int8Array(t3), e2.HEAP16 = new Int16Array(t3), e2.HEAP32 = A = new Int32Array(t3), e2.HEAPU8 = O = new Uint8Array(t3), e2.HEAPU16 = new Uint16Array(t3), e2.HEAPU32 = E = new Uint32Array(t3), e2.HEAPF32 = new Float32Array(t3), e2.HEAPF64 = new Float64Array(t3);
            }
            var N, L = [], R = [], j = [], M = [], U = 0;
            function V() {
              var t3 = e2.preRun.shift();
              L.unshift(t3);
            }
            var B, z = 0, H = null;
            function W(t3) {
              throw e2.onAbort && e2.onAbort(t3), v(t3 = "Aborted(" + t3 + ")"), I = true, t3 = new WebAssembly.RuntimeError(t3 + ". Build with -sASSERTIONS for more info."), i(t3), t3;
            }
            function q() {
              return B.startsWith("data:application/octet-stream;base64,");
            }
            if (B = "ort-wasm.wasm", !q()) {
              var X = B;
              B = e2.locateFile ? e2.locateFile(X, m) : m + X;
            }
            function Y() {
              var t3 = B;
              try {
                if (t3 == B && y) return new Uint8Array(y);
                if (s) return s(t3);
                throw "both async and sync fetching of the wasm failed";
              } catch (t4) {
                W(t4);
              }
            }
            function K(t3) {
              this.name = "ExitStatus", this.message = "Program terminated with exit(" + t3 + ")", this.status = t3;
            }
            function Z(t3) {
              for (; 0 < t3.length; ) t3.shift()(e2);
            }
            var J = [], Q = 0, tt = 0;
            function et(t3) {
              this.Db = t3, this.zb = t3 - 24, this.Ub = function(t4) {
                E[this.zb + 4 >> 2 >>> 0] = t4;
              }, this.Eb = function() {
                return E[this.zb + 4 >> 2 >>> 0];
              }, this.Sb = function(t4) {
                E[this.zb + 8 >> 2 >>> 0] = t4;
              }, this.Wb = function() {
                return E[this.zb + 8 >> 2 >>> 0];
              }, this.Tb = function() {
                A[this.zb >> 2 >>> 0] = 0;
              }, this.Ib = function(t4) {
                S[this.zb + 12 >> 0 >>> 0] = t4 ? 1 : 0;
              }, this.Pb = function() {
                return 0 != S[this.zb + 12 >> 0 >>> 0];
              }, this.Jb = function(t4) {
                S[this.zb + 13 >> 0 >>> 0] = t4 ? 1 : 0;
              }, this.Lb = function() {
                return 0 != S[this.zb + 13 >> 0 >>> 0];
              }, this.Rb = function(t4, e3) {
                this.Fb(0), this.Ub(t4), this.Sb(e3), this.Tb(), this.Ib(false), this.Jb(false);
              }, this.Nb = function() {
                A[this.zb >> 2 >>> 0] += 1;
              }, this.Xb = function() {
                var t4 = A[this.zb >> 2 >>> 0];
                return A[this.zb >> 2 >>> 0] = t4 - 1, 1 === t4;
              }, this.Fb = function(t4) {
                E[this.zb + 16 >> 2 >>> 0] = t4;
              }, this.Ob = function() {
                return E[this.zb + 16 >> 2 >>> 0];
              }, this.Qb = function() {
                if (Et(this.Eb())) return E[this.Db >> 2 >>> 0];
                var t4 = this.Ob();
                return 0 !== t4 ? t4 : this.Db;
              };
            }
            function nt(t3) {
              return _t(new et(t3).zb);
            }
            var rt = [];
            function it(t3) {
              var e3 = rt[t3];
              return e3 || (t3 >= rt.length && (rt.length = t3 + 1), rt[t3] = e3 = N.get(t3)), e3;
            }
            function ot(t3) {
              var e3 = C(t3) + 1, n2 = yt(e3);
              return n2 && k(t3, S, n2, e3), n2;
            }
            var at = {};
            function st() {
              if (!ut) {
                var t3, e3 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: f || "./this.program" };
                for (t3 in at) void 0 === at[t3] ? delete e3[t3] : e3[t3] = at[t3];
                var n2 = [];
                for (t3 in e3) n2.push(t3 + "=" + e3[t3]);
                ut = n2;
              }
              return ut;
            }
            var ut, ct = [null, [], []];
            function lt(t3, e3) {
              var n2 = ct[t3];
              0 === e3 || 10 === e3 ? ((1 === t3 ? _ : v)(D(n2, 0)), n2.length = 0) : n2.push(e3);
            }
            var pt = 0;
            function ft(t3) {
              return 0 == t3 % 4 && (0 != t3 % 100 || 0 == t3 % 400);
            }
            var dt = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ht = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
            function gt(t3, e3, n2, r3) {
              function i2(t4, e4, n3) {
                for (t4 = "number" == typeof t4 ? t4.toString() : t4 || ""; t4.length < e4; ) t4 = n3[0] + t4;
                return t4;
              }
              function o2(t4, e4) {
                return i2(t4, e4, "0");
              }
              function a2(t4, e4) {
                function n3(t5) {
                  return 0 > t5 ? -1 : 0 < t5 ? 1 : 0;
                }
                var r4;
                return 0 === (r4 = n3(t4.getFullYear() - e4.getFullYear())) && 0 === (r4 = n3(t4.getMonth() - e4.getMonth())) && (r4 = n3(t4.getDate() - e4.getDate())), r4;
              }
              function s2(t4) {
                switch (t4.getDay()) {
                  case 0:
                    return new Date(t4.getFullYear() - 1, 11, 29);
                  case 1:
                    return t4;
                  case 2:
                    return new Date(t4.getFullYear(), 0, 3);
                  case 3:
                    return new Date(t4.getFullYear(), 0, 2);
                  case 4:
                    return new Date(t4.getFullYear(), 0, 1);
                  case 5:
                    return new Date(t4.getFullYear() - 1, 11, 31);
                  case 6:
                    return new Date(t4.getFullYear() - 1, 11, 30);
                }
              }
              function u2(t4) {
                var e4 = t4.Bb;
                for (t4 = new Date(new Date(t4.Cb + 1900, 0, 1).getTime()); 0 < e4; ) {
                  var n3 = t4.getMonth(), r4 = (ft(t4.getFullYear()) ? dt : ht)[n3];
                  if (!(e4 > r4 - t4.getDate())) {
                    t4.setDate(t4.getDate() + e4);
                    break;
                  }
                  e4 -= r4 - t4.getDate() + 1, t4.setDate(1), 11 > n3 ? t4.setMonth(n3 + 1) : (t4.setMonth(0), t4.setFullYear(t4.getFullYear() + 1));
                }
                return n3 = new Date(t4.getFullYear() + 1, 0, 4), e4 = s2(new Date(t4.getFullYear(), 0, 4)), n3 = s2(n3), 0 >= a2(e4, t4) ? 0 >= a2(n3, t4) ? t4.getFullYear() + 1 : t4.getFullYear() : t4.getFullYear() - 1;
              }
              var c2 = A[r3 + 40 >> 2 >>> 0];
              for (var l2 in r3 = { $b: A[r3 >> 2 >>> 0], Zb: A[r3 + 4 >> 2 >>> 0], Gb: A[r3 + 8 >> 2 >>> 0], Kb: A[r3 + 12 >> 2 >>> 0], Hb: A[r3 + 16 >> 2 >>> 0], Cb: A[r3 + 20 >> 2 >>> 0], Ab: A[r3 + 24 >> 2 >>> 0], Bb: A[r3 + 28 >> 2 >>> 0], bc: A[r3 + 32 >> 2 >>> 0], Yb: A[r3 + 36 >> 2 >>> 0], ac: c2 ? $(c2) : "" }, n2 = $(n2), c2 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S", "%Ec": "%c", "%EC": "%C", "%Ex": "%m/%d/%y", "%EX": "%H:%M:%S", "%Ey": "%y", "%EY": "%Y", "%Od": "%d", "%Oe": "%e", "%OH": "%H", "%OI": "%I", "%Om": "%m", "%OM": "%M", "%OS": "%S", "%Ou": "%u", "%OU": "%U", "%OV": "%V", "%Ow": "%w", "%OW": "%W", "%Oy": "%y" }) n2 = n2.replace(new RegExp(l2, "g"), c2[l2]);
              var p2 = "Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "), f2 = "January February March April May June July August September October November December".split(" ");
              for (l2 in c2 = { "%a": function(t4) {
                return p2[t4.Ab].substring(0, 3);
              }, "%A": function(t4) {
                return p2[t4.Ab];
              }, "%b": function(t4) {
                return f2[t4.Hb].substring(0, 3);
              }, "%B": function(t4) {
                return f2[t4.Hb];
              }, "%C": function(t4) {
                return o2((t4.Cb + 1900) / 100 | 0, 2);
              }, "%d": function(t4) {
                return o2(t4.Kb, 2);
              }, "%e": function(t4) {
                return i2(t4.Kb, 2, " ");
              }, "%g": function(t4) {
                return u2(t4).toString().substring(2);
              }, "%G": function(t4) {
                return u2(t4);
              }, "%H": function(t4) {
                return o2(t4.Gb, 2);
              }, "%I": function(t4) {
                return 0 == (t4 = t4.Gb) ? t4 = 12 : 12 < t4 && (t4 -= 12), o2(t4, 2);
              }, "%j": function(t4) {
                for (var e4 = 0, n3 = 0; n3 <= t4.Hb - 1; e4 += (ft(t4.Cb + 1900) ? dt : ht)[n3++]) ;
                return o2(t4.Kb + e4, 3);
              }, "%m": function(t4) {
                return o2(t4.Hb + 1, 2);
              }, "%M": function(t4) {
                return o2(t4.Zb, 2);
              }, "%n": function() {
                return "\n";
              }, "%p": function(t4) {
                return 0 <= t4.Gb && 12 > t4.Gb ? "AM" : "PM";
              }, "%S": function(t4) {
                return o2(t4.$b, 2);
              }, "%t": function() {
                return "	";
              }, "%u": function(t4) {
                return t4.Ab || 7;
              }, "%U": function(t4) {
                return o2(Math.floor((t4.Bb + 7 - t4.Ab) / 7), 2);
              }, "%V": function(t4) {
                var e4 = Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7);
                if (2 >= (t4.Ab + 371 - t4.Bb - 2) % 7 && e4++, e4) 53 == e4 && (4 == (n3 = (t4.Ab + 371 - t4.Bb) % 7) || 3 == n3 && ft(t4.Cb) || (e4 = 1));
                else {
                  e4 = 52;
                  var n3 = (t4.Ab + 7 - t4.Bb - 1) % 7;
                  (4 == n3 || 5 == n3 && ft(t4.Cb % 400 - 1)) && e4++;
                }
                return o2(e4, 2);
              }, "%w": function(t4) {
                return t4.Ab;
              }, "%W": function(t4) {
                return o2(Math.floor((t4.Bb + 7 - (t4.Ab + 6) % 7) / 7), 2);
              }, "%y": function(t4) {
                return (t4.Cb + 1900).toString().substring(2);
              }, "%Y": function(t4) {
                return t4.Cb + 1900;
              }, "%z": function(t4) {
                var e4 = 0 <= (t4 = t4.Yb);
                return t4 = Math.abs(t4) / 60, (e4 ? "+" : "-") + String("0000" + (t4 / 60 * 100 + t4 % 60)).slice(-4);
              }, "%Z": function(t4) {
                return t4.ac;
              }, "%%": function() {
                return "%";
              } }, n2 = n2.replace(/%%/g, "\0\0"), c2) n2.includes(l2) && (n2 = n2.replace(new RegExp(l2, "g"), c2[l2](r3)));
              return l2 = function(t4) {
                var e4 = Array(C(t4) + 1);
                return k(t4, e4, 0, e4.length), e4;
              }(n2 = n2.replace(/\0\0/g, "%")), l2.length > e3 ? 0 : (S.set(l2, t3 >>> 0), l2.length - 1);
            }
            var bt = { a: function(t3) {
              return yt(t3 + 24) + 24;
            }, m: function(t3) {
              return (t3 = new et(t3)).Pb() || (t3.Ib(true), Q--), t3.Jb(false), J.push(t3), t3.Nb(), t3.Qb();
            }, ia: function(t3) {
              throw v("Unexpected exception thrown, this is not properly supported - aborting"), I = true, t3;
            }, w: function() {
              xt(0);
              var t3 = J.pop();
              if (t3.Xb() && !t3.Lb()) {
                var e3 = t3.Wb();
                e3 && it(e3)(t3.Db), nt(t3.Db);
              }
              tt = 0;
            }, d: function() {
              var t3 = tt;
              if (!t3) return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2) return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (At(o2, n2, e3.zb + 16)) return pt = o2, t3;
              }
              return pt = n2, t3;
            }, k: function() {
              var t3 = tt;
              if (!t3) return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2) return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (At(o2, n2, e3.zb + 16)) return pt = o2, t3;
              }
              return pt = n2, t3;
            }, g: function() {
              var t3 = tt;
              if (!t3) return pt = 0;
              var e3 = new et(t3);
              e3.Fb(t3);
              var n2 = e3.Eb();
              if (!n2) return pt = 0, t3;
              for (var r3 = Array.prototype.slice.call(arguments), i2 = 0; i2 < r3.length; i2++) {
                var o2 = r3[i2];
                if (0 === o2 || o2 === n2) break;
                if (At(o2, n2, e3.zb + 16)) return pt = o2, t3;
              }
              return pt = n2, t3;
            }, s: nt, L: function() {
              var t3 = J.pop();
              t3 || W("no exception to throw");
              var e3 = t3.Db;
              throw t3.Lb() || (J.push(t3), t3.Jb(true), t3.Ib(false), Q++), tt = e3, e3;
            }, b: function(t3, e3, n2) {
              throw new et(t3).Rb(e3, n2), tt = t3, Q++, t3;
            }, la: function() {
              return Q;
            }, i: function(t3) {
              throw tt || (tt = t3), t3;
            }, H: function() {
              return 0;
            }, Ba: function() {
            }, pa: function() {
            }, ra: function() {
            }, ka: function() {
              return 0;
            }, za: function() {
            }, ua: function() {
            }, ya: function() {
            }, R: function() {
            }, qa: function() {
            }, na: function() {
            }, Aa: function() {
            }, oa: function() {
            }, Ha: function() {
            }, Ja: function() {
              W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, Ia: function() {
              W("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking");
            }, S: function() {
              return Date.now();
            }, Ca: function() {
              return true;
            }, Da: function(t3, e3) {
              t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getUTCSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getUTCMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getUTCHours(), A[e3 + 12 >> 2 >>> 0] = t3.getUTCDate(), A[e3 + 16 >> 2 >>> 0] = t3.getUTCMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getUTCFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getUTCDay(), A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - Date.UTC(t3.getUTCFullYear(), 0, 1, 0, 0, 0, 0)) / 864e5 | 0;
            }, Ea: function(t3, e3) {
              t3 = new Date(1e3 * (E[t3 >>> 2] + 4294967296 * A[t3 + 4 >>> 2])), A[e3 >> 2 >>> 0] = t3.getSeconds(), A[e3 + 4 >> 2 >>> 0] = t3.getMinutes(), A[e3 + 8 >> 2 >>> 0] = t3.getHours(), A[e3 + 12 >> 2 >>> 0] = t3.getDate(), A[e3 + 16 >> 2 >>> 0] = t3.getMonth(), A[e3 + 20 >> 2 >>> 0] = t3.getFullYear() - 1900, A[e3 + 24 >> 2 >>> 0] = t3.getDay();
              var n2 = new Date(t3.getFullYear(), 0, 1);
              A[e3 + 28 >> 2 >>> 0] = (t3.getTime() - n2.getTime()) / 864e5 | 0, A[e3 + 36 >> 2 >>> 0] = -60 * t3.getTimezoneOffset();
              var r3 = new Date(t3.getFullYear(), 6, 1).getTimezoneOffset();
              n2 = n2.getTimezoneOffset(), A[e3 + 32 >> 2 >>> 0] = 0 | (r3 != n2 && t3.getTimezoneOffset() == Math.min(n2, r3));
            }, Fa: function(t3) {
              var e3 = new Date(A[t3 + 20 >> 2 >>> 0] + 1900, A[t3 + 16 >> 2 >>> 0], A[t3 + 12 >> 2 >>> 0], A[t3 + 8 >> 2 >>> 0], A[t3 + 4 >> 2 >>> 0], A[t3 >> 2 >>> 0], 0), n2 = A[t3 + 32 >> 2 >>> 0], r3 = e3.getTimezoneOffset(), i2 = new Date(e3.getFullYear(), 0, 1), o2 = new Date(e3.getFullYear(), 6, 1).getTimezoneOffset(), a2 = i2.getTimezoneOffset(), s2 = Math.min(a2, o2);
              return 0 > n2 ? A[t3 + 32 >> 2 >>> 0] = Number(o2 != a2 && s2 == r3) : 0 < n2 != (s2 == r3) && (o2 = Math.max(a2, o2), e3.setTime(e3.getTime() + 6e4 * ((0 < n2 ? s2 : o2) - r3))), A[t3 + 24 >> 2 >>> 0] = e3.getDay(), A[t3 + 28 >> 2 >>> 0] = (e3.getTime() - i2.getTime()) / 864e5 | 0, A[t3 >> 2 >>> 0] = e3.getSeconds(), A[t3 + 4 >> 2 >>> 0] = e3.getMinutes(), A[t3 + 8 >> 2 >>> 0] = e3.getHours(), A[t3 + 12 >> 2 >>> 0] = e3.getDate(), A[t3 + 16 >> 2 >>> 0] = e3.getMonth(), e3.getTime() / 1e3 | 0;
            }, sa: function() {
              return -52;
            }, ta: function() {
            }, Ga: function t3(e3, n2, r3) {
              t3.Vb || (t3.Vb = true, function(t4, e4, n3) {
                function r4(t5) {
                  return (t5 = t5.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? t5[1] : "GMT";
                }
                var i2 = (/* @__PURE__ */ new Date()).getFullYear(), o2 = new Date(i2, 0, 1), a2 = new Date(i2, 6, 1);
                i2 = o2.getTimezoneOffset();
                var s2 = a2.getTimezoneOffset();
                A[t4 >> 2 >>> 0] = 60 * Math.max(i2, s2), A[e4 >> 2 >>> 0] = Number(i2 != s2), t4 = r4(o2), e4 = r4(a2), t4 = ot(t4), e4 = ot(e4), s2 < i2 ? (E[n3 >> 2 >>> 0] = t4, E[n3 + 4 >> 2 >>> 0] = e4) : (E[n3 >> 2 >>> 0] = e4, E[n3 + 4 >> 2 >>> 0] = t4);
              }(e3, n2, r3));
            }, B: function() {
              W("");
            }, ma: function() {
              return 4294901760;
            }, I: b ? () => {
              var t3 = process.hrtime();
              return 1e3 * t3[0] + t3[1] / 1e6;
            } : () => performance.now(), xa: function(t3, e3, n2) {
              O.copyWithin(t3 >>> 0, e3 >>> 0, e3 + n2 >>> 0);
            }, G: function(t3) {
              var e3 = O.length;
              if (4294901760 < (t3 >>>= 0)) return false;
              for (var n2 = 1; 4 >= n2; n2 *= 2) {
                var r3 = e3 * (1 + 0.2 / n2);
                r3 = Math.min(r3, t3 + 100663296);
                var i2 = Math;
                r3 = Math.max(t3, r3), i2 = i2.min.call(i2, 4294901760, r3 + (65536 - r3 % 65536) % 65536);
                t: {
                  try {
                    x.grow(i2 - T.byteLength + 65535 >>> 16), F();
                    var o2 = 1;
                    break t;
                  } catch (t4) {
                  }
                  o2 = void 0;
                }
                if (o2) return true;
              }
              return false;
            }, va: function(t3, e3) {
              var n2 = 0;
              return st().forEach(function(r3, i2) {
                var o2 = e3 + n2;
                for (i2 = E[t3 + 4 * i2 >> 2 >>> 0] = o2, o2 = 0; o2 < r3.length; ++o2) S[i2++ >> 0 >>> 0] = r3.charCodeAt(o2);
                S[i2 >> 0 >>> 0] = 0, n2 += r3.length + 1;
              }), 0;
            }, wa: function(t3, e3) {
              var n2 = st();
              E[t3 >> 2 >>> 0] = n2.length;
              var r3 = 0;
              return n2.forEach(function(t4) {
                r3 += t4.length + 1;
              }), E[e3 >> 2 >>> 0] = r3, 0;
            }, ba: function(t3) {
              w || 0 < U || (wt(), Z(j), vt(0), ct[1].length && lt(1, 10), ct[2].length && lt(2, 10)), w || 0 < U || (e2.onExit && e2.onExit(t3), I = true), d(t3, new K(t3));
            }, E: function() {
              return 52;
            }, Q: function() {
              return 52;
            }, ca: function() {
              return 70;
            }, P: function(t3, e3, n2, r3) {
              for (var i2 = 0, o2 = 0; o2 < n2; o2++) {
                var a2 = E[e3 >> 2 >>> 0], s2 = E[e3 + 4 >> 2 >>> 0];
                e3 += 8;
                for (var u2 = 0; u2 < s2; u2++) lt(t3, O[a2 + u2 >>> 0]);
                i2 += s2;
              }
              return E[r3 >> 2 >>> 0] = i2, 0;
            }, c: function() {
              return pt;
            }, ja: function t3(e3, r3) {
              t3.Mb || (t3.Mb = function() {
                if ("object" == typeof crypto && "function" == typeof crypto.getRandomValues) {
                  var t4 = new Uint8Array(1);
                  return () => (crypto.getRandomValues(t4), t4[0]);
                }
                if (b) try {
                  var e4 = n(Object(function() {
                    var t5 = new Error("Cannot find module 'crypto'");
                    throw t5.code = "MODULE_NOT_FOUND", t5;
                  }()));
                  return () => e4.randomBytes(1)[0];
                } catch (t5) {
                }
                return () => W("randomDevice");
              }());
              for (var i2 = 0; i2 < r3; i2++) S[e3 + i2 >> 0 >>> 0] = t3.Mb();
              return 0;
            }, ea: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, fa: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, J: function(t3) {
              var e3 = Tt();
              try {
                return it(t3)();
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, e: function(t3, e3) {
              var n2 = Tt();
              try {
                return it(t3)(e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, N: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, O: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, j: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, o: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                return it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, p: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, M: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, r: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, v: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, K: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, D: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Tt();
              try {
                return it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (St(f2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, X: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                return Lt(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, V: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                return Pt(t3, e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, U: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                return Rt(t3, e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, Z: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                return Ft(t3, e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, W: function(t3) {
              var e3 = Tt();
              try {
                return It(t3);
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, Y: function(t3, e3) {
              var n2 = Tt();
              try {
                return Nt(t3, e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, T: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                return Dt(t3, e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, f: function(t3) {
              var e3 = Tt();
              try {
                it(t3)();
              } catch (t4) {
                if (St(e3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, q: function(t3, e3) {
              var n2 = Tt();
              try {
                it(t3)(e3);
              } catch (t4) {
                if (St(n2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, h: function(t3, e3, n2) {
              var r3 = Tt();
              try {
                it(t3)(e3, n2);
              } catch (t4) {
                if (St(r3), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, da: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, l: function(t3, e3, n2, r3) {
              var i2 = Tt();
              try {
                it(t3)(e3, n2, r3);
              } catch (t4) {
                if (St(i2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, t: function(t3, e3, n2, r3, i2) {
              var o2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2);
              } catch (t4) {
                if (St(o2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, u: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, x: function(t3, e3, n2, r3, i2, o2, a2) {
              var s2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2);
              } catch (t4) {
                if (St(s2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, z: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, ga: function(t3, e3, n2, r3, i2, o2, a2, s2, u2) {
              var c2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2);
              } catch (t4) {
                if (St(c2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, A: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2) {
              var p2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2);
              } catch (t4) {
                if (St(p2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, C: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2) {
              var b2 = Tt();
              try {
                it(t3)(e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2, f2, d2, h2, g2);
              } catch (t4) {
                if (St(b2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, aa: function(t3, e3, n2, r3, i2, o2, a2, s2) {
              var u2 = Tt();
              try {
                $t(t3, e3, n2, r3, i2, o2, a2, s2);
              } catch (t4) {
                if (St(u2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, _: function(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2) {
              var f2 = Tt();
              try {
                Ct(t3, e3, n2, r3, i2, o2, a2, s2, u2, c2, l2, p2);
              } catch (t4) {
                if (St(f2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, $: function(t3, e3, n2, r3, i2, o2) {
              var a2 = Tt();
              try {
                kt(t3, e3, n2, r3, i2, o2);
              } catch (t4) {
                if (St(a2), t4 !== t4 + 0) throw t4;
                xt(1, 0);
              }
            }, n: function(t3) {
              return t3;
            }, F: function(t3) {
              pt = t3;
            }, ha: gt, y: function(t3, e3, n2, r3) {
              return gt(t3, e3, n2, r3);
            } };
            !function() {
              function t3(t4) {
                e2.asm = t4.exports, x = e2.asm.Ka, F(), N = e2.asm.ib, R.unshift(e2.asm.La), z--, e2.monitorRunDependencies && e2.monitorRunDependencies(z), 0 == z && (H && (t4 = H, H = null, t4()));
              }
              function n2(e3) {
                t3(e3.instance);
              }
              function r3(t4) {
                return function() {
                  if (!y && (h || g)) {
                    if ("function" == typeof fetch && !B.startsWith("file://")) return fetch(B, { credentials: "same-origin" }).then(function(t5) {
                      if (!t5.ok) throw "failed to load wasm binary file at '" + B + "'";
                      return t5.arrayBuffer();
                    }).catch(function() {
                      return Y();
                    });
                    if (a) return new Promise(function(t5, e3) {
                      a(B, function(e4) {
                        t5(new Uint8Array(e4));
                      }, e3);
                    });
                  }
                  return Promise.resolve().then(function() {
                    return Y();
                  });
                }().then(function(t5) {
                  return WebAssembly.instantiate(t5, o2);
                }).then(function(t5) {
                  return t5;
                }).then(t4, function(t5) {
                  v("failed to asynchronously prepare wasm: " + t5), W(t5);
                });
              }
              var o2 = { a: bt };
              if (z++, e2.monitorRunDependencies && e2.monitorRunDependencies(z), e2.instantiateWasm) try {
                return e2.instantiateWasm(o2, t3);
              } catch (t4) {
                return v("Module.instantiateWasm callback failed with error: " + t4), false;
              }
              (y || "function" != typeof WebAssembly.instantiateStreaming || q() || B.startsWith("file://") || b || "function" != typeof fetch ? r3(n2) : fetch(B, { credentials: "same-origin" }).then(function(t4) {
                return WebAssembly.instantiateStreaming(t4, o2).then(n2, function(t5) {
                  return v("wasm streaming compile failed: " + t5), v("falling back to ArrayBuffer instantiation"), r3(n2);
                });
              })).catch(i);
            }(), e2.___wasm_call_ctors = function() {
              return (e2.___wasm_call_ctors = e2.asm.La).apply(null, arguments);
            }, e2._OrtInit = function() {
              return (e2._OrtInit = e2.asm.Ma).apply(null, arguments);
            }, e2._OrtCreateSessionOptions = function() {
              return (e2._OrtCreateSessionOptions = e2.asm.Na).apply(null, arguments);
            }, e2._OrtAppendExecutionProvider = function() {
              return (e2._OrtAppendExecutionProvider = e2.asm.Oa).apply(null, arguments);
            }, e2._OrtAddSessionConfigEntry = function() {
              return (e2._OrtAddSessionConfigEntry = e2.asm.Pa).apply(null, arguments);
            }, e2._OrtReleaseSessionOptions = function() {
              return (e2._OrtReleaseSessionOptions = e2.asm.Qa).apply(null, arguments);
            }, e2._OrtCreateSession = function() {
              return (e2._OrtCreateSession = e2.asm.Ra).apply(null, arguments);
            }, e2._OrtReleaseSession = function() {
              return (e2._OrtReleaseSession = e2.asm.Sa).apply(null, arguments);
            }, e2._OrtGetInputCount = function() {
              return (e2._OrtGetInputCount = e2.asm.Ta).apply(null, arguments);
            }, e2._OrtGetOutputCount = function() {
              return (e2._OrtGetOutputCount = e2.asm.Ua).apply(null, arguments);
            }, e2._OrtGetInputName = function() {
              return (e2._OrtGetInputName = e2.asm.Va).apply(null, arguments);
            }, e2._OrtGetOutputName = function() {
              return (e2._OrtGetOutputName = e2.asm.Wa).apply(null, arguments);
            }, e2._OrtFree = function() {
              return (e2._OrtFree = e2.asm.Xa).apply(null, arguments);
            }, e2._OrtCreateTensor = function() {
              return (e2._OrtCreateTensor = e2.asm.Ya).apply(null, arguments);
            }, e2._OrtGetTensorData = function() {
              return (e2._OrtGetTensorData = e2.asm.Za).apply(null, arguments);
            }, e2._OrtReleaseTensor = function() {
              return (e2._OrtReleaseTensor = e2.asm._a).apply(null, arguments);
            }, e2._OrtCreateRunOptions = function() {
              return (e2._OrtCreateRunOptions = e2.asm.$a).apply(null, arguments);
            }, e2._OrtAddRunConfigEntry = function() {
              return (e2._OrtAddRunConfigEntry = e2.asm.ab).apply(null, arguments);
            }, e2._OrtReleaseRunOptions = function() {
              return (e2._OrtReleaseRunOptions = e2.asm.bb).apply(null, arguments);
            }, e2._OrtRun = function() {
              return (e2._OrtRun = e2.asm.cb).apply(null, arguments);
            }, e2._OrtEndProfiling = function() {
              return (e2._OrtEndProfiling = e2.asm.db).apply(null, arguments);
            };
            var mt, yt = e2._malloc = function() {
              return (yt = e2._malloc = e2.asm.eb).apply(null, arguments);
            }, _t = e2._free = function() {
              return (_t = e2._free = e2.asm.fb).apply(null, arguments);
            }, vt = e2._fflush = function() {
              return (vt = e2._fflush = e2.asm.gb).apply(null, arguments);
            }, wt = e2.___funcs_on_exit = function() {
              return (wt = e2.___funcs_on_exit = e2.asm.hb).apply(null, arguments);
            }, xt = e2._setThrew = function() {
              return (xt = e2._setThrew = e2.asm.jb).apply(null, arguments);
            }, Tt = e2.stackSave = function() {
              return (Tt = e2.stackSave = e2.asm.kb).apply(null, arguments);
            }, St = e2.stackRestore = function() {
              return (St = e2.stackRestore = e2.asm.lb).apply(null, arguments);
            }, Ot = e2.stackAlloc = function() {
              return (Ot = e2.stackAlloc = e2.asm.mb).apply(null, arguments);
            }, At = e2.___cxa_can_catch = function() {
              return (At = e2.___cxa_can_catch = e2.asm.nb).apply(null, arguments);
            }, Et = e2.___cxa_is_pointer_type = function() {
              return (Et = e2.___cxa_is_pointer_type = e2.asm.ob).apply(null, arguments);
            }, It = e2.dynCall_j = function() {
              return (It = e2.dynCall_j = e2.asm.pb).apply(null, arguments);
            }, Pt = e2.dynCall_iiiiij = function() {
              return (Pt = e2.dynCall_iiiiij = e2.asm.qb).apply(null, arguments);
            }, Dt = e2.dynCall_jii = function() {
              return (Dt = e2.dynCall_jii = e2.asm.rb).apply(null, arguments);
            }, $t = e2.dynCall_viiiiij = function() {
              return ($t = e2.dynCall_viiiiij = e2.asm.sb).apply(null, arguments);
            }, kt = e2.dynCall_vjji = function() {
              return (kt = e2.dynCall_vjji = e2.asm.tb).apply(null, arguments);
            }, Ct = e2.dynCall_viiijjjii = function() {
              return (Ct = e2.dynCall_viiijjjii = e2.asm.ub).apply(null, arguments);
            }, Ft = e2.dynCall_iij = function() {
              return (Ft = e2.dynCall_iij = e2.asm.vb).apply(null, arguments);
            }, Nt = e2.dynCall_ji = function() {
              return (Nt = e2.dynCall_ji = e2.asm.wb).apply(null, arguments);
            }, Lt = e2.dynCall_iiiiiij = function() {
              return (Lt = e2.dynCall_iiiiiij = e2.asm.xb).apply(null, arguments);
            }, Rt = e2.dynCall_iiij = function() {
              return (Rt = e2.dynCall_iiij = e2.asm.yb).apply(null, arguments);
            };
            function jt() {
              function t3() {
                if (!mt && (mt = true, e2.calledRun = true, !I)) {
                  if (Z(R), r2(e2), e2.onRuntimeInitialized && e2.onRuntimeInitialized(), e2.postRun) for ("function" == typeof e2.postRun && (e2.postRun = [e2.postRun]); e2.postRun.length; ) {
                    var t4 = e2.postRun.shift();
                    M.unshift(t4);
                  }
                  Z(M);
                }
              }
              if (!(0 < z)) {
                if (e2.preRun) for ("function" == typeof e2.preRun && (e2.preRun = [e2.preRun]); e2.preRun.length; ) V();
                Z(L), 0 < z || (e2.setStatus ? (e2.setStatus("Running..."), setTimeout(function() {
                  setTimeout(function() {
                    e2.setStatus("");
                  }, 1), t3();
                }, 1)) : t3());
              }
            }
            if (e2.UTF8ToString = $, e2.stringToUTF8 = function(t3, e3, n2) {
              return k(t3, O, e3, n2);
            }, e2.lengthBytesUTF8 = C, e2.stackSave = Tt, e2.stackRestore = St, e2.stackAlloc = Ot, H = function t3() {
              mt || jt(), mt || (H = t3);
            }, e2.preInit) for ("function" == typeof e2.preInit && (e2.preInit = [e2.preInit]); 0 < e2.preInit.length; ) e2.preInit.pop()();
            return jt(), t2.ready;
          });
          t.exports = r;
        }, 4537: (t) => {
          t.exports = function(t2, e) {
            for (var n = new Array(arguments.length - 1), r = 0, i = 2, o = true; i < arguments.length; ) n[r++] = arguments[i++];
            return new Promise(function(i2, a) {
              n[r] = function(t3) {
                if (o) if (o = false, t3) a(t3);
                else {
                  for (var e2 = new Array(arguments.length - 1), n2 = 0; n2 < e2.length; ) e2[n2++] = arguments[n2];
                  i2.apply(null, e2);
                }
              };
              try {
                t2.apply(e || null, n);
              } catch (t3) {
                o && (o = false, a(t3));
              }
            });
          };
        }, 7419: (t, e) => {
          var n = e;
          n.length = function(t2) {
            var e2 = t2.length;
            if (!e2) return 0;
            for (var n2 = 0; --e2 % 4 > 1 && "=" === t2.charAt(e2); ) ++n2;
            return Math.ceil(3 * t2.length) / 4 - n2;
          };
          for (var r = new Array(64), i = new Array(123), o = 0; o < 64; ) i[r[o] = o < 26 ? o + 65 : o < 52 ? o + 71 : o < 62 ? o - 4 : o - 59 | 43] = o++;
          n.encode = function(t2, e2, n2) {
            for (var i2, o2 = null, a2 = [], s = 0, u = 0; e2 < n2; ) {
              var c = t2[e2++];
              switch (u) {
                case 0:
                  a2[s++] = r[c >> 2], i2 = (3 & c) << 4, u = 1;
                  break;
                case 1:
                  a2[s++] = r[i2 | c >> 4], i2 = (15 & c) << 2, u = 2;
                  break;
                case 2:
                  a2[s++] = r[i2 | c >> 6], a2[s++] = r[63 & c], u = 0;
              }
              s > 8191 && ((o2 || (o2 = [])).push(String.fromCharCode.apply(String, a2)), s = 0);
            }
            return u && (a2[s++] = r[i2], a2[s++] = 61, 1 === u && (a2[s++] = 61)), o2 ? (s && o2.push(String.fromCharCode.apply(String, a2.slice(0, s))), o2.join("")) : String.fromCharCode.apply(String, a2.slice(0, s));
          };
          var a = "invalid encoding";
          n.decode = function(t2, e2, n2) {
            for (var r2, o2 = n2, s = 0, u = 0; u < t2.length; ) {
              var c = t2.charCodeAt(u++);
              if (61 === c && s > 1) break;
              if (void 0 === (c = i[c])) throw Error(a);
              switch (s) {
                case 0:
                  r2 = c, s = 1;
                  break;
                case 1:
                  e2[n2++] = r2 << 2 | (48 & c) >> 4, r2 = c, s = 2;
                  break;
                case 2:
                  e2[n2++] = (15 & r2) << 4 | (60 & c) >> 2, r2 = c, s = 3;
                  break;
                case 3:
                  e2[n2++] = (3 & r2) << 6 | c, s = 0;
              }
            }
            if (1 === s) throw Error(a);
            return n2 - o2;
          }, n.test = function(t2) {
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t2);
          };
        }, 9211: (t) => {
          function e() {
            this._listeners = {};
          }
          t.exports = e, e.prototype.on = function(t2, e2, n) {
            return (this._listeners[t2] || (this._listeners[t2] = [])).push({ fn: e2, ctx: n || this }), this;
          }, e.prototype.off = function(t2, e2) {
            if (void 0 === t2) this._listeners = {};
            else if (void 0 === e2) this._listeners[t2] = [];
            else for (var n = this._listeners[t2], r = 0; r < n.length; ) n[r].fn === e2 ? n.splice(r, 1) : ++r;
            return this;
          }, e.prototype.emit = function(t2) {
            var e2 = this._listeners[t2];
            if (e2) {
              for (var n = [], r = 1; r < arguments.length; ) n.push(arguments[r++]);
              for (r = 0; r < e2.length; ) e2[r].fn.apply(e2[r++].ctx, n);
            }
            return this;
          };
        }, 945: (t) => {
          function e(t2) {
            return "undefined" != typeof Float32Array ? function() {
              var e2 = new Float32Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[3];
              function i2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3];
              }
              function o2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[3], r3[i3 + 1] = n2[2], r3[i3 + 2] = n2[1], r3[i3 + 3] = n2[0];
              }
              function a(t3, r3) {
                return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], e2[0];
              }
              function s(t3, r3) {
                return n2[3] = t3[r3], n2[2] = t3[r3 + 1], n2[1] = t3[r3 + 2], n2[0] = t3[r3 + 3], e2[0];
              }
              t2.writeFloatLE = r2 ? i2 : o2, t2.writeFloatBE = r2 ? o2 : i2, t2.readFloatLE = r2 ? a : s, t2.readFloatBE = r2 ? s : a;
            }() : function() {
              function e2(t3, e3, n2, r2) {
                var i2 = e3 < 0 ? 1 : 0;
                if (i2 && (e3 = -e3), 0 === e3) t3(1 / e3 > 0 ? 0 : 2147483648, n2, r2);
                else if (isNaN(e3)) t3(2143289344, n2, r2);
                else if (e3 > 34028234663852886e22) t3((i2 << 31 | 2139095040) >>> 0, n2, r2);
                else if (e3 < 11754943508222875e-54) t3((i2 << 31 | Math.round(e3 / 1401298464324817e-60)) >>> 0, n2, r2);
                else {
                  var o2 = Math.floor(Math.log(e3) / Math.LN2);
                  t3((i2 << 31 | o2 + 127 << 23 | 8388607 & Math.round(e3 * Math.pow(2, -o2) * 8388608)) >>> 0, n2, r2);
                }
              }
              function a(t3, e3, n2) {
                var r2 = t3(e3, n2), i2 = 2 * (r2 >> 31) + 1, o2 = r2 >>> 23 & 255, a2 = 8388607 & r2;
                return 255 === o2 ? a2 ? NaN : i2 * (1 / 0) : 0 === o2 ? 1401298464324817e-60 * i2 * a2 : i2 * Math.pow(2, o2 - 150) * (a2 + 8388608);
              }
              t2.writeFloatLE = e2.bind(null, n), t2.writeFloatBE = e2.bind(null, r), t2.readFloatLE = a.bind(null, i), t2.readFloatBE = a.bind(null, o);
            }(), "undefined" != typeof Float64Array ? function() {
              var e2 = new Float64Array([-0]), n2 = new Uint8Array(e2.buffer), r2 = 128 === n2[7];
              function i2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[0], r3[i3 + 1] = n2[1], r3[i3 + 2] = n2[2], r3[i3 + 3] = n2[3], r3[i3 + 4] = n2[4], r3[i3 + 5] = n2[5], r3[i3 + 6] = n2[6], r3[i3 + 7] = n2[7];
              }
              function o2(t3, r3, i3) {
                e2[0] = t3, r3[i3] = n2[7], r3[i3 + 1] = n2[6], r3[i3 + 2] = n2[5], r3[i3 + 3] = n2[4], r3[i3 + 4] = n2[3], r3[i3 + 5] = n2[2], r3[i3 + 6] = n2[1], r3[i3 + 7] = n2[0];
              }
              function a(t3, r3) {
                return n2[0] = t3[r3], n2[1] = t3[r3 + 1], n2[2] = t3[r3 + 2], n2[3] = t3[r3 + 3], n2[4] = t3[r3 + 4], n2[5] = t3[r3 + 5], n2[6] = t3[r3 + 6], n2[7] = t3[r3 + 7], e2[0];
              }
              function s(t3, r3) {
                return n2[7] = t3[r3], n2[6] = t3[r3 + 1], n2[5] = t3[r3 + 2], n2[4] = t3[r3 + 3], n2[3] = t3[r3 + 4], n2[2] = t3[r3 + 5], n2[1] = t3[r3 + 6], n2[0] = t3[r3 + 7], e2[0];
              }
              t2.writeDoubleLE = r2 ? i2 : o2, t2.writeDoubleBE = r2 ? o2 : i2, t2.readDoubleLE = r2 ? a : s, t2.readDoubleBE = r2 ? s : a;
            }() : function() {
              function e2(t3, e3, n2, r2, i2, o2) {
                var a2 = r2 < 0 ? 1 : 0;
                if (a2 && (r2 = -r2), 0 === r2) t3(0, i2, o2 + e3), t3(1 / r2 > 0 ? 0 : 2147483648, i2, o2 + n2);
                else if (isNaN(r2)) t3(0, i2, o2 + e3), t3(2146959360, i2, o2 + n2);
                else if (r2 > 17976931348623157e292) t3(0, i2, o2 + e3), t3((a2 << 31 | 2146435072) >>> 0, i2, o2 + n2);
                else {
                  var s;
                  if (r2 < 22250738585072014e-324) t3((s = r2 / 5e-324) >>> 0, i2, o2 + e3), t3((a2 << 31 | s / 4294967296) >>> 0, i2, o2 + n2);
                  else {
                    var u = Math.floor(Math.log(r2) / Math.LN2);
                    1024 === u && (u = 1023), t3(4503599627370496 * (s = r2 * Math.pow(2, -u)) >>> 0, i2, o2 + e3), t3((a2 << 31 | u + 1023 << 20 | 1048576 * s & 1048575) >>> 0, i2, o2 + n2);
                  }
                }
              }
              function a(t3, e3, n2, r2, i2) {
                var o2 = t3(r2, i2 + e3), a2 = t3(r2, i2 + n2), s = 2 * (a2 >> 31) + 1, u = a2 >>> 20 & 2047, c = 4294967296 * (1048575 & a2) + o2;
                return 2047 === u ? c ? NaN : s * (1 / 0) : 0 === u ? 5e-324 * s * c : s * Math.pow(2, u - 1075) * (c + 4503599627370496);
              }
              t2.writeDoubleLE = e2.bind(null, n, 0, 4), t2.writeDoubleBE = e2.bind(null, r, 4, 0), t2.readDoubleLE = a.bind(null, i, 0, 4), t2.readDoubleBE = a.bind(null, o, 4, 0);
            }(), t2;
          }
          function n(t2, e2, n2) {
            e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
          }
          function r(t2, e2, n2) {
            e2[n2] = t2 >>> 24, e2[n2 + 1] = t2 >>> 16 & 255, e2[n2 + 2] = t2 >>> 8 & 255, e2[n2 + 3] = 255 & t2;
          }
          function i(t2, e2) {
            return (t2[e2] | t2[e2 + 1] << 8 | t2[e2 + 2] << 16 | t2[e2 + 3] << 24) >>> 0;
          }
          function o(t2, e2) {
            return (t2[e2] << 24 | t2[e2 + 1] << 16 | t2[e2 + 2] << 8 | t2[e2 + 3]) >>> 0;
          }
          t.exports = e(e);
        }, 7199: (module) => {
          function inquire(moduleName) {
            try {
              var mod = eval("quire".replace(/^/, "re"))(moduleName);
              if (mod && (mod.length || Object.keys(mod).length)) return mod;
            } catch (t) {
            }
            return null;
          }
          module.exports = inquire;
        }, 6662: (t) => {
          t.exports = function(t2, e, n) {
            var r = n || 8192, i = r >>> 1, o = null, a = r;
            return function(n2) {
              if (n2 < 1 || n2 > i) return t2(n2);
              a + n2 > r && (o = t2(r), a = 0);
              var s = e.call(o, a, a += n2);
              return 7 & a && (a = 1 + (7 | a)), s;
            };
          };
        }, 4997: (t, e) => {
          var n = e;
          n.length = function(t2) {
            for (var e2 = 0, n2 = 0, r = 0; r < t2.length; ++r) (n2 = t2.charCodeAt(r)) < 128 ? e2 += 1 : n2 < 2048 ? e2 += 2 : 55296 == (64512 & n2) && 56320 == (64512 & t2.charCodeAt(r + 1)) ? (++r, e2 += 4) : e2 += 3;
            return e2;
          }, n.read = function(t2, e2, n2) {
            if (n2 - e2 < 1) return "";
            for (var r, i = null, o = [], a = 0; e2 < n2; ) (r = t2[e2++]) < 128 ? o[a++] = r : r > 191 && r < 224 ? o[a++] = (31 & r) << 6 | 63 & t2[e2++] : r > 239 && r < 365 ? (r = ((7 & r) << 18 | (63 & t2[e2++]) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++]) - 65536, o[a++] = 55296 + (r >> 10), o[a++] = 56320 + (1023 & r)) : o[a++] = (15 & r) << 12 | (63 & t2[e2++]) << 6 | 63 & t2[e2++], a > 8191 && ((i || (i = [])).push(String.fromCharCode.apply(String, o)), a = 0);
            return i ? (a && i.push(String.fromCharCode.apply(String, o.slice(0, a))), i.join("")) : String.fromCharCode.apply(String, o.slice(0, a));
          }, n.write = function(t2, e2, n2) {
            for (var r, i, o = n2, a = 0; a < t2.length; ++a) (r = t2.charCodeAt(a)) < 128 ? e2[n2++] = r : r < 2048 ? (e2[n2++] = r >> 6 | 192, e2[n2++] = 63 & r | 128) : 55296 == (64512 & r) && 56320 == (64512 & (i = t2.charCodeAt(a + 1))) ? (r = 65536 + ((1023 & r) << 10) + (1023 & i), ++a, e2[n2++] = r >> 18 | 240, e2[n2++] = r >> 12 & 63 | 128, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128) : (e2[n2++] = r >> 12 | 224, e2[n2++] = r >> 6 & 63 | 128, e2[n2++] = 63 & r | 128);
            return n2 - o;
          };
        }, 3442: (t, e) => {
          e.__esModule = true;
          var n = function() {
            function t2(e2) {
              if (!e2) throw new TypeError("Invalid argument; `value` has no value.");
              this.value = t2.EMPTY, e2 && t2.isGuid(e2) && (this.value = e2);
            }
            return t2.isGuid = function(e2) {
              var n2 = e2.toString();
              return e2 && (e2 instanceof t2 || t2.validator.test(n2));
            }, t2.create = function() {
              return new t2([t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-"));
            }, t2.createEmpty = function() {
              return new t2("emptyguid");
            }, t2.parse = function(e2) {
              return new t2(e2);
            }, t2.raw = function() {
              return [t2.gen(2), t2.gen(1), t2.gen(1), t2.gen(1), t2.gen(3)].join("-");
            }, t2.gen = function(t3) {
              for (var e2 = "", n2 = 0; n2 < t3; n2++) e2 += (65536 * (1 + Math.random()) | 0).toString(16).substring(1);
              return e2;
            }, t2.prototype.equals = function(e2) {
              return t2.isGuid(e2) && this.value === e2.toString();
            }, t2.prototype.isEmpty = function() {
              return this.value === t2.EMPTY;
            }, t2.prototype.toString = function() {
              return this.value;
            }, t2.prototype.toJSON = function() {
              return { value: this.value };
            }, t2.validator = new RegExp("^[a-z0-9]{8}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{4}-[a-z0-9]{12}$", "i"), t2.EMPTY = "00000000-0000-0000-0000-000000000000", t2;
          }();
          e.Guid = n;
        }, 3720: (t) => {
          t.exports = n;
          var e = null;
          try {
            e = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11])), {}).exports;
          } catch (t2) {
          }
          function n(t2, e2, n2) {
            this.low = 0 | t2, this.high = 0 | e2, this.unsigned = !!n2;
          }
          function r(t2) {
            return true === (t2 && t2.__isLong__);
          }
          n.prototype.__isLong__, Object.defineProperty(n.prototype, "__isLong__", { value: true }), n.isLong = r;
          var i = {}, o = {};
          function a(t2, e2) {
            var n2, r2, a2;
            return e2 ? (a2 = 0 <= (t2 >>>= 0) && t2 < 256) && (r2 = o[t2]) ? r2 : (n2 = u(t2, (0 | t2) < 0 ? -1 : 0, true), a2 && (o[t2] = n2), n2) : (a2 = -128 <= (t2 |= 0) && t2 < 128) && (r2 = i[t2]) ? r2 : (n2 = u(t2, t2 < 0 ? -1 : 0, false), a2 && (i[t2] = n2), n2);
          }
          function s(t2, e2) {
            if (isNaN(t2)) return e2 ? m : b;
            if (e2) {
              if (t2 < 0) return m;
              if (t2 >= d) return x;
            } else {
              if (t2 <= -h) return T;
              if (t2 + 1 >= h) return w;
            }
            return t2 < 0 ? s(-t2, e2).neg() : u(t2 % f | 0, t2 / f | 0, e2);
          }
          function u(t2, e2, r2) {
            return new n(t2, e2, r2);
          }
          n.fromInt = a, n.fromNumber = s, n.fromBits = u;
          var c = Math.pow;
          function l(t2, e2, n2) {
            if (0 === t2.length) throw Error("empty string");
            if ("NaN" === t2 || "Infinity" === t2 || "+Infinity" === t2 || "-Infinity" === t2) return b;
            if ("number" == typeof e2 ? (n2 = e2, e2 = false) : e2 = !!e2, (n2 = n2 || 10) < 2 || 36 < n2) throw RangeError("radix");
            var r2;
            if ((r2 = t2.indexOf("-")) > 0) throw Error("interior hyphen");
            if (0 === r2) return l(t2.substring(1), e2, n2).neg();
            for (var i2 = s(c(n2, 8)), o2 = b, a2 = 0; a2 < t2.length; a2 += 8) {
              var u2 = Math.min(8, t2.length - a2), p2 = parseInt(t2.substring(a2, a2 + u2), n2);
              if (u2 < 8) {
                var f2 = s(c(n2, u2));
                o2 = o2.mul(f2).add(s(p2));
              } else o2 = (o2 = o2.mul(i2)).add(s(p2));
            }
            return o2.unsigned = e2, o2;
          }
          function p(t2, e2) {
            return "number" == typeof t2 ? s(t2, e2) : "string" == typeof t2 ? l(t2, e2) : u(t2.low, t2.high, "boolean" == typeof e2 ? e2 : t2.unsigned);
          }
          n.fromString = l, n.fromValue = p;
          var f = 4294967296, d = f * f, h = d / 2, g = a(1 << 24), b = a(0);
          n.ZERO = b;
          var m = a(0, true);
          n.UZERO = m;
          var y = a(1);
          n.ONE = y;
          var _ = a(1, true);
          n.UONE = _;
          var v = a(-1);
          n.NEG_ONE = v;
          var w = u(-1, 2147483647, false);
          n.MAX_VALUE = w;
          var x = u(-1, -1, true);
          n.MAX_UNSIGNED_VALUE = x;
          var T = u(0, -2147483648, false);
          n.MIN_VALUE = T;
          var S = n.prototype;
          S.toInt = function() {
            return this.unsigned ? this.low >>> 0 : this.low;
          }, S.toNumber = function() {
            return this.unsigned ? (this.high >>> 0) * f + (this.low >>> 0) : this.high * f + (this.low >>> 0);
          }, S.toString = function(t2) {
            if ((t2 = t2 || 10) < 2 || 36 < t2) throw RangeError("radix");
            if (this.isZero()) return "0";
            if (this.isNegative()) {
              if (this.eq(T)) {
                var e2 = s(t2), n2 = this.div(e2), r2 = n2.mul(e2).sub(this);
                return n2.toString(t2) + r2.toInt().toString(t2);
              }
              return "-" + this.neg().toString(t2);
            }
            for (var i2 = s(c(t2, 6), this.unsigned), o2 = this, a2 = ""; ; ) {
              var u2 = o2.div(i2), l2 = (o2.sub(u2.mul(i2)).toInt() >>> 0).toString(t2);
              if ((o2 = u2).isZero()) return l2 + a2;
              for (; l2.length < 6; ) l2 = "0" + l2;
              a2 = "" + l2 + a2;
            }
          }, S.getHighBits = function() {
            return this.high;
          }, S.getHighBitsUnsigned = function() {
            return this.high >>> 0;
          }, S.getLowBits = function() {
            return this.low;
          }, S.getLowBitsUnsigned = function() {
            return this.low >>> 0;
          }, S.getNumBitsAbs = function() {
            if (this.isNegative()) return this.eq(T) ? 64 : this.neg().getNumBitsAbs();
            for (var t2 = 0 != this.high ? this.high : this.low, e2 = 31; e2 > 0 && 0 == (t2 & 1 << e2); e2--) ;
            return 0 != this.high ? e2 + 33 : e2 + 1;
          }, S.isZero = function() {
            return 0 === this.high && 0 === this.low;
          }, S.eqz = S.isZero, S.isNegative = function() {
            return !this.unsigned && this.high < 0;
          }, S.isPositive = function() {
            return this.unsigned || this.high >= 0;
          }, S.isOdd = function() {
            return 1 == (1 & this.low);
          }, S.isEven = function() {
            return 0 == (1 & this.low);
          }, S.equals = function(t2) {
            return r(t2) || (t2 = p(t2)), (this.unsigned === t2.unsigned || this.high >>> 31 != 1 || t2.high >>> 31 != 1) && this.high === t2.high && this.low === t2.low;
          }, S.eq = S.equals, S.notEquals = function(t2) {
            return !this.eq(t2);
          }, S.neq = S.notEquals, S.ne = S.notEquals, S.lessThan = function(t2) {
            return this.comp(t2) < 0;
          }, S.lt = S.lessThan, S.lessThanOrEqual = function(t2) {
            return this.comp(t2) <= 0;
          }, S.lte = S.lessThanOrEqual, S.le = S.lessThanOrEqual, S.greaterThan = function(t2) {
            return this.comp(t2) > 0;
          }, S.gt = S.greaterThan, S.greaterThanOrEqual = function(t2) {
            return this.comp(t2) >= 0;
          }, S.gte = S.greaterThanOrEqual, S.ge = S.greaterThanOrEqual, S.compare = function(t2) {
            if (r(t2) || (t2 = p(t2)), this.eq(t2)) return 0;
            var e2 = this.isNegative(), n2 = t2.isNegative();
            return e2 && !n2 ? -1 : !e2 && n2 ? 1 : this.unsigned ? t2.high >>> 0 > this.high >>> 0 || t2.high === this.high && t2.low >>> 0 > this.low >>> 0 ? -1 : 1 : this.sub(t2).isNegative() ? -1 : 1;
          }, S.comp = S.compare, S.negate = function() {
            return !this.unsigned && this.eq(T) ? T : this.not().add(y);
          }, S.neg = S.negate, S.add = function(t2) {
            r(t2) || (t2 = p(t2));
            var e2 = this.high >>> 16, n2 = 65535 & this.high, i2 = this.low >>> 16, o2 = 65535 & this.low, a2 = t2.high >>> 16, s2 = 65535 & t2.high, c2 = t2.low >>> 16, l2 = 0, f2 = 0, d2 = 0, h2 = 0;
            return d2 += (h2 += o2 + (65535 & t2.low)) >>> 16, f2 += (d2 += i2 + c2) >>> 16, l2 += (f2 += n2 + s2) >>> 16, l2 += e2 + a2, u((d2 &= 65535) << 16 | (h2 &= 65535), (l2 &= 65535) << 16 | (f2 &= 65535), this.unsigned);
          }, S.subtract = function(t2) {
            return r(t2) || (t2 = p(t2)), this.add(t2.neg());
          }, S.sub = S.subtract, S.multiply = function(t2) {
            if (this.isZero()) return b;
            if (r(t2) || (t2 = p(t2)), e) return u(e.mul(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned);
            if (t2.isZero()) return b;
            if (this.eq(T)) return t2.isOdd() ? T : b;
            if (t2.eq(T)) return this.isOdd() ? T : b;
            if (this.isNegative()) return t2.isNegative() ? this.neg().mul(t2.neg()) : this.neg().mul(t2).neg();
            if (t2.isNegative()) return this.mul(t2.neg()).neg();
            if (this.lt(g) && t2.lt(g)) return s(this.toNumber() * t2.toNumber(), this.unsigned);
            var n2 = this.high >>> 16, i2 = 65535 & this.high, o2 = this.low >>> 16, a2 = 65535 & this.low, c2 = t2.high >>> 16, l2 = 65535 & t2.high, f2 = t2.low >>> 16, d2 = 65535 & t2.low, h2 = 0, m2 = 0, y2 = 0, _2 = 0;
            return y2 += (_2 += a2 * d2) >>> 16, m2 += (y2 += o2 * d2) >>> 16, y2 &= 65535, m2 += (y2 += a2 * f2) >>> 16, h2 += (m2 += i2 * d2) >>> 16, m2 &= 65535, h2 += (m2 += o2 * f2) >>> 16, m2 &= 65535, h2 += (m2 += a2 * l2) >>> 16, h2 += n2 * d2 + i2 * f2 + o2 * l2 + a2 * c2, u((y2 &= 65535) << 16 | (_2 &= 65535), (h2 &= 65535) << 16 | (m2 &= 65535), this.unsigned);
          }, S.mul = S.multiply, S.divide = function(t2) {
            if (r(t2) || (t2 = p(t2)), t2.isZero()) throw Error("division by zero");
            var n2, i2, o2;
            if (e) return this.unsigned || -2147483648 !== this.high || -1 !== t2.low || -1 !== t2.high ? u((this.unsigned ? e.div_u : e.div_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this;
            if (this.isZero()) return this.unsigned ? m : b;
            if (this.unsigned) {
              if (t2.unsigned || (t2 = t2.toUnsigned()), t2.gt(this)) return m;
              if (t2.gt(this.shru(1))) return _;
              o2 = m;
            } else {
              if (this.eq(T)) return t2.eq(y) || t2.eq(v) ? T : t2.eq(T) ? y : (n2 = this.shr(1).div(t2).shl(1)).eq(b) ? t2.isNegative() ? y : v : (i2 = this.sub(t2.mul(n2)), o2 = n2.add(i2.div(t2)));
              if (t2.eq(T)) return this.unsigned ? m : b;
              if (this.isNegative()) return t2.isNegative() ? this.neg().div(t2.neg()) : this.neg().div(t2).neg();
              if (t2.isNegative()) return this.div(t2.neg()).neg();
              o2 = b;
            }
            for (i2 = this; i2.gte(t2); ) {
              n2 = Math.max(1, Math.floor(i2.toNumber() / t2.toNumber()));
              for (var a2 = Math.ceil(Math.log(n2) / Math.LN2), l2 = a2 <= 48 ? 1 : c(2, a2 - 48), f2 = s(n2), d2 = f2.mul(t2); d2.isNegative() || d2.gt(i2); ) d2 = (f2 = s(n2 -= l2, this.unsigned)).mul(t2);
              f2.isZero() && (f2 = y), o2 = o2.add(f2), i2 = i2.sub(d2);
            }
            return o2;
          }, S.div = S.divide, S.modulo = function(t2) {
            return r(t2) || (t2 = p(t2)), e ? u((this.unsigned ? e.rem_u : e.rem_s)(this.low, this.high, t2.low, t2.high), e.get_high(), this.unsigned) : this.sub(this.div(t2).mul(t2));
          }, S.mod = S.modulo, S.rem = S.modulo, S.not = function() {
            return u(~this.low, ~this.high, this.unsigned);
          }, S.and = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low & t2.low, this.high & t2.high, this.unsigned);
          }, S.or = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low | t2.low, this.high | t2.high, this.unsigned);
          }, S.xor = function(t2) {
            return r(t2) || (t2 = p(t2)), u(this.low ^ t2.low, this.high ^ t2.high, this.unsigned);
          }, S.shiftLeft = function(t2) {
            return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low << t2, this.high << t2 | this.low >>> 32 - t2, this.unsigned) : u(0, this.low << t2 - 32, this.unsigned);
          }, S.shl = S.shiftLeft, S.shiftRight = function(t2) {
            return r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63) ? this : t2 < 32 ? u(this.low >>> t2 | this.high << 32 - t2, this.high >> t2, this.unsigned) : u(this.high >> t2 - 32, this.high >= 0 ? 0 : -1, this.unsigned);
          }, S.shr = S.shiftRight, S.shiftRightUnsigned = function(t2) {
            if (r(t2) && (t2 = t2.toInt()), 0 == (t2 &= 63)) return this;
            var e2 = this.high;
            return t2 < 32 ? u(this.low >>> t2 | e2 << 32 - t2, e2 >>> t2, this.unsigned) : u(32 === t2 ? e2 : e2 >>> t2 - 32, 0, this.unsigned);
          }, S.shru = S.shiftRightUnsigned, S.shr_u = S.shiftRightUnsigned, S.toSigned = function() {
            return this.unsigned ? u(this.low, this.high, false) : this;
          }, S.toUnsigned = function() {
            return this.unsigned ? this : u(this.low, this.high, true);
          }, S.toBytes = function(t2) {
            return t2 ? this.toBytesLE() : this.toBytesBE();
          }, S.toBytesLE = function() {
            var t2 = this.high, e2 = this.low;
            return [255 & e2, e2 >>> 8 & 255, e2 >>> 16 & 255, e2 >>> 24, 255 & t2, t2 >>> 8 & 255, t2 >>> 16 & 255, t2 >>> 24];
          }, S.toBytesBE = function() {
            var t2 = this.high, e2 = this.low;
            return [t2 >>> 24, t2 >>> 16 & 255, t2 >>> 8 & 255, 255 & t2, e2 >>> 24, e2 >>> 16 & 255, e2 >>> 8 & 255, 255 & e2];
          }, n.fromBytes = function(t2, e2, r2) {
            return r2 ? n.fromBytesLE(t2, e2) : n.fromBytesBE(t2, e2);
          }, n.fromBytesLE = function(t2, e2) {
            return new n(t2[0] | t2[1] << 8 | t2[2] << 16 | t2[3] << 24, t2[4] | t2[5] << 8 | t2[6] << 16 | t2[7] << 24, e2);
          }, n.fromBytesBE = function(t2, e2) {
            return new n(t2[4] << 24 | t2[5] << 16 | t2[6] << 8 | t2[7], t2[0] << 24 | t2[1] << 16 | t2[2] << 8 | t2[3], e2);
          };
        }, 1446: (t, e, n) => {
          var r, i, o, a = n(2100), s = a.Reader, u = a.Writer, c = a.util, l = a.roots.default || (a.roots.default = {});
          l.onnx = ((o = {}).Version = (r = {}, (i = Object.create(r))[r[0] = "_START_VERSION"] = 0, i[r[1] = "IR_VERSION_2017_10_10"] = 1, i[r[2] = "IR_VERSION_2017_10_30"] = 2, i[r[3] = "IR_VERSION_2017_11_3"] = 3, i[r[4] = "IR_VERSION_2019_1_22"] = 4, i[r[5] = "IR_VERSION"] = 5, i), o.AttributeProto = function() {
            function t2(t3) {
              if (this.floats = [], this.ints = [], this.strings = [], this.tensors = [], this.graphs = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.name = "", t2.prototype.refAttrName = "", t2.prototype.docString = "", t2.prototype.type = 0, t2.prototype.f = 0, t2.prototype.i = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.s = c.newBuffer([]), t2.prototype.t = null, t2.prototype.g = null, t2.prototype.floats = c.emptyArray, t2.prototype.ints = c.emptyArray, t2.prototype.strings = c.emptyArray, t2.prototype.tensors = c.emptyArray, t2.prototype.graphs = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.f && t3.hasOwnProperty("f") && e2.uint32(21).float(t3.f), null != t3.i && t3.hasOwnProperty("i") && e2.uint32(24).int64(t3.i), null != t3.s && t3.hasOwnProperty("s") && e2.uint32(34).bytes(t3.s), null != t3.t && t3.hasOwnProperty("t") && l.onnx.TensorProto.encode(t3.t, e2.uint32(42).fork()).ldelim(), null != t3.g && t3.hasOwnProperty("g") && l.onnx.GraphProto.encode(t3.g, e2.uint32(50).fork()).ldelim(), null != t3.floats && t3.floats.length) {
                e2.uint32(58).fork();
                for (var n2 = 0; n2 < t3.floats.length; ++n2) e2.float(t3.floats[n2]);
                e2.ldelim();
              }
              if (null != t3.ints && t3.ints.length) {
                for (e2.uint32(66).fork(), n2 = 0; n2 < t3.ints.length; ++n2) e2.int64(t3.ints[n2]);
                e2.ldelim();
              }
              if (null != t3.strings && t3.strings.length) for (n2 = 0; n2 < t3.strings.length; ++n2) e2.uint32(74).bytes(t3.strings[n2]);
              if (null != t3.tensors && t3.tensors.length) for (n2 = 0; n2 < t3.tensors.length; ++n2) l.onnx.TensorProto.encode(t3.tensors[n2], e2.uint32(82).fork()).ldelim();
              if (null != t3.graphs && t3.graphs.length) for (n2 = 0; n2 < t3.graphs.length; ++n2) l.onnx.GraphProto.encode(t3.graphs[n2], e2.uint32(90).fork()).ldelim();
              return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(106).string(t3.docString), null != t3.type && t3.hasOwnProperty("type") && e2.uint32(160).int32(t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && e2.uint32(170).string(t3.refAttrName), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.AttributeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.name = t3.string();
                    break;
                  case 21:
                    r2.refAttrName = t3.string();
                    break;
                  case 13:
                    r2.docString = t3.string();
                    break;
                  case 20:
                    r2.type = t3.int32();
                    break;
                  case 2:
                    r2.f = t3.float();
                    break;
                  case 3:
                    r2.i = t3.int64();
                    break;
                  case 4:
                    r2.s = t3.bytes();
                    break;
                  case 5:
                    r2.t = l.onnx.TensorProto.decode(t3, t3.uint32());
                    break;
                  case 6:
                    r2.g = l.onnx.GraphProto.decode(t3, t3.uint32());
                    break;
                  case 7:
                    if (r2.floats && r2.floats.length || (r2.floats = []), 2 == (7 & i2)) for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.floats.push(t3.float());
                    else r2.floats.push(t3.float());
                    break;
                  case 8:
                    if (r2.ints && r2.ints.length || (r2.ints = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.ints.push(t3.int64());
                    else r2.ints.push(t3.int64());
                    break;
                  case 9:
                    r2.strings && r2.strings.length || (r2.strings = []), r2.strings.push(t3.bytes());
                    break;
                  case 10:
                    r2.tensors && r2.tensors.length || (r2.tensors = []), r2.tensors.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                    break;
                  case 11:
                    r2.graphs && r2.graphs.length || (r2.graphs = []), r2.graphs.push(l.onnx.GraphProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name)) return "name: string expected";
              if (null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && !c.isString(t3.refAttrName)) return "refAttrName: string expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString)) return "docString: string expected";
              if (null != t3.type && t3.hasOwnProperty("type")) switch (t3.type) {
                default:
                  return "type: enum value expected";
                case 0:
                case 1:
                case 2:
                case 3:
                case 4:
                case 5:
                case 6:
                case 7:
                case 8:
                case 9:
                case 10:
              }
              if (null != t3.f && t3.hasOwnProperty("f") && "number" != typeof t3.f) return "f: number expected";
              if (null != t3.i && t3.hasOwnProperty("i") && !(c.isInteger(t3.i) || t3.i && c.isInteger(t3.i.low) && c.isInteger(t3.i.high))) return "i: integer|Long expected";
              if (null != t3.s && t3.hasOwnProperty("s") && !(t3.s && "number" == typeof t3.s.length || c.isString(t3.s))) return "s: buffer expected";
              if (null != t3.t && t3.hasOwnProperty("t") && (n2 = l.onnx.TensorProto.verify(t3.t))) return "t." + n2;
              if (null != t3.g && t3.hasOwnProperty("g") && (n2 = l.onnx.GraphProto.verify(t3.g))) return "g." + n2;
              if (null != t3.floats && t3.hasOwnProperty("floats")) {
                if (!Array.isArray(t3.floats)) return "floats: array expected";
                for (var e2 = 0; e2 < t3.floats.length; ++e2) if ("number" != typeof t3.floats[e2]) return "floats: number[] expected";
              }
              if (null != t3.ints && t3.hasOwnProperty("ints")) {
                if (!Array.isArray(t3.ints)) return "ints: array expected";
                for (e2 = 0; e2 < t3.ints.length; ++e2) if (!(c.isInteger(t3.ints[e2]) || t3.ints[e2] && c.isInteger(t3.ints[e2].low) && c.isInteger(t3.ints[e2].high))) return "ints: integer|Long[] expected";
              }
              if (null != t3.strings && t3.hasOwnProperty("strings")) {
                if (!Array.isArray(t3.strings)) return "strings: array expected";
                for (e2 = 0; e2 < t3.strings.length; ++e2) if (!(t3.strings[e2] && "number" == typeof t3.strings[e2].length || c.isString(t3.strings[e2]))) return "strings: buffer[] expected";
              }
              if (null != t3.tensors && t3.hasOwnProperty("tensors")) {
                if (!Array.isArray(t3.tensors)) return "tensors: array expected";
                for (e2 = 0; e2 < t3.tensors.length; ++e2) if (n2 = l.onnx.TensorProto.verify(t3.tensors[e2])) return "tensors." + n2;
              }
              if (null != t3.graphs && t3.hasOwnProperty("graphs")) {
                if (!Array.isArray(t3.graphs)) return "graphs: array expected";
                for (e2 = 0; e2 < t3.graphs.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.GraphProto.verify(t3.graphs[e2])) return "graphs." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.AttributeProto) return t3;
              var e2 = new l.onnx.AttributeProto();
              switch (null != t3.name && (e2.name = String(t3.name)), null != t3.refAttrName && (e2.refAttrName = String(t3.refAttrName)), null != t3.docString && (e2.docString = String(t3.docString)), t3.type) {
                case "UNDEFINED":
                case 0:
                  e2.type = 0;
                  break;
                case "FLOAT":
                case 1:
                  e2.type = 1;
                  break;
                case "INT":
                case 2:
                  e2.type = 2;
                  break;
                case "STRING":
                case 3:
                  e2.type = 3;
                  break;
                case "TENSOR":
                case 4:
                  e2.type = 4;
                  break;
                case "GRAPH":
                case 5:
                  e2.type = 5;
                  break;
                case "FLOATS":
                case 6:
                  e2.type = 6;
                  break;
                case "INTS":
                case 7:
                  e2.type = 7;
                  break;
                case "STRINGS":
                case 8:
                  e2.type = 8;
                  break;
                case "TENSORS":
                case 9:
                  e2.type = 9;
                  break;
                case "GRAPHS":
                case 10:
                  e2.type = 10;
              }
              if (null != t3.f && (e2.f = Number(t3.f)), null != t3.i && (c.Long ? (e2.i = c.Long.fromValue(t3.i)).unsigned = false : "string" == typeof t3.i ? e2.i = parseInt(t3.i, 10) : "number" == typeof t3.i ? e2.i = t3.i : "object" == typeof t3.i && (e2.i = new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber())), null != t3.s && ("string" == typeof t3.s ? c.base64.decode(t3.s, e2.s = c.newBuffer(c.base64.length(t3.s)), 0) : t3.s.length && (e2.s = t3.s)), null != t3.t) {
                if ("object" != typeof t3.t) throw TypeError(".onnx.AttributeProto.t: object expected");
                e2.t = l.onnx.TensorProto.fromObject(t3.t);
              }
              if (null != t3.g) {
                if ("object" != typeof t3.g) throw TypeError(".onnx.AttributeProto.g: object expected");
                e2.g = l.onnx.GraphProto.fromObject(t3.g);
              }
              if (t3.floats) {
                if (!Array.isArray(t3.floats)) throw TypeError(".onnx.AttributeProto.floats: array expected");
                e2.floats = [];
                for (var n2 = 0; n2 < t3.floats.length; ++n2) e2.floats[n2] = Number(t3.floats[n2]);
              }
              if (t3.ints) {
                if (!Array.isArray(t3.ints)) throw TypeError(".onnx.AttributeProto.ints: array expected");
                for (e2.ints = [], n2 = 0; n2 < t3.ints.length; ++n2) c.Long ? (e2.ints[n2] = c.Long.fromValue(t3.ints[n2])).unsigned = false : "string" == typeof t3.ints[n2] ? e2.ints[n2] = parseInt(t3.ints[n2], 10) : "number" == typeof t3.ints[n2] ? e2.ints[n2] = t3.ints[n2] : "object" == typeof t3.ints[n2] && (e2.ints[n2] = new c.LongBits(t3.ints[n2].low >>> 0, t3.ints[n2].high >>> 0).toNumber());
              }
              if (t3.strings) {
                if (!Array.isArray(t3.strings)) throw TypeError(".onnx.AttributeProto.strings: array expected");
                for (e2.strings = [], n2 = 0; n2 < t3.strings.length; ++n2) "string" == typeof t3.strings[n2] ? c.base64.decode(t3.strings[n2], e2.strings[n2] = c.newBuffer(c.base64.length(t3.strings[n2])), 0) : t3.strings[n2].length && (e2.strings[n2] = t3.strings[n2]);
              }
              if (t3.tensors) {
                if (!Array.isArray(t3.tensors)) throw TypeError(".onnx.AttributeProto.tensors: array expected");
                for (e2.tensors = [], n2 = 0; n2 < t3.tensors.length; ++n2) {
                  if ("object" != typeof t3.tensors[n2]) throw TypeError(".onnx.AttributeProto.tensors: object expected");
                  e2.tensors[n2] = l.onnx.TensorProto.fromObject(t3.tensors[n2]);
                }
              }
              if (t3.graphs) {
                if (!Array.isArray(t3.graphs)) throw TypeError(".onnx.AttributeProto.graphs: array expected");
                for (e2.graphs = [], n2 = 0; n2 < t3.graphs.length; ++n2) {
                  if ("object" != typeof t3.graphs[n2]) throw TypeError(".onnx.AttributeProto.graphs: object expected");
                  e2.graphs[n2] = l.onnx.GraphProto.fromObject(t3.graphs[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.floats = [], n2.ints = [], n2.strings = [], n2.tensors = [], n2.graphs = []), e2.defaults) {
                if (n2.name = "", n2.f = 0, c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.i = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                } else n2.i = e2.longs === String ? "0" : 0;
                e2.bytes === String ? n2.s = "" : (n2.s = [], e2.bytes !== Array && (n2.s = c.newBuffer(n2.s))), n2.t = null, n2.g = null, n2.docString = "", n2.type = e2.enums === String ? "UNDEFINED" : 0, n2.refAttrName = "";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.f && t3.hasOwnProperty("f") && (n2.f = e2.json && !isFinite(t3.f) ? String(t3.f) : t3.f), null != t3.i && t3.hasOwnProperty("i") && ("number" == typeof t3.i ? n2.i = e2.longs === String ? String(t3.i) : t3.i : n2.i = e2.longs === String ? c.Long.prototype.toString.call(t3.i) : e2.longs === Number ? new c.LongBits(t3.i.low >>> 0, t3.i.high >>> 0).toNumber() : t3.i), null != t3.s && t3.hasOwnProperty("s") && (n2.s = e2.bytes === String ? c.base64.encode(t3.s, 0, t3.s.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.s) : t3.s), null != t3.t && t3.hasOwnProperty("t") && (n2.t = l.onnx.TensorProto.toObject(t3.t, e2)), null != t3.g && t3.hasOwnProperty("g") && (n2.g = l.onnx.GraphProto.toObject(t3.g, e2)), t3.floats && t3.floats.length) {
                n2.floats = [];
                for (var i2 = 0; i2 < t3.floats.length; ++i2) n2.floats[i2] = e2.json && !isFinite(t3.floats[i2]) ? String(t3.floats[i2]) : t3.floats[i2];
              }
              if (t3.ints && t3.ints.length) for (n2.ints = [], i2 = 0; i2 < t3.ints.length; ++i2) "number" == typeof t3.ints[i2] ? n2.ints[i2] = e2.longs === String ? String(t3.ints[i2]) : t3.ints[i2] : n2.ints[i2] = e2.longs === String ? c.Long.prototype.toString.call(t3.ints[i2]) : e2.longs === Number ? new c.LongBits(t3.ints[i2].low >>> 0, t3.ints[i2].high >>> 0).toNumber() : t3.ints[i2];
              if (t3.strings && t3.strings.length) for (n2.strings = [], i2 = 0; i2 < t3.strings.length; ++i2) n2.strings[i2] = e2.bytes === String ? c.base64.encode(t3.strings[i2], 0, t3.strings[i2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.strings[i2]) : t3.strings[i2];
              if (t3.tensors && t3.tensors.length) for (n2.tensors = [], i2 = 0; i2 < t3.tensors.length; ++i2) n2.tensors[i2] = l.onnx.TensorProto.toObject(t3.tensors[i2], e2);
              if (t3.graphs && t3.graphs.length) for (n2.graphs = [], i2 = 0; i2 < t3.graphs.length; ++i2) n2.graphs[i2] = l.onnx.GraphProto.toObject(t3.graphs[i2], e2);
              return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.type && t3.hasOwnProperty("type") && (n2.type = e2.enums === String ? l.onnx.AttributeProto.AttributeType[t3.type] : t3.type), null != t3.refAttrName && t3.hasOwnProperty("refAttrName") && (n2.refAttrName = t3.refAttrName), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.AttributeType = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "INT"] = 2, e2[t3[3] = "STRING"] = 3, e2[t3[4] = "TENSOR"] = 4, e2[t3[5] = "GRAPH"] = 5, e2[t3[6] = "FLOATS"] = 6, e2[t3[7] = "INTS"] = 7, e2[t3[8] = "STRINGS"] = 8, e2[t3[9] = "TENSORS"] = 9, e2[t3[10] = "GRAPHS"] = 10, e2;
            }(), t2;
          }(), o.ValueInfoProto = function() {
            function t2(t3) {
              if (t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.name = "", t2.prototype.type = null, t2.prototype.docString = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.name && t3.hasOwnProperty("name") && e2.uint32(10).string(t3.name), null != t3.type && t3.hasOwnProperty("type") && l.onnx.TypeProto.encode(t3.type, e2.uint32(18).fork()).ldelim(), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(26).string(t3.docString), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ValueInfoProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.name = t3.string();
                    break;
                  case 2:
                    r2.type = l.onnx.TypeProto.decode(t3, t3.uint32());
                    break;
                  case 3:
                    r2.docString = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name)) return "name: string expected";
              if (null != t3.type && t3.hasOwnProperty("type")) {
                var e2 = l.onnx.TypeProto.verify(t3.type);
                if (e2) return "type." + e2;
              }
              return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.ValueInfoProto) return t3;
              var e2 = new l.onnx.ValueInfoProto();
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.type) {
                if ("object" != typeof t3.type) throw TypeError(".onnx.ValueInfoProto.type: object expected");
                e2.type = l.onnx.TypeProto.fromObject(t3.type);
              }
              return null != t3.docString && (e2.docString = String(t3.docString)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              return e2.defaults && (n2.name = "", n2.type = null, n2.docString = ""), null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.type && t3.hasOwnProperty("type") && (n2.type = l.onnx.TypeProto.toObject(t3.type, e2)), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.NodeProto = function() {
            function t2(t3) {
              if (this.input = [], this.output = [], this.attribute = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.name = "", t2.prototype.opType = "", t2.prototype.domain = "", t2.prototype.attribute = c.emptyArray, t2.prototype.docString = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.input && t3.input.length) for (var n2 = 0; n2 < t3.input.length; ++n2) e2.uint32(10).string(t3.input[n2]);
              if (null != t3.output && t3.output.length) for (n2 = 0; n2 < t3.output.length; ++n2) e2.uint32(18).string(t3.output[n2]);
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(26).string(t3.name), null != t3.opType && t3.hasOwnProperty("opType") && e2.uint32(34).string(t3.opType), null != t3.attribute && t3.attribute.length) for (n2 = 0; n2 < t3.attribute.length; ++n2) l.onnx.AttributeProto.encode(t3.attribute[n2], e2.uint32(42).fork()).ldelim();
              return null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(58).string(t3.domain), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.NodeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(t3.string());
                    break;
                  case 2:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(t3.string());
                    break;
                  case 3:
                    r2.name = t3.string();
                    break;
                  case 4:
                    r2.opType = t3.string();
                    break;
                  case 7:
                    r2.domain = t3.string();
                    break;
                  case 5:
                    r2.attribute && r2.attribute.length || (r2.attribute = []), r2.attribute.push(l.onnx.AttributeProto.decode(t3, t3.uint32()));
                    break;
                  case 6:
                    r2.docString = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.input && t3.hasOwnProperty("input")) {
                if (!Array.isArray(t3.input)) return "input: array expected";
                for (var e2 = 0; e2 < t3.input.length; ++e2) if (!c.isString(t3.input[e2])) return "input: string[] expected";
              }
              if (null != t3.output && t3.hasOwnProperty("output")) {
                if (!Array.isArray(t3.output)) return "output: array expected";
                for (e2 = 0; e2 < t3.output.length; ++e2) if (!c.isString(t3.output[e2])) return "output: string[] expected";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name)) return "name: string expected";
              if (null != t3.opType && t3.hasOwnProperty("opType") && !c.isString(t3.opType)) return "opType: string expected";
              if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain)) return "domain: string expected";
              if (null != t3.attribute && t3.hasOwnProperty("attribute")) {
                if (!Array.isArray(t3.attribute)) return "attribute: array expected";
                for (e2 = 0; e2 < t3.attribute.length; ++e2) {
                  var n2 = l.onnx.AttributeProto.verify(t3.attribute[e2]);
                  if (n2) return "attribute." + n2;
                }
              }
              return null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString) ? "docString: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.NodeProto) return t3;
              var e2 = new l.onnx.NodeProto();
              if (t3.input) {
                if (!Array.isArray(t3.input)) throw TypeError(".onnx.NodeProto.input: array expected");
                e2.input = [];
                for (var n2 = 0; n2 < t3.input.length; ++n2) e2.input[n2] = String(t3.input[n2]);
              }
              if (t3.output) {
                if (!Array.isArray(t3.output)) throw TypeError(".onnx.NodeProto.output: array expected");
                for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2) e2.output[n2] = String(t3.output[n2]);
              }
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.opType && (e2.opType = String(t3.opType)), null != t3.domain && (e2.domain = String(t3.domain)), t3.attribute) {
                if (!Array.isArray(t3.attribute)) throw TypeError(".onnx.NodeProto.attribute: array expected");
                for (e2.attribute = [], n2 = 0; n2 < t3.attribute.length; ++n2) {
                  if ("object" != typeof t3.attribute[n2]) throw TypeError(".onnx.NodeProto.attribute: object expected");
                  e2.attribute[n2] = l.onnx.AttributeProto.fromObject(t3.attribute[n2]);
                }
              }
              return null != t3.docString && (e2.docString = String(t3.docString)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.input = [], n2.output = [], n2.attribute = []), e2.defaults && (n2.name = "", n2.opType = "", n2.docString = "", n2.domain = ""), t3.input && t3.input.length) {
                n2.input = [];
                for (var r2 = 0; r2 < t3.input.length; ++r2) n2.input[r2] = t3.input[r2];
              }
              if (t3.output && t3.output.length) for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2) n2.output[r2] = t3.output[r2];
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.opType && t3.hasOwnProperty("opType") && (n2.opType = t3.opType), t3.attribute && t3.attribute.length) for (n2.attribute = [], r2 = 0; r2 < t3.attribute.length; ++r2) n2.attribute[r2] = l.onnx.AttributeProto.toObject(t3.attribute[r2], e2);
              return null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.ModelProto = function() {
            function t2(t3) {
              if (this.opsetImport = [], this.metadataProps = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.irVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.opsetImport = c.emptyArray, t2.prototype.producerName = "", t2.prototype.producerVersion = "", t2.prototype.domain = "", t2.prototype.modelVersion = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.prototype.docString = "", t2.prototype.graph = null, t2.prototype.metadataProps = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.irVersion && t3.hasOwnProperty("irVersion") && e2.uint32(8).int64(t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && e2.uint32(18).string(t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && e2.uint32(26).string(t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(34).string(t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && e2.uint32(40).int64(t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(50).string(t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && l.onnx.GraphProto.encode(t3.graph, e2.uint32(58).fork()).ldelim(), null != t3.opsetImport && t3.opsetImport.length) for (var n2 = 0; n2 < t3.opsetImport.length; ++n2) l.onnx.OperatorSetIdProto.encode(t3.opsetImport[n2], e2.uint32(66).fork()).ldelim();
              if (null != t3.metadataProps && t3.metadataProps.length) for (n2 = 0; n2 < t3.metadataProps.length; ++n2) l.onnx.StringStringEntryProto.encode(t3.metadataProps[n2], e2.uint32(114).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.ModelProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.irVersion = t3.int64();
                    break;
                  case 8:
                    r2.opsetImport && r2.opsetImport.length || (r2.opsetImport = []), r2.opsetImport.push(l.onnx.OperatorSetIdProto.decode(t3, t3.uint32()));
                    break;
                  case 2:
                    r2.producerName = t3.string();
                    break;
                  case 3:
                    r2.producerVersion = t3.string();
                    break;
                  case 4:
                    r2.domain = t3.string();
                    break;
                  case 5:
                    r2.modelVersion = t3.int64();
                    break;
                  case 6:
                    r2.docString = t3.string();
                    break;
                  case 7:
                    r2.graph = l.onnx.GraphProto.decode(t3, t3.uint32());
                    break;
                  case 14:
                    r2.metadataProps && r2.metadataProps.length || (r2.metadataProps = []), r2.metadataProps.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && !(c.isInteger(t3.irVersion) || t3.irVersion && c.isInteger(t3.irVersion.low) && c.isInteger(t3.irVersion.high))) return "irVersion: integer|Long expected";
              if (null != t3.opsetImport && t3.hasOwnProperty("opsetImport")) {
                if (!Array.isArray(t3.opsetImport)) return "opsetImport: array expected";
                for (var e2 = 0; e2 < t3.opsetImport.length; ++e2) if (n2 = l.onnx.OperatorSetIdProto.verify(t3.opsetImport[e2])) return "opsetImport." + n2;
              }
              if (null != t3.producerName && t3.hasOwnProperty("producerName") && !c.isString(t3.producerName)) return "producerName: string expected";
              if (null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && !c.isString(t3.producerVersion)) return "producerVersion: string expected";
              if (null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain)) return "domain: string expected";
              if (null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && !(c.isInteger(t3.modelVersion) || t3.modelVersion && c.isInteger(t3.modelVersion.low) && c.isInteger(t3.modelVersion.high))) return "modelVersion: integer|Long expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString)) return "docString: string expected";
              if (null != t3.graph && t3.hasOwnProperty("graph") && (n2 = l.onnx.GraphProto.verify(t3.graph))) return "graph." + n2;
              if (null != t3.metadataProps && t3.hasOwnProperty("metadataProps")) {
                if (!Array.isArray(t3.metadataProps)) return "metadataProps: array expected";
                for (e2 = 0; e2 < t3.metadataProps.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.StringStringEntryProto.verify(t3.metadataProps[e2])) return "metadataProps." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.ModelProto) return t3;
              var e2 = new l.onnx.ModelProto();
              if (null != t3.irVersion && (c.Long ? (e2.irVersion = c.Long.fromValue(t3.irVersion)).unsigned = false : "string" == typeof t3.irVersion ? e2.irVersion = parseInt(t3.irVersion, 10) : "number" == typeof t3.irVersion ? e2.irVersion = t3.irVersion : "object" == typeof t3.irVersion && (e2.irVersion = new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber())), t3.opsetImport) {
                if (!Array.isArray(t3.opsetImport)) throw TypeError(".onnx.ModelProto.opsetImport: array expected");
                e2.opsetImport = [];
                for (var n2 = 0; n2 < t3.opsetImport.length; ++n2) {
                  if ("object" != typeof t3.opsetImport[n2]) throw TypeError(".onnx.ModelProto.opsetImport: object expected");
                  e2.opsetImport[n2] = l.onnx.OperatorSetIdProto.fromObject(t3.opsetImport[n2]);
                }
              }
              if (null != t3.producerName && (e2.producerName = String(t3.producerName)), null != t3.producerVersion && (e2.producerVersion = String(t3.producerVersion)), null != t3.domain && (e2.domain = String(t3.domain)), null != t3.modelVersion && (c.Long ? (e2.modelVersion = c.Long.fromValue(t3.modelVersion)).unsigned = false : "string" == typeof t3.modelVersion ? e2.modelVersion = parseInt(t3.modelVersion, 10) : "number" == typeof t3.modelVersion ? e2.modelVersion = t3.modelVersion : "object" == typeof t3.modelVersion && (e2.modelVersion = new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber())), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.graph) {
                if ("object" != typeof t3.graph) throw TypeError(".onnx.ModelProto.graph: object expected");
                e2.graph = l.onnx.GraphProto.fromObject(t3.graph);
              }
              if (t3.metadataProps) {
                if (!Array.isArray(t3.metadataProps)) throw TypeError(".onnx.ModelProto.metadataProps: array expected");
                for (e2.metadataProps = [], n2 = 0; n2 < t3.metadataProps.length; ++n2) {
                  if ("object" != typeof t3.metadataProps[n2]) throw TypeError(".onnx.ModelProto.metadataProps: object expected");
                  e2.metadataProps[n2] = l.onnx.StringStringEntryProto.fromObject(t3.metadataProps[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.opsetImport = [], n2.metadataProps = []), e2.defaults) {
                if (c.Long) {
                  var r2 = new c.Long(0, 0, false);
                  n2.irVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                } else n2.irVersion = e2.longs === String ? "0" : 0;
                n2.producerName = "", n2.producerVersion = "", n2.domain = "", c.Long ? (r2 = new c.Long(0, 0, false), n2.modelVersion = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.modelVersion = e2.longs === String ? "0" : 0, n2.docString = "", n2.graph = null;
              }
              if (null != t3.irVersion && t3.hasOwnProperty("irVersion") && ("number" == typeof t3.irVersion ? n2.irVersion = e2.longs === String ? String(t3.irVersion) : t3.irVersion : n2.irVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.irVersion) : e2.longs === Number ? new c.LongBits(t3.irVersion.low >>> 0, t3.irVersion.high >>> 0).toNumber() : t3.irVersion), null != t3.producerName && t3.hasOwnProperty("producerName") && (n2.producerName = t3.producerName), null != t3.producerVersion && t3.hasOwnProperty("producerVersion") && (n2.producerVersion = t3.producerVersion), null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.modelVersion && t3.hasOwnProperty("modelVersion") && ("number" == typeof t3.modelVersion ? n2.modelVersion = e2.longs === String ? String(t3.modelVersion) : t3.modelVersion : n2.modelVersion = e2.longs === String ? c.Long.prototype.toString.call(t3.modelVersion) : e2.longs === Number ? new c.LongBits(t3.modelVersion.low >>> 0, t3.modelVersion.high >>> 0).toNumber() : t3.modelVersion), null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), null != t3.graph && t3.hasOwnProperty("graph") && (n2.graph = l.onnx.GraphProto.toObject(t3.graph, e2)), t3.opsetImport && t3.opsetImport.length) {
                n2.opsetImport = [];
                for (var i2 = 0; i2 < t3.opsetImport.length; ++i2) n2.opsetImport[i2] = l.onnx.OperatorSetIdProto.toObject(t3.opsetImport[i2], e2);
              }
              if (t3.metadataProps && t3.metadataProps.length) for (n2.metadataProps = [], i2 = 0; i2 < t3.metadataProps.length; ++i2) n2.metadataProps[i2] = l.onnx.StringStringEntryProto.toObject(t3.metadataProps[i2], e2);
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.StringStringEntryProto = function() {
            function t2(t3) {
              if (t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.key = "", t2.prototype.value = "", t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.key && t3.hasOwnProperty("key") && e2.uint32(10).string(t3.key), null != t3.value && t3.hasOwnProperty("value") && e2.uint32(18).string(t3.value), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.StringStringEntryProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.key = t3.string();
                    break;
                  case 2:
                    r2.value = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.key && t3.hasOwnProperty("key") && !c.isString(t3.key) ? "key: string expected" : null != t3.value && t3.hasOwnProperty("value") && !c.isString(t3.value) ? "value: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.StringStringEntryProto) return t3;
              var e2 = new l.onnx.StringStringEntryProto();
              return null != t3.key && (e2.key = String(t3.key)), null != t3.value && (e2.value = String(t3.value)), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              return e2.defaults && (n2.key = "", n2.value = ""), null != t3.key && t3.hasOwnProperty("key") && (n2.key = t3.key), null != t3.value && t3.hasOwnProperty("value") && (n2.value = t3.value), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.TensorAnnotation = function() {
            function t2(t3) {
              if (this.quantParameterTensorNames = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.tensorName = "", t2.prototype.quantParameterTensorNames = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.tensorName && t3.hasOwnProperty("tensorName") && e2.uint32(10).string(t3.tensorName), null != t3.quantParameterTensorNames && t3.quantParameterTensorNames.length) for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2) l.onnx.StringStringEntryProto.encode(t3.quantParameterTensorNames[n2], e2.uint32(18).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorAnnotation(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.tensorName = t3.string();
                    break;
                  case 2:
                    r2.quantParameterTensorNames && r2.quantParameterTensorNames.length || (r2.quantParameterTensorNames = []), r2.quantParameterTensorNames.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.tensorName && t3.hasOwnProperty("tensorName") && !c.isString(t3.tensorName)) return "tensorName: string expected";
              if (null != t3.quantParameterTensorNames && t3.hasOwnProperty("quantParameterTensorNames")) {
                if (!Array.isArray(t3.quantParameterTensorNames)) return "quantParameterTensorNames: array expected";
                for (var e2 = 0; e2 < t3.quantParameterTensorNames.length; ++e2) {
                  var n2 = l.onnx.StringStringEntryProto.verify(t3.quantParameterTensorNames[e2]);
                  if (n2) return "quantParameterTensorNames." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorAnnotation) return t3;
              var e2 = new l.onnx.TensorAnnotation();
              if (null != t3.tensorName && (e2.tensorName = String(t3.tensorName)), t3.quantParameterTensorNames) {
                if (!Array.isArray(t3.quantParameterTensorNames)) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: array expected");
                e2.quantParameterTensorNames = [];
                for (var n2 = 0; n2 < t3.quantParameterTensorNames.length; ++n2) {
                  if ("object" != typeof t3.quantParameterTensorNames[n2]) throw TypeError(".onnx.TensorAnnotation.quantParameterTensorNames: object expected");
                  e2.quantParameterTensorNames[n2] = l.onnx.StringStringEntryProto.fromObject(t3.quantParameterTensorNames[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.quantParameterTensorNames = []), e2.defaults && (n2.tensorName = ""), null != t3.tensorName && t3.hasOwnProperty("tensorName") && (n2.tensorName = t3.tensorName), t3.quantParameterTensorNames && t3.quantParameterTensorNames.length) {
                n2.quantParameterTensorNames = [];
                for (var r2 = 0; r2 < t3.quantParameterTensorNames.length; ++r2) n2.quantParameterTensorNames[r2] = l.onnx.StringStringEntryProto.toObject(t3.quantParameterTensorNames[r2], e2);
              }
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.GraphProto = function() {
            function t2(t3) {
              if (this.node = [], this.initializer = [], this.input = [], this.output = [], this.valueInfo = [], this.quantizationAnnotation = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.node = c.emptyArray, t2.prototype.name = "", t2.prototype.initializer = c.emptyArray, t2.prototype.docString = "", t2.prototype.input = c.emptyArray, t2.prototype.output = c.emptyArray, t2.prototype.valueInfo = c.emptyArray, t2.prototype.quantizationAnnotation = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.node && t3.node.length) for (var n2 = 0; n2 < t3.node.length; ++n2) l.onnx.NodeProto.encode(t3.node[n2], e2.uint32(10).fork()).ldelim();
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(18).string(t3.name), null != t3.initializer && t3.initializer.length) for (n2 = 0; n2 < t3.initializer.length; ++n2) l.onnx.TensorProto.encode(t3.initializer[n2], e2.uint32(42).fork()).ldelim();
              if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(82).string(t3.docString), null != t3.input && t3.input.length) for (n2 = 0; n2 < t3.input.length; ++n2) l.onnx.ValueInfoProto.encode(t3.input[n2], e2.uint32(90).fork()).ldelim();
              if (null != t3.output && t3.output.length) for (n2 = 0; n2 < t3.output.length; ++n2) l.onnx.ValueInfoProto.encode(t3.output[n2], e2.uint32(98).fork()).ldelim();
              if (null != t3.valueInfo && t3.valueInfo.length) for (n2 = 0; n2 < t3.valueInfo.length; ++n2) l.onnx.ValueInfoProto.encode(t3.valueInfo[n2], e2.uint32(106).fork()).ldelim();
              if (null != t3.quantizationAnnotation && t3.quantizationAnnotation.length) for (n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2) l.onnx.TensorAnnotation.encode(t3.quantizationAnnotation[n2], e2.uint32(114).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.GraphProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.node && r2.node.length || (r2.node = []), r2.node.push(l.onnx.NodeProto.decode(t3, t3.uint32()));
                    break;
                  case 2:
                    r2.name = t3.string();
                    break;
                  case 5:
                    r2.initializer && r2.initializer.length || (r2.initializer = []), r2.initializer.push(l.onnx.TensorProto.decode(t3, t3.uint32()));
                    break;
                  case 10:
                    r2.docString = t3.string();
                    break;
                  case 11:
                    r2.input && r2.input.length || (r2.input = []), r2.input.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 12:
                    r2.output && r2.output.length || (r2.output = []), r2.output.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 13:
                    r2.valueInfo && r2.valueInfo.length || (r2.valueInfo = []), r2.valueInfo.push(l.onnx.ValueInfoProto.decode(t3, t3.uint32()));
                    break;
                  case 14:
                    r2.quantizationAnnotation && r2.quantizationAnnotation.length || (r2.quantizationAnnotation = []), r2.quantizationAnnotation.push(l.onnx.TensorAnnotation.decode(t3, t3.uint32()));
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.node && t3.hasOwnProperty("node")) {
                if (!Array.isArray(t3.node)) return "node: array expected";
                for (var e2 = 0; e2 < t3.node.length; ++e2) if (n2 = l.onnx.NodeProto.verify(t3.node[e2])) return "node." + n2;
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name)) return "name: string expected";
              if (null != t3.initializer && t3.hasOwnProperty("initializer")) {
                if (!Array.isArray(t3.initializer)) return "initializer: array expected";
                for (e2 = 0; e2 < t3.initializer.length; ++e2) if (n2 = l.onnx.TensorProto.verify(t3.initializer[e2])) return "initializer." + n2;
              }
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString)) return "docString: string expected";
              if (null != t3.input && t3.hasOwnProperty("input")) {
                if (!Array.isArray(t3.input)) return "input: array expected";
                for (e2 = 0; e2 < t3.input.length; ++e2) if (n2 = l.onnx.ValueInfoProto.verify(t3.input[e2])) return "input." + n2;
              }
              if (null != t3.output && t3.hasOwnProperty("output")) {
                if (!Array.isArray(t3.output)) return "output: array expected";
                for (e2 = 0; e2 < t3.output.length; ++e2) if (n2 = l.onnx.ValueInfoProto.verify(t3.output[e2])) return "output." + n2;
              }
              if (null != t3.valueInfo && t3.hasOwnProperty("valueInfo")) {
                if (!Array.isArray(t3.valueInfo)) return "valueInfo: array expected";
                for (e2 = 0; e2 < t3.valueInfo.length; ++e2) if (n2 = l.onnx.ValueInfoProto.verify(t3.valueInfo[e2])) return "valueInfo." + n2;
              }
              if (null != t3.quantizationAnnotation && t3.hasOwnProperty("quantizationAnnotation")) {
                if (!Array.isArray(t3.quantizationAnnotation)) return "quantizationAnnotation: array expected";
                for (e2 = 0; e2 < t3.quantizationAnnotation.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.TensorAnnotation.verify(t3.quantizationAnnotation[e2])) return "quantizationAnnotation." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.GraphProto) return t3;
              var e2 = new l.onnx.GraphProto();
              if (t3.node) {
                if (!Array.isArray(t3.node)) throw TypeError(".onnx.GraphProto.node: array expected");
                e2.node = [];
                for (var n2 = 0; n2 < t3.node.length; ++n2) {
                  if ("object" != typeof t3.node[n2]) throw TypeError(".onnx.GraphProto.node: object expected");
                  e2.node[n2] = l.onnx.NodeProto.fromObject(t3.node[n2]);
                }
              }
              if (null != t3.name && (e2.name = String(t3.name)), t3.initializer) {
                if (!Array.isArray(t3.initializer)) throw TypeError(".onnx.GraphProto.initializer: array expected");
                for (e2.initializer = [], n2 = 0; n2 < t3.initializer.length; ++n2) {
                  if ("object" != typeof t3.initializer[n2]) throw TypeError(".onnx.GraphProto.initializer: object expected");
                  e2.initializer[n2] = l.onnx.TensorProto.fromObject(t3.initializer[n2]);
                }
              }
              if (null != t3.docString && (e2.docString = String(t3.docString)), t3.input) {
                if (!Array.isArray(t3.input)) throw TypeError(".onnx.GraphProto.input: array expected");
                for (e2.input = [], n2 = 0; n2 < t3.input.length; ++n2) {
                  if ("object" != typeof t3.input[n2]) throw TypeError(".onnx.GraphProto.input: object expected");
                  e2.input[n2] = l.onnx.ValueInfoProto.fromObject(t3.input[n2]);
                }
              }
              if (t3.output) {
                if (!Array.isArray(t3.output)) throw TypeError(".onnx.GraphProto.output: array expected");
                for (e2.output = [], n2 = 0; n2 < t3.output.length; ++n2) {
                  if ("object" != typeof t3.output[n2]) throw TypeError(".onnx.GraphProto.output: object expected");
                  e2.output[n2] = l.onnx.ValueInfoProto.fromObject(t3.output[n2]);
                }
              }
              if (t3.valueInfo) {
                if (!Array.isArray(t3.valueInfo)) throw TypeError(".onnx.GraphProto.valueInfo: array expected");
                for (e2.valueInfo = [], n2 = 0; n2 < t3.valueInfo.length; ++n2) {
                  if ("object" != typeof t3.valueInfo[n2]) throw TypeError(".onnx.GraphProto.valueInfo: object expected");
                  e2.valueInfo[n2] = l.onnx.ValueInfoProto.fromObject(t3.valueInfo[n2]);
                }
              }
              if (t3.quantizationAnnotation) {
                if (!Array.isArray(t3.quantizationAnnotation)) throw TypeError(".onnx.GraphProto.quantizationAnnotation: array expected");
                for (e2.quantizationAnnotation = [], n2 = 0; n2 < t3.quantizationAnnotation.length; ++n2) {
                  if ("object" != typeof t3.quantizationAnnotation[n2]) throw TypeError(".onnx.GraphProto.quantizationAnnotation: object expected");
                  e2.quantizationAnnotation[n2] = l.onnx.TensorAnnotation.fromObject(t3.quantizationAnnotation[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.node = [], n2.initializer = [], n2.input = [], n2.output = [], n2.valueInfo = [], n2.quantizationAnnotation = []), e2.defaults && (n2.name = "", n2.docString = ""), t3.node && t3.node.length) {
                n2.node = [];
                for (var r2 = 0; r2 < t3.node.length; ++r2) n2.node[r2] = l.onnx.NodeProto.toObject(t3.node[r2], e2);
              }
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), t3.initializer && t3.initializer.length) for (n2.initializer = [], r2 = 0; r2 < t3.initializer.length; ++r2) n2.initializer[r2] = l.onnx.TensorProto.toObject(t3.initializer[r2], e2);
              if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.input && t3.input.length) for (n2.input = [], r2 = 0; r2 < t3.input.length; ++r2) n2.input[r2] = l.onnx.ValueInfoProto.toObject(t3.input[r2], e2);
              if (t3.output && t3.output.length) for (n2.output = [], r2 = 0; r2 < t3.output.length; ++r2) n2.output[r2] = l.onnx.ValueInfoProto.toObject(t3.output[r2], e2);
              if (t3.valueInfo && t3.valueInfo.length) for (n2.valueInfo = [], r2 = 0; r2 < t3.valueInfo.length; ++r2) n2.valueInfo[r2] = l.onnx.ValueInfoProto.toObject(t3.valueInfo[r2], e2);
              if (t3.quantizationAnnotation && t3.quantizationAnnotation.length) for (n2.quantizationAnnotation = [], r2 = 0; r2 < t3.quantizationAnnotation.length; ++r2) n2.quantizationAnnotation[r2] = l.onnx.TensorAnnotation.toObject(t3.quantizationAnnotation[r2], e2);
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o.TensorProto = function() {
            function t2(t3) {
              if (this.dims = [], this.floatData = [], this.int32Data = [], this.stringData = [], this.int64Data = [], this.externalData = [], this.doubleData = [], this.uint64Data = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.dims = c.emptyArray, t2.prototype.dataType = 0, t2.prototype.segment = null, t2.prototype.floatData = c.emptyArray, t2.prototype.int32Data = c.emptyArray, t2.prototype.stringData = c.emptyArray, t2.prototype.int64Data = c.emptyArray, t2.prototype.name = "", t2.prototype.docString = "", t2.prototype.rawData = c.newBuffer([]), t2.prototype.externalData = c.emptyArray, t2.prototype.dataLocation = 0, t2.prototype.doubleData = c.emptyArray, t2.prototype.uint64Data = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.dims && t3.dims.length) {
                e2.uint32(10).fork();
                for (var n2 = 0; n2 < t3.dims.length; ++n2) e2.int64(t3.dims[n2]);
                e2.ldelim();
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && e2.uint32(16).int32(t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && l.onnx.TensorProto.Segment.encode(t3.segment, e2.uint32(26).fork()).ldelim(), null != t3.floatData && t3.floatData.length) {
                for (e2.uint32(34).fork(), n2 = 0; n2 < t3.floatData.length; ++n2) e2.float(t3.floatData[n2]);
                e2.ldelim();
              }
              if (null != t3.int32Data && t3.int32Data.length) {
                for (e2.uint32(42).fork(), n2 = 0; n2 < t3.int32Data.length; ++n2) e2.int32(t3.int32Data[n2]);
                e2.ldelim();
              }
              if (null != t3.stringData && t3.stringData.length) for (n2 = 0; n2 < t3.stringData.length; ++n2) e2.uint32(50).bytes(t3.stringData[n2]);
              if (null != t3.int64Data && t3.int64Data.length) {
                for (e2.uint32(58).fork(), n2 = 0; n2 < t3.int64Data.length; ++n2) e2.int64(t3.int64Data[n2]);
                e2.ldelim();
              }
              if (null != t3.name && t3.hasOwnProperty("name") && e2.uint32(66).string(t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && e2.uint32(74).bytes(t3.rawData), null != t3.doubleData && t3.doubleData.length) {
                for (e2.uint32(82).fork(), n2 = 0; n2 < t3.doubleData.length; ++n2) e2.double(t3.doubleData[n2]);
                e2.ldelim();
              }
              if (null != t3.uint64Data && t3.uint64Data.length) {
                for (e2.uint32(90).fork(), n2 = 0; n2 < t3.uint64Data.length; ++n2) e2.uint64(t3.uint64Data[n2]);
                e2.ldelim();
              }
              if (null != t3.docString && t3.hasOwnProperty("docString") && e2.uint32(98).string(t3.docString), null != t3.externalData && t3.externalData.length) for (n2 = 0; n2 < t3.externalData.length; ++n2) l.onnx.StringStringEntryProto.encode(t3.externalData[n2], e2.uint32(106).fork()).ldelim();
              return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && e2.uint32(112).int32(t3.dataLocation), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    if (r2.dims && r2.dims.length || (r2.dims = []), 2 == (7 & i2)) for (var o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.dims.push(t3.int64());
                    else r2.dims.push(t3.int64());
                    break;
                  case 2:
                    r2.dataType = t3.int32();
                    break;
                  case 3:
                    r2.segment = l.onnx.TensorProto.Segment.decode(t3, t3.uint32());
                    break;
                  case 4:
                    if (r2.floatData && r2.floatData.length || (r2.floatData = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.floatData.push(t3.float());
                    else r2.floatData.push(t3.float());
                    break;
                  case 5:
                    if (r2.int32Data && r2.int32Data.length || (r2.int32Data = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.int32Data.push(t3.int32());
                    else r2.int32Data.push(t3.int32());
                    break;
                  case 6:
                    r2.stringData && r2.stringData.length || (r2.stringData = []), r2.stringData.push(t3.bytes());
                    break;
                  case 7:
                    if (r2.int64Data && r2.int64Data.length || (r2.int64Data = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.int64Data.push(t3.int64());
                    else r2.int64Data.push(t3.int64());
                    break;
                  case 8:
                    r2.name = t3.string();
                    break;
                  case 12:
                    r2.docString = t3.string();
                    break;
                  case 9:
                    r2.rawData = t3.bytes();
                    break;
                  case 13:
                    r2.externalData && r2.externalData.length || (r2.externalData = []), r2.externalData.push(l.onnx.StringStringEntryProto.decode(t3, t3.uint32()));
                    break;
                  case 14:
                    r2.dataLocation = t3.int32();
                    break;
                  case 10:
                    if (r2.doubleData && r2.doubleData.length || (r2.doubleData = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.doubleData.push(t3.double());
                    else r2.doubleData.push(t3.double());
                    break;
                  case 11:
                    if (r2.uint64Data && r2.uint64Data.length || (r2.uint64Data = []), 2 == (7 & i2)) for (o2 = t3.uint32() + t3.pos; t3.pos < o2; ) r2.uint64Data.push(t3.uint64());
                    else r2.uint64Data.push(t3.uint64());
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.dims && t3.hasOwnProperty("dims")) {
                if (!Array.isArray(t3.dims)) return "dims: array expected";
                for (var e2 = 0; e2 < t3.dims.length; ++e2) if (!(c.isInteger(t3.dims[e2]) || t3.dims[e2] && c.isInteger(t3.dims[e2].low) && c.isInteger(t3.dims[e2].high))) return "dims: integer|Long[] expected";
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && !c.isInteger(t3.dataType)) return "dataType: integer expected";
              if (null != t3.segment && t3.hasOwnProperty("segment") && (n2 = l.onnx.TensorProto.Segment.verify(t3.segment))) return "segment." + n2;
              if (null != t3.floatData && t3.hasOwnProperty("floatData")) {
                if (!Array.isArray(t3.floatData)) return "floatData: array expected";
                for (e2 = 0; e2 < t3.floatData.length; ++e2) if ("number" != typeof t3.floatData[e2]) return "floatData: number[] expected";
              }
              if (null != t3.int32Data && t3.hasOwnProperty("int32Data")) {
                if (!Array.isArray(t3.int32Data)) return "int32Data: array expected";
                for (e2 = 0; e2 < t3.int32Data.length; ++e2) if (!c.isInteger(t3.int32Data[e2])) return "int32Data: integer[] expected";
              }
              if (null != t3.stringData && t3.hasOwnProperty("stringData")) {
                if (!Array.isArray(t3.stringData)) return "stringData: array expected";
                for (e2 = 0; e2 < t3.stringData.length; ++e2) if (!(t3.stringData[e2] && "number" == typeof t3.stringData[e2].length || c.isString(t3.stringData[e2]))) return "stringData: buffer[] expected";
              }
              if (null != t3.int64Data && t3.hasOwnProperty("int64Data")) {
                if (!Array.isArray(t3.int64Data)) return "int64Data: array expected";
                for (e2 = 0; e2 < t3.int64Data.length; ++e2) if (!(c.isInteger(t3.int64Data[e2]) || t3.int64Data[e2] && c.isInteger(t3.int64Data[e2].low) && c.isInteger(t3.int64Data[e2].high))) return "int64Data: integer|Long[] expected";
              }
              if (null != t3.name && t3.hasOwnProperty("name") && !c.isString(t3.name)) return "name: string expected";
              if (null != t3.docString && t3.hasOwnProperty("docString") && !c.isString(t3.docString)) return "docString: string expected";
              if (null != t3.rawData && t3.hasOwnProperty("rawData") && !(t3.rawData && "number" == typeof t3.rawData.length || c.isString(t3.rawData))) return "rawData: buffer expected";
              if (null != t3.externalData && t3.hasOwnProperty("externalData")) {
                if (!Array.isArray(t3.externalData)) return "externalData: array expected";
                for (e2 = 0; e2 < t3.externalData.length; ++e2) {
                  var n2;
                  if (n2 = l.onnx.StringStringEntryProto.verify(t3.externalData[e2])) return "externalData." + n2;
                }
              }
              if (null != t3.dataLocation && t3.hasOwnProperty("dataLocation")) switch (t3.dataLocation) {
                default:
                  return "dataLocation: enum value expected";
                case 0:
                case 1:
              }
              if (null != t3.doubleData && t3.hasOwnProperty("doubleData")) {
                if (!Array.isArray(t3.doubleData)) return "doubleData: array expected";
                for (e2 = 0; e2 < t3.doubleData.length; ++e2) if ("number" != typeof t3.doubleData[e2]) return "doubleData: number[] expected";
              }
              if (null != t3.uint64Data && t3.hasOwnProperty("uint64Data")) {
                if (!Array.isArray(t3.uint64Data)) return "uint64Data: array expected";
                for (e2 = 0; e2 < t3.uint64Data.length; ++e2) if (!(c.isInteger(t3.uint64Data[e2]) || t3.uint64Data[e2] && c.isInteger(t3.uint64Data[e2].low) && c.isInteger(t3.uint64Data[e2].high))) return "uint64Data: integer|Long[] expected";
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorProto) return t3;
              var e2 = new l.onnx.TensorProto();
              if (t3.dims) {
                if (!Array.isArray(t3.dims)) throw TypeError(".onnx.TensorProto.dims: array expected");
                e2.dims = [];
                for (var n2 = 0; n2 < t3.dims.length; ++n2) c.Long ? (e2.dims[n2] = c.Long.fromValue(t3.dims[n2])).unsigned = false : "string" == typeof t3.dims[n2] ? e2.dims[n2] = parseInt(t3.dims[n2], 10) : "number" == typeof t3.dims[n2] ? e2.dims[n2] = t3.dims[n2] : "object" == typeof t3.dims[n2] && (e2.dims[n2] = new c.LongBits(t3.dims[n2].low >>> 0, t3.dims[n2].high >>> 0).toNumber());
              }
              if (null != t3.dataType && (e2.dataType = 0 | t3.dataType), null != t3.segment) {
                if ("object" != typeof t3.segment) throw TypeError(".onnx.TensorProto.segment: object expected");
                e2.segment = l.onnx.TensorProto.Segment.fromObject(t3.segment);
              }
              if (t3.floatData) {
                if (!Array.isArray(t3.floatData)) throw TypeError(".onnx.TensorProto.floatData: array expected");
                for (e2.floatData = [], n2 = 0; n2 < t3.floatData.length; ++n2) e2.floatData[n2] = Number(t3.floatData[n2]);
              }
              if (t3.int32Data) {
                if (!Array.isArray(t3.int32Data)) throw TypeError(".onnx.TensorProto.int32Data: array expected");
                for (e2.int32Data = [], n2 = 0; n2 < t3.int32Data.length; ++n2) e2.int32Data[n2] = 0 | t3.int32Data[n2];
              }
              if (t3.stringData) {
                if (!Array.isArray(t3.stringData)) throw TypeError(".onnx.TensorProto.stringData: array expected");
                for (e2.stringData = [], n2 = 0; n2 < t3.stringData.length; ++n2) "string" == typeof t3.stringData[n2] ? c.base64.decode(t3.stringData[n2], e2.stringData[n2] = c.newBuffer(c.base64.length(t3.stringData[n2])), 0) : t3.stringData[n2].length && (e2.stringData[n2] = t3.stringData[n2]);
              }
              if (t3.int64Data) {
                if (!Array.isArray(t3.int64Data)) throw TypeError(".onnx.TensorProto.int64Data: array expected");
                for (e2.int64Data = [], n2 = 0; n2 < t3.int64Data.length; ++n2) c.Long ? (e2.int64Data[n2] = c.Long.fromValue(t3.int64Data[n2])).unsigned = false : "string" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = parseInt(t3.int64Data[n2], 10) : "number" == typeof t3.int64Data[n2] ? e2.int64Data[n2] = t3.int64Data[n2] : "object" == typeof t3.int64Data[n2] && (e2.int64Data[n2] = new c.LongBits(t3.int64Data[n2].low >>> 0, t3.int64Data[n2].high >>> 0).toNumber());
              }
              if (null != t3.name && (e2.name = String(t3.name)), null != t3.docString && (e2.docString = String(t3.docString)), null != t3.rawData && ("string" == typeof t3.rawData ? c.base64.decode(t3.rawData, e2.rawData = c.newBuffer(c.base64.length(t3.rawData)), 0) : t3.rawData.length && (e2.rawData = t3.rawData)), t3.externalData) {
                if (!Array.isArray(t3.externalData)) throw TypeError(".onnx.TensorProto.externalData: array expected");
                for (e2.externalData = [], n2 = 0; n2 < t3.externalData.length; ++n2) {
                  if ("object" != typeof t3.externalData[n2]) throw TypeError(".onnx.TensorProto.externalData: object expected");
                  e2.externalData[n2] = l.onnx.StringStringEntryProto.fromObject(t3.externalData[n2]);
                }
              }
              switch (t3.dataLocation) {
                case "DEFAULT":
                case 0:
                  e2.dataLocation = 0;
                  break;
                case "EXTERNAL":
                case 1:
                  e2.dataLocation = 1;
              }
              if (t3.doubleData) {
                if (!Array.isArray(t3.doubleData)) throw TypeError(".onnx.TensorProto.doubleData: array expected");
                for (e2.doubleData = [], n2 = 0; n2 < t3.doubleData.length; ++n2) e2.doubleData[n2] = Number(t3.doubleData[n2]);
              }
              if (t3.uint64Data) {
                if (!Array.isArray(t3.uint64Data)) throw TypeError(".onnx.TensorProto.uint64Data: array expected");
                for (e2.uint64Data = [], n2 = 0; n2 < t3.uint64Data.length; ++n2) c.Long ? (e2.uint64Data[n2] = c.Long.fromValue(t3.uint64Data[n2])).unsigned = true : "string" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = parseInt(t3.uint64Data[n2], 10) : "number" == typeof t3.uint64Data[n2] ? e2.uint64Data[n2] = t3.uint64Data[n2] : "object" == typeof t3.uint64Data[n2] && (e2.uint64Data[n2] = new c.LongBits(t3.uint64Data[n2].low >>> 0, t3.uint64Data[n2].high >>> 0).toNumber(true));
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.dims = [], n2.floatData = [], n2.int32Data = [], n2.stringData = [], n2.int64Data = [], n2.doubleData = [], n2.uint64Data = [], n2.externalData = []), e2.defaults && (n2.dataType = 0, n2.segment = null, n2.name = "", e2.bytes === String ? n2.rawData = "" : (n2.rawData = [], e2.bytes !== Array && (n2.rawData = c.newBuffer(n2.rawData))), n2.docString = "", n2.dataLocation = e2.enums === String ? "DEFAULT" : 0), t3.dims && t3.dims.length) {
                n2.dims = [];
                for (var r2 = 0; r2 < t3.dims.length; ++r2) "number" == typeof t3.dims[r2] ? n2.dims[r2] = e2.longs === String ? String(t3.dims[r2]) : t3.dims[r2] : n2.dims[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.dims[r2]) : e2.longs === Number ? new c.LongBits(t3.dims[r2].low >>> 0, t3.dims[r2].high >>> 0).toNumber() : t3.dims[r2];
              }
              if (null != t3.dataType && t3.hasOwnProperty("dataType") && (n2.dataType = t3.dataType), null != t3.segment && t3.hasOwnProperty("segment") && (n2.segment = l.onnx.TensorProto.Segment.toObject(t3.segment, e2)), t3.floatData && t3.floatData.length) for (n2.floatData = [], r2 = 0; r2 < t3.floatData.length; ++r2) n2.floatData[r2] = e2.json && !isFinite(t3.floatData[r2]) ? String(t3.floatData[r2]) : t3.floatData[r2];
              if (t3.int32Data && t3.int32Data.length) for (n2.int32Data = [], r2 = 0; r2 < t3.int32Data.length; ++r2) n2.int32Data[r2] = t3.int32Data[r2];
              if (t3.stringData && t3.stringData.length) for (n2.stringData = [], r2 = 0; r2 < t3.stringData.length; ++r2) n2.stringData[r2] = e2.bytes === String ? c.base64.encode(t3.stringData[r2], 0, t3.stringData[r2].length) : e2.bytes === Array ? Array.prototype.slice.call(t3.stringData[r2]) : t3.stringData[r2];
              if (t3.int64Data && t3.int64Data.length) for (n2.int64Data = [], r2 = 0; r2 < t3.int64Data.length; ++r2) "number" == typeof t3.int64Data[r2] ? n2.int64Data[r2] = e2.longs === String ? String(t3.int64Data[r2]) : t3.int64Data[r2] : n2.int64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.int64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.int64Data[r2].low >>> 0, t3.int64Data[r2].high >>> 0).toNumber() : t3.int64Data[r2];
              if (null != t3.name && t3.hasOwnProperty("name") && (n2.name = t3.name), null != t3.rawData && t3.hasOwnProperty("rawData") && (n2.rawData = e2.bytes === String ? c.base64.encode(t3.rawData, 0, t3.rawData.length) : e2.bytes === Array ? Array.prototype.slice.call(t3.rawData) : t3.rawData), t3.doubleData && t3.doubleData.length) for (n2.doubleData = [], r2 = 0; r2 < t3.doubleData.length; ++r2) n2.doubleData[r2] = e2.json && !isFinite(t3.doubleData[r2]) ? String(t3.doubleData[r2]) : t3.doubleData[r2];
              if (t3.uint64Data && t3.uint64Data.length) for (n2.uint64Data = [], r2 = 0; r2 < t3.uint64Data.length; ++r2) "number" == typeof t3.uint64Data[r2] ? n2.uint64Data[r2] = e2.longs === String ? String(t3.uint64Data[r2]) : t3.uint64Data[r2] : n2.uint64Data[r2] = e2.longs === String ? c.Long.prototype.toString.call(t3.uint64Data[r2]) : e2.longs === Number ? new c.LongBits(t3.uint64Data[r2].low >>> 0, t3.uint64Data[r2].high >>> 0).toNumber(true) : t3.uint64Data[r2];
              if (null != t3.docString && t3.hasOwnProperty("docString") && (n2.docString = t3.docString), t3.externalData && t3.externalData.length) for (n2.externalData = [], r2 = 0; r2 < t3.externalData.length; ++r2) n2.externalData[r2] = l.onnx.StringStringEntryProto.toObject(t3.externalData[r2], e2);
              return null != t3.dataLocation && t3.hasOwnProperty("dataLocation") && (n2.dataLocation = e2.enums === String ? l.onnx.TensorProto.DataLocation[t3.dataLocation] : t3.dataLocation), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.DataType = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "UNDEFINED"] = 0, e2[t3[1] = "FLOAT"] = 1, e2[t3[2] = "UINT8"] = 2, e2[t3[3] = "INT8"] = 3, e2[t3[4] = "UINT16"] = 4, e2[t3[5] = "INT16"] = 5, e2[t3[6] = "INT32"] = 6, e2[t3[7] = "INT64"] = 7, e2[t3[8] = "STRING"] = 8, e2[t3[9] = "BOOL"] = 9, e2[t3[10] = "FLOAT16"] = 10, e2[t3[11] = "DOUBLE"] = 11, e2[t3[12] = "UINT32"] = 12, e2[t3[13] = "UINT64"] = 13, e2[t3[14] = "COMPLEX64"] = 14, e2[t3[15] = "COMPLEX128"] = 15, e2[t3[16] = "BFLOAT16"] = 16, e2;
            }(), t2.Segment = function() {
              function t3(t4) {
                if (t4) for (var e2 = Object.keys(t4), n2 = 0; n2 < e2.length; ++n2) null != t4[e2[n2]] && (this[e2[n2]] = t4[e2[n2]]);
              }
              return t3.prototype.begin = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.end = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.create = function(e2) {
                return new t3(e2);
              }, t3.encode = function(t4, e2) {
                return e2 || (e2 = u.create()), null != t4.begin && t4.hasOwnProperty("begin") && e2.uint32(8).int64(t4.begin), null != t4.end && t4.hasOwnProperty("end") && e2.uint32(16).int64(t4.end), e2;
              }, t3.encodeDelimited = function(t4, e2) {
                return this.encode(t4, e2).ldelim();
              }, t3.decode = function(t4, e2) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e2 ? t4.len : t4.pos + e2, r2 = new l.onnx.TensorProto.Segment(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.begin = t4.int64();
                      break;
                    case 2:
                      r2.end = t4.int64();
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                return "object" != typeof t4 || null === t4 ? "object expected" : null != t4.begin && t4.hasOwnProperty("begin") && !(c.isInteger(t4.begin) || t4.begin && c.isInteger(t4.begin.low) && c.isInteger(t4.begin.high)) ? "begin: integer|Long expected" : null != t4.end && t4.hasOwnProperty("end") && !(c.isInteger(t4.end) || t4.end && c.isInteger(t4.end.low) && c.isInteger(t4.end.high)) ? "end: integer|Long expected" : null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TensorProto.Segment) return t4;
                var e2 = new l.onnx.TensorProto.Segment();
                return null != t4.begin && (c.Long ? (e2.begin = c.Long.fromValue(t4.begin)).unsigned = false : "string" == typeof t4.begin ? e2.begin = parseInt(t4.begin, 10) : "number" == typeof t4.begin ? e2.begin = t4.begin : "object" == typeof t4.begin && (e2.begin = new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber())), null != t4.end && (c.Long ? (e2.end = c.Long.fromValue(t4.end)).unsigned = false : "string" == typeof t4.end ? e2.end = parseInt(t4.end, 10) : "number" == typeof t4.end ? e2.end = t4.end : "object" == typeof t4.end && (e2.end = new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber())), e2;
              }, t3.toObject = function(t4, e2) {
                e2 || (e2 = {});
                var n2 = {};
                if (e2.defaults) {
                  if (c.Long) {
                    var r2 = new c.Long(0, 0, false);
                    n2.begin = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
                  } else n2.begin = e2.longs === String ? "0" : 0;
                  c.Long ? (r2 = new c.Long(0, 0, false), n2.end = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2) : n2.end = e2.longs === String ? "0" : 0;
                }
                return null != t4.begin && t4.hasOwnProperty("begin") && ("number" == typeof t4.begin ? n2.begin = e2.longs === String ? String(t4.begin) : t4.begin : n2.begin = e2.longs === String ? c.Long.prototype.toString.call(t4.begin) : e2.longs === Number ? new c.LongBits(t4.begin.low >>> 0, t4.begin.high >>> 0).toNumber() : t4.begin), null != t4.end && t4.hasOwnProperty("end") && ("number" == typeof t4.end ? n2.end = e2.longs === String ? String(t4.end) : t4.end : n2.end = e2.longs === String ? c.Long.prototype.toString.call(t4.end) : e2.longs === Number ? new c.LongBits(t4.end.low >>> 0, t4.end.high >>> 0).toNumber() : t4.end), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2.DataLocation = function() {
              var t3 = {}, e2 = Object.create(t3);
              return e2[t3[0] = "DEFAULT"] = 0, e2[t3[1] = "EXTERNAL"] = 1, e2;
            }(), t2;
          }(), o.TensorShapeProto = function() {
            function t2(t3) {
              if (this.dim = [], t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.dim = c.emptyArray, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              if (e2 || (e2 = u.create()), null != t3.dim && t3.dim.length) for (var n2 = 0; n2 < t3.dim.length; ++n2) l.onnx.TensorShapeProto.Dimension.encode(t3.dim[n2], e2.uint32(10).fork()).ldelim();
              return e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.TensorShapeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                i2 >>> 3 == 1 ? (r2.dim && r2.dim.length || (r2.dim = []), r2.dim.push(l.onnx.TensorShapeProto.Dimension.decode(t3, t3.uint32()))) : t3.skipType(7 & i2);
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.dim && t3.hasOwnProperty("dim")) {
                if (!Array.isArray(t3.dim)) return "dim: array expected";
                for (var e2 = 0; e2 < t3.dim.length; ++e2) {
                  var n2 = l.onnx.TensorShapeProto.Dimension.verify(t3.dim[e2]);
                  if (n2) return "dim." + n2;
                }
              }
              return null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TensorShapeProto) return t3;
              var e2 = new l.onnx.TensorShapeProto();
              if (t3.dim) {
                if (!Array.isArray(t3.dim)) throw TypeError(".onnx.TensorShapeProto.dim: array expected");
                e2.dim = [];
                for (var n2 = 0; n2 < t3.dim.length; ++n2) {
                  if ("object" != typeof t3.dim[n2]) throw TypeError(".onnx.TensorShapeProto.dim: object expected");
                  e2.dim[n2] = l.onnx.TensorShapeProto.Dimension.fromObject(t3.dim[n2]);
                }
              }
              return e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if ((e2.arrays || e2.defaults) && (n2.dim = []), t3.dim && t3.dim.length) {
                n2.dim = [];
                for (var r2 = 0; r2 < t3.dim.length; ++r2) n2.dim[r2] = l.onnx.TensorShapeProto.Dimension.toObject(t3.dim[r2], e2);
              }
              return n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.Dimension = function() {
              function t3(t4) {
                if (t4) for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2) null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
              }
              var e2;
              return t3.prototype.dimValue = c.Long ? c.Long.fromBits(0, 0, false) : 0, t3.prototype.dimParam = "", t3.prototype.denotation = "", Object.defineProperty(t3.prototype, "value", { get: c.oneOfGetter(e2 = ["dimValue", "dimParam"]), set: c.oneOfSetter(e2) }), t3.create = function(e3) {
                return new t3(e3);
              }, t3.encode = function(t4, e3) {
                return e3 || (e3 = u.create()), null != t4.dimValue && t4.hasOwnProperty("dimValue") && e3.uint32(8).int64(t4.dimValue), null != t4.dimParam && t4.hasOwnProperty("dimParam") && e3.uint32(18).string(t4.dimParam), null != t4.denotation && t4.hasOwnProperty("denotation") && e3.uint32(26).string(t4.denotation), e3;
              }, t3.encodeDelimited = function(t4, e3) {
                return this.encode(t4, e3).ldelim();
              }, t3.decode = function(t4, e3) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TensorShapeProto.Dimension(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.dimValue = t4.int64();
                      break;
                    case 2:
                      r2.dimParam = t4.string();
                      break;
                    case 3:
                      r2.denotation = t4.string();
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                if ("object" != typeof t4 || null === t4) return "object expected";
                var e3 = {};
                if (null != t4.dimValue && t4.hasOwnProperty("dimValue") && (e3.value = 1, !(c.isInteger(t4.dimValue) || t4.dimValue && c.isInteger(t4.dimValue.low) && c.isInteger(t4.dimValue.high)))) return "dimValue: integer|Long expected";
                if (null != t4.dimParam && t4.hasOwnProperty("dimParam")) {
                  if (1 === e3.value) return "value: multiple values";
                  if (e3.value = 1, !c.isString(t4.dimParam)) return "dimParam: string expected";
                }
                return null != t4.denotation && t4.hasOwnProperty("denotation") && !c.isString(t4.denotation) ? "denotation: string expected" : null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TensorShapeProto.Dimension) return t4;
                var e3 = new l.onnx.TensorShapeProto.Dimension();
                return null != t4.dimValue && (c.Long ? (e3.dimValue = c.Long.fromValue(t4.dimValue)).unsigned = false : "string" == typeof t4.dimValue ? e3.dimValue = parseInt(t4.dimValue, 10) : "number" == typeof t4.dimValue ? e3.dimValue = t4.dimValue : "object" == typeof t4.dimValue && (e3.dimValue = new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber())), null != t4.dimParam && (e3.dimParam = String(t4.dimParam)), null != t4.denotation && (e3.denotation = String(t4.denotation)), e3;
              }, t3.toObject = function(t4, e3) {
                e3 || (e3 = {});
                var n2 = {};
                return e3.defaults && (n2.denotation = ""), null != t4.dimValue && t4.hasOwnProperty("dimValue") && ("number" == typeof t4.dimValue ? n2.dimValue = e3.longs === String ? String(t4.dimValue) : t4.dimValue : n2.dimValue = e3.longs === String ? c.Long.prototype.toString.call(t4.dimValue) : e3.longs === Number ? new c.LongBits(t4.dimValue.low >>> 0, t4.dimValue.high >>> 0).toNumber() : t4.dimValue, e3.oneofs && (n2.value = "dimValue")), null != t4.dimParam && t4.hasOwnProperty("dimParam") && (n2.dimParam = t4.dimParam, e3.oneofs && (n2.value = "dimParam")), null != t4.denotation && t4.hasOwnProperty("denotation") && (n2.denotation = t4.denotation), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2;
          }(), o.TypeProto = function() {
            function t2(t3) {
              if (t3) for (var e3 = Object.keys(t3), n2 = 0; n2 < e3.length; ++n2) null != t3[e3[n2]] && (this[e3[n2]] = t3[e3[n2]]);
            }
            var e2;
            return t2.prototype.tensorType = null, t2.prototype.denotation = "", Object.defineProperty(t2.prototype, "value", { get: c.oneOfGetter(e2 = ["tensorType"]), set: c.oneOfSetter(e2) }), t2.create = function(e3) {
              return new t2(e3);
            }, t2.encode = function(t3, e3) {
              return e3 || (e3 = u.create()), null != t3.tensorType && t3.hasOwnProperty("tensorType") && l.onnx.TypeProto.Tensor.encode(t3.tensorType, e3.uint32(10).fork()).ldelim(), null != t3.denotation && t3.hasOwnProperty("denotation") && e3.uint32(50).string(t3.denotation), e3;
            }, t2.encodeDelimited = function(t3, e3) {
              return this.encode(t3, e3).ldelim();
            }, t2.decode = function(t3, e3) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e3 ? t3.len : t3.pos + e3, r2 = new l.onnx.TypeProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.tensorType = l.onnx.TypeProto.Tensor.decode(t3, t3.uint32());
                    break;
                  case 6:
                    r2.denotation = t3.string();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              if ("object" != typeof t3 || null === t3) return "object expected";
              if (null != t3.tensorType && t3.hasOwnProperty("tensorType")) {
                var e3 = l.onnx.TypeProto.Tensor.verify(t3.tensorType);
                if (e3) return "tensorType." + e3;
              }
              return null != t3.denotation && t3.hasOwnProperty("denotation") && !c.isString(t3.denotation) ? "denotation: string expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.TypeProto) return t3;
              var e3 = new l.onnx.TypeProto();
              if (null != t3.tensorType) {
                if ("object" != typeof t3.tensorType) throw TypeError(".onnx.TypeProto.tensorType: object expected");
                e3.tensorType = l.onnx.TypeProto.Tensor.fromObject(t3.tensorType);
              }
              return null != t3.denotation && (e3.denotation = String(t3.denotation)), e3;
            }, t2.toObject = function(t3, e3) {
              e3 || (e3 = {});
              var n2 = {};
              return e3.defaults && (n2.denotation = ""), null != t3.tensorType && t3.hasOwnProperty("tensorType") && (n2.tensorType = l.onnx.TypeProto.Tensor.toObject(t3.tensorType, e3), e3.oneofs && (n2.value = "tensorType")), null != t3.denotation && t3.hasOwnProperty("denotation") && (n2.denotation = t3.denotation), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2.Tensor = function() {
              function t3(t4) {
                if (t4) for (var e3 = Object.keys(t4), n2 = 0; n2 < e3.length; ++n2) null != t4[e3[n2]] && (this[e3[n2]] = t4[e3[n2]]);
              }
              return t3.prototype.elemType = 0, t3.prototype.shape = null, t3.create = function(e3) {
                return new t3(e3);
              }, t3.encode = function(t4, e3) {
                return e3 || (e3 = u.create()), null != t4.elemType && t4.hasOwnProperty("elemType") && e3.uint32(8).int32(t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && l.onnx.TensorShapeProto.encode(t4.shape, e3.uint32(18).fork()).ldelim(), e3;
              }, t3.encodeDelimited = function(t4, e3) {
                return this.encode(t4, e3).ldelim();
              }, t3.decode = function(t4, e3) {
                t4 instanceof s || (t4 = s.create(t4));
                for (var n2 = void 0 === e3 ? t4.len : t4.pos + e3, r2 = new l.onnx.TypeProto.Tensor(); t4.pos < n2; ) {
                  var i2 = t4.uint32();
                  switch (i2 >>> 3) {
                    case 1:
                      r2.elemType = t4.int32();
                      break;
                    case 2:
                      r2.shape = l.onnx.TensorShapeProto.decode(t4, t4.uint32());
                      break;
                    default:
                      t4.skipType(7 & i2);
                  }
                }
                return r2;
              }, t3.decodeDelimited = function(t4) {
                return t4 instanceof s || (t4 = new s(t4)), this.decode(t4, t4.uint32());
              }, t3.verify = function(t4) {
                if ("object" != typeof t4 || null === t4) return "object expected";
                if (null != t4.elemType && t4.hasOwnProperty("elemType") && !c.isInteger(t4.elemType)) return "elemType: integer expected";
                if (null != t4.shape && t4.hasOwnProperty("shape")) {
                  var e3 = l.onnx.TensorShapeProto.verify(t4.shape);
                  if (e3) return "shape." + e3;
                }
                return null;
              }, t3.fromObject = function(t4) {
                if (t4 instanceof l.onnx.TypeProto.Tensor) return t4;
                var e3 = new l.onnx.TypeProto.Tensor();
                if (null != t4.elemType && (e3.elemType = 0 | t4.elemType), null != t4.shape) {
                  if ("object" != typeof t4.shape) throw TypeError(".onnx.TypeProto.Tensor.shape: object expected");
                  e3.shape = l.onnx.TensorShapeProto.fromObject(t4.shape);
                }
                return e3;
              }, t3.toObject = function(t4, e3) {
                e3 || (e3 = {});
                var n2 = {};
                return e3.defaults && (n2.elemType = 0, n2.shape = null), null != t4.elemType && t4.hasOwnProperty("elemType") && (n2.elemType = t4.elemType), null != t4.shape && t4.hasOwnProperty("shape") && (n2.shape = l.onnx.TensorShapeProto.toObject(t4.shape, e3)), n2;
              }, t3.prototype.toJSON = function() {
                return this.constructor.toObject(this, a.util.toJSONOptions);
              }, t3;
            }(), t2;
          }(), o.OperatorSetIdProto = function() {
            function t2(t3) {
              if (t3) for (var e2 = Object.keys(t3), n2 = 0; n2 < e2.length; ++n2) null != t3[e2[n2]] && (this[e2[n2]] = t3[e2[n2]]);
            }
            return t2.prototype.domain = "", t2.prototype.version = c.Long ? c.Long.fromBits(0, 0, false) : 0, t2.create = function(e2) {
              return new t2(e2);
            }, t2.encode = function(t3, e2) {
              return e2 || (e2 = u.create()), null != t3.domain && t3.hasOwnProperty("domain") && e2.uint32(10).string(t3.domain), null != t3.version && t3.hasOwnProperty("version") && e2.uint32(16).int64(t3.version), e2;
            }, t2.encodeDelimited = function(t3, e2) {
              return this.encode(t3, e2).ldelim();
            }, t2.decode = function(t3, e2) {
              t3 instanceof s || (t3 = s.create(t3));
              for (var n2 = void 0 === e2 ? t3.len : t3.pos + e2, r2 = new l.onnx.OperatorSetIdProto(); t3.pos < n2; ) {
                var i2 = t3.uint32();
                switch (i2 >>> 3) {
                  case 1:
                    r2.domain = t3.string();
                    break;
                  case 2:
                    r2.version = t3.int64();
                    break;
                  default:
                    t3.skipType(7 & i2);
                }
              }
              return r2;
            }, t2.decodeDelimited = function(t3) {
              return t3 instanceof s || (t3 = new s(t3)), this.decode(t3, t3.uint32());
            }, t2.verify = function(t3) {
              return "object" != typeof t3 || null === t3 ? "object expected" : null != t3.domain && t3.hasOwnProperty("domain") && !c.isString(t3.domain) ? "domain: string expected" : null != t3.version && t3.hasOwnProperty("version") && !(c.isInteger(t3.version) || t3.version && c.isInteger(t3.version.low) && c.isInteger(t3.version.high)) ? "version: integer|Long expected" : null;
            }, t2.fromObject = function(t3) {
              if (t3 instanceof l.onnx.OperatorSetIdProto) return t3;
              var e2 = new l.onnx.OperatorSetIdProto();
              return null != t3.domain && (e2.domain = String(t3.domain)), null != t3.version && (c.Long ? (e2.version = c.Long.fromValue(t3.version)).unsigned = false : "string" == typeof t3.version ? e2.version = parseInt(t3.version, 10) : "number" == typeof t3.version ? e2.version = t3.version : "object" == typeof t3.version && (e2.version = new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber())), e2;
            }, t2.toObject = function(t3, e2) {
              e2 || (e2 = {});
              var n2 = {};
              if (e2.defaults) if (n2.domain = "", c.Long) {
                var r2 = new c.Long(0, 0, false);
                n2.version = e2.longs === String ? r2.toString() : e2.longs === Number ? r2.toNumber() : r2;
              } else n2.version = e2.longs === String ? "0" : 0;
              return null != t3.domain && t3.hasOwnProperty("domain") && (n2.domain = t3.domain), null != t3.version && t3.hasOwnProperty("version") && ("number" == typeof t3.version ? n2.version = e2.longs === String ? String(t3.version) : t3.version : n2.version = e2.longs === String ? c.Long.prototype.toString.call(t3.version) : e2.longs === Number ? new c.LongBits(t3.version.low >>> 0, t3.version.high >>> 0).toNumber() : t3.version), n2;
            }, t2.prototype.toJSON = function() {
              return this.constructor.toObject(this, a.util.toJSONOptions);
            }, t2;
          }(), o), t.exports = l;
        }, 2100: (t, e, n) => {
          t.exports = n(9482);
        }, 9482: (t, e, n) => {
          var r = e;
          function i() {
            r.util._configure(), r.Writer._configure(r.BufferWriter), r.Reader._configure(r.BufferReader);
          }
          r.build = "minimal", r.Writer = n(1173), r.BufferWriter = n(3155), r.Reader = n(1408), r.BufferReader = n(593), r.util = n(9693), r.rpc = n(5994), r.roots = n(5054), r.configure = i, i();
        }, 1408: (t, e, n) => {
          t.exports = u;
          var r, i = n(9693), o = i.LongBits, a = i.utf8;
          function s(t2, e2) {
            return RangeError("index out of range: " + t2.pos + " + " + (e2 || 1) + " > " + t2.len);
          }
          function u(t2) {
            this.buf = t2, this.pos = 0, this.len = t2.length;
          }
          var c, l = "undefined" != typeof Uint8Array ? function(t2) {
            if (t2 instanceof Uint8Array || Array.isArray(t2)) return new u(t2);
            throw Error("illegal buffer");
          } : function(t2) {
            if (Array.isArray(t2)) return new u(t2);
            throw Error("illegal buffer");
          }, p = function() {
            return i.Buffer ? function(t2) {
              return (u.create = function(t3) {
                return i.Buffer.isBuffer(t3) ? new r(t3) : l(t3);
              })(t2);
            } : l;
          };
          function f() {
            var t2 = new o(0, 0), e2 = 0;
            if (!(this.len - this.pos > 4)) {
              for (; e2 < 3; ++e2) {
                if (this.pos >= this.len) throw s(this);
                if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128) return t2;
              }
              return t2.lo = (t2.lo | (127 & this.buf[this.pos++]) << 7 * e2) >>> 0, t2;
            }
            for (; e2 < 4; ++e2) if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 7 * e2) >>> 0, this.buf[this.pos++] < 128) return t2;
            if (t2.lo = (t2.lo | (127 & this.buf[this.pos]) << 28) >>> 0, t2.hi = (t2.hi | (127 & this.buf[this.pos]) >> 4) >>> 0, this.buf[this.pos++] < 128) return t2;
            if (e2 = 0, this.len - this.pos > 4) {
              for (; e2 < 5; ++e2) if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128) return t2;
            } else for (; e2 < 5; ++e2) {
              if (this.pos >= this.len) throw s(this);
              if (t2.hi = (t2.hi | (127 & this.buf[this.pos]) << 7 * e2 + 3) >>> 0, this.buf[this.pos++] < 128) return t2;
            }
            throw Error("invalid varint encoding");
          }
          function d(t2, e2) {
            return (t2[e2 - 4] | t2[e2 - 3] << 8 | t2[e2 - 2] << 16 | t2[e2 - 1] << 24) >>> 0;
          }
          function h() {
            if (this.pos + 8 > this.len) throw s(this, 8);
            return new o(d(this.buf, this.pos += 4), d(this.buf, this.pos += 4));
          }
          u.create = p(), u.prototype._slice = i.Array.prototype.subarray || i.Array.prototype.slice, u.prototype.uint32 = (c = 4294967295, function() {
            if (c = (127 & this.buf[this.pos]) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 7) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 14) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (127 & this.buf[this.pos]) << 21) >>> 0, this.buf[this.pos++] < 128) return c;
            if (c = (c | (15 & this.buf[this.pos]) << 28) >>> 0, this.buf[this.pos++] < 128) return c;
            if ((this.pos += 5) > this.len) throw this.pos = this.len, s(this, 10);
            return c;
          }), u.prototype.int32 = function() {
            return 0 | this.uint32();
          }, u.prototype.sint32 = function() {
            var t2 = this.uint32();
            return t2 >>> 1 ^ -(1 & t2) | 0;
          }, u.prototype.bool = function() {
            return 0 !== this.uint32();
          }, u.prototype.fixed32 = function() {
            if (this.pos + 4 > this.len) throw s(this, 4);
            return d(this.buf, this.pos += 4);
          }, u.prototype.sfixed32 = function() {
            if (this.pos + 4 > this.len) throw s(this, 4);
            return 0 | d(this.buf, this.pos += 4);
          }, u.prototype.float = function() {
            if (this.pos + 4 > this.len) throw s(this, 4);
            var t2 = i.float.readFloatLE(this.buf, this.pos);
            return this.pos += 4, t2;
          }, u.prototype.double = function() {
            if (this.pos + 8 > this.len) throw s(this, 4);
            var t2 = i.float.readDoubleLE(this.buf, this.pos);
            return this.pos += 8, t2;
          }, u.prototype.bytes = function() {
            var t2 = this.uint32(), e2 = this.pos, n2 = this.pos + t2;
            if (n2 > this.len) throw s(this, t2);
            return this.pos += t2, Array.isArray(this.buf) ? this.buf.slice(e2, n2) : e2 === n2 ? new this.buf.constructor(0) : this._slice.call(this.buf, e2, n2);
          }, u.prototype.string = function() {
            var t2 = this.bytes();
            return a.read(t2, 0, t2.length);
          }, u.prototype.skip = function(t2) {
            if ("number" == typeof t2) {
              if (this.pos + t2 > this.len) throw s(this, t2);
              this.pos += t2;
            } else do {
              if (this.pos >= this.len) throw s(this);
            } while (128 & this.buf[this.pos++]);
            return this;
          }, u.prototype.skipType = function(t2) {
            switch (t2) {
              case 0:
                this.skip();
                break;
              case 1:
                this.skip(8);
                break;
              case 2:
                this.skip(this.uint32());
                break;
              case 3:
                for (; 4 != (t2 = 7 & this.uint32()); ) this.skipType(t2);
                break;
              case 5:
                this.skip(4);
                break;
              default:
                throw Error("invalid wire type " + t2 + " at offset " + this.pos);
            }
            return this;
          }, u._configure = function(t2) {
            r = t2, u.create = p(), r._configure();
            var e2 = i.Long ? "toLong" : "toNumber";
            i.merge(u.prototype, { int64: function() {
              return f.call(this)[e2](false);
            }, uint64: function() {
              return f.call(this)[e2](true);
            }, sint64: function() {
              return f.call(this).zzDecode()[e2](false);
            }, fixed64: function() {
              return h.call(this)[e2](true);
            }, sfixed64: function() {
              return h.call(this)[e2](false);
            } });
          };
        }, 593: (t, e, n) => {
          t.exports = o;
          var r = n(1408);
          (o.prototype = Object.create(r.prototype)).constructor = o;
          var i = n(9693);
          function o(t2) {
            r.call(this, t2);
          }
          o._configure = function() {
            i.Buffer && (o.prototype._slice = i.Buffer.prototype.slice);
          }, o.prototype.string = function() {
            var t2 = this.uint32();
            return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + t2, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + t2, this.len));
          }, o._configure();
        }, 5054: (t) => {
          t.exports = {};
        }, 5994: (t, e, n) => {
          e.Service = n(7948);
        }, 7948: (t, e, n) => {
          t.exports = i;
          var r = n(9693);
          function i(t2, e2, n2) {
            if ("function" != typeof t2) throw TypeError("rpcImpl must be a function");
            r.EventEmitter.call(this), this.rpcImpl = t2, this.requestDelimited = Boolean(e2), this.responseDelimited = Boolean(n2);
          }
          (i.prototype = Object.create(r.EventEmitter.prototype)).constructor = i, i.prototype.rpcCall = function t2(e2, n2, i2, o, a) {
            if (!o) throw TypeError("request must be specified");
            var s = this;
            if (!a) return r.asPromise(t2, s, e2, n2, i2, o);
            if (s.rpcImpl) try {
              return s.rpcImpl(e2, n2[s.requestDelimited ? "encodeDelimited" : "encode"](o).finish(), function(t3, n3) {
                if (t3) return s.emit("error", t3, e2), a(t3);
                if (null !== n3) {
                  if (!(n3 instanceof i2)) try {
                    n3 = i2[s.responseDelimited ? "decodeDelimited" : "decode"](n3);
                  } catch (t4) {
                    return s.emit("error", t4, e2), a(t4);
                  }
                  return s.emit("data", n3, e2), a(null, n3);
                }
                s.end(true);
              });
            } catch (t3) {
              return s.emit("error", t3, e2), void setTimeout(function() {
                a(t3);
              }, 0);
            }
            else setTimeout(function() {
              a(Error("already ended"));
            }, 0);
          }, i.prototype.end = function(t2) {
            return this.rpcImpl && (t2 || this.rpcImpl(null, null, null), this.rpcImpl = null, this.emit("end").off()), this;
          };
        }, 1945: (t, e, n) => {
          t.exports = i;
          var r = n(9693);
          function i(t2, e2) {
            this.lo = t2 >>> 0, this.hi = e2 >>> 0;
          }
          var o = i.zero = new i(0, 0);
          o.toNumber = function() {
            return 0;
          }, o.zzEncode = o.zzDecode = function() {
            return this;
          }, o.length = function() {
            return 1;
          };
          var a = i.zeroHash = "\0\0\0\0\0\0\0\0";
          i.fromNumber = function(t2) {
            if (0 === t2) return o;
            var e2 = t2 < 0;
            e2 && (t2 = -t2);
            var n2 = t2 >>> 0, r2 = (t2 - n2) / 4294967296 >>> 0;
            return e2 && (r2 = ~r2 >>> 0, n2 = ~n2 >>> 0, ++n2 > 4294967295 && (n2 = 0, ++r2 > 4294967295 && (r2 = 0))), new i(n2, r2);
          }, i.from = function(t2) {
            if ("number" == typeof t2) return i.fromNumber(t2);
            if (r.isString(t2)) {
              if (!r.Long) return i.fromNumber(parseInt(t2, 10));
              t2 = r.Long.fromString(t2);
            }
            return t2.low || t2.high ? new i(t2.low >>> 0, t2.high >>> 0) : o;
          }, i.prototype.toNumber = function(t2) {
            if (!t2 && this.hi >>> 31) {
              var e2 = 1 + ~this.lo >>> 0, n2 = ~this.hi >>> 0;
              return e2 || (n2 = n2 + 1 >>> 0), -(e2 + 4294967296 * n2);
            }
            return this.lo + 4294967296 * this.hi;
          }, i.prototype.toLong = function(t2) {
            return r.Long ? new r.Long(0 | this.lo, 0 | this.hi, Boolean(t2)) : { low: 0 | this.lo, high: 0 | this.hi, unsigned: Boolean(t2) };
          };
          var s = String.prototype.charCodeAt;
          i.fromHash = function(t2) {
            return t2 === a ? o : new i((s.call(t2, 0) | s.call(t2, 1) << 8 | s.call(t2, 2) << 16 | s.call(t2, 3) << 24) >>> 0, (s.call(t2, 4) | s.call(t2, 5) << 8 | s.call(t2, 6) << 16 | s.call(t2, 7) << 24) >>> 0);
          }, i.prototype.toHash = function() {
            return String.fromCharCode(255 & this.lo, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, 255 & this.hi, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
          }, i.prototype.zzEncode = function() {
            var t2 = this.hi >> 31;
            return this.hi = ((this.hi << 1 | this.lo >>> 31) ^ t2) >>> 0, this.lo = (this.lo << 1 ^ t2) >>> 0, this;
          }, i.prototype.zzDecode = function() {
            var t2 = -(1 & this.lo);
            return this.lo = ((this.lo >>> 1 | this.hi << 31) ^ t2) >>> 0, this.hi = (this.hi >>> 1 ^ t2) >>> 0, this;
          }, i.prototype.length = function() {
            var t2 = this.lo, e2 = (this.lo >>> 28 | this.hi << 4) >>> 0, n2 = this.hi >>> 24;
            return 0 === n2 ? 0 === e2 ? t2 < 16384 ? t2 < 128 ? 1 : 2 : t2 < 2097152 ? 3 : 4 : e2 < 16384 ? e2 < 128 ? 5 : 6 : e2 < 2097152 ? 7 : 8 : n2 < 128 ? 9 : 10;
          };
        }, 9693: function(t, e, n) {
          var r = e;
          function i(t2, e2, n2) {
            for (var r2 = Object.keys(e2), i2 = 0; i2 < r2.length; ++i2) void 0 !== t2[r2[i2]] && n2 || (t2[r2[i2]] = e2[r2[i2]]);
            return t2;
          }
          function o(t2) {
            function e2(t3, n2) {
              if (!(this instanceof e2)) return new e2(t3, n2);
              Object.defineProperty(this, "message", { get: function() {
                return t3;
              } }), Error.captureStackTrace ? Error.captureStackTrace(this, e2) : Object.defineProperty(this, "stack", { value: new Error().stack || "" }), n2 && i(this, n2);
            }
            return (e2.prototype = Object.create(Error.prototype)).constructor = e2, Object.defineProperty(e2.prototype, "name", { get: function() {
              return t2;
            } }), e2.prototype.toString = function() {
              return this.name + ": " + this.message;
            }, e2;
          }
          r.asPromise = n(4537), r.base64 = n(7419), r.EventEmitter = n(9211), r.float = n(945), r.inquire = n(7199), r.utf8 = n(4997), r.pool = n(6662), r.LongBits = n(1945), r.isNode = Boolean(void 0 !== n.g && n.g && n.g.process && n.g.process.versions && n.g.process.versions.node), r.global = r.isNode && n.g || "undefined" != typeof window && window || "undefined" != typeof self && self || this, r.emptyArray = Object.freeze ? Object.freeze([]) : [], r.emptyObject = Object.freeze ? Object.freeze({}) : {}, r.isInteger = Number.isInteger || function(t2) {
            return "number" == typeof t2 && isFinite(t2) && Math.floor(t2) === t2;
          }, r.isString = function(t2) {
            return "string" == typeof t2 || t2 instanceof String;
          }, r.isObject = function(t2) {
            return t2 && "object" == typeof t2;
          }, r.isset = r.isSet = function(t2, e2) {
            var n2 = t2[e2];
            return !(null == n2 || !t2.hasOwnProperty(e2)) && ("object" != typeof n2 || (Array.isArray(n2) ? n2.length : Object.keys(n2).length) > 0);
          }, r.Buffer = function() {
            try {
              var t2 = r.inquire("buffer").Buffer;
              return t2.prototype.utf8Write ? t2 : null;
            } catch (t3) {
              return null;
            }
          }(), r._Buffer_from = null, r._Buffer_allocUnsafe = null, r.newBuffer = function(t2) {
            return "number" == typeof t2 ? r.Buffer ? r._Buffer_allocUnsafe(t2) : new r.Array(t2) : r.Buffer ? r._Buffer_from(t2) : "undefined" == typeof Uint8Array ? t2 : new Uint8Array(t2);
          }, r.Array = "undefined" != typeof Uint8Array ? Uint8Array : Array, r.Long = r.global.dcodeIO && r.global.dcodeIO.Long || r.global.Long || r.inquire("long"), r.key2Re = /^true|false|0|1$/, r.key32Re = /^-?(?:0|[1-9][0-9]*)$/, r.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/, r.longToHash = function(t2) {
            return t2 ? r.LongBits.from(t2).toHash() : r.LongBits.zeroHash;
          }, r.longFromHash = function(t2, e2) {
            var n2 = r.LongBits.fromHash(t2);
            return r.Long ? r.Long.fromBits(n2.lo, n2.hi, e2) : n2.toNumber(Boolean(e2));
          }, r.merge = i, r.lcFirst = function(t2) {
            return t2.charAt(0).toLowerCase() + t2.substring(1);
          }, r.newError = o, r.ProtocolError = o("ProtocolError"), r.oneOfGetter = function(t2) {
            for (var e2 = {}, n2 = 0; n2 < t2.length; ++n2) e2[t2[n2]] = 1;
            return function() {
              for (var t3 = Object.keys(this), n3 = t3.length - 1; n3 > -1; --n3) if (1 === e2[t3[n3]] && void 0 !== this[t3[n3]] && null !== this[t3[n3]]) return t3[n3];
            };
          }, r.oneOfSetter = function(t2) {
            return function(e2) {
              for (var n2 = 0; n2 < t2.length; ++n2) t2[n2] !== e2 && delete this[t2[n2]];
            };
          }, r.toJSONOptions = { longs: String, enums: String, bytes: String, json: true }, r._configure = function() {
            var t2 = r.Buffer;
            t2 ? (r._Buffer_from = t2.from !== Uint8Array.from && t2.from || function(e2, n2) {
              return new t2(e2, n2);
            }, r._Buffer_allocUnsafe = t2.allocUnsafe || function(e2) {
              return new t2(e2);
            }) : r._Buffer_from = r._Buffer_allocUnsafe = null;
          };
        }, 1173: (t, e, n) => {
          t.exports = p;
          var r, i = n(9693), o = i.LongBits, a = i.base64, s = i.utf8;
          function u(t2, e2, n2) {
            this.fn = t2, this.len = e2, this.next = void 0, this.val = n2;
          }
          function c() {
          }
          function l(t2) {
            this.head = t2.head, this.tail = t2.tail, this.len = t2.len, this.next = t2.states;
          }
          function p() {
            this.len = 0, this.head = new u(c, 0, 0), this.tail = this.head, this.states = null;
          }
          var f = function() {
            return i.Buffer ? function() {
              return (p.create = function() {
                return new r();
              })();
            } : function() {
              return new p();
            };
          };
          function d(t2, e2, n2) {
            e2[n2] = 255 & t2;
          }
          function h(t2, e2) {
            this.len = t2, this.next = void 0, this.val = e2;
          }
          function g(t2, e2, n2) {
            for (; t2.hi; ) e2[n2++] = 127 & t2.lo | 128, t2.lo = (t2.lo >>> 7 | t2.hi << 25) >>> 0, t2.hi >>>= 7;
            for (; t2.lo > 127; ) e2[n2++] = 127 & t2.lo | 128, t2.lo = t2.lo >>> 7;
            e2[n2++] = t2.lo;
          }
          function b(t2, e2, n2) {
            e2[n2] = 255 & t2, e2[n2 + 1] = t2 >>> 8 & 255, e2[n2 + 2] = t2 >>> 16 & 255, e2[n2 + 3] = t2 >>> 24;
          }
          p.create = f(), p.alloc = function(t2) {
            return new i.Array(t2);
          }, i.Array !== Array && (p.alloc = i.pool(p.alloc, i.Array.prototype.subarray)), p.prototype._push = function(t2, e2, n2) {
            return this.tail = this.tail.next = new u(t2, e2, n2), this.len += e2, this;
          }, h.prototype = Object.create(u.prototype), h.prototype.fn = function(t2, e2, n2) {
            for (; t2 > 127; ) e2[n2++] = 127 & t2 | 128, t2 >>>= 7;
            e2[n2] = t2;
          }, p.prototype.uint32 = function(t2) {
            return this.len += (this.tail = this.tail.next = new h((t2 >>>= 0) < 128 ? 1 : t2 < 16384 ? 2 : t2 < 2097152 ? 3 : t2 < 268435456 ? 4 : 5, t2)).len, this;
          }, p.prototype.int32 = function(t2) {
            return t2 < 0 ? this._push(g, 10, o.fromNumber(t2)) : this.uint32(t2);
          }, p.prototype.sint32 = function(t2) {
            return this.uint32((t2 << 1 ^ t2 >> 31) >>> 0);
          }, p.prototype.uint64 = function(t2) {
            var e2 = o.from(t2);
            return this._push(g, e2.length(), e2);
          }, p.prototype.int64 = p.prototype.uint64, p.prototype.sint64 = function(t2) {
            var e2 = o.from(t2).zzEncode();
            return this._push(g, e2.length(), e2);
          }, p.prototype.bool = function(t2) {
            return this._push(d, 1, t2 ? 1 : 0);
          }, p.prototype.fixed32 = function(t2) {
            return this._push(b, 4, t2 >>> 0);
          }, p.prototype.sfixed32 = p.prototype.fixed32, p.prototype.fixed64 = function(t2) {
            var e2 = o.from(t2);
            return this._push(b, 4, e2.lo)._push(b, 4, e2.hi);
          }, p.prototype.sfixed64 = p.prototype.fixed64, p.prototype.float = function(t2) {
            return this._push(i.float.writeFloatLE, 4, t2);
          }, p.prototype.double = function(t2) {
            return this._push(i.float.writeDoubleLE, 8, t2);
          };
          var m = i.Array.prototype.set ? function(t2, e2, n2) {
            e2.set(t2, n2);
          } : function(t2, e2, n2) {
            for (var r2 = 0; r2 < t2.length; ++r2) e2[n2 + r2] = t2[r2];
          };
          p.prototype.bytes = function(t2) {
            var e2 = t2.length >>> 0;
            if (!e2) return this._push(d, 1, 0);
            if (i.isString(t2)) {
              var n2 = p.alloc(e2 = a.length(t2));
              a.decode(t2, n2, 0), t2 = n2;
            }
            return this.uint32(e2)._push(m, e2, t2);
          }, p.prototype.string = function(t2) {
            var e2 = s.length(t2);
            return e2 ? this.uint32(e2)._push(s.write, e2, t2) : this._push(d, 1, 0);
          }, p.prototype.fork = function() {
            return this.states = new l(this), this.head = this.tail = new u(c, 0, 0), this.len = 0, this;
          }, p.prototype.reset = function() {
            return this.states ? (this.head = this.states.head, this.tail = this.states.tail, this.len = this.states.len, this.states = this.states.next) : (this.head = this.tail = new u(c, 0, 0), this.len = 0), this;
          }, p.prototype.ldelim = function() {
            var t2 = this.head, e2 = this.tail, n2 = this.len;
            return this.reset().uint32(n2), n2 && (this.tail.next = t2.next, this.tail = e2, this.len += n2), this;
          }, p.prototype.finish = function() {
            for (var t2 = this.head.next, e2 = this.constructor.alloc(this.len), n2 = 0; t2; ) t2.fn(t2.val, e2, n2), n2 += t2.len, t2 = t2.next;
            return e2;
          }, p._configure = function(t2) {
            r = t2, p.create = f(), r._configure();
          };
        }, 3155: (t, e, n) => {
          t.exports = o;
          var r = n(1173);
          (o.prototype = Object.create(r.prototype)).constructor = o;
          var i = n(9693);
          function o() {
            r.call(this);
          }
          function a(t2, e2, n2) {
            t2.length < 40 ? i.utf8.write(t2, e2, n2) : e2.utf8Write ? e2.utf8Write(t2, n2) : e2.write(t2, n2);
          }
          o._configure = function() {
            o.alloc = i._Buffer_allocUnsafe, o.writeBytesBuffer = i.Buffer && i.Buffer.prototype instanceof Uint8Array && "set" === i.Buffer.prototype.set.name ? function(t2, e2, n2) {
              e2.set(t2, n2);
            } : function(t2, e2, n2) {
              if (t2.copy) t2.copy(e2, n2, 0, t2.length);
              else for (var r2 = 0; r2 < t2.length; ) e2[n2++] = t2[r2++];
            };
          }, o.prototype.bytes = function(t2) {
            i.isString(t2) && (t2 = i._Buffer_from(t2, "base64"));
            var e2 = t2.length >>> 0;
            return this.uint32(e2), e2 && this._push(o.writeBytesBuffer, e2, t2), this;
          }, o.prototype.string = function(t2) {
            var e2 = i.Buffer.byteLength(t2);
            return this.uint32(e2), e2 && this._push(a, e2, t2), this;
          }, o._configure();
        }, 7714: (t, e, n) => {
          e.R = void 0;
          const r = n(6919), i = n(7448);
          e.R = new class {
            init() {
              return __async(this, null, function* () {
              });
            }
            createSessionHandler(t2, e2) {
              return __async(this, null, function* () {
                const n2 = new r.Session(e2);
                return yield n2.loadModel(t2), new i.OnnxjsSessionHandler(n2);
              });
            }
          }();
        }, 4200: (t, e, n) => {
          e.c8 = e.rX = void 0;
          const r = n(1670), i = n(5381), o = n(2157), a = n(2306);
          e.rX = () => {
            if (("number" != typeof r.env.wasm.initTimeout || r.env.wasm.initTimeout < 0) && (r.env.wasm.initTimeout = 0), "boolean" != typeof r.env.wasm.simd && (r.env.wasm.simd = true), "boolean" != typeof r.env.wasm.proxy && (r.env.wasm.proxy = false), "number" != typeof r.env.wasm.numThreads || !Number.isInteger(r.env.wasm.numThreads) || r.env.wasm.numThreads <= 0) {
              const t2 = "undefined" == typeof navigator ? (0, i.cpus)().length : navigator.hardwareConcurrency;
              r.env.wasm.numThreads = Math.min(4, Math.ceil((t2 || 1) / 2));
            }
          }, e.c8 = new class {
            init() {
              return __async(this, null, function* () {
                (0, e.rX)(), yield (0, o.initWasm)();
              });
            }
            createSessionHandler(t2, e2) {
              return __async(this, null, function* () {
                const n2 = new a.OnnxruntimeWebAssemblySessionHandler();
                return yield n2.loadModel(t2, e2), Promise.resolve(n2);
              });
            }
          }();
        }, 6018: function(t, e, n) {
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__exportStar || function(t2, e2) {
            for (var n2 in t2) "default" === n2 || Object.prototype.hasOwnProperty.call(e2, n2) || r(e2, t2, n2);
          };
          Object.defineProperty(e, "__esModule", { value: true }), i(n(1670), e);
          const o = n(1670);
          {
            const t2 = n(7714).R;
            (0, o.registerBackend)("webgl", t2, -10);
          }
          {
            const t2 = n(4200).c8;
            (0, o.registerBackend)("cpu", t2, 10), (0, o.registerBackend)("wasm", t2, 10), (0, o.registerBackend)("xnnpack", t2, 9);
          }
        }, 246: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createAttributeWithCacheKey = void 0;
          class n {
            constructor(t2) {
              Object.assign(this, t2);
            }
            get cacheKey() {
              return this._cacheKey || (this._cacheKey = Object.getOwnPropertyNames(this).sort().map((t2) => `${this[t2]}`).join(";")), this._cacheKey;
            }
          }
          e.createAttributeWithCacheKey = (t2) => new n(t2);
        }, 7778: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.Attribute = void 0;
          const r = n(1446), i = n(9395), o = n(9162), a = n(2517);
          var s = i.onnxruntime.experimental.fbs;
          class u {
            constructor(t2) {
              if (this._attributes = /* @__PURE__ */ new Map(), null != t2) {
                for (const e2 of t2) e2 instanceof r.onnx.AttributeProto ? this._attributes.set(e2.name, [u.getValue(e2), u.getType(e2)]) : e2 instanceof s.Attribute && this._attributes.set(e2.name(), [u.getValue(e2), u.getType(e2)]);
                if (this._attributes.size < t2.length) throw new Error("duplicated attribute names");
              }
            }
            set(t2, e2, n2) {
              this._attributes.set(t2, [n2, e2]);
            }
            delete(t2) {
              this._attributes.delete(t2);
            }
            getFloat(t2, e2) {
              return this.get(t2, "float", e2);
            }
            getInt(t2, e2) {
              return this.get(t2, "int", e2);
            }
            getString(t2, e2) {
              return this.get(t2, "string", e2);
            }
            getTensor(t2, e2) {
              return this.get(t2, "tensor", e2);
            }
            getFloats(t2, e2) {
              return this.get(t2, "floats", e2);
            }
            getInts(t2, e2) {
              return this.get(t2, "ints", e2);
            }
            getStrings(t2, e2) {
              return this.get(t2, "strings", e2);
            }
            getTensors(t2, e2) {
              return this.get(t2, "tensors", e2);
            }
            get(t2, e2, n2) {
              const r2 = this._attributes.get(t2);
              if (void 0 === r2) {
                if (void 0 !== n2) return n2;
                throw new Error(`required attribute not found: ${t2}`);
              }
              if (r2[1] !== e2) throw new Error(`type mismatch: expected ${e2} but got ${r2[1]}`);
              return r2[0];
            }
            static getType(t2) {
              const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
              switch (e2) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return "float";
                case r.onnx.AttributeProto.AttributeType.INT:
                  return "int";
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return "string";
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return "tensor";
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return "floats";
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return "ints";
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return "strings";
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return "tensors";
                default:
                  throw new Error(`attribute type is not supported yet: ${r.onnx.AttributeProto.AttributeType[e2]}`);
              }
            }
            static getValue(t2) {
              const e2 = t2 instanceof r.onnx.AttributeProto ? t2.type : t2.type();
              if (e2 === r.onnx.AttributeProto.AttributeType.GRAPH || e2 === r.onnx.AttributeProto.AttributeType.GRAPHS) throw new Error("graph attribute is not supported yet");
              const n2 = this.getValueNoCheck(t2);
              if (e2 === r.onnx.AttributeProto.AttributeType.INT && a.LongUtil.isLong(n2)) return a.LongUtil.longToNumber(n2);
              if (e2 === r.onnx.AttributeProto.AttributeType.INTS) {
                const t3 = n2, e3 = new Array(t3.length);
                for (let n3 = 0; n3 < t3.length; n3++) {
                  const r2 = t3[n3];
                  e3[n3] = a.LongUtil.longToNumber(r2);
                }
                return e3;
              }
              if (e2 === r.onnx.AttributeProto.AttributeType.TENSOR) return t2 instanceof r.onnx.AttributeProto ? o.Tensor.fromProto(n2) : o.Tensor.fromOrtTensor(n2);
              if (e2 === r.onnx.AttributeProto.AttributeType.TENSORS) {
                if (t2 instanceof r.onnx.AttributeProto) return n2.map((t3) => o.Tensor.fromProto(t3));
                if (t2 instanceof s.Attribute) return n2.map((t3) => o.Tensor.fromOrtTensor(t3));
              }
              if (e2 === r.onnx.AttributeProto.AttributeType.STRING && t2 instanceof r.onnx.AttributeProto) {
                const t3 = n2;
                return (0, a.decodeUtf8String)(t3);
              }
              return e2 === r.onnx.AttributeProto.AttributeType.STRINGS && t2 instanceof r.onnx.AttributeProto ? n2.map(a.decodeUtf8String) : n2;
            }
            static getValueNoCheck(t2) {
              return t2 instanceof r.onnx.AttributeProto ? this.getValueNoCheckFromOnnxFormat(t2) : this.getValueNoCheckFromOrtFormat(t2);
            }
            static getValueNoCheckFromOnnxFormat(t2) {
              switch (t2.type) {
                case r.onnx.AttributeProto.AttributeType.FLOAT:
                  return t2.f;
                case r.onnx.AttributeProto.AttributeType.INT:
                  return t2.i;
                case r.onnx.AttributeProto.AttributeType.STRING:
                  return t2.s;
                case r.onnx.AttributeProto.AttributeType.TENSOR:
                  return t2.t;
                case r.onnx.AttributeProto.AttributeType.GRAPH:
                  return t2.g;
                case r.onnx.AttributeProto.AttributeType.FLOATS:
                  return t2.floats;
                case r.onnx.AttributeProto.AttributeType.INTS:
                  return t2.ints;
                case r.onnx.AttributeProto.AttributeType.STRINGS:
                  return t2.strings;
                case r.onnx.AttributeProto.AttributeType.TENSORS:
                  return t2.tensors;
                case r.onnx.AttributeProto.AttributeType.GRAPHS:
                  return t2.graphs;
                default:
                  throw new Error(`unsupported attribute type: ${r.onnx.AttributeProto.AttributeType[t2.type]}`);
              }
            }
            static getValueNoCheckFromOrtFormat(t2) {
              switch (t2.type()) {
                case s.AttributeType.FLOAT:
                  return t2.f();
                case s.AttributeType.INT:
                  return t2.i();
                case s.AttributeType.STRING:
                  return t2.s();
                case s.AttributeType.TENSOR:
                  return t2.t();
                case s.AttributeType.GRAPH:
                  return t2.g();
                case s.AttributeType.FLOATS:
                  return t2.floatsArray();
                case s.AttributeType.INTS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.intsLength(); n2++) e2.push(t2.ints(n2));
                  return e2;
                }
                case s.AttributeType.STRINGS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.stringsLength(); n2++) e2.push(t2.strings(n2));
                  return e2;
                }
                case s.AttributeType.TENSORS: {
                  const e2 = [];
                  for (let n2 = 0; n2 < t2.tensorsLength(); n2++) e2.push(t2.tensors(n2));
                  return e2;
                }
                default:
                  throw new Error(`unsupported attribute type: ${s.AttributeType[t2.type()]}`);
              }
            }
          }
          e.Attribute = u;
        }, 7091: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.resolveBackend = e.backend = void 0;
          const r = n(5038), i = /* @__PURE__ */ new Map();
          function o(t2) {
            return __async(this, null, function* () {
              const n2 = e.backend;
              if (void 0 !== n2[t2] && function(t3) {
                const e2 = t3;
                return "initialize" in e2 && "function" == typeof e2.initialize && "createSessionHandler" in e2 && "function" == typeof e2.createSessionHandler && "dispose" in e2 && "function" == typeof e2.dispose;
              }(n2[t2])) {
                const e2 = n2[t2];
                let r2 = e2.initialize();
                if ("object" == typeof r2 && "then" in r2 && (r2 = yield r2), r2) return i.set(t2, e2), e2;
              }
            });
          }
          e.backend = { webgl: new r.WebGLBackend() }, e.resolveBackend = function t2(e2) {
            return __async(this, null, function* () {
              if (!e2) return t2(["webgl"]);
              {
                const t3 = "string" == typeof e2 ? [e2] : e2;
                for (const e3 of t3) {
                  const t4 = i.get(e3);
                  if (t4) return t4;
                  const n2 = yield o(e3);
                  if (n2) return n2;
                }
              }
              throw new Error("no available backend to use");
            });
          };
        }, 5038: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLBackend = void 0;
          const r = n(1670), i = n(6231), o = n(6416), a = n(7305);
          e.WebGLBackend = class {
            get contextId() {
              return r.env.webgl.contextId;
            }
            set contextId(t2) {
              r.env.webgl.contextId = t2;
            }
            get matmulMaxBatchSize() {
              return r.env.webgl.matmulMaxBatchSize;
            }
            set matmulMaxBatchSize(t2) {
              r.env.webgl.matmulMaxBatchSize = t2;
            }
            get textureCacheMode() {
              return r.env.webgl.textureCacheMode;
            }
            set textureCacheMode(t2) {
              r.env.webgl.textureCacheMode = t2;
            }
            get pack() {
              return r.env.webgl.pack;
            }
            set pack(t2) {
              r.env.webgl.pack = t2;
            }
            get async() {
              return r.env.webgl.async;
            }
            set async(t2) {
              r.env.webgl.async = t2;
            }
            initialize() {
              try {
                return this.glContext = (0, a.createWebGLContext)(this.contextId), "number" != typeof this.matmulMaxBatchSize && (this.matmulMaxBatchSize = 16), "string" != typeof this.textureCacheMode && (this.textureCacheMode = "full"), "boolean" != typeof this.pack && (this.pack = false), "boolean" != typeof this.async && (this.async = false), i.Logger.setWithEnv(r.env), i.Logger.verbose("WebGLBackend", `Created WebGLContext: ${typeof this.glContext} with matmulMaxBatchSize: ${this.matmulMaxBatchSize}; textureCacheMode: ${this.textureCacheMode}; pack: ${this.pack}; async: ${this.async}.`), true;
              } catch (t2) {
                return i.Logger.warning("WebGLBackend", `Unable to initialize WebGLBackend. ${t2}`), false;
              }
            }
            createSessionHandler(t2) {
              return new o.WebGLSessionHandler(this, t2);
            }
            dispose() {
              this.glContext.dispose();
            }
          };
        }, 5107: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.CoordsGlslLib = void 0;
          const r = n(2517), i = n(8520), o = n(5060), a = n(7859), s = n(9390);
          class u extends i.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.offsetToCoords()), this.coordsToOffset()), this.toVec()), this.valueFrom()), this.getCommonUtilFuncs()), this.getInputsSamplingSnippets()), this.getOutputSamplingSnippet());
            }
            getCustomTypes() {
              return {};
            }
            offsetToCoords() {
              return { offsetToCoords: new i.GlslLibRoutine("\n      vec2 offsetToCoords(int offset, int width, int height) {\n        int t = offset / width;\n        int s = offset - t*width;\n        vec2 coords = (vec2(s,t) + vec2(0.5,0.5)) / vec2(width, height);\n        return coords;\n      }\n      ") };
            }
            coordsToOffset() {
              return { coordsToOffset: new i.GlslLibRoutine("\n      int coordsToOffset(vec2 coords, int width, int height) {\n        float s = coords.s * float(width);\n        float t = coords.t * float(height);\n        int offset = int(t) * width + int(s);\n        return offset;\n      }\n      ") };
            }
            getOutputSamplingSnippet() {
              const t2 = this.context.outputTextureLayout;
              return t2.isPacked ? this.getPackedOutputSamplingSnippet(t2) : this.getUnpackedOutputSamplingSnippet(t2);
            }
            getPackedOutputSamplingSnippet(t2) {
              const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
              switch (e2.length) {
                case 0:
                  r2[a2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[a2] = this.getOutputPacked1DCoords(e2, n2);
                  break;
                case 2:
                  r2[a2] = this.getOutputPacked2DCoords(e2, n2);
                  break;
                case 3:
                  r2[a2] = this.getOutputPacked3DCoords(e2, n2);
                  break;
                default:
                  r2[a2] = this.getOutputPackedNDCoords(e2, n2);
              }
              const s2 = `
      void setOutput(vec4 val) {
        ${(0, o.getGlsl)(this.context.glContext.version).output} = val;
      }
    `;
              return r2.floatTextureSetRGBA = new i.GlslLibRoutine(s2), r2;
            }
            getUnpackedOutputSamplingSnippet(t2) {
              const e2 = t2.unpackedShape, n2 = [t2.width, t2.height], r2 = {}, a2 = "getOutputCoords";
              switch (e2.length) {
                case 0:
                  r2[a2] = this.getOutputScalarCoords();
                  break;
                case 1:
                  r2[a2] = this.getOutputUnpacked1DCoords(e2, n2);
                  break;
                case 2:
                  r2[a2] = this.getOutputUnpacked2DCoords(e2, n2);
                  break;
                case 3:
                  r2[a2] = this.getOutputUnpacked3DCoords(e2, n2);
                  break;
                case 4:
                  r2[a2] = this.getOutputUnpacked4DCoords(e2, n2);
                  break;
                case 5:
                  r2[a2] = this.getOutputUnpacked5DCoords(e2, n2);
                  break;
                case 6:
                  r2[a2] = this.getOutputUnpacked6DCoords(e2, n2);
                  break;
                default:
                  throw new Error(`Unsupported output dimensionality: ${e2.length}`);
              }
              const s2 = `
        void setOutput(float val) {
          ${(0, o.getGlsl)(this.context.glContext.version).output} = vec4(val, 0, 0, 0);
        }
    `;
              return r2.floatTextureSetR = new i.GlslLibRoutine(s2), r2;
            }
            getOutputScalarCoords() {
              return new i.GlslLibRoutine("\n      int getOutputCoords() {\n        return 0;\n      }\n    ");
            }
            getOutputPacked1DCoords(t2, e2) {
              const n2 = e2;
              let r2 = "";
              return 1 === n2[0] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.y * ${n2[1]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : 1 === n2[1] ? (r2 = `
          int getOutputCoords() {
            return 2 * int(TexCoords.x * ${n2[0]}.0);
          }
        `, new i.GlslLibRoutine(r2)) : (r2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                 vec2(${n2[0]}, ${n2[1]}));
          return 2 * (resTexRC.y * ${n2[0]} + resTexRC.x);
        }
      `, new i.GlslLibRoutine(r2));
            }
            getOutputPacked2DCoords(t2, e2) {
              let n2 = "";
              if (r.ArrayUtil.arraysEqual(t2, e2)) return n2 = `
        ivec2 getOutputCoords() {
          return 2 * ivec2(TexCoords.xy * vec2(${e2[0]}, ${e2[1]}));
        }
      `, new i.GlslLibRoutine(n2);
              const o2 = e2, a2 = Math.ceil(t2[1] / 2);
              return n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${o2[0]}, ${o2[1]}));

          int index = resTexRC.y * ${o2[0]} + resTexRC.x;

          // reverse r and c order for packed texture
          int r = imod(index, ${a2}) * 2;
          int c = 2 * (index / ${a2});

          return ivec2(r, c);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputPacked3DCoords(t2, e2) {
              const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[2] / 2), o2 = r2 * Math.ceil(t2[1] / 2), a2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${n2[0]}, ${n2[1]}));
          int index = resTexRC.y * ${n2[0]} + resTexRC.x;

          int b = index / ${o2};
          index -= b * ${o2};

          // reverse r and c order for packed texture
          int r = imod(index, ${r2}) * 2;
          int c = 2 * (index / ${r2});

          return ivec3(b, r, c);
        }
      `;
              return new i.GlslLibRoutine(a2);
            }
            getOutputPackedNDCoords(t2, e2) {
              const n2 = [e2[0], e2[1]], r2 = Math.ceil(t2[t2.length - 1] / 2), o2 = r2 * Math.ceil(t2[t2.length - 2] / 2);
              let a2 = o2, s2 = "", u2 = "b, r, c";
              for (let e3 = 2; e3 < t2.length - 1; e3++) a2 *= t2[t2.length - e3 - 1], s2 = `
      int b${e3} = index / ${a2};
      index -= b${e3} * ${a2};
    ` + s2, u2 = `b${e3}, ` + u2;
              const c = `
      ivec${t2.length} getOutputCoords() {
        ivec2 resTexRC = ivec2(TexCoords.xy *
                              vec2(${n2[0]}, ${n2[1]}));
        int index = resTexRC.y * ${n2[0]} + resTexRC.x;

        ${s2}

        int b = index / ${o2};
        index -= b * ${o2};

        // reverse r and c order for packed texture
        int r = imod(index, ${r2}) * 2;
        int c = 2 * (index / ${r2});

        return ivec${t2.length}(${u2});
      }
    `;
              return new i.GlslLibRoutine(c);
            }
            getOutputUnpacked1DCoords(t2, e2) {
              const n2 = `
        int getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          return resTexRC.y * ${e2[0]} + resTexRC.x;
        }
      `;
              return new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked2DCoords(t2, e2) {
              const n2 = `
        ivec2 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          int r = index / ${t2[1]};
          int c = index - r * ${t2[1]};
          return ivec2(r, c);
        }
      `;
              return new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked3DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3) o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
        ivec3 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec3(r, c, d);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked4DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3) o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
      ivec4 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec4(r, c, d, d2);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked5DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3) o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2", "d3"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
      ivec5 getOutputCoords() {
          ivec2 resTexRC = ivec2(TexCoords.xy *
                                vec2(${e2[0]}, ${e2[1]}));
          int index = resTexRC.y * ${e2[0]} + resTexRC.x;
          ${s2}
          return ivec5(r, c, d, d2, d3);
        }
      `, new i.GlslLibRoutine(n2);
            }
            getOutputUnpacked6DCoords(t2, e2) {
              let n2 = "";
              const r2 = t2.length;
              let o2 = null;
              r2 < 2 && (o2 = []), o2 = new Array(r2 - 1), o2[r2 - 2] = t2[r2 - 1];
              for (let e3 = r2 - 3; e3 >= 0; --e3) o2[e3] = o2[e3 + 1] * t2[e3 + 1];
              const a2 = ["r", "c", "d", "d2", "d3", "d4"], s2 = o2.map((t3, e3) => `int ${a2[e3]} = index / ${t3}; ${e3 === o2.length - 1 ? `int ${a2[e3 + 1]} = index - ${a2[e3]} * ${t3}` : `index -= ${a2[e3]} * ${t3}`};`).join("");
              return n2 = `
     ivec6 getOutputCoords() {
         ivec2 resTexRC = ivec2(TexCoords.xy *
                               vec2(${e2[0]}, ${e2[1]}));
         int index = resTexRC.y * ${e2[0]} + resTexRC.x;
         ${s2}
         return ivec6(r, c, d, d2, d3, d4);
       }
     `, new i.GlslLibRoutine(n2);
            }
            getCommonUtilFuncs() {
              const t2 = {};
              let e2 = "uvFromFlat";
              t2[e2] = new i.GlslLibRoutine("\n    vec2 uvFromFlat(int texNumR, int texNumC, int index) {\n      int texC = index / texNumR;\n      int texR = index - texC * texNumR;\n      // TODO: swap texR, texC order in following function so row is corresponding to u and column is corresponding to\n      //       v.\n      return (vec2(texR, texC) + halfCR) / vec2(texNumR, texNumC);\n    }\n    "), e2 = "packedUVfrom1D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n        int texelIndex = index / 2;\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom2D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom2D(int texNumR, int texNumC, int texelsInLogicalRow, int row, int col) {\n        int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = texelIndex / texNumC;\n        int texC = texelIndex - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "packedUVfrom3D", t2[e2] = new i.GlslLibRoutine("\n      vec2 packedUVfrom3D(int texNumR, int texNumC,\n          int texelsInBatch, int texelsInLogicalRow, int b,\n          int row, int col) {\n        int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n        int texR = index / texNumC;\n        int texC = index - texR * texNumC;\n        return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n      }\n      "), e2 = "sampleTexture";
              const n2 = (0, o.getGlsl)(this.context.glContext.version);
              return t2[e2] = new i.GlslLibRoutine(`
        float sampleTexture(sampler2D textureSampler, vec2 uv) {
            return ${n2.texture2D}(textureSampler, uv).r;
        }`), t2;
            }
            getInputsSamplingSnippets() {
              const t2 = {}, e2 = this.context.outputTextureLayout;
              return this.context.programInfo.inputNames.forEach((n2, r2) => {
                const i2 = this.context.inputTextureLayouts[r2], o2 = (0, s.generateShaderFuncNameFromInputSamplerName)(n2);
                i2.isPacked ? t2[o2] = this.getPackedSamplerFromInput(o2, n2, i2) : t2[o2] = this.getUnpackedSamplerFromInput(o2, n2, i2);
                const a2 = (0, s.generateShaderFuncNameFromInputSamplerNameAtOutCoords)(n2);
                i2.unpackedShape.length <= e2.unpackedShape.length && (i2.isPacked ? t2[a2] = this.getPackedSamplerAtOutputCoords(a2, i2, e2, n2) : t2[a2] = this.getUnpackedSamplerAtOutputCoords(a2, i2, e2, n2));
              }), t2;
            }
            getPackedSamplerAtOutputCoords(t2, e2, n2, o2) {
              const a2 = e2.unpackedShape, u2 = n2.unpackedShape, c = o2, l = (0, s.generateShaderFuncNameFromInputSamplerName)(c), p = a2.length, f = u2.length, d = r.BroadcastUtil.getBroadcastDims(a2, u2), h = (0, s.getCoordsDataType)(f), g = f - p;
              let b;
              const m = (0, s.getGlChannels)();
              b = 0 === p ? "" : f < 2 && d.length >= 1 ? "coords = 0;" : d.map((t3) => `coords.${m[t3 + g]} = 0;`).join("\n");
              let y = "";
              y = f < 2 && p > 0 ? "coords" : a2.map((t3, e3) => `coords.${m[e3 + g]}`).join(", ");
              let _ = "return outputValue;";
              const v = 1 === r.ShapeUtil.size(a2), w = 1 === r.ShapeUtil.size(u2);
              if (1 !== p || v || w) {
                if (v && !w) _ = 1 === f ? "\n          return vec4(outputValue.x, outputValue.x, 0., 0.);\n        " : "\n          return vec4(outputValue.x);\n        ";
                else if (d.length) {
                  const t3 = p - 2, e3 = p - 1;
                  d.indexOf(t3) > -1 && d.indexOf(e3) > -1 ? _ = "return vec4(outputValue.x);" : d.indexOf(t3) > -1 ? _ = "return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);" : d.indexOf(e3) > -1 && (_ = "return vec4(outputValue.xx, outputValue.zz);");
                }
              } else _ = "\n        return vec4(outputValue.xy, outputValue.xy);\n      ";
              const x = `
      vec4 ${t2}() {
        ${h} coords = getOutputCoords();
        
        int lastDim = coords.${m[f - 1]};
        coords.${m[f - 1]} = coords.${m[f - 2]};
        coords.${m[f - 2]} = lastDim;
      
        ${b}
        vec4 outputValue = ${l}(${y});
        ${_}
      }
    `;
              return new i.GlslLibRoutine(x, ["coordinates.getOutputCoords"]);
            }
            getUnpackedSamplerAtOutputCoords(t2, e2, n2, o2) {
              const a2 = [n2.width, n2.height], u2 = [e2.width, e2.height], c = e2.unpackedShape.length, l = n2.unpackedShape.length, p = e2.unpackedShape, f = n2.unpackedShape, d = (0, s.generateShaderFuncNameFromInputSamplerName)(o2);
              if (c === l && r.ArrayUtil.arraysEqual(u2, a2)) {
                const e3 = `
          float ${t2}() {
            return sampleTexture(${o2}, TexCoords);
          }
        `;
                return new i.GlslLibRoutine(e3, ["coordinates.sampleTexture"]);
              }
              const h = (0, s.getCoordsDataType)(l), g = r.BroadcastUtil.getBroadcastDims(p, f), b = l - c;
              let m;
              const y = (0, s.getGlChannels)();
              m = 0 === c ? "" : l < 2 && g.length >= 1 ? "coords = 0;" : g.map((t3) => `coords.${y[t3 + b]} = 0;`).join("\n");
              let _ = "";
              _ = l < 2 && c > 0 ? "coords" : e2.unpackedShape.map((t3, e3) => `coords.${y[e3 + b]}`).join(", ");
              const v = `
        float ${t2}() {
          ${h} coords = getOutputCoords();
          ${m}
          return ${d}(${_});
        }
      `;
              return new i.GlslLibRoutine(v, ["coordinates.getOutputCoords"]);
            }
            getPackedSamplerFromInput(t2, e2, n2) {
              switch (n2.unpackedShape.length) {
                case 0:
                  return this.getPackedSamplerScalar(t2, e2);
                case 1:
                  return this.getPackedSampler1D(t2, e2, n2);
                case 2:
                  return this.getPackedSampler2D(t2, e2, n2);
                case 3:
                  return this.getPackedSampler3D(t2, e2, n2);
                default:
                  return this.getPackedSamplerND(t2, e2, n2);
              }
            }
            getUnpackedSamplerFromInput(t2, e2, n2) {
              const r2 = n2.unpackedShape;
              switch (r2.length) {
                case 0:
                  return this.getUnpackedSamplerScalar(t2, e2, n2);
                case 1:
                  return this.getUnpackedSampler1D(t2, e2, n2);
                case 2:
                  return this.getUnpackedSampler2D(t2, e2, n2);
                case 3:
                  return this.getUnpackedSampler3D(t2, e2, n2);
                case 4:
                  return this.getUnpackedSampler4D(t2, e2, n2);
                case 5:
                  return this.getUnpackedSampler5D(t2, e2, n2);
                case 6:
                  return this.getUnpackedSampler6D(t2, e2, n2);
                default:
                  throw new Error(`Unsupported dimension ${r2.length}-D`);
              }
            }
            getPackedSamplerScalar(t2, e2) {
              const n2 = `
          vec4 ${t2}() {
            return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${e2}, halfCR);
          }
        `;
              return new i.GlslLibRoutine(n2);
            }
            getPackedSampler1D(t2, e2, n2) {
              const r2 = [n2.width, n2.height], a2 = [r2[1], r2[0]], s2 = (0, o.getGlsl)(this.context.glContext.version), u2 = `vec4 ${t2}(int index) {
      vec2 uv = packedUVfrom1D(
      ${a2[0]}, ${a2[1]}, index);
      return ${s2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(u2, ["coordinates.packedUVfrom1D"]);
            }
            getPackedSampler2D(t2, e2, n2) {
              const a2 = n2.unpackedShape, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = s2[0], l = s2[1];
              if (null != s2 && r.ArrayUtil.arraysEqual(a2, s2)) {
                const n3 = `vec4 ${t2}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${l}.0, ${c}.0);
        return ${u2.texture2D}(${e2}, uv);
      }`;
                return new i.GlslLibRoutine(n3);
              }
              const p = s2, f = Math.ceil(a2[1] / 2), d = `vec4 ${t2}(int row, int col) {
      vec2 uv = packedUVfrom2D(${p[1]}, ${p[0]}, ${f}, row, col);
      return ${u2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom2D"]);
            }
            getPackedSampler3D(t2, e2, n2) {
              const r2 = n2.unpackedShape, a2 = [n2.width, n2.height], u2 = [a2[0], a2[1]], c = (0, o.getGlsl)(this.context.glContext.version);
              if (1 === r2[0]) {
                const o2 = r2.slice(1), a3 = [1, 2], u3 = (0, s.squeezeInputShape)(r2, o2), c2 = ["b", "row", "col"], l2 = JSON.parse(JSON.stringify(n2));
                l2.unpackedShape = u3;
                const p2 = this.getPackedSamplerFromInput(t2, e2, l2), f2 = `${p2.routineBody}
      vec4 ${t2}(int b, int row, int col) {
        return ${t2}(${(0, s.getSqueezedParams)(c2, a3)});
      } `;
                return new i.GlslLibRoutine(f2, p2.dependencies);
              }
              const l = u2[0], p = u2[1], f = Math.ceil(r2[2] / 2), d = `vec4 ${t2}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${p}, ${l}, ${f * Math.ceil(r2[1] / 2)}, ${f}, b, row, col);
      return ${c.texture2D}(${e2}, uv);}`;
              return new i.GlslLibRoutine(d, ["coordinates.packedUVfrom3D"]);
            }
            getPackedSamplerND(t2, e2, n2) {
              const r2 = n2.unpackedShape, a2 = r2.length, s2 = [n2.width, n2.height], u2 = (0, o.getGlsl)(this.context.glContext.version), c = [s2[0], s2[1]], l = c[1], p = c[0], f = Math.ceil(r2[a2 - 1] / 2);
              let d = f * Math.ceil(r2[a2 - 2] / 2), h = "int b, int row, int col", g = `b * ${d} + (row / 2) * ${f} + (col / 2)`;
              for (let t3 = 2; t3 < a2 - 1; t3++) h = `int b${t3}, ` + h, d *= r2[a2 - t3 - 1], g = `b${t3} * ${d} + ` + g;
              const b = `vec4 ${t2}(${h}) {
      int index = ${g};
      int texR = index / ${p};
      int texC = index - texR * ${p};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${p}, ${l});
      return ${u2.texture2D}(${e2}, uv);
    }`;
              return new i.GlslLibRoutine(b);
            }
            getUnpackedSamplerScalar(t2, e2, n2) {
              const [r2, o2] = [n2.width, n2.height];
              if (1 === r2 && 1 === o2) {
                const n3 = `
          float ${t2}() {
            return sampleTexture(${e2}, halfCR);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const a2 = `
        float ${t2}() {
          int offset_${e2} = coordsToOffset(TexCoords, ${r2}, ${o2});
          vec2 uv = uvFromFlat(${r2}, ${o2}, offset_${e2});
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler1D(t2, e2, n2) {
              const r2 = n2.width, o2 = n2.height;
              if (1 === o2 && 1 === r2) {
                const n3 = `
        float ${t2}(int index) {
          return sampleTexture(${e2}, halfCR);
        }
      `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === o2) {
                const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2((float(index) + 0.5) / ${r2}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              if (1 === r2) {
                const n3 = `
          float ${t2}(int index) {
            vec2 uv = vec2(0.5, (float(index) + 0.5) / ${o2}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const a2 = `
        float ${t2}(int index) {
          vec2 uv = uvFromFlat(${r2}, ${o2}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(a2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler2D(t2, e2, n2) {
              const o2 = n2.unpackedShape, u2 = [n2.height, n2.width];
              if (null != u2 && r.ArrayUtil.arraysEqual(o2, u2)) {
                const n3 = `
          float ${t2}(int row, int col) {
            vec2 uv = (vec2(row, col) + halfCR) / vec2(${u2[1]}.0, ${u2[0]}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture"]);
              }
              const { newShape: c, keptDims: l } = (0, a.squeezeShape)(o2), p = c;
              if (p.length < o2.length) {
                const r2 = (0, s.squeezeInputShape)(o2, p), a2 = JSON.parse(JSON.stringify(n2));
                a2.unpackedShape = r2;
                const u3 = ["col", "row"], c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, a2).routineBody}
          float ${t2}(int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(u3, l)});
          }
        `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture"]);
              }
              const f = u2[1], d = u2[0];
              if (1 === d) {
                const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2(0.5, (index + 0.5) / ${f}.0);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              if (1 === f) {
                const n3 = `
          float ${t2}(int row, int col) {
            int offset_${e2} = coordsToOffset(TexCoords, ${f}, ${d});
            float index = dot(vec3(row, col, offset_${e2}), vec3(${o2[1]}, 1, 1));
            vec2 uv = vec2((index + 0.5) / ${d}.0, 0.5);
            return sampleTexture(${e2}, uv);
          }
        `;
                return new i.GlslLibRoutine(n3, ["coordinates.sampleTexture", "coordinates.coordsToOffset"]);
              }
              const h = `
        float ${t2}(int row, int col) {
          int index = col * ${o2[1]} + row;
          vec2 uv = uvFromFlat(${f}, ${d}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler3D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[1] * r2[2], u2 = r2[2], { newShape: c, keptDims: l } = (0, a.squeezeShape)(r2), p = c;
              if (p.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["batch", "col", "row"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = this.getUnpackedSamplerFromInput(t2, e2, u3), f2 = l.reverse(), d = `
          ${c2.routineBody}
          float ${t2}(int batch, int row, int col) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f2)});
          }
        `;
                return new i.GlslLibRoutine(d, c2.dependencies);
              }
              const f = `
          float ${t2}(int depth, int row, int col) {
            // Explicitly use integer operations as dot() only works on floats.
            int index = depth * ${o2} + col * ${u2} + row;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
      `;
              return new i.GlslLibRoutine(f, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            getUnpackedSampler4D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[3], a2 = r2[2] * o2, s2 = `
        float ${t2}(int row, int col, int depth, int depth2) {
          int index = row * ${r2[1] * a2} + col * ${a2} +
              depth2 * ${o2} + depth;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(s2, ["coordinates.uvFromFlat", "coordinates.sampleTexture"]);
            }
            getUnpackedSampler5D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[4], u2 = r2[3] * o2, c = r2[2] * u2, l = r2[1] * c, { newShape: p, keptDims: f } = (0, a.squeezeShape)(r2);
              if (p.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, p), a2 = ["row", "col", "depth", "depth2", "depth3"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = `
          ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
          float ${t2}(int row, int col, int depth, int depth2, int depth3) {
            return ${t2}(${(0, s.getSqueezedParams)(a2, f)});
          }
        `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const d = `
        float ${t2}(int row, int col, int depth, int depth2, int depth3) {
          int index = row * ${l} + col * ${c} + depth * ${u2} +
          depth3 * ${o2} + depth2;
          vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
          return sampleTexture(${e2}, uv);
        }
      `;
              return new i.GlslLibRoutine(d, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
            }
            getUnpackedSampler6D(t2, e2, n2) {
              const r2 = n2.unpackedShape, o2 = r2[5], u2 = r2[4] * o2, c = r2[3] * u2, l = r2[2] * c, p = r2[1] * l, { newShape: f, keptDims: d } = (0, a.squeezeShape)(r2);
              if (f.length < r2.length) {
                const o3 = (0, s.squeezeInputShape)(r2, f), a2 = ["row", "col", "depth", "depth2", "depth3", "depth4"], u3 = JSON.parse(JSON.stringify(n2));
                u3.unpackedShape = o3;
                const c2 = `
            ${this.getUnpackedSamplerFromInput(t2, e2, u3).routineBody}
            float ${t2}(int row, int col, int depth,
              int depth2, int depth3, int depth4) {
              return ${t2}(${(0, s.getSqueezedParams)(a2, d)});
            }
          `;
                return new i.GlslLibRoutine(c2, ["coordinates.sampleTexture", "coordinates.uvFromFlat"]);
              }
              const h = `
          float ${t2}(int row, int col, int depth,
            int depth2, int depth3, int depth4) {
            int index = row * ${p} + col * ${l} + depth * ${c} +
            depth2 * ${u2} + depth3 * ${o2} + depth4;
            vec2 uv = uvFromFlat(${n2.width}, ${n2.height}, index);
            return sampleTexture(${e2}, uv);
          }
        `;
              return new i.GlslLibRoutine(h, ["coordinates.uvFromFlat", "coordinates.sampleTexture", "coordinates.coordsToOffset"]);
            }
            toVec() {
              const t2 = this.context.outputTextureLayout, e2 = t2.shape.length, n2 = t2.strides, r2 = t2.width, o2 = t2.height, a2 = [];
              for (let t3 = 0; t3 < e2 - 1; ++t3) a2.push(`
        c[${t3}] = offset / ${n2[t3]};`), a2.push(`
        offset -= c[${t3}] * ${n2[t3]};`);
              a2.push(`
        c[${e2 - 1}] = offset;`);
              const s2 = `
      void toVec(vec2 texCoords, out int c[${e2}]) {
        int offset = coordsToOffset(texCoords, ${r2}, ${o2});
        ${a2.join("")}
      }
      void toVec(int offset, out int c[${e2}]) {
        ${a2.join("")}
      }
    `;
              return { toVec: new i.GlslLibRoutine(s2, ["coordinates.coordsToOffset"]) };
            }
            valueFrom() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const r2 = this.context.inputTextureLayouts[n2], o2 = (r2.unpackedShape.length > 0 ? r2.unpackedShape : r2.shape).length;
                let a2 = `_${e2}`;
                t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, false), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]), a2 += "_T", t2[a2] = new i.GlslLibRoutine(this.getValueFromSingle(e2, o2, r2.width, r2.height, true), [`shapeUtils.indicesToOffset${a2}`, "coordinates.offsetToCoords", "fragcolor.getColorAsFloat"]);
              }), t2;
            }
            getValueFromSingle(t2, e2, n2, r2, i2) {
              let a2 = `_${t2}`;
              return i2 && (a2 += "_T"), `
        float ${a2}(int m[${e2}]) {
          int offset = indicesToOffset${a2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          float value = getColorAsFloat(${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords));
          return value;
        }
        `;
            }
            getPackedValueFrom(t2, e2, n2, r2, i2) {
              let a2 = `_${t2}_Pack`;
              return i2 && (a2 += "_T"), `
        vec4 ${a2}(int m[${e2}]) {
          int offset = indicesToOffset_${t2}(m);
          vec2 coords = offsetToCoords(offset, ${n2}, ${r2});
          return ${(0, o.getGlsl)(this.context.glContext.version).texture2D}(${t2}, coords);
        }
        `;
            }
          }
          e.CoordsGlslLib = u;
        }, 8520: (t, e) => {
          var n;
          Object.defineProperty(e, "__esModule", { value: true }), e.TopologicalSortGlslRoutines = e.GlslLibRoutineNode = e.GlslLibRoutine = e.GlslLib = e.GlslContext = e.FunctionType = void 0, (n = e.FunctionType || (e.FunctionType = {}))[n.ValueBased = 0] = "ValueBased", n[n.Positional = 1] = "Positional", e.GlslContext = class {
            constructor(t2, e2, n2, r) {
              this.glContext = t2, this.programInfo = e2, this.inputTextureLayouts = n2, this.outputTextureLayout = r;
            }
          }, e.GlslLib = class {
            constructor(t2) {
              this.context = t2;
            }
          }, e.GlslLibRoutine = class {
            constructor(t2, e2) {
              this.routineBody = t2, this.dependencies = e2;
            }
          }, e.GlslLibRoutineNode = class {
            constructor(t2, e2, n2) {
              this.name = t2, this.dependencies = n2 || [], e2 && (this.routineBody = e2);
            }
            addDependency(t2) {
              t2 && this.dependencies.push(t2);
            }
          }, e.TopologicalSortGlslRoutines = class {
            static returnOrderedNodes(t2) {
              if (!t2 || 0 === t2.length) return [];
              if (1 === t2.length) return t2;
              const e2 = /* @__PURE__ */ new Set(), n2 = /* @__PURE__ */ new Set(), r = new Array();
              return this.createOrderedNodes(t2, e2, n2, r), r;
            }
            static createOrderedNodes(t2, e2, n2, r) {
              for (let i = 0; i < t2.length; ++i) this.dfsTraverse(t2[i], e2, n2, r);
            }
            static dfsTraverse(t2, e2, n2, r) {
              if (!t2 || n2.has(t2.name)) return;
              if (e2.has(t2.name)) throw new Error("Cyclic dependency detected. Can't topologically sort routines needed for shader.");
              e2.add(t2.name);
              const i = t2.dependencies;
              if (i && i.length > 0) for (let t3 = 0; t3 < i.length; ++t3) this.dfsTraverse(i[t3], e2, n2, r);
              r.push(t2), n2.add(t2.name), e2.delete(t2.name);
            }
          };
        }, 7341: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.EncodingGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.encodeFloat32()), this.decodeFloat32());
            }
            getCustomTypes() {
              return {};
            }
            encodeFloat32() {
              return { encode: new r.GlslLibRoutine("highp vec4 encode(highp float f) {\n        return vec4(f, 0.0, 0.0, 0.0);\n      }\n        ") };
            }
            decodeFloat32() {
              return { decode: new r.GlslLibRoutine("highp float decode(highp vec4 rgba) {\n        return rgba.r;\n      }\n        ") };
            }
            encodeUint8() {
              const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { encode: new r.GlslLibRoutine(`
      highp vec4 encode(highp float f) {
        highp float F = abs(f);
        highp float Sign = step(0.0,-f);
        highp float Exponent = floor(log2(F));
        highp float Mantissa = (exp2(- Exponent) * F);
        Exponent = floor(log2(F) + 127.0) + floor(log2(Mantissa));
        highp vec4 rgba;
        rgba[0] = 128.0 * Sign  + floor(Exponent*exp2(-1.0));
        rgba[1] = 128.0 * mod(Exponent,2.0) + mod(floor(Mantissa*128.0),128.0);
        rgba[2] = floor(mod(floor(Mantissa*exp2(23.0 -8.0)),exp2(8.0)));
        rgba[3] = floor(exp2(23.0)*mod(Mantissa,exp2(-15.0)));
        ${t2}
        rgba = rgba / 255.0; // values need to be normalized to [0,1]
        return rgba;
    }
        `) };
            }
            decodeUint8() {
              const t2 = i.isLittleEndian() ? "rgba.rgba=rgba.abgr;" : "";
              return { decode: new r.GlslLibRoutine(`
        highp float decode(highp vec4 rgba) {
          rgba = rgba * 255.0; // values need to be de-normalized from [0,1] to [0,255]
          ${t2}
          highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;
          highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;
          highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);
          highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));
          return Result;
      }
        `) };
            }
            static isLittleEndian() {
              const t2 = new ArrayBuffer(4), e2 = new Uint32Array(t2), n2 = new Uint8Array(t2);
              if (e2[0] = 3735928559, 239 === n2[0]) return true;
              if (222 === n2[0]) return false;
              throw new Error("unknown endianness");
            }
          }
          e.EncodingGlslLib = i;
        }, 9894: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.FragColorGlslLib = void 0;
          const r = n(8520), i = n(5060);
          class o extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign({}, this.setFragColor()), this.getColorAsFloat());
            }
            getCustomTypes() {
              return {};
            }
            setFragColor() {
              const t2 = (0, i.getGlsl)(this.context.glContext.version);
              return { setFragColor: new r.GlslLibRoutine(`
        void setFragColor(float value) {
            ${t2.output} = encode(value);
        }
        `, ["encoding.encode"]) };
            }
            getColorAsFloat() {
              return { getColorAsFloat: new r.GlslLibRoutine("\n        float getColorAsFloat(vec4 color) {\n            return decode(color);\n        }\n        ", ["encoding.decode"]) };
            }
          }
          e.FragColorGlslLib = o;
        }, 2848: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.replaceInlines = void 0;
          const n = /@inline[\s\n\r]+(\w+)[\s\n\r]+([0-9a-zA-Z_]+)\s*\(([^)]*)\)\s*{(([^}]|[\n\r])*)}/gm;
          e.replaceInlines = function(t2) {
            const e2 = {};
            let r;
            for (; null !== (r = n.exec(t2)); ) {
              const t3 = r[3].split(",").map((t4) => {
                const e3 = t4.trim().split(" ");
                return e3 && 2 === e3.length ? { type: e3[0], name: e3[1] } : null;
              }).filter((t4) => null !== t4);
              e2[r[2]] = { params: t3, body: r[4] };
            }
            for (const n2 in e2) {
              const i = "(\\w+)?\\s+([_0-9a-zA-Z]+)\\s+=\\s+__FUNC__\\((.*)\\)\\s*;".replace("__FUNC__", n2), o = new RegExp(i, "gm");
              for (; null !== (r = o.exec(t2)); ) {
                const i2 = r[1], o2 = r[2], a = r[3].split(","), s = i2 ? `${i2} ${o2};` : "";
                let u = e2[n2].body, c = "";
                e2[n2].params.forEach((t3, e3) => {
                  t3 && (c += `${t3.type} ${t3.name} = ${a[e3]};
`);
                }), u = `${c}
 ${u}`, u = u.replace("return", `${o2} = `);
                const l = `
      ${s}
      {
        ${u}
      }
      `;
                t2 = t2.replace(r[0], l);
              }
            }
            return t2.replace(n, "");
          };
        }, 8879: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.GlslPreprocessor = void 0;
          const r = n(8520), i = n(2848), o = n(5483), a = n(5060);
          e.GlslPreprocessor = class {
            constructor(t2, e2, n2, i2) {
              this.libs = {}, this.glslLibRoutineDependencyGraph = {}, this.context = new r.GlslContext(t2, e2, n2, i2), Object.keys(o.glslRegistry).forEach((t3) => {
                const e3 = new o.glslRegistry[t3](this.context);
                this.libs[t3] = e3;
              });
              const a2 = this.glslLibRoutineDependencyGraph;
              for (const t3 in this.libs) {
                const e3 = this.libs[t3].getFunctions();
                for (const n3 in e3) {
                  const i3 = t3 + "." + n3;
                  let o2;
                  a2[i3] ? (o2 = a2[i3], o2.routineBody = e3[n3].routineBody) : (o2 = new r.GlslLibRoutineNode(i3, e3[n3].routineBody), a2[i3] = o2);
                  const s = e3[n3].dependencies;
                  if (s) for (let t4 = 0; t4 < s.length; ++t4) if (a2[s[t4]]) o2.addDependency(a2[s[t4]]);
                  else {
                    const e4 = new r.GlslLibRoutineNode(s[t4]);
                    a2[s[t4]] = e4, o2.addDependency(e4);
                  }
                }
              }
            }
            preprocess() {
              const t2 = this.context.programInfo;
              let e2 = t2.shaderSource;
              return this.context.programInfo.hasMain || (e2 = `${e2}
      ${(0, a.getDefaultFragShaderMain)(this.context.glContext.version, this.context.outputTextureLayout.shape.length)}`), e2 = (0, i.replaceInlines)(e2), `${(0, a.getFragShaderPreamble)(this.context.glContext.version)}
    ${this.getUniforms(t2.inputNames, t2.variables)}
    ${this.getImports(e2)}
    ${e2}`;
            }
            getImports(t2) {
              const e2 = this.selectGlslLibRoutinesToBeIncluded(t2);
              if (0 === e2.length) return "";
              let n2 = "";
              for (let t3 = 0; t3 < e2.length; ++t3) {
                if (!e2[t3].routineBody) throw new Error(`Missing body for the Glsl Library routine: ${e2[t3].name}`);
                n2 += e2[t3].routineBody + "\n";
              }
              return n2;
            }
            selectGlslLibRoutinesToBeIncluded(t2) {
              const e2 = [];
              return Object.keys(this.glslLibRoutineDependencyGraph).forEach((n2) => {
                const r2 = n2.split(".")[1];
                -1 !== t2.indexOf(r2) && e2.push(this.glslLibRoutineDependencyGraph[n2]);
              }), r.TopologicalSortGlslRoutines.returnOrderedNodes(e2);
            }
            getUniforms(t2, e2) {
              const n2 = [];
              if (t2) for (const e3 of t2) n2.push(`uniform sampler2D ${e3};`);
              if (e2) for (const t3 of e2) n2.push(`uniform ${t3.type} ${t3.name}${t3.arrayLength ? `[${t3.arrayLength}]` : ""};`);
              return n2.join("\n");
            }
          };
        }, 5483: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.glslRegistry = void 0;
          const r = n(5107), i = n(7341), o = n(9894), a = n(2655), s = n(3891);
          e.glslRegistry = { encoding: i.EncodingGlslLib, fragcolor: o.FragColorGlslLib, vec: s.VecGlslLib, shapeUtils: a.ShapeUtilsGlslLib, coordinates: r.CoordsGlslLib };
        }, 2655: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.ShapeUtilsGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, this.bcastIndex()), this.bcastMatmulIndex()), this.offsetToIndices()), this.indicesToOffset()), this.incrementIndices());
            }
            getCustomTypes() {
              return {};
            }
            bcastIndex() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
              return this.context.programInfo.inputNames.forEach((n2, i2) => {
                const o = this.context.inputTextureLayouts[i2].unpackedShape;
                if (o.length <= t2) {
                  const i3 = o.length, a = t2 - i3, s = `bcastIndices_${n2}`;
                  let u = "";
                  for (let t3 = 0; t3 < i3; ++t3) u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                  const c = `
        void ${s} (int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
        }
        `;
                  e2[s] = new r.GlslLibRoutine(c);
                }
              }), e2;
            }
            bcastMatmulIndex() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = {};
              return this.context.programInfo.inputNames.forEach((n2, i2) => {
                const o = this.context.inputTextureLayouts[i2].shape;
                if (!(o.length < 2 || o.length > t2)) {
                  const i3 = o.length, a = t2 - i3, s = `bcastMatmulIndices_${n2}`;
                  let u = "";
                  for (let t3 = 0; t3 < i3 - 2; ++t3) u += `
          realIndices[${t3}] = int( mod(float(bcastedIndices[${a + t3}]), ${o[t3]}.0) );
          `;
                  const c = `
        void ${s}(int bcastedIndices[${t2}], out int realIndices[${i3}]) {
          ${u}
          realIndices[${i3 - 1}] = bcastedIndices[${t2 - 1}];
          realIndices[${i3 - 2}] = bcastedIndices[${t2 - 2}];
        }
        `;
                  e2[s] = new r.GlslLibRoutine(c);
                }
              }), e2;
            }
            indicesToOffset() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                let u = `indicesToOffset_${e2}`;
                t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a)), u = `indicesToOffset_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.indexToOffsetSingle(u, s, a.slice().reverse()));
              }), t2;
            }
            static indexToOffsetSingle(t2, e2, n2) {
              let r2 = "";
              for (let t3 = e2 - 1; t3 >= 0; --t3) r2 += `
        offset += indices[${t3}] * ${n2[t3]};
        `;
              return `
      int ${t2}(int indices[${e2}]) {
        int offset = 0;
        ${r2}
        return offset;
      }
      `;
            }
            offsetToIndices() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const o = this.context.inputTextureLayouts[n2].shape, a = this.context.inputTextureLayouts[n2].strides, s = o.length;
                let u = `offsetToIndices_${e2}`;
                t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a)), u = `offsetToIndices_${e2}_T`, t2[u] = new r.GlslLibRoutine(i.offsetToIndicesSingle(u, s, a.slice().reverse()));
              }), t2;
            }
            static offsetToIndicesSingle(t2, e2, n2) {
              const r2 = [];
              for (let t3 = 0; t3 < e2 - 1; ++t3) r2.push(`
      indices[${t3}] = offset / ${n2[t3]};`), r2.push(`
        offset -= indices[${t3}] * ${n2[t3]};`);
              return r2.push(`
      indices[${e2 - 1}] = offset;`), `
      void ${t2}(int offset, out int indices[${e2}]) {
        ${r2.join("")}
      }
      `;
            }
            incrementIndices() {
              const t2 = {};
              return this.context.programInfo.inputNames.forEach((e2, n2) => {
                const i2 = this.context.inputTextureLayouts[n2].shape, o = i2.length, a = `incrementIndices_${e2}`;
                let s = "";
                for (let t3 = 0; t3 < o; ++t3) s += `
        shape[${t3}] = ${i2[t3]};`;
                const u = `
        void ${a}(int axis, out int indices[${o}]) {
          int shape[${o}];
          ${s};
          for(int i = ${o} -1 ; i >= 0; --i) {
            if(i > axis) continue;
            indices[i] += 1;
            if(indices[i] < shape[i]) {
              break;
            }
            indices[i] = 0;
          }
        }
        `;
                t2[a] = new r.GlslLibRoutine(u);
              }), t2;
            }
          }
          e.ShapeUtilsGlslLib = i;
        }, 5060: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.getDefaultFragShaderMain = e.getFragShaderPreamble = e.getVertexShaderSource = e.getGlsl = void 0;
          const n = { version: "", attribute: "attribute", varyingVertex: "varying", varyingFrag: "varying", texture2D: "texture2D", output: "gl_FragColor", outputDeclaration: "" }, r = { version: "#version 300 es", attribute: "in", varyingVertex: "out", varyingFrag: "in", texture2D: "texture", output: "outputColor", outputDeclaration: "out vec4 outputColor;" };
          function i(t2) {
            return 1 === t2 ? n : r;
          }
          e.getGlsl = i, e.getVertexShaderSource = function(t2) {
            const e2 = i(t2);
            return `${e2.version}
      precision highp float;
      ${e2.attribute} vec3 position;
      ${e2.attribute} vec2 textureCoord;

      ${e2.varyingVertex} vec2 TexCoords;

      void main()
      {
          gl_Position = vec4(position, 1.0);
          TexCoords = textureCoord;
      }`;
          }, e.getFragShaderPreamble = function(t2) {
            const e2 = i(t2);
            return `${e2.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${e2.varyingFrag} vec2 TexCoords;
    ${e2.outputDeclaration}
    const vec2 halfCR = vec2(0.5, 0.5);

    // Custom vector types to handle higher dimenalities.
    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    `;
          }, e.getDefaultFragShaderMain = function(t2, e2) {
            return `
  void main() {
    int indices[${e2}];
    toVec(TexCoords, indices);
    vec4 result = vec4(process(indices));
    ${i(t2).output} = result;
  }
  `;
          };
        }, 3891: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.VecGlslLib = void 0;
          const r = n(8520);
          class i extends r.GlslLib {
            constructor(t2) {
              super(t2);
            }
            getCustomTypes() {
              return {};
            }
            getFunctions() {
              return Object.assign(Object.assign(Object.assign(Object.assign({}, this.binaryVecFunctions()), this.copyVec()), this.setVecItem()), this.getVecItem());
            }
            binaryVecFunctions() {
              const t2 = this.context.outputTextureLayout.shape.length, e2 = { add: "+=", sub: "-=", mul: "*=", div: "/=" }, n2 = {};
              for (const i2 in e2) {
                const o = `${i2}Vec`;
                let a = "";
                for (let n3 = 0; n3 < t2; ++n3) a += `
          dest[${n3}] ${e2[i2]} src[${n3}];
          `;
                const s = `
        void ${o}(int src[${t2}], out int dest[${t2}]) {
          ${a}
        }
        `;
                n2[o] = new r.GlslLibRoutine(s);
              }
              return n2;
            }
            copyVec() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = "";
              for (let n3 = 0; n3 < t2; ++n3) e2 += `
        dest[${n3}] = src[${n3}];
        `;
              const n2 = `
      void copyVec(int src[${t2}], out int dest[${t2}]) {
        ${e2}
      }
      `;
              return { copyVec: new r.GlslLibRoutine(n2) };
            }
            setVecItem() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = `
        if(index < 0)
            index =${t2} + index;
        if (index == 0)
            m[0] = value;
        `;
              for (let n3 = 1; n3 < t2 - 1; ++n3) e2 += `
        else if (index == ${n3})
            m[${n3}] = value;
            `;
              e2 += `
        else
            m[${t2 - 1}] = value;
        `;
              const n2 = `
      void setVecItem(out int m[${t2}], int index, int value) {
        ${e2}
      }
        `;
              return { setVecItem: new r.GlslLibRoutine(n2) };
            }
            getVecItem() {
              const t2 = this.context.outputTextureLayout.shape.length;
              let e2 = `
        if(index < 0)
            index = ${t2} + index;
        if (index == 0)
            return m[0];
      `;
              for (let n3 = 1; n3 < t2 - 1; ++n3) e2 += `
        else if (index == ${n3})
            return m[${n3}];
      `;
              e2 += `
        else
            return m[${t2 - 1}];
        `;
              const n2 = `
      int getVecItem(int m[${t2}], int index) {
        ${e2}
      }
    `;
              return { getVecItem: new r.GlslLibRoutine(n2) };
            }
          }
          e.VecGlslLib = i;
        }, 8316: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLInferenceHandler = void 0;
          const r = n(6231), i = n(9162), o = n(2517), a = n(2403), s = n(7019), u = n(8710), c = n(5611), l = n(4057), p = n(2039);
          e.WebGLInferenceHandler = class {
            constructor(t2) {
              this.session = t2, this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            calculateTextureWidthAndHeight(t2, e2) {
              return (0, l.calculateTextureWidthAndHeight)(this.session.layoutStrategy, t2, e2);
            }
            executeProgram(t2, e2) {
              if (e2.length < t2.inputNames.length) throw new Error(`Input size mustn't be less than ${t2.inputNames.length}.`);
              if (t2.inputNames.length !== t2.inputTypes.length) throw new Error("input names size does not match input types");
              const n2 = [];
              for (let r3 = 0; r3 < t2.inputNames.length; ++r3) n2[r3] = this.getOrCreateTextureData(e2[r3], t2.inputTypes[r3]);
              const r2 = ((t3, e3) => {
                const n3 = e3.map((t4) => `${t4.unpackedShape.join(",")};${t4.width}x${t4.height}`).join("_");
                let r3 = t3.name;
                return t3.cacheHint && (r3 += "[" + t3.cacheHint + "]"), r3 += ":" + n3, r3;
              })(t2, n2);
              let i2 = this.session.programManager.getArtifact(r2);
              const o2 = i2 ? i2.programInfo : "function" == typeof t2.get ? t2.get() : t2, a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2.output.dims, o2.output.textureType), s2 = this.createTextureData(a2, o2.output.type);
              return i2 || (i2 = this.session.programManager.build(o2, n2, s2), this.session.programManager.setArtifact(r2, i2)), this.runProgram(i2, n2, s2), s2;
            }
            run(t2, e2) {
              return this.executeProgram(t2, e2).tensor;
            }
            runProgram(t2, e2, n2) {
              for (let n3 = 0; n3 < e2.length; ++n3) if (!!e2[n3].isPacked != (t2.programInfo.inputTypes[n3] === p.TextureType.packed)) throw new Error(`input[${n3}] property packed inconsistent`);
              if (!!n2.isPacked != (t2.programInfo.output.textureType === p.TextureType.packed)) throw new Error("output property packed inconsistent");
              this.session.programManager.run(t2, e2, n2);
            }
            getOrCreateTextureData(t2, e2) {
              let n2 = this.getTextureData(t2.dataId, e2 === p.TextureType.packed);
              if (!n2 && (n2 = this.getTextureData(t2.dataId, e2 !== p.TextureType.packed), n2)) return e2 === p.TextureType.packed ? this.pack(n2) : this.unpack(n2);
              if (!n2) {
                const r2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, t2.dims, e2);
                if (e2 === p.TextureType.packedLastDimension) {
                  const n3 = 1, r3 = 4, i2 = t2.dims;
                  if (4 === i2.length) {
                    const o2 = [i2[0], Math.ceil(i2[1] * i2[2] * i2[3] / r3)], a2 = (0, l.createTextureLayoutFromTextureType)(this.session.layoutStrategy, o2, e2);
                    let s2 = t2.numberData;
                    if (i2[1] * i2[2] * i2[3] % r3 != 0) {
                      const e3 = i2[0], o3 = i2[1] * i2[2] * i2[3], a3 = Math.ceil(o3 * n3 / r3) * r3;
                      s2 = new Float32Array(e3 * a3);
                      for (let r4 = 0; r4 < e3; ++r4) {
                        const e4 = r4 * o3, i3 = r4 * a3 + r4 % n3 * o3;
                        s2.set(t2.numberData.subarray(e4, e4 + o3), i3);
                      }
                    }
                    return this.createTextureData(a2, t2.type, s2, t2, 1);
                  }
                }
                if (e2 === p.TextureType.packed) {
                  const e3 = (0, l.createTextureLayoutFromShape)(this.session.layoutStrategy, t2.dims, 1, [], { reverseWH: true }), r3 = this.createTextureData(e3, t2.type, t2.numberData, t2, 1);
                  n2 = this.pack(r3);
                } else n2 = this.createTextureData(r2, t2.type, t2.numberData, t2, 1);
              }
              return n2;
            }
            createTextureDataFromLayoutBindTensor(t2, e2, n2, r2) {
              return this.createTextureData(t2, e2, n2, r2, 1);
            }
            createTextureData(t2, e2, n2, i2, o2) {
              r.Logger.verbose("InferenceHandler", `Creating TextureData: layout:[${JSON.stringify(t2)}]`);
              const a2 = this.session.textureManager.createTextureFromLayout(e2, t2, n2, o2);
              return this.createTextureDataFromTexture(t2, e2, a2, i2);
            }
            reshapeUnpacked(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked), r2 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2 };
              return this.createTextureDataFromTexture(r2, t2.type, n2.texture).tensor;
            }
            reshapePacked(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.packed);
              if ((0, s.isReshapeCheap)(t2.dims, e2)) {
                const r3 = { channels: n2.channels, height: n2.height, width: n2.width, shape: 0 !== e2.length ? e2 : [1], strides: o.ShapeUtil.computeStrides(e2), unpackedShape: e2, isPacked: true };
                return this.createTextureDataFromTexture(r3, t2.type, n2.texture).tensor;
              }
              const r2 = (0, s.processDims3D)(t2.dims), i2 = (0, s.processDims3D)(e2), a2 = this.reshapePacked(t2, r2), u2 = this.run((0, s.createPackedReshape3DProgramInfoLoader)(this, a2, i2), [a2]);
              return this.reshapePacked(u2, e2);
            }
            cast(t2, e2) {
              const n2 = this.getOrCreateTextureData(t2, p.TextureType.unpacked);
              return this.createTextureDataFromTexture(n2, e2, n2.texture).tensor;
            }
            createTextureDataFromTexture(t2, e2, n2, r2, o2) {
              const a2 = Object.assign(Object.assign({}, t2), { tensor: r2 || new i.Tensor(t2.unpackedShape, e2, (t3) => this.readTexture(a2), (t3) => __async(this, null, function* () {
                return this.readTextureAsync(a2);
              }), void 0, o2), texture: n2 });
              return this.setTextureData(a2.tensor.dataId, a2, t2.isPacked), a2;
            }
            getTextureData(t2, e2 = false) {
              return this.session.isInitializer(t2) ? this.session.getTextureData(t2, e2) : e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
            }
            setTextureData(t2, e2, n2 = false) {
              this.session.isInitializer(t2) ? this.session.setTextureData(t2, e2, n2) : (n2 ? this.packedTextureDataCache : this.unpackedTextureDataCache).set(t2, e2);
            }
            isTextureLayoutCached(t2, e2 = false) {
              return !!this.getTextureData(t2.dataId, e2);
            }
            dispose() {
              this.session.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.session.textureManager.releaseTexture(t2)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            readTexture(t2) {
              return t2.isPacked ? this.readTexture(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTexture(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
            }
            readTextureAsync(t2) {
              return __async(this, null, function* () {
                return t2.isPacked ? this.readTextureAsync(this.unpack(t2)) : this.session.backend.glContext.isFloat32DownloadSupported ? this.session.textureManager.readTextureAsync(t2, t2.tensor.type, t2.channels) : this.session.textureManager.readUint8TextureAsFloat((0, u.encodeAsUint8)(this, t2));
              });
            }
            pack(t2) {
              return this.executeProgram((0, a.createPackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
            }
            unpack(t2) {
              return this.executeProgram((0, c.createUnpackProgramInfoLoader)(this, t2.tensor), [t2.tensor]);
            }
          };
        }, 1640: function(t, e, n) {
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule) return t2;
            var e2 = {};
            if (null != t2) for (var n2 in t2) "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.WEBGL_OP_RESOLVE_RULES = void 0;
          const a = n(2898), s = o(n(7839)), u = n(4196), c = n(2069), l = n(8138), p = n(9663), f = n(5193), d = n(7992), h = n(1253), g = n(4776), b = n(6572), m = n(3346), y = n(5623), _ = n(2870), v = n(2143), w = n(4939), x = n(718), T = n(2268), S = n(8117), O = n(2278), A = n(5524), E = n(5975), I = n(3933), P = n(6558), D = n(5723), $ = n(3738), k = o(n(4909)), C = n(8428), F = n(9793);
          e.WEBGL_OP_RESOLVE_RULES = [["Abs", "", "6+", k.abs], ["Acos", "", "7+", k.acos], ["Add", "", "7+", s.add], ["And", "", "7+", s.and], ["Asin", "", "7+", k.asin], ["Atan", "", "7+", k.atan], ["AveragePool", "", "7+", v.averagePool, v.parseAveragePoolAttributes], ["BatchNormalization", "", "7+", a.batchNormalization, a.parseBatchNormalizationAttributes], ["Cast", "", "6+", u.cast, u.parseCastAttributes], ["Ceil", "", "6+", k.ceil], ["Clip", "", "6-10", k.clip, k.parseClipAttributes], ["Clip", "", "11+", k.clipV11], ["Concat", "", "4+", c.concat, c.parseConcatAttributes], ["Conv", "", "1+", l.conv, l.parseConvAttributes], ["ConvTranspose", "", "1+", p.convTranspose, p.parseConvTransposeAttributes], ["Cos", "", "7+", k.cos], ["Div", "", "7+", s.div], ["Dropout", "", "7+", k.identity], ["DepthToSpace", "", "1+", f.depthToSpace, f.parseDepthToSpaceAttributes], ["Equal", "", "7+", s.equal], ["Elu", "", "6+", k.elu, k.parseEluAttributes], ["Exp", "", "6+", k.exp], ["Flatten", "", "1+", d.flatten, d.parseFlattenAttributes], ["Floor", "", "6+", k.floor], ["FusedConv", "com.microsoft", "1+", l.conv, l.parseConvAttributes], ["Gather", "", "1+", h.gather, h.parseGatherAttributes], ["Gemm", "", "7-10", g.gemm, g.parseGemmAttributesV7], ["Gemm", "", "11+", g.gemm, g.parseGemmAttributesV11], ["GlobalAveragePool", "", "1+", v.globalAveragePool, v.parseGlobalAveragePoolAttributes], ["GlobalMaxPool", "", "1+", v.globalMaxPool], ["Greater", "", "7+", s.greater], ["Identity", "", "1+", k.identity], ["ImageScaler", "", "1+", b.imageScaler, b.parseImageScalerAttributes], ["InstanceNormalization", "", "6+", m.instanceNormalization, m.parseInstanceNormalizationAttributes], ["LeakyRelu", "", "6+", k.leakyRelu, k.parseLeakyReluAttributes], ["Less", "", "7+", s.less], ["Log", "", "6+", k.log], ["MatMul", "", "1+", y.matMul, y.parseMatMulAttributes], ["MaxPool", "", "1+", v.maxPool, v.parseMaxPoolAttributes], ["Mul", "", "7+", s.mul], ["Neg", "", "6+", k.neg], ["Not", "", "1+", k.not], ["Or", "", "7+", s.or], ["Pad", "", "2-10", _.padV2, _.parsePadAttributesV2], ["Pad", "", "11+", _.padV11, _.parsePadAttributesV11], ["Pow", "", "7+", s.pow], ["PRelu", "", "7+", s.pRelu], ["ReduceLogSum", "", "1+", w.reduceLogSum, w.parseReduceAttributes], ["ReduceMax", "", "1+", w.reduceMax, w.parseReduceAttributes], ["ReduceMean", "", "1+", w.reduceMean, w.parseReduceAttributes], ["ReduceMin", "", "1+", w.reduceMin, w.parseReduceAttributes], ["ReduceProd", "", "1+", w.reduceProd, w.parseReduceAttributes], ["ReduceSum", "", "1-12", w.reduceSum, w.parseReduceAttributes], ["ReduceSumSquare", "", "1+", w.reduceLogSumSquare, w.parseReduceAttributes], ["Relu", "", "6+", k.relu], ["Reshape", "", "5+", x.reshape], ["Resize", "", "10", T.resize, T.parseResizeAttributesV10], ["Resize", "", "11+", T.resize, T.parseResizeAttributesV11], ["Shape", "", "1+", S.shape], ["Sigmoid", "", "6+", k.sigmoid], ["Sin", "", "7+", k.sin], ["Slice", "", "10+", O.sliceV10], ["Slice", "", "1-9", O.slice, O.parseSliceAttributes], ["Softmax", "", "1-12", A.softmax, A.parseSoftmaxAttributes], ["Softmax", "", "13+", A.softmaxV13, A.parseSoftmaxAttributesV13], ["Split", "", "2-12", E.split, E.parseSplitAttributes], ["Sqrt", "", "6+", k.sqrt], ["Squeeze", "", "1-12", I.squeeze, I.parseSqueezeAttributes], ["Squeeze", "", "13+", I.squeezeV13], ["Sub", "", "7+", s.sub], ["Sum", "", "6+", P.sum], ["Tan", "", "7+", k.tan], ["Tanh", "", "6+", k.tanh], ["Tile", "", "6+", D.tile], ["Transpose", "", "1+", $.transpose, $.parseTransposeAttributes], ["Upsample", "", "7-8", F.upsample, F.parseUpsampleAttributesV7], ["Upsample", "", "9", F.upsample, F.parseUpsampleAttributesV9], ["Unsqueeze", "", "1-12", C.unsqueeze, C.parseUnsqueezeAttributes], ["Unsqueeze", "", "13+", C.unsqueezeV13], ["Xor", "", "7+", s.xor]];
        }, 2898: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseBatchNormalizationAttributes = e.batchNormalization = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = { name: "BatchNormalization", inputNames: ["A", "Scale", "B", "Mean", "Variance"], inputTypes: [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] };
          e.batchNormalization = (t2, e2, n2) => (u(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2, n2) }), e2)]), e.parseBatchNormalizationAttributes = (t2) => {
            const e2 = t2.attributes.getFloat("epsilon", 1e-5), n2 = t2.attributes.getFloat("momentum", 0.9), i2 = t2.attributes.getInt("spatial", 1);
            return (0, r.createAttributeWithCacheKey)({ epsilon: e2, momentum: n2, spatial: i2 });
          };
          const s = (t2, e2, n2) => {
            const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), s2 = e2[0].dims.length, [u2, c] = t2.calculateTextureWidthAndHeight(e2[1].dims, o.TextureType.unpacked), l = `
  float process(int[${s2}] indices) {
    vec2 position = offsetToCoords(indices[1], ${u2}, ${c});
    float scale = getColorAsFloat(${r2.texture2D}(Scale, position));
    float mean = getColorAsFloat(${r2.texture2D}(Mean, position));
    float variance = getColorAsFloat(${r2.texture2D}(Variance, position));
    float b = getColorAsFloat(${r2.texture2D}(B, position));

    return scale * ( (_A(indices) - mean) / sqrt(variance + float(${n2.epsilon})) ) + b;
  }`;
            return Object.assign(Object.assign({}, a), { output: { dims: e2[0].dims, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: l });
          }, u = (t2) => {
            if (!t2 || 5 !== t2.length) throw new Error("BatchNormalization requires 5 inputs.");
            const e2 = t2[0], n2 = t2[1], r2 = t2[2], i2 = t2[3], o2 = t2[4];
            if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length || 1 !== i2.dims.length || 1 !== o2.dims.length) throw new Error("invalid input shape.");
            if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1] || i2.dims[0] !== e2.dims[1] || o2.dims[0] !== e2.dims[1]) throw new Error("invalid input shape.");
            if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type || "float32" !== i2.type && "float64" !== i2.type || "float32" !== o2.type && "float64" !== o2.type) throw new Error("invalid input tensor types.");
          };
        }, 7839: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.xor = e.sub = e.pRelu = e.pow = e.or = e.mul = e.less = e.greater = e.equal = e.div = e.and = e.add = e.glslPRelu = e.glslPow = e.glslXor = e.glslOr = e.glslAnd = e.glslLess = e.glslGreater = e.glslEqual = e.glslSub = e.glslMul = e.glslDiv = e.glslAdd = void 0;
          const r = n(2517), i = n(8520), o = n(5060), a = n(2039);
          function s() {
            const t2 = "add_";
            return { body: `
  float ${t2}(float a, float b) {
    return a + b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 + v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function u() {
            const t2 = "div_";
            return { body: `
  float ${t2}(float a, float b) {
    return a / b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 / v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function c() {
            const t2 = "mul_";
            return { body: `
  float ${t2}(float a, float b) {
    return a * b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 * v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function l() {
            const t2 = "sub_";
            return { body: `
  float ${t2}(float a, float b) {
    return a - b;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return v1 - v2;
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function p() {
            const t2 = "equal_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a == b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(equal(v1, v2));
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function f() {
            const t2 = "greater_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a > b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r > v2.r ,
      v1.g > v2.g,
      v1.b > v2.b,
      v1.a > v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function d() {
            const t2 = "less_";
            return { body: `
  float ${t2}(float a, float b) {
    return float(a < b);
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4( v1.r < v2.r ,
                v1.g < v2.g,
                v1.b < v2.b,
                v1.a < v2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function h() {
            const t2 = "and_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) && bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r && b2.r ,
                b1.g && b2.g,
                b1.b && b2.b,
                b1.a && b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function g() {
            const t2 = "or_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) || bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r || b2.r ,
                b1.g || b2.g,
                b1.b || b2.b,
                b1.a || b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function b() {
            const t2 = "xor_";
            return { body: `
  float ${t2}(float a, float b) {
    return float( bool(a) ^^ bool(b) );
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    bvec4 b1 = bvec4(v1);
    bvec4 b2 = bvec4(v2);
    return vec4( b1.r ^^ b2.r ,
                b1.g ^^ b2.g,
                b1.b ^^ b2.b,
                b1.a ^^ b2.a );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          function m() {
            return function(t2) {
              const e2 = `${t2}_`;
              return { body: `
  float ${e2}(float a, float b) {
    return ${t2}(a, b);
  }
  vec4 ${e2}(vec4 v1, vec4 v2) {
    return ${t2}(v1, v2);
  }
  `, name: e2, type: i.FunctionType.ValueBased };
            }("pow");
          }
          function y() {
            const t2 = "prelu_";
            return { body: `
  float ${t2}(float a, float b) {
    return a < 0.0 ? a * b: a;
  }
  vec4 ${t2}(vec4 v1, vec4 v2) {
    return vec4(
      v1.r < 0.0 ? v1.r * v2.r: v1.r,
      v1.g < 0.0 ? v1.g * v2.g: v1.g,
      v1.b < 0.0 ? v1.b * v2.b: v1.b,
      v1.a < 0.0 ? v1.a * v2.a: v1.a
      );
  }
  `, name: t2, type: i.FunctionType.ValueBased };
          }
          e.glslAdd = s, e.glslDiv = u, e.glslMul = c, e.glslSub = l, e.glslEqual = p, e.glslGreater = f, e.glslLess = d, e.glslAnd = h, e.glslOr = g, e.glslXor = b, e.glslPow = m, e.glslPRelu = y;
          const _ = (t2, e2, n2, r2 = e2[0].type, i2) => {
            const o2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [o2, o2], cacheHint: i2, get: () => v(t2, e2, n2, r2) };
          }, v = (t2, e2, n2, i2 = e2[0].type) => {
            const s2 = t2.session.pack ? a.TextureType.packed : a.TextureType.unpacked, u2 = !r.ShapeUtil.areEqual(e2[0].dims, e2[1].dims);
            let c2 = e2[0].dims;
            const l2 = t2.session.pack;
            if (u2) {
              const a2 = r.BroadcastUtil.calcShape(e2[0].dims, e2[1].dims, false);
              if (!a2) throw new Error("Can't perform binary op on the given tensors");
              c2 = a2;
              const u3 = c2.length, p3 = 0 !== e2[0].dims.length ? e2[0].dims.length : 1, f3 = 0 !== e2[1].dims.length ? e2[1].dims.length : 1, d2 = 0 !== e2[0].dims.length ? "bcastIndices_A(indices, aindices);" : "aindices[0] = 0;", h2 = 0 !== e2[1].dims.length ? "bcastIndices_B(indices, bindices);" : "bindices[0] = 0;", g2 = (0, o.getGlsl)(t2.session.backend.glContext.version), b2 = l2 ? `
      ${n2.body}
      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();
        vec4 result = ${n2.name}(a, b);
        ${g2.output} = result;
      }` : `
      ${n2.body}
      float process(int indices[${u3}]) {
        int aindices[${p3}];
        int bindices[${f3}];
        ${d2}
        ${h2}
        return ${n2.name}(_A(aindices), _B(bindices));
      }`;
              return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: c2, type: i2, textureType: s2 }, shaderSource: b2, hasMain: l2 };
            }
            const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
    ${n2.body}
    void main() {
      vec4 v1 = ${p2.texture2D}(A, TexCoords);
      vec4 v2 = ${p2.texture2D}(B, TexCoords);
      vec4 result = ${n2.name}(v1, v2);
      ${p2.output} = result;
    }
    `;
            return { name: n2.name, inputNames: ["A", "B"], inputTypes: [s2, s2], output: { dims: e2[0].dims, type: i2, textureType: s2 }, shaderSource: f2, hasMain: true };
          };
          e.add = (t2, e2) => [t2.run(_(t2, e2, s()), e2)], e.and = (t2, e2) => [t2.run(_(t2, e2, h(), "bool"), e2)], e.div = (t2, e2) => [t2.run(_(t2, e2, u()), e2)], e.equal = (t2, e2) => [t2.run(_(t2, e2, p(), "bool"), e2)], e.greater = (t2, e2) => [t2.run(_(t2, e2, f(), "bool"), e2)], e.less = (t2, e2) => [t2.run(_(t2, e2, d(), "bool"), e2)], e.mul = (t2, e2) => [t2.run(_(t2, e2, c()), e2)], e.or = (t2, e2) => [t2.run(_(t2, e2, g(), "bool"), e2)], e.pow = (t2, e2) => [t2.run(_(t2, e2, m()), e2)], e.pRelu = (t2, e2) => [t2.run(_(t2, e2, y()), e2)], e.sub = (t2, e2) => [t2.run(_(t2, e2, l()), e2)], e.xor = (t2, e2) => [t2.run(_(t2, e2, b(), "bool"), e2)];
        }, 4196: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseCastAttributes = e.cast = void 0;
          const r = n(2517);
          e.cast = (t2, e2, n2) => (i(e2), [t2.cast(e2[0], n2)]), e.parseCastAttributes = (t2) => r.ProtoUtil.tensorDataTypeFromProto(t2.attributes.getInt("to"));
          const i = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Cast requires 1 input.");
            if ("string" === t2[0].type) throw new Error("Invalid input type.");
          };
        }, 1163: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedConcatProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827);
          e.createPackedConcatProgramInfoLoader = (t2, e2, n2) => {
            const u = (c = e2.length, l = n2.cacheKey, { name: "Concat (packed)", inputNames: Array.from({ length: c }, (t3, e3) => `X${e3}`), inputTypes: Array(c).fill(i.TextureType.packed), cacheHint: l });
            var c, l;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
              const c2 = n3[0].dims.slice();
              if (u2 >= c2.length || u2 < -1 * c2.length) throw new Error("axis specified for concat doesn't match input dimensionality");
              u2 < 0 && (u2 = c2.length + u2);
              const l2 = c2.slice(0);
              for (let t4 = 1; t4 < n3.length; t4++) {
                const e4 = n3[t4].dims.slice();
                for (let t5 = 0; t5 < c2.length; t5++) if (t5 === u2) l2[u2] += e4[t5];
                else if (c2[t5] !== e4[t5]) throw new Error("non concat dimensions must match");
              }
              const p = l2.length, f = (0, a.getChannels)("coords", p), d = (0, o.getCoordsDataType)(p), h = (0, a.unpackFromChannel)(), g = n3.map((t4) => t4.dims), b = (0, o.getGlChannels)(p), m = new Array(g.length - 1);
              m[0] = g[0][u2];
              for (let t4 = 1; t4 < m.length; t4++) m[t4] = m[t4 - 1] + g[t4][u2];
              const y = b[u2], _ = b.slice(-2), v = b.join();
              let w = `if (${y} < ${m[0]}) {
        return getChannel(
            getX0(${v}), vec2(${_.join()}));
        }`;
              for (let t4 = 1; t4 < m.length; t4++) {
                const e4 = m[t4 - 1];
                w += `
            if (${y} < ${m[t4]}  && ${y} >= ${m[t4 - 1]}) {
              return getChannel(
                getX${t4}(${s(b, y, e4)}),
                vec2(${s(_, y, e4)}));
            }`;
              }
              const x = m.length, T = m[m.length - 1];
              w += `
            return getChannel(
              getX${x}(${s(b, y, T)}),
              vec2(${s(_, y, T)}));`;
              const S = (0, r.getGlsl)(t3.session.backend.glContext.version), O = `
          ${h}
          float getValue(${b.map((t4) => "int " + t4)}) {
            ${w}
          }

          void main() {
            ${d} coords = getOutputCoords();
            int lastDim = coords.${b[p - 1]};
            coords.${b[p - 1]} = coords.${b[p - 2]};
            coords.${b[p - 2]} = lastDim;

            vec4 result = vec4(getValue(${f}), 0., 0., 0.);

            ${f[p - 1]} = ${f[p - 1]} + 1;
            if (${f[p - 1]} < ${l2[p - 1]}) {
              result.g = getValue(${f});
            }

            ${f[p - 2]} = ${f[p - 2]} + 1;
            if (${f[p - 2]} < ${l2[p - 2]}) {
              result.a = getValue(${f});
            }

            ${f[p - 1]} = ${f[p - 1]} - 1;
            if (${f[p - 2]} < ${l2[p - 2]} &&
                ${f[p - 1]} < ${l2[p - 1]}) {
              result.b = getValue(${f});
            }
            ${S.output} = result;
          }
        `;
              return Object.assign(Object.assign({}, e3), { output: { dims: l2, type: n3[0].type, textureType: i.TextureType.packed }, shaderSource: O, hasMain: true });
            })(t2, u, e2, n2.axis) });
          };
          const s = (t2, e2, n2) => {
            const r2 = t2.indexOf(e2);
            return t2.map((t3, e3) => e3 === r2 ? `${t3} - ${n2}` : t3).join();
          };
        }, 2069: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConcatAttributes = e.concat = void 0;
          const r = n(246), i = n(2039), o = n(1163);
          e.concat = (t2, e2, n2) => (p(e2), t2.session.pack && e2[0].dims.length > 1 ? [t2.run((0, o.createPackedConcatProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(a(t2, e2, n2), e2)]);
          const a = (t2, e2, n2) => {
            const r2 = (o2 = e2.length, a2 = n2.cacheKey, { name: "Concat", inputNames: Array.from({ length: o2 }, (t3, e3) => `X${e3}`), inputTypes: Array(o2).fill(i.TextureType.unpacked), cacheHint: a2 });
            var o2, a2;
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const o3 = n3[0].dims.slice();
              if (r3 >= o3.length || r3 < -1 * o3.length) throw new Error("axis specified for concat doesn't match input dimensionality");
              r3 < 0 && (r3 = o3.length + r3);
              const a3 = o3.slice(0);
              for (let t4 = 1; t4 < n3.length; t4++) {
                const e4 = n3[t4].dims.slice();
                for (let t5 = 0; t5 < o3.length; t5++) if (t5 === r3) a3[r3] += e4[t5];
                else if (o3[t5] !== e4[t5]) throw new Error("non concat dimensions must match");
              }
              const p2 = a3.length, f = new Array(n3.length);
              let d = 0;
              for (let t4 = 0; t4 < f.length; ++t4) d += n3[t4].dims[r3], f[t4] = d;
              let h = "";
              h = n3.length < 5 ? s(f) : u(f);
              const g = `
        ${c(n3.length, p2)}
        ${l(f)}
        ${h}
        float process(int indices[${p2}]) {
          int textureIndex = getTextureWhereDataResides (indices[${r3}]);

          if(textureIndex != 0) {
            indices[${r3}] = indices[${r3}] - int(getSizeInConcatAxisValueFromIndex(textureIndex-int(1)));
          }

          return fetchDataFromCorrectTexture(textureIndex, indices);
        }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: a3, type: n3[0].type, textureType: i.TextureType.unpacked }, shaderSource: g });
            })(0, r2, e2, n2.axis) });
          }, s = (t2) => `int getTextureWhereDataResides(int index) {
      ${t2.map((t3, e2) => `if(index<${t3}) {return ${e2};}
`).join("")}
    }`, u = (t2) => s(t2), c = (t2, e2) => {
            const n2 = [`float fetchDataFromCorrectTexture(int textureIndex, int indices[${e2}]) {`];
            for (let e3 = 0; e3 < t2; ++e3) 0 === e3 ? n2.push(`	if (textureIndex == ${e3}) { return _X${e3}(indices); }`) : e3 === t2 - 1 ? n2.push(`	else { return _X${e3}(indices); }`) : n2.push(`	else if (textureIndex == ${e3}) { return _X${e3}(indices); }`);
            return n2.push("	}"), n2.join("\n");
          }, l = (t2) => {
            const e2 = ["int getSizeInConcatAxisValueFromIndex(int index) {"];
            for (let n2 = 0; n2 < t2.length; ++n2) 0 === n2 ? e2.push(`	if (index == ${n2}) { return ${t2[n2]}; }`) : n2 === t2.length - 1 ? e2.push(`	else { return ${t2[n2]}; }`) : e2.push(`	else if (index == ${n2}) { return ${t2[n2]}; }`);
            return e2.push("	}"), e2.join("\n");
          };
          e.parseConcatAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis") });
          const p = (t2) => {
            if (!t2 || t2.length < 1) throw new Error("too few inputs");
            const e2 = t2[0].type, n2 = t2[0].dims.length;
            if ("string" === e2) throw new Error("string tensor is not supported yet");
            for (const r2 of t2) {
              if (r2.type !== e2) throw new Error("input tensors should be one type");
              if (r2.dims.length !== n2) throw new Error("input tensors should have the same shape");
            }
          };
        }, 4770: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackedGroupedConvProgramInfoLoader = void 0;
          const r = n(6231), i = n(5060), o = n(2039), a = n(8138), s = n(2823);
          e.createUnpackedGroupedConvProgramInfoLoader = (t2, e2, n2) => {
            const u = (c = e2.length > 2, l = n2.cacheKey, { name: "GroupedConv", inputNames: c ? ["X", "W", "Bias"] : ["X", "W"], inputTypes: c ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: l });
            var c, l;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, u2) => {
              const c2 = e3.length > 2 ? "value += getBias(output_channel);" : "", l2 = e3[0].dims.slice(), p = e3[1].dims.slice(), f = p[0] / u2.group;
              r.Logger.verbose("GroupedConv", `autpPad:${u2.autoPad}, dilations:${u2.dilations}, group:${u2.group}, kernelShape:${u2.kernelShape}, pads:${u2.pads}, strides:${u2.strides}`);
              const d = (0, a.calculateOutputShape)(l2, p, u2.dilations, u2.pads, u2.strides), h = (0, i.getGlsl)(t3.session.backend.glContext.version), { activationFunction: g, applyActivation: b } = (0, s.getActivationSnippet)(u2), m = `
  const ivec2 strides = ivec2(${u2.strides[0]}, ${u2.strides[1]});
  const ivec2 pads = ivec2(${u2.pads[0]}, ${u2.pads[1]});
  ${g}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;
    ivec2 xRCCorner = coords.zw * strides - pads;
    int group_id = output_channel / ${f};

    float value = 0.0;
    for (int wInChannel = 0; wInChannel < ${p[1]}; wInChannel++) {
      int input_channel = group_id * ${p[1]} + wInChannel;
      for (int wHeight = 0; wHeight < ${p[2]}; wHeight++) {
        int xHeight = xRCCorner.x + wHeight * ${u2.dilations[0]};

        if (xHeight < 0 || xHeight >= ${l2[2]}) {
          continue;
        }

        for (int wWidth = 0; wWidth < ${p[3]}; wWidth++) {
          int xWidth = xRCCorner.y + wWidth * ${u2.dilations[1]};
          if (xWidth < 0 || xWidth >= ${l2[3]}) {
            continue;
          }

          float xVal = getX(batch, input_channel, xWidth, xHeight);
          float wVal = getW(output_channel, wInChannel, wWidth, wHeight);
          value += xVal*wVal;
        }
      }
    }
    ${c2}
    ${b}
    ${h.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n3), { output: { dims: d, type: e3[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, hasMain: true });
            })(t2, e2, u, n2) });
          };
        }, 1386: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.conv2DPacked = e.conv2DPackedPointwise = void 0;
          const r = n(8138), i = n(8555), o = n(708);
          e.conv2DPackedPointwise = (t2, e2, n2) => {
            const i2 = e2[0].dims, a = e2[1].dims, s = (0, r.calculateOutputShape)(i2, a, n2.dilations, n2.pads, n2.strides), u = t2.reshapePacked(e2[0], [i2[1], i2[2] * i2[3]]), c = t2.reshapePacked(e2[1], [a[0], a[1]]), l = e2.length > 2 ? [c, u, e2[2]] : [c, u], p = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, l, n2), l);
            return t2.reshapePacked(p, s);
          }, e.conv2DPacked = (t2, e2, n2) => {
            const a = e2[0].dims, s = e2[1].dims, u = (0, r.calculateOutputShape)(a, s, n2.dilations, n2.pads, n2.strides), c = t2.run((0, i.createPackedIm2ColProgramInfoLoader)(t2, e2[0], e2[1], u, n2), [e2[0]]), l = t2.reshapePacked(e2[1], [s[0], s[1] * s[2] * s[3]]), p = 3 === e2.length ? [l, c, e2[2]] : [l, c], f = t2.run((0, o.createPackedMatmulProgramInfoLoader)(t2, p, n2), p);
            return t2.reshapePacked(f, u);
          };
        }, 9663: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConvTransposeAttributes = e.convTranspose = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = n(2823), s = (t2, e2, n2, r2, i2, o2) => (t2 - 1) * e2 + n2 + (r2 - 1) * i2 + 1 - o2, u = (t2, e2, n2, r2, i2) => {
            const o2 = Math.floor(t2 / 2);
            "SAME_UPPER" === e2 ? (n2[r2] = o2, n2[i2] = t2 - o2) : "SAME_LOWER" === e2 && (n2[r2] = t2 - o2, n2[i2] = o2);
          };
          e.convTranspose = (t2, e2, n2) => (f(e2, n2), c(t2, e2, n2));
          const c = (t2, e2, n2) => {
            const r2 = p(n2, e2);
            return [l(t2, e2, r2)];
          }, l = (t2, e2, n2) => t2.run(((t3, e3, n3) => {
            const r2 = (s2 = e3.length > 2, u2 = n3.cacheKey, { name: "ConvTranspose", inputNames: s2 ? ["X", "W", "B"] : ["X", "W"], inputTypes: s2 ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], cacheHint: u2 });
            var s2, u2;
            return Object.assign(Object.assign({}, r2), { get: () => ((t4, e4, n4, r3) => {
              const s3 = e4.length > 2 ? "getB(output_channel)" : "0.0", u3 = e4[0].dims, c2 = e4[1].dims, l2 = c2[1], p2 = c2[0] / r3.group, f2 = [e4[0].dims[0], e4[1].dims[1] * r3.group, ...r3.outputShape], d = (0, i.getGlsl)(t4.session.backend.glContext.version), { activationFunction: h, applyActivation: g } = (0, a.getActivationSnippet)(r3), b = `
  const ivec2 strides = ivec2(${r3.strides[0]}, ${r3.strides[1]});
  const ivec2 pads = ivec2(${r3.pads[0]}, ${r3.pads[1]});
  ${h}
  void main() {
    ivec4 coords = getOutputCoords();
    int batch = coords.x;
    int output_channel = coords.y;

    ivec2 loc = coords.zw + pads;

    int group_id = output_channel / ${l2};
    int wOutChannel = output_channel - group_id * ${l2};

    float value = ${s3};
    for (int inChannelOffset = 0; inChannelOffset < ${p2}; inChannelOffset++) {
      int input_channel = group_id * ${p2} + inChannelOffset;
      for (int wWOff = 0; wWOff < ${c2[2]}; wWOff++) {
        for (int wHOff = 0; wHOff < ${c2[3]}; wHOff++) {
          ivec2 wOff = ivec2(wWOff * ${r3.dilations[0]}, wHOff * ${r3.dilations[1]});
          ivec2 wLoc = loc - wOff;
          ivec2 wLocIn = wLoc / strides;
          if (
            wLocIn * strides == wLoc &&
            wLocIn.x >= 0 && wLocIn.x < ${u3[2]} &&
            wLocIn.y >= 0 && wLocIn.y < ${u3[3]}
          ) {
            float xVal = getX(batch, input_channel, wLocIn.y, wLocIn.x);
            float wVal = getW(input_channel, wOutChannel, wHOff, wWOff);
            value += xVal * wVal;
          }
        }
      }
    }
    ${g}
    ${d.output} = vec4(value, .0, .0, .0);
  }
`;
              return Object.assign(Object.assign({}, n4), { output: { dims: f2, type: e4[0].type, textureType: o.TextureType.unpacked }, shaderSource: b, hasMain: true });
            })(t3, e3, r2, n3) });
          })(t2, e2, n2), e2), p = (t2, e2) => {
            const n2 = t2.kernelShape.slice();
            if (0 === t2.kernelShape.length) for (let t3 = 2; t3 < e2[1].dims.length; ++t3) n2.push(e2[1].dims[t3]);
            const r2 = t2.pads.slice(), i2 = t2.outputShape.slice();
            ((t3, e3, n3, r3, i3, o3, a2, c2) => {
              const l2 = t3.length - 2, p2 = 0 === c2.length;
              for (let f2 = 0; f2 < l2; ++f2) {
                const d = p2 ? t3[f2 + 2] * o3[f2] : c2[f2], h = s(t3[f2 + 2], o3[f2], i3[f2], e3[f2], n3[f2], d);
                u(h, r3, i3, f2, f2 + l2), p2 && c2.push(o3[f2] * (t3[f2 + 2] - 1) + a2[f2] + (e3[f2] - 1) * n3[f2] + 1 - i3[f2] - i3[f2 + l2]);
              }
            })(e2[0].dims, n2, t2.dilations, t2.autoPad, r2, t2.strides, t2.outputPadding, i2);
            const o2 = Object.assign({}, t2);
            return Object.assign(o2, { kernelShape: n2, pads: r2, outputShape: i2, cacheKey: t2.cacheKey }), o2;
          };
          e.parseConvTransposeAttributes = (t2) => {
            const e2 = t2.attributes, n2 = (0, a.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), s2 = e2.getInt("group", 1), u2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("output_padding", [0, 0]), l2 = e2.getInts("output_shape", []), p2 = e2.getInts("pads", [0, 0, 0, 0]), f2 = e2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: s2, kernelShape: u2, outputPadding: c2, outputShape: l2, pads: p2, strides: f2 }, n2));
          };
          const f = (t2, e2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length) throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length) throw new Error("currently only support 2-dimensional conv");
            if (t2[0].dims[1] !== t2[1].dims[0]) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            const n2 = t2[1].dims[1] * e2.group;
            if (3 === t2.length && (1 !== t2[2].dims.length || t2[2].dims[0] !== n2)) throw new Error("invalid bias");
            const r2 = t2[0].dims.length - 2;
            if (e2.dilations.length !== r2) throw new Error(`dilations should be ${r2}D`);
            if (e2.strides.length !== r2) throw new Error(`strides should be ${r2}D`);
            if (e2.pads.length !== 2 * r2) throw new Error(`pads should be ${2 * r2}D`);
            if (e2.outputPadding.length !== r2) throw new Error(`output_padding should be ${r2}D`);
            if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2) throw new Error("invalid kernel shape");
            if (0 !== e2.outputShape.length && e2.outputShape.length !== t2[0].dims.length - 2) throw new Error("invalid output shape");
            if ("float32" !== t2[0].type || "float32" !== t2[1].type) throw new Error("ConvTranspose input(X,W) should be float tensor");
            if (3 === t2.length && "float32" !== t2[2].type) throw new Error("ConvTranspose input(bias) should be float tensor");
          };
        }, 8138: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseConvAttributes = e.conv = e.calculateOutputShape = void 0;
          const r = n(246), i = n(2517), o = n(4770), a = n(1386), s = n(9828), u = n(2823), c = n(3248), l = n(5623);
          e.calculateOutputShape = (t2, e2, n2, r2, i2) => {
            const o2 = t2[0], a2 = t2.slice(2), s2 = a2.length, u2 = e2[0], c2 = e2.slice(2).map((t3, e3) => t3 + (t3 - 1) * (n2[e3] - 1)), l2 = a2.map((t3, e3) => t3 + r2[e3] + r2[e3 + s2]).map((t3, e3) => Math.floor((t3 - c2[e3] + i2[e3]) / i2[e3]));
            return [o2, u2].concat(...l2);
          }, e.conv = (t2, e2, n2) => (g(e2, n2), p(t2, e2, n2));
          const p = (t2, e2, n2) => {
            const r2 = h(n2, e2), i2 = t2.session.pack, s2 = 1 === r2.kernelShape[0] && 1 === r2.kernelShape[1];
            return r2.group > 1 ? [t2.run((0, o.createUnpackedGroupedConvProgramInfoLoader)(t2, e2, r2), e2)] : s2 && i2 ? [f(t2, e2, r2)] : i2 && 4 === e2[0].dims.length && 1 === e2[0].dims[0] && !s2 ? [(0, a.conv2DPacked)(t2, e2, r2)] : [d(t2, e2, r2)];
          }, f = (t2, n2, r2) => {
            const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), s2 = t2.reshapeUnpacked(n2[0], [i2[1], i2[2] * i2[3]]), u2 = t2.reshapeUnpacked(n2[1], [o2[0], o2[1]]), c2 = n2.length > 2 ? [u2, s2, n2[2]] : [u2, s2], p2 = t2.run((0, l.createMatmulProgramInfoLoader)(c2, r2), c2);
            return t2.reshapeUnpacked(p2, a2);
          }, d = (t2, n2, r2) => {
            const i2 = n2[0].dims, o2 = n2[1].dims, a2 = (0, e.calculateOutputShape)(i2, o2, r2.dilations, r2.pads, r2.strides), u2 = t2.run((0, c.createIm2ColProgramInfoLoader)(t2, n2[0], n2[1], a2, r2), [n2[0]]), l2 = 3 === n2.length ? [u2, n2[1], n2[2]] : [u2, n2[1]];
            return t2.run((0, s.createDotProductProgramInfoLoader)(t2, n2, a2, r2), l2);
          }, h = (t2, e2) => {
            const n2 = t2.kernelShape.slice();
            if (0 === t2.kernelShape.length) for (let t3 = 2; t3 < e2[1].dims.length; ++t3) n2.push(e2[1].dims[t3]);
            const r2 = t2.pads.slice();
            i.PoolConvUtil.adjustPadsBasedOnAutoPad(e2[0].dims, t2.strides, t2.dilations, n2, r2, t2.autoPad);
            const o2 = Object.assign({}, t2);
            return Object.assign(o2, { kernelShape: n2, pads: r2, cacheKey: t2.cacheKey }), o2;
          };
          e.parseConvAttributes = (t2) => {
            const e2 = t2.attributes, n2 = (0, u.parseInternalActivationAttributes)(e2), i2 = e2.getString("auto_pad", "NOTSET"), o2 = e2.getInts("dilations", [1, 1]), a2 = e2.getInt("group", 1), s2 = e2.getInts("kernel_shape", []), c2 = e2.getInts("pads", [0, 0, 0, 0]), l2 = e2.getInts("strides", [1, 1]);
            return (0, r.createAttributeWithCacheKey)(Object.assign({ autoPad: i2, dilations: o2, group: a2, kernelShape: s2, pads: c2, strides: l2 }, n2));
          };
          const g = (t2, e2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length) throw new Error("Conv requires 2 or 3 inputs");
            if (4 !== t2[0].dims.length || 4 !== t2[1].dims.length) throw new Error("currently only support 2-dimensional conv");
            if (t2[0].dims[1] !== t2[1].dims[1] * e2.group) throw new Error("FILTER_IN_CHANNEL should be equal to DATA_CHANNEL");
            if (3 === t2.length && (1 !== t2[2].dims.length || t2[1].dims[0] !== t2[2].dims[0])) throw new Error("invalid bias");
            const n2 = t2[0].dims.length - 2;
            if (e2.dilations.length !== n2) throw new Error(`dilations should be ${n2}D`);
            if (e2.strides.length !== n2) throw new Error(`strides should be ${n2}D`);
            if (e2.pads.length !== 2 * n2) throw new Error(`pads should be ${2 * n2}D`);
            if (0 !== e2.kernelShape.length && e2.kernelShape.length !== t2[1].dims.length - 2) throw new Error("invalid kernel shape");
            if ("float32" !== t2[0].type || "float32" !== t2[1].type) throw new Error("Conv input(X,W) should be float tensor");
            if (3 === t2.length && "float32" !== t2[2].type) throw new Error("Conv input(bias) should be float tensor");
          };
        }, 5193: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseDepthToSpaceAttributes = e.depthToSpace = void 0;
          const r = n(3738);
          e.depthToSpace = (t2, e2, n2) => {
            i(e2);
            const o = n2.blocksize, a = o * o, s = "DCR" === n2.mode ? [0, 3, 4, 1, 5, 2] : [0, 1, 4, 2, 5, 3], u = "DCR" === n2.mode ? [e2[0].dims[0], o, o, e2[0].dims[1] / a, e2[0].dims[2], e2[0].dims[3]] : [e2[0].dims[0], e2[0].dims[1] / a, o, o, e2[0].dims[2], e2[0].dims[3]], c = t2.reshapeUnpacked(e2[0], u), l = { perm: s, cacheKey: `${s}` }, [p] = (0, r.transpose)(t2, [c], l), f = [e2[0].dims[0], e2[0].dims[1] / a, e2[0].dims[2] * o, e2[0].dims[3] * o];
            return [t2.reshapeUnpacked(p, f)];
          }, e.parseDepthToSpaceAttributes = (t2) => {
            const e2 = t2.attributes.getInt("blocksize");
            if (e2 < 1) throw new Error(`blocksize must be >= 1, but got : ${e2} for DepthToSpace`);
            const n2 = t2.attributes.getString("mode", "DCR");
            if ("DCR" !== n2 && "CRD" !== n2) throw new Error(`unrecognized mode: ${n2} for DepthToSpace`);
            return { mode: n2, blocksize: e2 };
          };
          const i = (t2) => {
            if (1 !== t2.length) throw new Error(`DepthToSpace expect 1 inputs, but got ${t2.length}`);
            if ("string" === t2[0].type || 4 !== t2[0].dims.length) throw new TypeError("DepthToSpace input should be a 4-D numeric tensor");
          };
        }, 9828: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createDotProductProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(2823), s = n(3248);
          e.createDotProductProgramInfoLoader = (t2, e2, n2, u) => {
            const c = ((t3, e3) => ({ name: "ConvDotProduct", inputNames: t3 ? ["Im2Col", "K", "B"] : ["Im2Col", "K"], inputTypes: t3 ? [o.TextureType.unpacked, o.TextureType.packedLastDimension, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.packedLastDimension], cacheKey: e3.activationCacheKey }))(e2.length > 2, u);
            return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, u2, c2) => {
              const l = n3[0].dims, p = n3[1].dims, f = [p[0], Math.ceil(l[1] * p[2] * p[3] / 4)], d = (0, s.calculateIm2ColDims)(l, p, u2), [h, g] = t3.calculateTextureWidthAndHeight(f, o.TextureType.packedLastDimension), b = r.ShapeUtil.computeStrides(d), [m, y] = t3.calculateTextureWidthAndHeight(d, o.TextureType.packedLastDimension), _ = u2.length, v = n3.length < 3 ? "0.0" : "_B(b)", w = Math.ceil(l[1] * p[2] * p[3] / 4), { activationFunction: x, applyActivation: T } = (0, a.getActivationSnippet)(c2), S = (0, i.getGlsl)(t3.session.backend.glContext.version), O = `
${x}
float process(int indices[${_}]) {
  int b[1];
  b[0] = indices[1];
  int im2col[4];
  im2col[0] = indices[0];
  im2col[1] = indices[2];
  im2col[2] = indices[3];
  int im2colOffset = im2col[0] * ${b[0]} + im2col[1] * ${b[1]} + im2col[2] * ${b[2]};
  int kernelOffset = indices[1] * ${f[1]};
  float value = ${v};
  for (int i = 0; i < ${w}; ++i) {
    vec2 im2colCoords = offsetToCoords(im2colOffset, ${m}, ${y});
    vec2 kernelCoords = offsetToCoords(kernelOffset, ${h}, ${g});
    value += dot(${S.texture2D}(Im2Col, im2colCoords), ${S.texture2D}(K, kernelCoords));
    ++im2colOffset;
    ++kernelOffset;
  }
  ${T}
  return value;
}`;
              return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: o.TextureType.unpacked }, shaderSource: O });
            })(t2, c, e2, n2, u) });
          };
        }, 7992: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseFlattenAttributes = e.flatten = void 0;
          const r = n(2517);
          e.flatten = (t2, e2, n2) => {
            i(e2, n2);
            const o = r.ShapeUtil.flattenShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o)];
          }, e.parseFlattenAttributes = (t2) => t2.attributes.getInt("axis", 1);
          const i = (t2, e2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Flatten requires 1 input.");
            const n2 = t2[0].dims.length;
            if (0 === n2) throw new Error("scalar tensor is not supported.");
            if (e2 < -n2 || e2 > n2) throw new Error("Invalid axis");
            if ("string" === t2[0].type) throw new Error("string tensor is not supported.");
          };
        }, 2823: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseInternalActivationAttributes = e.getActivationSnippet = void 0;
          const r = n(2517), i = n(4909);
          e.getActivationSnippet = function(t2) {
            let e2;
            switch (t2.activation) {
              case "Relu":
                e2 = (0, i.glslRelu)();
                break;
              case "Sigmoid":
                e2 = (0, i.glslSigmoid)();
                break;
              case "Clip":
                e2 = (0, i.glslClip)(t2.clipMin, t2.clipMax);
                break;
              default:
                return { activationFunction: "", applyActivation: "" };
            }
            const n2 = e2.name;
            return { activationFunction: e2.body, applyActivation: `value = ${n2}_(value);` };
          }, e.parseInternalActivationAttributes = (t2) => {
            const e2 = t2.getString("activation", "");
            if ("Clip" === e2) {
              const [n2, i2] = t2.getFloats("activation_params", [r.MIN_CLIP, r.MAX_CLIP]);
              return { activation: e2, clipMax: i2, clipMin: n2, activationCacheKey: `${e2}:${n2},${i2}` };
            }
            return { activation: e2, activationCacheKey: e2 };
          };
        }, 1253: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseGatherAttributes = e.gather = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039);
          e.gather = (t2, e2, n2) => (c(e2, n2.axis), [t2.run(u(t2, e2, n2), e2)]), e.parseGatherAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 0) });
          const s = { name: "Gather", inputNames: ["A", "B"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, u = (t2, e2, n2) => {
            const r2 = Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const i2 = n3[0].dims.slice(), s2 = n3[1].dims.slice(), u2 = new Array(i2.length + s2.length - 1);
              r3 = o.ShapeUtil.normalizeAxis(r3, i2.length);
              const c2 = [];
              for (let t4 = 0; t4 < u2.length; t4++) t4 < r3 ? (u2[t4] = i2[t4], c2.push(`inputIdx[${t4}] = outputIdx[${t4}];`)) : t4 < r3 + s2.length ? (u2[t4] = s2[t4 - r3], c2.push(`indexDataIdx[${t4 - r3}] = outputIdx[${t4}];`)) : (u2[t4] = i2[t4 - s2.length + 1], c2.push(`inputIdx[${t4 - s2.length + 1}] = outputIdx[${t4}];`));
              const l = `
      float process(int outputIdx[${u2.length || 1}]) {
        int inputIdx[${i2.length}];
        int indexDataIdx[${s2.length || 1}];
        indexDataIdx[0] = 0;
        ${c2.join("\n        ")}
        int idx = int(_B(indexDataIdx));
        inputIdx[${r3}] = idx < 0 ? idx + ${i2[r3]} : idx;
        return _A(inputIdx);
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: u2, type: n3[0].type, textureType: a.TextureType.unpacked }, shaderSource: l });
            })(0, r2, e2, n2.axis) });
          }, c = (t2, e2) => {
            if (!t2 || 2 !== t2.length) throw new Error("Gather requires 2 inputs.");
            const n2 = t2[0].dims.length;
            if (n2 < 1) throw new Error("Invalid input shape.");
            if (e2 < -n2 || e2 > n2 - 1) throw new Error("Invalid axis.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type)) throw new Error("Invaid input type.");
            if ("int32" !== t2[1].type && "int16" !== t2[1].type) throw new Error("Invaid input type.");
          };
        }, 4776: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseGemmAttributesV11 = e.parseGemmAttributesV7 = e.gemm = void 0;
          const r = n(246), i = n(2517), o = n(2039);
          e.gemm = (t2, e2, n2) => (c(e2, n2), [t2.run(s(e2, n2), e2)]);
          const a = (t2, e2) => {
            const n2 = 0 !== t2.attributes.getInt("transA", 0), i2 = 0 !== t2.attributes.getInt("transB", 0), o2 = t2.attributes.getFloat("alpha", 1), a2 = t2.attributes.getFloat("beta", 1);
            return (0, r.createAttributeWithCacheKey)({ transA: n2, transB: i2, alpha: o2, beta: a2, isOptionalC: e2 });
          };
          e.parseGemmAttributesV7 = (t2) => a(t2, false), e.parseGemmAttributesV11 = (t2) => a(t2, true);
          const s = (t2, e2) => {
            const n2 = { name: "Gemm", inputNames: 3 === t2.length ? ["A", "B", "C"] : ["A", "B"], inputTypes: 3 === t2.length ? [o.TextureType.unpacked, o.TextureType.unpacked, o.TextureType.unpacked] : [o.TextureType.unpacked, o.TextureType.unpacked], key: e2.cacheKey };
            return Object.assign(Object.assign({}, n2), { get: () => u(n2, t2, e2) });
          }, u = (t2, e2, n2) => {
            const r2 = e2[0].dims.slice(), a2 = e2[1].dims.slice(), [s2, u2] = i.GemmUtil.getShapeOfGemmResult(r2, n2.transA, a2, n2.transB, 3 === e2.length ? e2[2].dims : void 0), c2 = [s2, u2];
            if (!c2) throw new Error("Can't use gemm on the given tensors");
            let l = r2[r2.length - 1], p = "";
            n2.transA && (l = r2[0]), n2.transA && n2.transB ? p = "value += _A_T(a) * _B_T(b);" : n2.transA && !n2.transB ? p = "value += _A_T(a) * _B(b);" : !n2.transA && n2.transB ? p = "value += _A(a) * _B_T(b);" : n2.transA || n2.transB || (p = "value += _A(a) * _B(b);");
            const f = c2.length, d = `
      float process(int indices[${f}]) {
          int a[${f}];
          int b[${f}];
          ${3 === e2.length ? `int c[${e2[2].dims.length}];` : ""}

          copyVec(indices, a);
          copyVec(indices, b);
          ${3 === e2.length ? "bcastIndices_C(indices, c);" : ""}

          float value = 0.0;
          for (int k=0; k<${l}; ++k) {
              a[${f - 1}] = k;
              b[${f - 2}] = k;
              ${p}
          }

          value = value * alpha;
          ${3 === e2.length ? "value += beta * _C(c);" : ""}
          return value;
      }`;
            return Object.assign(Object.assign({}, t2), { output: { dims: c2, type: e2[0].type, textureType: o.TextureType.unpacked }, variables: [{ name: "alpha", type: "float", data: n2.alpha }, { name: "beta", type: "float", data: n2.beta }], shaderSource: d });
          }, c = (t2, e2) => {
            if (!t2) throw new Error("Input is missing");
            if (e2.isOptionalC && (t2.length < 2 || t2.length > 3)) throw new Error("Invaid input shape.");
            if (!e2.isOptionalC && 3 !== t2.length) throw new Error("Gemm requires 3 inputs");
            if (3 === t2.length && 1 !== t2[2].dims.length && 2 !== t2[2].dims.length) throw new Error("Invalid input shape of C");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type || 3 === t2.length && "float32" !== t2[2].type && "float64" !== t2[2].type) throw new Error("Invalid input type.");
            if (t2[0].type !== t2[1].type || 3 === t2.length && t2[0].type !== t2[2].type) throw new Error("Input types are mismatched");
          };
        }, 8555: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedIm2ColProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(2827);
          e.createPackedIm2ColProgramInfoLoader = (t2, e2, n2, a, s) => {
            const u = (c = s.cacheKey, { name: "Im2Col (packed)", inputNames: ["A"], inputTypes: [i.TextureType.packed], cacheHint: c });
            var c;
            return Object.assign(Object.assign({}, u), { get: () => ((t3, e3, n3, a2, s2, u2) => {
              const c2 = n3.dims, l = a2.dims, p = s2.length, f = [l[1] * l[2] * l[3], s2[2] * s2[3]], d = l[2] * l[3], h = (0, o.unpackFromChannel)(), g = (0, r.getGlsl)(t3.session.backend.glContext.version);
              let b = "";
              for (let t4 = 0; t4 <= 1; t4++) for (let e4 = 0; e4 <= 1; e4++) b += `
            blockIndex = rc.x + ${e4};
            pos = rc.y + ${t4};

            if(blockIndex < ${f[1]} && pos < ${f[0]}) {
              offsetY = int(blockIndex / (${s2[p - 1]})) * ${u2.strides[0]} -
                ${u2.pads[0]};
              d0 = offsetY + ${u2.dilations[0]} * (imod(pos, ${d}) / ${l[2]});

              if(d0 < ${c2[2]} && d0 >= 0) {
                offsetX = imod(blockIndex, ${s2[p - 1]}) * ${u2.strides[1]} -
                  ${u2.pads[1]};
                d1 = offsetX + ${u2.dilations[1]} * imod(imod(pos, ${d}), ${l[2]});

                if(d1 < ${c2[3]} && d1 >= 0) {

                  ch = int(float(pos)/ ${d}.);
                    innerDims = vec2(d0, d1);
                    result[${2 * t4 + e4}] = getChannel(
                      getA(0, ch, int(innerDims.x),
                      int(innerDims.y)), innerDims);
                }
              }
            }

          `;
              const m = `
      ${h}

      void main() {
        ivec2 rc = getOutputCoords();
          vec4 result = vec4(0.0);
          int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
          vec2 innerDims;
          ${b}
          ${g.output} = result;
      }
            `;
              return Object.assign(Object.assign({}, e3), { output: { dims: f, type: n3.type, textureType: i.TextureType.packed }, shaderSource: m, hasMain: true });
            })(t2, u, e2, n2, a, s) });
          };
        }, 3248: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.calculateIm2ColDims = e.createIm2ColProgramInfoLoader = void 0;
          const r = n(2039);
          e.createIm2ColProgramInfoLoader = (t2, n2, i, o, a) => {
            const s = (u = a.cacheKey, { name: "Im2Col", inputNames: ["X"], inputTypes: [r.TextureType.unpacked], cacheHint: u });
            var u;
            return Object.assign(Object.assign({}, s), { get: () => ((t3, n3, i2, o2, a2, s2) => {
              const u2 = i2.dims, c = o2.dims, l = a2.length, p = (0, e.calculateIm2ColDims)(u2, c, a2, 4), f = `
        const int XC = ${u2[1]};
        const int XH = ${u2[2]};
        const int XW = ${u2[3]};
        const int KH = ${s2.kernelShape[0]};
        const int KW = ${s2.kernelShape[1]};
        const int dilationH = ${s2.dilations[0]};
        const int dilationW = ${s2.dilations[1]};
        const int strideH = ${s2.strides[0]};
        const int strideW = ${s2.strides[1]};
        const int padH = ${s2.pads[0]};
        const int padW = ${s2.pads[1]};
        const int KHKW = KH*KW;
        const int XCKHKW = XC * KHKW;
        const int outputChannels = 4;
        vec4 process(int indices[${l}]) {
          int b  = indices[0]; // batch size
          int oh = indices[1] * strideH - padH; //output height
          int ow = indices[2] * strideW - padW; //output width
          int p = indices[3] * outputChannels; //patch
          vec4 value = vec4(0.0);
          for(int i=0; i < outputChannels; ++i) {
            if(p < XCKHKW) {
              int patchC = p / KHKW;
              int patchH = (p - patchC*KHKW) / KW;
              int patchW = (p - patchC*KHKW) - patchH * KW;
              int xh2 = oh + patchH * dilationH;
              int xw2 = ow + patchW * dilationW;
              int x[${u2.length}];
              x[0] = b;
              x[1] = patchC;
              x[2] = xh2;
              x[3] = xw2;
              if(xh2 >= 0 &&
                  xh2 < XH &&
                  xw2 >= 0 &&
                  xw2 < XW) {
                value[i] = _X(x);
              }
            }
            ++p;
          }
          return value;
        }
        `;
              return Object.assign(Object.assign({}, n3), { output: { dims: p, type: i2.type, textureType: r.TextureType.packedLastDimension }, shaderSource: f });
            })(0, s, n2, i, o, a) });
          }, e.calculateIm2ColDims = (t2, e2, n2, r2 = 4) => [n2[0], n2[2], n2[3], Math.ceil(t2[1] * e2[2] * e2[3] / r2)];
        }, 6572: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseImageScalerAttributes = e.imageScaler = void 0;
          const r = n(246), i = n(2039);
          e.imageScaler = (t2, e2, n2) => (u(e2), [t2.run(a(t2, e2, n2), e2)]), e.parseImageScalerAttributes = (t2) => {
            const e2 = t2.attributes.getFloat("scale"), n2 = t2.attributes.getFloats("bias");
            return (0, r.createAttributeWithCacheKey)({ scale: e2, bias: n2 });
          };
          const o = { name: "ImageScaler", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2, e2, n2) => {
            const r2 = Object.assign(Object.assign({}, o), { cacheHint: n2.cacheKey });
            return Object.assign(Object.assign({}, r2), { get: () => ((t3, e3, n3, r3) => {
              const o2 = n3[0].dims.slice(), a2 = o2.length, u2 = `
      ${s(r3.bias.length)}
      float process(int indices[${a2}]) {
        return _X(indices) * scale + getBias(bias, indices[1]);
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: o2, type: n3[0].type, textureType: i.TextureType.unpacked }, variables: [{ name: "bias", type: "float", arrayLength: r3.bias.length, data: r3.bias }, { name: "scale", type: "float", data: r3.scale }], shaderSource: u2 });
            })(0, r2, e2, n2) });
          }, s = (t2) => {
            const e2 = [`float getBias(float bias[${t2}], int channel) {`];
            for (let n2 = 0; n2 < t2; ++n2) 0 === n2 ? e2.push(`	if (channel == ${n2}) { return bias[${n2}]; }`) : n2 === t2 - 1 ? e2.push(`	else { return bias[${n2}]; }`) : e2.push(`	else if (channel == ${n2}) { return bias[${n2}]; }`);
            return e2.push("	}"), e2.join("\n");
          }, u = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("ImageScaler requires 1 input.");
            if (4 !== t2[0].dims.length) throw new Error("Invalid input shape.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("Invalid input type.");
          };
        }, 3346: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseInstanceNormalizationAttributes = e.instanceNormalization = void 0;
          const r = n(5060), i = n(2039);
          e.instanceNormalization = (t2, e2, n2) => {
            c(e2);
            const r2 = t2.run(a(e2[0]), e2);
            return [t2.run(u(t2, e2[0], n2, r2.dims), [e2[0], r2, e2[1], e2[2]])];
          }, e.parseInstanceNormalizationAttributes = (t2) => t2.attributes.getFloat("epsilon", 1e-5);
          const o = { name: "InstanceNormalization_MeanAndVariance", inputNames: ["X"], inputTypes: [i.TextureType.unpacked] }, a = (t2) => Object.assign(Object.assign({}, o), { get: () => ((t3, e2) => {
            const n2 = e2.dims.slice(), r2 = n2[1], o2 = n2[2] * n2[3], a2 = [n2[0], r2], s2 = `
      vec4 process(int[2] indices) {
        vec4 v = vec4(0.0);
        int a[4];
        a[0] = indices[0];
        a[1] = indices[1];
        float temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += x;
          }
        }
        float mean = temp / float(${o2});
        temp = 0.0;
        for(int a2=0; a2<${n2[2]}; a2++) {
          a[2] = a2;
          for(int a3=0; a3<${n2[3]}; a3++) {
            a[3] = a3;
            float x = _X(a);
            temp += (x - mean) * (x - mean);
          }
        }
        v.r = mean;
        v.g = temp / float(${o2});

        return v;
      }`;
            return Object.assign(Object.assign({}, t3), { output: { dims: a2, type: e2.type, textureType: i.TextureType.packedLastDimension }, shaderSource: s2 });
          })(o, t2) }), s = { name: "InstanceNormalization_ComputeOutput", inputNames: ["X", "MeanAndVariance", "Scale", "B"], inputTypes: [i.TextureType.unpacked, i.TextureType.packedLastDimension, i.TextureType.unpacked, i.TextureType.unpacked] }, u = (t2, e2, n2, o2) => {
            const a2 = Object.assign(Object.assign({}, s), { cacheHint: `${n2}` });
            return Object.assign(Object.assign({}, a2), { get: () => ((t3, e3, n3, o3, a3) => {
              const s2 = (0, r.getGlsl)(t3.session.backend.glContext.version), [u2, c2] = t3.calculateTextureWidthAndHeight(a3, i.TextureType.packedLastDimension), [l, p] = [u2 / 4, c2], f = `
      vec4 get_MeanAndVariance(int[2] mv) {
        int offset = indicesToOffset_MeanAndVariance(mv);
        vec2 coords = offsetToCoords(offset, ${l}, ${p});
        return ${s2.texture2D}(MeanAndVariance, coords);
      }

      float process(int[4] indices) {
        int mv[2];
        mv[0] = indices[0];
        mv[1] = indices[1];
        vec4 mean_and_variance = get_MeanAndVariance(mv);
        float mean = mean_and_variance.r;
        float variance = mean_and_variance.g;

        int sb[1];
        sb[0] = indices[1];
        float scale = _Scale(sb);
        float b = _B(sb);

        return scale * (_X(indices) - mean) / sqrt(variance + epsilon) + b;
      }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i.TextureType.unpacked }, variables: [{ name: "epsilon", type: "float", data: o3 }], shaderSource: f });
            })(t2, a2, e2, n2, o2) });
          }, c = (t2) => {
            if (!t2 || 3 !== t2.length) throw new Error("InstanceNormalization requires 3 inputs.");
            const e2 = t2[0], n2 = t2[1], r2 = t2[2];
            if (e2.dims.length < 3 || 1 !== n2.dims.length || 1 !== r2.dims.length) throw new Error("Invalid input shape.");
            if (n2.dims[0] !== e2.dims[1] || r2.dims[0] !== e2.dims[1]) throw new Error("Input shapes are mismatched.");
            if ("float32" !== e2.type && "float64" !== e2.type || "float32" !== n2.type && "float64" !== n2.type || "float32" !== r2.type && "float64" !== r2.type) throw new Error("Invalid input type.");
            if (4 !== t2[0].dims.length) throw new Error("Only support 4-D input shape.");
          };
        }, 708: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackedMatmulProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(9390), s = n(2823), u = n(5623);
          e.createPackedMatmulProgramInfoLoader = (t2, e2, n2) => {
            const c = (l = e2.length > 2, p = n2.activationCacheKey, { name: "MatMul (packed)", inputNames: l ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: l ? [o.TextureType.packed, o.TextureType.packed, o.TextureType.packed] : [o.TextureType.packed, o.TextureType.packed], cacheHint: p });
            var l, p;
            return Object.assign(Object.assign({}, c), { get: () => ((t3, e3, n3, c2) => {
              const l2 = n3.length > 2, p2 = l2 ? "value += getBiasForMatmul();" : "", f = n3[0].dims, d = n3[1].dims, h = r.BroadcastUtil.calcShape(f, d, true), g = !r.ShapeUtil.areEqual(n3[0].dims, n3[1].dims);
              if (!h) throw new Error("Can't use matmul on the given tensors");
              const b = f[f.length - 1], m = Math.ceil(b / 2), y = f.length, _ = d.length, v = (0, i.getGlsl)(t3.session.backend.glContext.version), w = (0, a.getCoordsDataType)(h.length), x = h.length, T = (0, a.getGlChannels)(), { activationFunction: S, applyActivation: O } = (0, s.getActivationSnippet)(c2), A = l2 ? `${(0, u.getBiasForMatmul)(w, T, n3[2].dims, h, true)}` : "", E = g ? `${function(t4, e4, n4, i2) {
                let o2 = [], a2 = [];
                const s2 = n4[0].dims, u2 = n4[1].dims, c3 = s2.length, l3 = u2.length, p3 = i2.length, f2 = p3 - c3, d2 = p3 - l3;
                o2 = s2.map((t5, n5) => `coords.${e4[n5 + f2]}`), o2[c3 - 1] = "i*2", o2.join(", "), a2 = u2.map((t5, n5) => `coords.${e4[n5 + d2]}`), a2[l3 - 2] = "i*2", a2.join(", ");
                const h2 = r.BroadcastUtil.getBroadcastDims(s2, i2), g2 = r.BroadcastUtil.getBroadcastDims(u2, i2), b2 = h2.map((t5) => `coords.${e4[t5 + f2]} = 0;`).join("\n"), m2 = g2.map((t5) => `coords.${e4[t5 + d2]} = 0;`).join("\n"), y2 = `int lastDim = coords.${e4[p3 - 1]};
  coords.${e4[p3 - 1]} = coords.${e4[p3 - 2]};
  coords.${e4[p3 - 2]} = lastDim;`;
                return `
vec4 getAAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${b2}
  vec4 outputValue = getA(${o2});
  return outputValue;
}

vec4 getBAtOutCoordsMatmul(int i) {
  ${t4} coords = getOutputCoords();
  ${y2}
  ${m2}
  vec4 outputValue = getB(${a2});
  return outputValue;
}`;
              }(w, T, n3, h)}` : "", I = g ? "getAAtOutCoordsMatmul(i)" : `getA(${function(t4, e4) {
                let n4 = "";
                for (let r2 = 0; r2 < e4 - 2; r2++) n4 += `rc.${t4[r2]}, `;
                return n4 += `rc.${t4[e4 - 2]}, i*2`, n4;
              }(T, y)})`, P = g ? "getBAtOutCoordsMatmul(i)" : `getB(${function(t4, e4) {
                let n4 = "";
                for (let r2 = 0; r2 < e4 - 2; r2++) n4 += `rc.${t4[r2]}, `;
                return n4 += `i*2, rc.${t4[e4 - 1]}`, n4;
              }(T, _)})`, D = `
            ${E}
            ${A}
            ${S}
            void main() {
              ${g ? "" : `${w} rc =
          getOutputCoords(); int lastDim = rc.${T[x - 1]}; rc.${T[x - 1]} =
          rc.${T[x - 2]}; rc.${T[x - 2]} = lastDim;
      `}

              vec4 value = vec4(0);
              for (int i = 0; i < ${m}; i++) {
                vec4 a = ${I};
                vec4 b = ${P};

                value += (a.rrbb * b.rgrg);
                value += (a.ggaa * b.baba);
              }
              ${p2}
              ${O}
              ${v.output} = value;
            }`;
              return Object.assign(Object.assign({}, e3), { output: { dims: h, type: n3[0].type, textureType: o.TextureType.packed }, shaderSource: D, hasMain: true });
            })(t2, c, e2, n2) });
          };
        }, 5623: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.getBiasForMatmul = e.createMatmulProgramInfoLoader = e.parseMatMulAttributes = e.matMul = void 0;
          const r = n(2517), i = n(2039), o = n(9390), a = n(2823), s = n(708);
          function u(t2, e2) {
            const n2 = (s2 = t2.length > 2, u2 = e2.activationCacheKey, { name: "MatMul", inputNames: s2 ? ["A", "B", "Bias"] : ["A", "B"], inputTypes: s2 ? [i.TextureType.unpacked, i.TextureType.unpacked, i.TextureType.unpacked] : [i.TextureType.unpacked, i.TextureType.unpacked], cacheHint: u2 });
            var s2, u2;
            return Object.assign(Object.assign({}, n2), { get: () => function(t3, e3, n3) {
              const s3 = e3[0].dims, u3 = e3[1].dims, c2 = r.BroadcastUtil.calcShape(s3, u3, true);
              if (!c2) throw new Error("Can't use matmul on the given tensors");
              const p = (0, o.getCoordsDataType)(c2.length), f = (0, o.getGlChannels)(), { activationFunction: d, applyActivation: h } = (0, a.getActivationSnippet)(n3), g = e3.length > 2, b = g ? "value += getBiasForMatmul();" : "", m = g ? `${l(p, f, e3[2].dims, c2, false)}` : "", y = c2.length, _ = s3.length, v = u3.length, w = `
    ${d}
    ${m}
    float process(int indices[${y}]) {
        int a[${_}];
        int b[${v}];
        bcastMatmulIndices_A(indices, a);
        bcastMatmulIndices_B(indices, b);

        float value;
        for (int k=0; k<${s3[s3.length - 1]}; ++k) {
            a[${_ - 1}] = k;
            b[${v - 2}] = k;
            value += _A(a) * _B(b);
        }
        ${b}
        ${h}
        return value;
    }`;
              return Object.assign(Object.assign({}, t3), { output: { dims: c2, type: e3[0].type, textureType: i.TextureType.unpacked }, shaderSource: w });
            }(n2, t2, e2) });
          }
          e.matMul = (t2, e2, n2) => (c(e2), t2.session.pack ? [t2.run((0, s.createPackedMatmulProgramInfoLoader)(t2, e2, n2), e2)] : [t2.run(u(e2, n2), e2)]), e.parseMatMulAttributes = (t2) => (0, a.parseInternalActivationAttributes)(t2.attributes), e.createMatmulProgramInfoLoader = u;
          const c = (t2) => {
            if (!t2 || 2 !== t2.length) throw new Error("MatMul requires 2 inputs.");
            if (t2[0].dims[t2[0].dims.length - 1] !== t2[1].dims[t2[1].dims.length - 2]) throw new Error("shared dimension does not match.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type || "float32" !== t2[1].type && "float64" !== t2[1].type) throw new Error("inputs should be float type");
            if (t2[0].type !== t2[1].type) throw new Error("inputs types should match");
          };
          function l(t2, e2, n2, i2, o2) {
            let a2 = "";
            const s2 = n2.length, u2 = i2.length, c2 = u2 - s2;
            a2 = u2 < 2 && s2 > 0 ? "coords" : n2.map((t3, n3) => `coords.${e2[n3 + c2]}`).join(", ");
            const l2 = r.BroadcastUtil.getBroadcastDims(n2, i2).map((t3) => `coords.${e2[t3 + c2]} = 0;`).join("\n");
            let p = "vec4(outputValue.xx, outputValue.yy)";
            return 1 === r.ShapeUtil.size(n2) && (p = "vec4(outputValue.x)"), o2 ? `
vec4 getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  vec4 outputValue = getBias(${a2});
  return ${p};
}` : `
float getBiasForMatmul() {
  ${t2} coords = getOutputCoords();
  ${l2}
  return getBias(coords.x);
}`;
          }
          e.getBiasForMatmul = l;
        }, 2403: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createPackProgramInfoLoader = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "pack", inputNames: ["A"], inputTypes: [i.TextureType.unpackedReversed] };
          e.createPackProgramInfoLoader = (t2, e2) => Object.assign(Object.assign({}, s), { get: () => ((t3, e3) => {
            const n2 = (0, r.getGlsl)(t3.session.backend.glContext.version), u = e3.dims, c = u.length, l = e3.dims.length, p = (0, o.getCoordsDataType)(l), f = (0, a.getChannels)("rc", l), d = (h = l, g = f, b = u[u.length - 2], m = u[u.length - 1], 0 === h || 1 === h ? "" : `
    int r = ${g[h - 2]};
    int c = ${g[h - 1]};
    int rp1 = ${g[h - 2]} + 1;
    int cp1 = ${g[h - 1]} + 1;
    bool rEdge = rp1 >= ${m};
    bool cEdge = cp1 >= ${b};
    `);
            var h, g, b, m;
            let y;
            y = 0 === c ? [1, 1] : 1 === c ? [u[0], 1] : [u[l - 1], u[l - 2]];
            const _ = function(t4, e4, n3) {
              if (0 === t4) return "false";
              if (1 === t4) return `rc > ${e4[0]}`;
              let r2 = "";
              for (let i2 = t4 - 2; i2 < t4; i2++) r2 += `${n3[i2]} >= ${e4[i2 - t4 + 2]}`, i2 < t4 - 1 && (r2 += "||");
              return r2;
            }(l, y, f), v = function(t4, e4) {
              const n3 = t4.length;
              if (0 === n3) return "getA(), 0, 0, 0";
              if (1 === n3) return `getA(rc),
            rc + 1 >= ${t4[0]} ? 0. : getA(rc + 1),
            0, 0`;
              let r2 = "";
              if (n3 > 2) for (let t5 = 0; t5 < n3 - 2; ++t5) r2 += `${e4[t5]},`;
              return `getA(${r2}r, c),
          rEdge ? 0. : getA(${r2}rp1, c),
          cEdge ? 0. : getA(${r2}r, cp1),
          rEdge || cEdge ? 0. : getA(${r2}rp1, cp1)`;
            }(u, f), w = `
        void main() {
          ${p} rc = getOutputCoords();

          if(${_}) {
            ${n2.output} = vec4(0);
          } else {
            ${d}

            ${n2.output} = vec4(${v});
          }
        }
      `;
            return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e3.dims, type: e3.type, textureType: i.TextureType.packed }, shaderSource: w });
          })(t2, e2) });
        }, 2827: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.unpackFromChannel = e.getChannels = e.getVecChannels = void 0;
          const r = n(9390);
          function i(t2, e2) {
            return (0, r.getGlChannels)(e2).map((e3) => `${t2}.${e3}`);
          }
          e.getVecChannels = i, e.getChannels = function(t2, e2) {
            return 1 === e2 ? [t2] : i(t2, e2);
          }, e.unpackFromChannel = function() {
            return "\n    float getChannel(vec4 frag, int dim) {\n      int modCoord = imod(dim, 2);\n      return modCoord == 0 ? frag.r : frag.g;\n    }\n\n    float getChannel(vec4 frag, vec2 innerDims) {\n      vec2 modCoord = mod(innerDims, 2.);\n      return modCoord.x == 0. ?\n        (modCoord.y == 0. ? frag.r : frag.g) :\n        (modCoord.y == 0. ? frag.b : frag.a);\n    }\n  ";
          };
        }, 2870: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parsePadAttributesV11 = e.padV11 = e.parsePadAttributesV2 = e.padV2 = void 0;
          const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          e.padV2 = (t2, e2, n2) => (l(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => c(t2, e2[0], n2) }), e2)]), e.parsePadAttributesV2 = (t2) => {
            const e2 = t2.attributes.getString("mode", "constant"), n2 = t2.attributes.getFloat("value", 0), i2 = t2.attributes.getInts("pads");
            return (0, r.createAttributeWithCacheKey)({ mode: e2, value: n2, pads: i2 });
          }, e.padV11 = (t2, n2, r2) => {
            p(n2);
            const i2 = u(t2, n2, r2);
            return (0, e.padV2)(t2, [n2[0]], i2);
          }, e.parsePadAttributesV11 = (t2) => t2.attributes.getString("mode", "constant");
          const u = (t2, e2, n2) => {
            if (!t2.session.isInitializer(e2[1].dataId) || e2.length >= 3 && !t2.session.isInitializer(e2[2].dataId)) throw new Error("dynamic pad attributes are not allowed");
            const i2 = Array.from(e2[1].integerData), o2 = e2.length >= 3 ? e2[2].floatData[0] : 0;
            return (0, r.createAttributeWithCacheKey)({ mode: n2, pads: i2, value: o2 });
          }, c = (t2, e2, n2) => {
            const r2 = i.ShapeUtil.padShape(e2.dims.slice(), n2.pads), o2 = r2.length, s2 = `
      ${f(t2, e2, n2)}
      float process(int[${o2}] indices) {
          return padA(indices);
      }`;
            return { name: "Pad", inputNames: ["A"], inputTypes: [a.TextureType.unpacked], output: { dims: r2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: s2 };
          }, l = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Pad requires 1 input");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("Invalid input type.");
          }, p = (t2) => {
            if (!t2 || 2 !== t2.length && 3 !== t2.length) throw new Error("Pad requires 2 or 3 inputs");
            if ("int32" !== t2[1].type) throw new Error("Invalid input type.");
            if (t2.length >= 3 && "string" === t2[2].type) throw new Error("Invalid input type.");
          }, f = (t2, e2, n2) => {
            const r2 = (0, o.getGlsl)(t2.session.backend.glContext.version), [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = i.ShapeUtil.computeStrides(e2.dims);
            switch (n2.mode) {
              case "constant":
                return d(r2, e2.dims, c2, s2, u2, n2.pads, n2.value);
              case "reflect":
                return h(r2, e2.dims, c2, s2, u2, n2.pads);
              case "edge":
                return g(r2, e2.dims, c2, s2, u2, n2.pads);
              default:
                throw new Error("Invalid mode");
            }
          }, d = (t2, e2, n2, r2, i2, o2, a2) => {
            const s2 = e2.length;
            let u2 = "";
            for (let t3 = s2 - 1; t3 >= 0; --t3) u2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  return constant;
        if (k >= ${e2[t3]}) return constant;
        offset += k * ${n2[t3]};
        `;
            return `
      float padA(int m[${s2}]) {
        const float constant = float(${a2});
        int offset = 0;
        int k = 0;
        ${u2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          }, h = (t2, e2, n2, r2, i2, o2) => {
            const a2 = e2.length;
            let s2 = "";
            for (let t3 = a2 - 1; t3 >= 0; --t3) s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0) { k = -k; }
        {
          const int _2n_1 = ${2 * (e2[t3] - 1)};
          k = int( mod( float(k), float(_2n_1) ) ) ;
          if(k >= ${e2[t3]}) { k = _2n_1 - k; }
        }
        offset += k * ${n2[t3]};
        `;
            return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          }, g = (t2, e2, n2, r2, i2, o2) => {
            const a2 = e2.length;
            let s2 = "";
            for (let t3 = a2 - 1; t3 >= 0; --t3) s2 += `
        k = m[${t3}] - ${o2[t3]};
        if (k < 0)  k = 0;
        if (k >= ${e2[t3]}) k = ${e2[t3] - 1};
        offset += k * ${n2[t3]};
      `;
            return `
      float padA(int m[${a2}]) {
        int offset = 0;
        int k = 0;
        ${s2}
        vec2 coords = offsetToCoords(offset, ${r2}, ${i2});
        float value = getColorAsFloat(${t2.texture2D}(A, coords));
        return value;
      }
      `;
          };
        }, 2143: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.globalMaxPool = e.parseMaxPoolAttributes = e.maxPool = e.parseGlobalAveragePoolAttributes = e.globalAveragePool = e.parseAveragePoolAttributes = e.averagePool = void 0;
          const r = n(246), i = n(2517), o = n(2039);
          e.averagePool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "AveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, false, n2) }), e2)];
          }, e.parseAveragePoolAttributes = (t2) => {
            const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = 0 !== t2.attributes.getInt("count_include_pad", 0), o2 = t2.attributes.getInts("kernel_shape"), a2 = t2.attributes.getInts("strides", []), s2 = t2.attributes.getInts("pads", []);
            if (0 !== n2) throw new Error("using ceil() in shape computation is not yet supported for AveragePool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: i2, kernelShape: o2, strides: a2, pads: s2 });
          };
          const a = (t2, e2, n2, r2) => {
            const [a2, s2] = u(t2, r2, n2), c2 = i.ShapeUtil.size(a2.kernelShape);
            let l2 = "";
            a2.countIncludePad ? l2 += `value /= float(${c2});` : l2 += `value /= float(${c2} - pad);`;
            const p2 = `
        ${f(t2[0].dims, a2, "value += _X(x);", l2, "0.0")}
      `;
            return Object.assign(Object.assign({}, e2), { output: { dims: s2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
          };
          e.globalAveragePool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "GlobalAveragePool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: `${n2.countIncludePad}` };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => a(e2, r2, true, n2) }), e2)];
          }, e.parseGlobalAveragePoolAttributes = (t2) => {
            const e2 = 0 !== t2.attributes.getInt("count_include_pad", 0);
            return (0, r.createAttributeWithCacheKey)({ autoPad: "", ceilMode: 0, countIncludePad: e2, kernelShape: [], strides: [], pads: [] });
          }, e.maxPool = (t2, e2, n2) => {
            p(e2);
            const r2 = { name: "MaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked], cacheHint: n2.cacheKey };
            return [t2.run(Object.assign(Object.assign({}, r2), { get: () => s(e2, r2, false, n2) }), e2)];
          }, e.parseMaxPoolAttributes = (t2) => {
            const e2 = t2.attributes.getString("auto_pad", "NOTSET"), n2 = t2.attributes.getInt("ceil_mode", 0), i2 = t2.attributes.getInts("kernel_shape"), o2 = t2.attributes.getInts("strides", []), a2 = t2.attributes.getInts("pads", []), s2 = t2.attributes.getInt("storage_order", 0), u2 = t2.attributes.getInts("dilations", []);
            if (0 !== s2) throw new Error("column major storage order is not yet supported for MaxPool");
            if (0 !== n2) throw new Error("using ceil() in shape computation is not yet supported for MaxPool");
            return (0, r.createAttributeWithCacheKey)({ autoPad: e2, ceilMode: n2, countIncludePad: false, kernelShape: i2, strides: o2, pads: a2, storageOrder: s2, dilations: u2 });
          };
          const s = (t2, e2, n2, r2) => {
            const [i2, a2] = u(t2, r2, n2), s2 = `
      ${f(t2[0].dims, i2, "\n      value = max(_X(x), value);\n    ", "", "-1e5")}
    `;
            return Object.assign(Object.assign({}, e2), { output: { dims: a2, type: t2[0].type, textureType: o.TextureType.unpacked }, shaderSource: s2 });
          }, u = (t2, e2, n2) => {
            const r2 = t2[0].dims.slice(), o2 = Object.hasOwnProperty.call(e2, "dilations"), a2 = e2.kernelShape.slice(), s2 = e2.strides.slice(), u2 = o2 ? e2.dilations.slice() : [], c2 = e2.pads.slice();
            i.PoolConvUtil.adjustPoolAttributes(n2, r2, a2, s2, u2, c2);
            const l2 = i.PoolConvUtil.computePoolOutputShape(n2, r2, s2, u2, a2, c2, e2.autoPad), p2 = Object.assign({}, e2);
            return o2 ? Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, dilations: u2, cacheKey: e2.cacheKey }) : Object.assign(p2, { kernelShape: a2, strides: s2, pads: c2, cacheKey: e2.cacheKey }), [p2, l2];
          }, c = { autoPad: "", ceilMode: 0, countIncludePad: false, kernelShape: [], strides: [], pads: [], storageOrder: 0, dilations: [], cacheKey: "" }, l = { name: "GlobalMaxPool", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
          e.globalMaxPool = (t2, e2) => (p(e2), [t2.run(Object.assign(Object.assign({}, l), { get: () => s(e2, l, true, c) }), e2)]);
          const p = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Pool ops requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("Invalid input type.");
          }, f = (t2, e2, n2, r2, o2) => {
            const a2 = t2.length;
            if (e2.kernelShape.length <= 2) {
              const i2 = e2.kernelShape[e2.kernelShape.length - 1], s2 = e2.strides[e2.strides.length - 1], u2 = e2.pads[e2.pads.length / 2 - 1], c2 = e2.pads[e2.pads.length - 1], l2 = t2[a2 - 1];
              let p2 = "", f2 = "", d2 = "";
              if (p2 = u2 + c2 !== 0 ? `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            if (x[${a2} - 1] < 0 || x[${a2} - 1] >= ${l2}) {
              pad++;
              continue;
            }
            ${n2}
          }` : `
          for (int i = 0; i < ${i2}; i++) {
            x[${a2} - 1] = indices[${a2} - 1] * ${s2} - ${u2} + i;
            ${n2}
          }`, 2 === e2.kernelShape.length) {
                const n3 = e2.kernelShape[e2.kernelShape.length - 2], r3 = e2.strides[e2.strides.length - 2], o3 = e2.pads[e2.pads.length / 2 - 2], s3 = e2.pads[e2.pads.length - 2], u3 = t2[a2 - 2];
                f2 = o3 + s3 !== 0 ? `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
              if (x[${a2} - 2] < 0 || x[${a2} - 2] >= ${u3}) {
                pad+= ${i2};
                continue;
              }
          ` : `
            for (int j = 0; j < ${n3}; j++) {
              x[${a2} - 2] = indices[${a2} - 2] * ${r3} - ${o3} + j;
            `, d2 = "\n          }\n        ";
              }
              return `
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);

          float value = ${o2};
          int pad = 0;
          ${f2}
          ${p2}
          ${d2}
          ${r2}
          return value;
        }
      `;
            }
            {
              const s2 = i.ShapeUtil.size(e2.kernelShape), u2 = i.ShapeUtil.computeStrides(e2.kernelShape), c2 = u2.length, l2 = e2.pads.length, p2 = h(c2), f2 = d(t2, "inputDims"), g = d(e2.pads, "pads"), b = d(u2, "kernelStrides"), m = d(e2.strides, "strides");
              let y = "";
              return y = e2.pads.reduce((t3, e3) => t3 + e3) ? `
            if (x[j] >= inputDims[j] || x[j] < 0) {
              pad++;
              isPad = true;
              break;
            }
          }
          if (!isPad) {
            ${n2}
          }` : `
          }
          ${n2}
        `, `
        ${p2}
        float process(int indices[${a2}]) {
          int x[${a2}];
          copyVec(indices, x);
          int offset[${c2}];
          int pads[${l2}];
          int inputDims[${a2}];
          int kernelStrides[${c2}];
          int strides[${c2}];
          ${g}
          ${f2}
          ${m}
          ${b}

          float value = ${o2};
          int pad = 0;
          bool isPad = false;
          for (int i = 0; i < ${s2}; i++) {
            offsetToIndices(i, kernelStrides, offset);
            isPad = false;
            for (int j = ${a2} - ${c2}; j < ${a2}; j++) {
              x[j] = indices[j] * strides[j - ${a2} + ${c2}]
                + offset[j - ${a2} + ${c2}] - pads[j - 2];
              ${y}
          }
          ${r2}

          return value;
        }
      `;
            }
          }, d = (t2, e2) => {
            let n2 = "";
            for (let r2 = 0; r2 < t2.length; r2++) n2 += `
      ${e2}[${r2}] = ${t2[r2]};
    `;
            return n2;
          }, h = (t2) => `
  void offsetToIndices(int offset, int[${t2}] strides, out int[${t2}] indices) {
    if (${t2} == 0) {
      return;
    }
    for (int i = 0; i < ${t2} - 1; ++i) {
      indices[i] = offset / strides[i];
      offset -= indices[i] * strides[i];
    }
    indices[${t2} - 1] = offset;
  }`;
        }, 4939: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.reduceLogSumSquare = e.reduceLogSum = e.reduceProd = e.reduceMin = e.reduceMax = e.reduceMean = e.reduceSum = e.parseReduceAttributes = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039), s = (t2, e2, n2, r2, i2) => {
            c(e2);
            const o2 = { name: r2, inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
            return [t2.run(Object.assign(Object.assign({}, o2), { cacheHint: n2.cacheKey, get: () => u(t2, e2, n2, r2, i2, o2) }), e2)];
          };
          e.parseReduceAttributes = (t2) => {
            const e2 = t2.attributes.getInts("axes", []), n2 = 1 === t2.attributes.getInt("keepdims", 1);
            return (0, r.createAttributeWithCacheKey)({ axes: e2, keepDims: n2 });
          };
          const u = (t2, e2, n2, r2, i2, s2) => {
            const u2 = [], c2 = e2[0].dims.length || 1, l = [], p = o.ShapeUtil.normalizeAxes(n2.axes, e2[0].dims.length), f = i2(e2, p);
            let d = f[1];
            for (let t3 = 0; t3 < e2[0].dims.length; t3++) p.indexOf(t3) >= 0 || 0 === p.length ? (n2.keepDims && u2.push(1), d = `
          for(int j${t3} = 0; j${t3} < ${e2[0].dims[t3]}; j${t3}++) {
            inputIdx[${t3}] = j${t3};
            ${d}
          }`) : (l.push(`inputIdx[${t3}] = outputIdx[${u2.length}];`), u2.push(e2[0].dims[t3]));
            const h = `
      float process(int outputIdx[${u2.length || 1}]) {
        float value;                 // final result
        int inputIdx[${c2}];      // addressing input data
        ${l.join("\n")}
        ${f[0]}       // init ops for reduce max/min
        ${d}
        ${f[2]}       // final computation for reduce mean
        return value;
      }`;
            return Object.assign(Object.assign({}, s2), { output: { dims: u2, type: e2[0].type, textureType: a.TextureType.unpacked }, shaderSource: h });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Reduce op requires 1 input.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type)) throw new Error("Invalid input type.");
          };
          e.reduceSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceSum", () => ["value = 0.0;", "value += _A(inputIdx);", ""]), e.reduceMean = (t2, e2, n2) => s(t2, e2, n2, "ReduceMean", (t3, e3) => {
            let n3 = 1;
            for (let r2 = 0; r2 < t3[0].dims.length; r2++) (e3.indexOf(r2) >= 0 || 0 === e3.length) && (n3 *= t3[0].dims[r2]);
            return ["value = 0.0;", "value += _A(inputIdx);", `value /= ${n3}.;`];
          }), e.reduceMax = (t2, e2, n2) => s(t2, e2, n2, "ReduceMax", (t3, e3) => {
            const n3 = [];
            for (let r2 = 0; r2 < t3[0].dims.length; r2++) (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = max(value, _A(inputIdx));", ""];
          }), e.reduceMin = (t2, e2, n2) => s(t2, e2, n2, "ReduceMin", (t3, e3) => {
            const n3 = [];
            for (let r2 = 0; r2 < t3[0].dims.length; r2++) (e3.indexOf(r2) >= 0 || 0 === e3.length) && n3.push(`inputIdx[${r2}] = 0;`);
            return [`${n3.join("\n")}
value = _A(inputIdx);`, "value = min(value, _A(inputIdx));", ""];
          }), e.reduceProd = (t2, e2, n2) => s(t2, e2, n2, "ReduceProd", () => ["value = 1.0;", "value *= _A(inputIdx);", ""]), e.reduceLogSum = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSum", () => ["value = 0.0;", "value += _A(inputIdx);", "value = log(value);"]), e.reduceLogSumSquare = (t2, e2, n2) => s(t2, e2, n2, "ReduceLogSumSquare", () => ["float t; value = 0.0;", "t = _A(inputIdx); value += t * t;", ""]);
        }, 7019: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.isReshapeCheap = e.processDims3D = e.createPackedReshape3DProgramInfoLoader = void 0;
          const r = n(2517), i = n(5060), o = n(2039), a = n(2827);
          e.createPackedReshape3DProgramInfoLoader = (t2, e2, n2) => {
            const s = ((t3) => ({ name: "Reshape (packed)", inputTypes: [o.TextureType.packed], inputNames: ["A"], cacheHint: `${t3}` }))(n2);
            return Object.assign(Object.assign({}, s), { get: () => ((t3, e3, n3, s2) => {
              const u = e3.dims, c = s2;
              let l = "";
              for (let t4 = 0; t4 < 4; t4++) {
                let e4 = "";
                switch (t4) {
                  case 0:
                    e4 = "outputCoords = rc;";
                    break;
                  case 1:
                    e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z);";
                    break;
                  case 2:
                    e4 = "outputCoords = ivec3(rc.x, rc.y, rc.z+1);";
                    break;
                  case 3:
                    e4 = "outputCoords = ivec3(rc.x, rc.y+1, rc.z+1);";
                    break;
                  default:
                    throw new Error();
                }
                l += `
        ${e4}
        ${t4 > 0 ? "if(outputCoords.y < rows && outputCoords.z < cols){" : ""}
          int flattenedIndex = getFlattenedIndex(outputCoords);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flattenedIndex);
          vec2 innerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${t4}] = getChannel(getA(inputRC.x, inputRC.y, inputRC.z), innerDims);

        ${t4 > 0 ? "}" : ""}
      `;
              }
              const p = (0, i.getGlsl)(t3.session.backend.glContext.version), f = `
      ${function(t4) {
                const e4 = r.ShapeUtil.computeStrides(t4), n4 = ["b", "r", "c"], i2 = "index";
                return `
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e4.map((t5, r2) => `int ${n4[r2]} = ${i2} / ${t5}; ${r2 === e4.length - 1 ? `int ${n4[r2 + 1]} = ${i2} - ${n4[r2]} * ${t5}` : `index -= ${n4[r2]} * ${t5}`};`).join("")}
      return ivec3(b, r, c);
    }
  `;
              }(u)}
      ${function(t4) {
                const e4 = r.ShapeUtil.computeStrides(t4);
                return `
  int getFlattenedIndex(ivec3 coords) {
    // reverse y, z order
    return coords.x * ${e4[0]} + coords.z * ${e4[1]} + coords.y;
  }
`;
              }(c)}
      ${(0, a.unpackFromChannel)()}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.0);

        ivec3 outputCoords;
        int rows = ${c[2]};
        int cols = ${c[1]};

        ${l}
        ${p.output} = result;
      }
    `;
              return Object.assign(Object.assign({}, n3), { output: { dims: c, type: e3.type, textureType: o.TextureType.packed }, shaderSource: f, hasMain: true });
            })(t2, e2, s, n2) });
          }, e.processDims3D = function(t2) {
            if (0 === t2.length) return [1, 1, 1];
            let e2 = 1;
            for (let n2 = 0; n2 < t2.length - 2; ++n2) e2 *= t2[n2];
            return [e2, t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
          }, e.isReshapeCheap = function(t2, e2) {
            let n2 = false;
            return n2 = 0 === t2.length || 0 === e2.length || (t2.length < 2 || e2.length < 2 ? t2[t2.length - 1] === e2[e2.length - 1] : t2[t2.length - 1] === e2[e2.length - 1] && t2[t2.length - 2] === e2[e2.length - 2]), n2;
          };
        }, 718: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.reshape = void 0;
          const r = n(2517);
          e.reshape = (t2, e2) => {
            const n2 = r.ShapeUtil.calculateReshapedDims(e2[0].dims, e2[1].integerData);
            return t2.session.pack ? [t2.reshapePacked(e2[0], n2)] : [t2.reshapeUnpacked(e2[0], n2)];
          };
        }, 2268: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseResizeAttributesV11 = e.parseResizeAttributesV10 = e.resize = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = n(9793), u = { name: "Resize", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
          e.resize = (t2, e2, n2) => ((0, s.validateInputs)(e2, n2), [t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => c(t2, e2, n2) }), e2)]), e.parseResizeAttributesV10 = (t2) => (0, s.parseUpsampleAttributes)(t2, 10), e.parseResizeAttributesV11 = (t2) => (0, s.parseUpsampleAttributes)(t2, 11);
          const c = (t2, e2, n2) => {
            const s2 = (0, r.getGlsl)(t2.session.backend.glContext.version), [c2, p2] = l(e2, n2);
            if (c2.every((t3) => 1 === t3) && "tf_crop_and_resize" !== n2.coordinateTransformMode) return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: `void main() {
                    vec4 v = ${s2.texture2D}(X, TexCoords);
                    ${s2.output} = v;
                }` });
            const f2 = p2.length;
            if (f2 < 2) throw new Error(`output dimension should be at least 2, but got ${f2}`);
            const d = p2[f2 - 2], h = p2[f2 - 1], g = e2[0].dims;
            if (f2 !== g.length) throw new Error(`output dimension should match input ${g.length}, but got ${f2}`);
            const b = g[f2 - 2], m = g[f2 - 1], y = c2[f2 - 2], _ = c2[f2 - 1];
            let v = "";
            if ("linear" !== n2.mode) throw new Error(`resize (packed) does not support mode: '${n2.mode}'`);
            switch (n2.coordinateTransformMode) {
              case "asymmetric":
                v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return vec4(coords) / scaleWHWH;\n                    }\n                ";
                break;
              case "half_pixel":
                v = "\n                    vec4 getSourceFracIndex(ivec4 coords) {\n                        return (vec4(coords) + 0.5) / scaleWHWH - 0.5;\n                    }\n                ";
                break;
              case "pytorch_half_pixel":
                v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 fcoords = vec4(coords);
                        return vec4(
                            ${h}.0 > 1.0 ? (fcoords.x + 0.5) / scaleWHWH.x - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.y + 0.5) / scaleWHWH.y - 0.5 : 0.0,
                            ${h}.0 > 1.0 ? (fcoords.z + 0.5) / scaleWHWH.z - 0.5 : 0.0,
                            ${d}.0 > 1.0 ? (fcoords.w + 0.5) / scaleWHWH.w - 0.5 : 0.0
                          );
                    }
                `;
                break;
              case "align_corners":
                v = `
                    vec4 getSourceFracIndex(ivec4 coords) {
                        vec4 resized = vec4(${h}.0 - 1.0, ${d}.0 - 1.0, ${h}.0 - 1.0,
                            ${d}.0 - 1.0);
                        vec4 original = vec4(${m}.0 - 1.0, ${b}.0 - 1.0, ${m}.0 - 1.0,
                            ${b}.0 - 1.0);
                        vec4 new_scale = original / resized;
                        return vec4(coords) * new_scale;
                    }
                `;
                break;
              default:
                throw new Error(`resize (packed) does not support coordinateTransformMode:                                 '${n2.coordinateTransformMode}'`);
            }
            const w = (0, o.getCoordsDataType)(f2), x = `
            const vec2 inputWH = vec2(${b}.0, ${m}.0);
            const vec4 scaleWHWH = vec4(float(${y}), float(${_}), float(${y}), float(${_}));
            ${(0, a.unpackFromChannel)()}
            ${v}
            float getAValue(int x10, int r, int c, int d) {
                return getChannel(getA(x10, r, c, d), vec2(c, d));
            }
            void main() {
                ${w} rc = getOutputCoords();

                int batch = rc[0];
                int depth = rc[1];

                // retrieve the 4 coordinates that is used in the 4 packed output values.
                ivec4 coords = ivec4(rc.wz, rc.w + 1, rc.z + 1);

                // calculate the source index in fraction
                vec4 sourceFrac = getSourceFracIndex(coords);

                // get the lower and upper bound of the 4 values that will be packed into one texel.
                ivec4 x00 = ivec4(max(sourceFrac.xy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xy)));
                ivec4 x01 = ivec4(max(sourceFrac.xw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.xw)));
                ivec4 x10 = ivec4(max(sourceFrac.zy, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zy)));
                ivec4 x11 = ivec4(max(sourceFrac.zw, vec2(0.0)), min(inputWH - 1.0, ceil(sourceFrac.zw)));

                bool hasNextRow = rc.w < ${d - 1};
                bool hasNextCol = rc.z < ${h - 1};

                // pack x00, x01, x10, x11's top-left corner into one vec4 structure
                vec4 topLeft = vec4(
                    getAValue(batch, depth, x00.x, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.y) : 0.0);

                // pack x00, x01, x10, x11's top-right corner into one vec4 structure
                vec4 topRight = vec4(
                    getAValue(batch, depth, x00.x, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.x, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.x, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.x, x11.w) : 0.0);

                // pack x00, x01, x10, x11's bottom-left corner into one vec4 structure
                vec4 bottomLeft = vec4(
                    getAValue(batch, depth, x00.z, x00.y),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.y) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.y) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.y) : 0.0);

                // pack x00, x01, x10, x11's bottom-right corner into one vec4 structure
                vec4 bottomRight = vec4(
                    getAValue(batch, depth, x00.z, x00.w),
                    hasNextCol ? getAValue(batch, depth, x01.z, x01.w) : 0.0,
                    hasNextRow ? getAValue(batch, depth, x10.z, x10.w) : 0.0,
                    (hasNextRow && hasNextCol) ? getAValue(batch, depth, x11.z, x11.w) : 0.0);

                // calculate the interpolation fraction on u and v direction
                vec4 frac = vec4(sourceFrac) - floor(sourceFrac);
                vec4 clampFrac = clamp(frac, vec4(0.0), vec4(1.0));

                vec4 top = mix(topLeft, topRight, clampFrac.ywyw);
                vec4 bottom = mix(bottomLeft, bottomRight, clampFrac.ywyw);
                vec4 newValue = mix(top, bottom, clampFrac.xxzz);

                ${s2.output} = vec4(newValue);
            }
        `;
            return Object.assign(Object.assign({}, u), { output: { dims: p2, type: e2[0].type, textureType: i.TextureType.packed }, hasMain: true, shaderSource: x });
          }, l = (t2, e2) => {
            const n2 = t2[0].dims;
            let r2, i2 = e2.scales;
            if (0 === i2.length) {
              const o3 = t2[e2.scalesInputIdx];
              if (o3 && 0 !== o3.size) {
                if (t2[e2.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
                i2 = p(o3, e2.mode, e2.isResize);
              } else {
                const o4 = t2[e2.sizesInputIdx];
                if (!o4 || 0 === o4.size) throw new Error("Either scales or sizes MUST be provided as input.");
                r2 = Array.from(o4.integerData), i2 = f(r2, n2, e2.mode, e2.isResize);
              }
            } else if (t2[e2.sizesInputIdx]) throw new Error("Only one of scales or sizes must be provided as input.");
            const o2 = r2 || n2.map((t3, e3) => Math.floor(t3 * i2[e3]));
            return [i2, o2];
          }, p = (t2, e2, n2) => {
            const r2 = Array.from(t2.floatData);
            return (0, s.scalesValidation)(r2, e2, n2), r2;
          }, f = (t2, e2, n2, r2) => {
            const i2 = e2.length, o2 = new Array(i2);
            for (let n3 = 0, r3 = i2; n3 < r3; n3++) if (0 === e2[n3]) {
              if (0 !== t2[n3]) throw new Error("Input dim is zero but required output dim is non-zero.");
              o2[n3] = 1;
            } else o2[n3] = t2[n3] / e2[n3];
            return (0, s.scalesValidation)(o2, n2, r2), o2;
          };
        }, 8117: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.shape = void 0;
          const r = n(9162);
          e.shape = (t2, e2) => (i(e2), [new r.Tensor([e2[0].dims.length], "int32", void 0, void 0, new Int32Array(e2[0].dims))]);
          const i = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Shape requires 1 input.");
          };
        }, 2278: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.sliceV10 = e.parseSliceAttributes = e.slice = void 0;
          const r = n(246), i = n(782), o = n(2517), a = n(2039), s = { name: "Slice", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] };
          e.slice = (t2, e2, n2) => (c(e2), [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), e2)]), e.parseSliceAttributes = (t2) => {
            const e2 = t2.attributes.getInts("starts"), n2 = t2.attributes.getInts("ends"), i2 = t2.attributes.getInts("axes", []);
            return (0, r.createAttributeWithCacheKey)({ starts: e2, ends: n2, axes: i2 });
          };
          const u = (t2, e2, n2) => {
            const r2 = 0 === n2.axes.length ? e2.dims.slice(0).map((t3, e3) => e3) : n2.axes, i2 = o.ShapeUtil.normalizeAxes(r2, e2.dims.length), u2 = n2.starts.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), c2 = n2.ends.map((t3, n3) => t3 > e2.dims[i2[n3]] - 1 ? e2.dims[i2[n3]] : o.ShapeUtil.normalizeAxis(t3, e2.dims[i2[n3]])), l2 = e2.dims.slice(), p2 = [];
            for (let t3 = 0; t3 < i2.length; t3++) l2[i2[t3]] = c2[t3] - u2[t3], u2[t3] > 0 && p2.push(`outputIdx[${i2[t3]}] += ${u2[t3]};`);
            const f = `
      float process(int outputIdx[${l2.length}]) {
        ${p2.join("\n      ")}
        return _A(outputIdx);
      }`;
            return Object.assign(Object.assign({}, s), { output: { dims: l2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Slice requires 1 input.");
            if (-1 === i.NUMBER_TYPES.indexOf(t2[0].type)) throw new Error("Invalid input type.");
          };
          e.sliceV10 = (t2, e2) => {
            p(e2);
            const n2 = l(t2, e2);
            return [t2.run(Object.assign(Object.assign({}, s), { cacheHint: n2.cacheKey, get: () => u(t2, e2[0], n2) }), [e2[0]])];
          };
          const l = (t2, e2) => {
            if (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId) || e2.length >= 4 && !t2.session.isInitializer(e2[3].dataId) || e2.length >= 5 && !t2.session.isInitializer(e2[4].dataId)) throw new Error("dynamic slice attributes are not allowed");
            if (e2.length >= 5 && e2[4].integerData.some((t3) => 1 !== t3)) throw new Error("currently non-1 steps is not supported for Slice");
            const n2 = Array.from(e2[1].integerData), r2 = Array.from(e2[2].integerData), i2 = e2.length >= 4 ? Array.from(e2[3].integerData) : [];
            return { starts: n2, ends: r2, axes: i2, cacheKey: `${i2};${n2};${r2}` };
          }, p = (t2) => {
            if (!t2 || t2.length < 3 || t2.length > 5) throw new Error("Invalid input number.");
            if ("int32" !== t2[1].type || 1 !== t2[1].dims.length) throw new Error("Invalid input type.");
            if ("int32" !== t2[2].type || 1 !== t2[2].dims.length) throw new Error("Invalid input type.");
            if (t2.length >= 4 && ("int32" !== t2[3].type || 1 !== t2[3].dims.length)) throw new Error("Invalid input type.");
            if (t2.length >= 5 && ("int32" !== t2[4].type || 1 !== t2[4].dims.length)) throw new Error("Invalid input type.");
          };
        }, 5524: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.softmaxV13 = e.parseSoftmaxAttributesV13 = e.parseSoftmaxAttributes = e.softmax = void 0;
          const r = n(246), i = n(2517), o = n(5060), a = n(2039), s = n(3738), u = { name: "SoftmaxComputeMax", inputNames: ["A"], inputTypes: [a.TextureType.unpacked] }, c = { name: "SoftmaxComputeScale", inputNames: ["A", "Max"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked] }, l = { name: "SoftMax", inputNames: ["A", "Max", "Norm"], inputTypes: [a.TextureType.unpacked, a.TextureType.unpacked, a.TextureType.unpacked] };
          e.softmax = (t2, e2, n2) => {
            g(e2);
            const r2 = e2[0].dims.slice(), o2 = i.ShapeUtil.normalizeAxis(n2.axis, r2.length), a2 = i.ShapeUtil.sizeToDimension(r2, o2), s2 = i.ShapeUtil.sizeFromDimension(r2, o2);
            return p(t2, e2, n2, a2, s2);
          }, e.parseSoftmaxAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", 1) }), e.parseSoftmaxAttributesV13 = (t2) => (0, r.createAttributeWithCacheKey)({ axis: t2.attributes.getInt("axis", -1) }), e.softmaxV13 = (t2, e2, n2) => {
            g(e2);
            const o2 = e2[0].dims.slice(), a2 = i.ShapeUtil.normalizeAxis(n2.axis, o2.length), u2 = o2.length, c2 = a2 !== u2 - 1, l2 = [];
            let f2, d2 = [], h2 = [];
            c2 && (d2 = Array.from({ length: u2 }).map((t3, e3) => e3), d2[a2] = u2 - 1, d2[u2 - 1] = a2, d2.map((t3) => l2.push(o2[t3])), f2 = (0, r.createAttributeWithCacheKey)({ perm: d2 }), h2 = (0, s.transpose)(t2, e2, f2));
            const b = c2 ? i.ShapeUtil.sizeToDimension(l2, u2 - 1) : i.ShapeUtil.sizeToDimension(o2, u2 - 1), m = c2 ? i.ShapeUtil.sizeFromDimension(l2, u2 - 1) : i.ShapeUtil.sizeFromDimension(o2, u2 - 1), y = p(t2, c2 ? h2 : e2, n2, b, m);
            return c2 ? (0, s.transpose)(t2, y, f2) : y;
          };
          const p = (t2, e2, n2, r2, i2) => {
            const o2 = f(t2, e2[0], r2, i2, [r2]), a2 = t2.run(Object.assign(Object.assign({}, u), { cacheHint: n2.cacheKey, get: () => o2 }), e2), s2 = d(t2, e2[0], r2, i2, o2.output.dims, [r2]), p2 = t2.run(Object.assign(Object.assign({}, c), { cacheHint: n2.cacheKey, get: () => s2 }), [e2[0], a2]), g2 = h(t2, e2[0], r2, i2, o2.output.dims, s2.output.dims);
            return [t2.run(Object.assign(Object.assign({}, l), { cacheHint: n2.cacheKey, get: () => g2 }), [e2[0], a2, p2])];
          }, f = (t2, e2, n2, r2, i2) => {
            const [s2, c2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), l2 = i2.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== i2.length) throw new Error("Dimensionality of the output should be 1");
            if (i2[0] !== n2) throw new Error("Shape of the output should be equal to logical row count");
            const p2 = (0, o.getGlsl)(t2.session.backend.glContext.version), f2 = `
      float process(int[${l2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float max = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset, ${s2},
        ${c2} )));
        for(int i=1; i<${r2}; ++i)
        {
          float current = getColorAsFloat(${p2.texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${s2}, ${c2})));
          if(current > max)
          max = current;
        }

        return max;
      }`;
            return Object.assign(Object.assign({}, u), { output: { dims: i2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
          }, d = (t2, e2, n2, r2, i2, s2) => {
            const [u2, l2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), p2 = s2.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== s2.length) throw new Error("Dimensionality of the output should be 1");
            if (s2[0] !== n2) throw new Error("Shape of the output should be equal to logical row count");
            if (1 !== i2.length) throw new Error("Dimensionality of the intermediate results should be 1");
            if (i2[0] !== n2) throw new Error("Shape of the intermediate results should be equal to logical row count");
            const f2 = `
      float process(int[${p2}] indices) {
        int logical_row_start_offset = indices[0] * ${r2};

        float norm_factor = 0.0;
        float max = _Max(indices);
        for(int i=0; i<${r2}; ++i)
        {
          norm_factor += exp(getColorAsFloat(${(0, o.getGlsl)(t2.session.backend.glContext.version).texture2D}(A, offsetToCoords(logical_row_start_offset + i,
            ${u2}, ${l2}))) - max);
        }

        return norm_factor;
      }`;
            return Object.assign(Object.assign({}, c), { output: { dims: s2, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: f2 });
          }, h = (t2, e2, n2, r2, i2, o2) => {
            const [s2, u2] = t2.calculateTextureWidthAndHeight(e2.dims, a.TextureType.unpacked), c2 = e2.dims.length;
            if (n2 < 1 || r2 < 1) throw new Error("Logical row count N and feature count D must be greater than or equal to 1");
            if (1 !== i2.length || 1 !== o2.length) throw new Error("Dimensionality of the intermediate results should be 1");
            if (i2[0] !== n2 || o2[0] !== n2) throw new Error("Shape of the intermediate results should be equal to logical row count");
            const p2 = `
      float process(int[${c2}] indices) {

      // get offset of current logical tensor index from the 2-D texture coordinates (TexCoords)
      int offset = coordsToOffset(TexCoords, ${s2}, ${u2});

      //determine the logical row for this index
      int logical_row_index[1];
      logical_row_index[0] = offset / ${r2};

      float norm_factor = _Norm(logical_row_index);

      // avoid possible division by 0
      // if norm_facor is 0, all elements are zero
      // if so, return 0
      if(norm_factor == 0.0)
        return 0.0;

      return exp(_A(indices) - _Max(logical_row_index)) / norm_factor;
    }`;
            return Object.assign(Object.assign({}, l), { output: { dims: e2.dims, type: e2.type, textureType: a.TextureType.unpacked }, shaderSource: p2 });
          }, g = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Softmax requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("Invalid input type");
          };
        }, 5975: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseSplitAttributes = e.split = void 0;
          const r = n(246), i = n(2517), o = n(2039), a = { name: "Split", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          e.split = (t2, e2, n2) => {
            c(e2);
            const r2 = i.ShapeUtil.normalizeAxis(n2.axis, e2[0].dims.length), o2 = s(t2, e2, r2, n2), l = [];
            for (let i2 = 0; i2 < o2; ++i2) l.push(t2.run(Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey};${i2}`, get: () => u(t2, e2[0], n2, r2, i2) }), e2));
            return l;
          }, e.parseSplitAttributes = (t2) => {
            const e2 = t2.attributes.getInt("axis", 0), n2 = t2.attributes.getInts("split", []), i2 = t2.outputs.length;
            return (0, r.createAttributeWithCacheKey)({ axis: e2, split: n2, numOutputs: i2 });
          };
          const s = (t2, e2, n2, r2) => {
            const [, o2] = i.SplitUtil.splitShape(e2[0].dims, n2, r2.split, r2.numOutputs);
            return o2.length;
          }, u = (t2, e2, n2, r2, s2) => {
            const [u2, c2] = i.SplitUtil.splitShape(e2.dims, r2, n2.split, n2.numOutputs), l = c2[s2], p = u2[s2], f = `
      float process(int indices[${p.length}]) {
        indices[${r2}] += ${l};
        return _A(indices);
      }
    `;
            return Object.assign(Object.assign({}, a), { cacheHint: `${n2.cacheKey}:${s2}`, output: { dims: p, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: f });
          }, c = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Split requires one input.");
            if ("int8" !== t2[0].type && "uint8" !== t2[0].type && "int16" !== t2[0].type && "uint16" !== t2[0].type && "int32" !== t2[0].type && "uint32" !== t2[0].type && "float32" !== t2[0].type && "float64" !== t2[0].type && "bool" !== t2[0].type) throw new Error("Invalid input type.");
          };
        }, 3933: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseSqueezeAttributes = e.squeezeV13 = e.squeeze = void 0;
          const r = n(2517);
          e.squeeze = (t2, e2, n2) => {
            i(e2);
            const o2 = r.ShapeUtil.squeezeShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o2)];
          }, e.squeezeV13 = (t2, n2) => (o(n2), (0, e.squeeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseSqueezeAttributes = (t2) => t2.attributes.getInts("axes");
          const i = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Squeeze requires 1 input.");
            if ("string" === t2[0].type) throw new Error("invalid input tensor types.");
          }, o = (t2) => {
            if (!t2 || 2 !== t2.length) throw new Error("Squeeze requires 2 inputs.");
            if ("int32" !== t2[1].type) throw new Error("Invalid input type.");
          };
        }, 6558: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.sum = void 0;
          const r = n(5060), i = n(2039);
          e.sum = (t2, e2) => {
            a(e2);
            const n2 = { name: "Sum", inputNames: e2.map((t3, e3) => `X${e3}`), inputTypes: new Array(e2.length).fill(i.TextureType.unpacked) };
            return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
          };
          const o = (t2, e2, n2) => {
            const o2 = (0, r.getGlsl)(t2.session.backend.glContext.version), a2 = e2[0].dims.slice(), s = `
      void main() {
        vec4 result = ${e2.map((t3, e3) => `${o2.texture2D}(X${e3},TexCoords)`).join(" + ")};
        ${o2.output} = result;
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: a2, type: e2[0].type, textureType: i.TextureType.unpacked }, hasMain: true, shaderSource: s });
          }, a = (t2) => {
            if (!t2 || 0 === t2.length) throw new Error("Sum requires inputs.");
            const e2 = t2[0].dims.length;
            for (let n2 = 1; n2 < t2.length; n2++) {
              if (e2 !== t2[n2].dims.length) throw new Error("Input shapes are mismatched.");
              for (let r2 = 0; r2 < e2; r2++) if (t2[0].dims[r2] !== t2[n2].dims[r2]) throw new Error("Input shapes are not matched.");
            }
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("Invalid input type.");
            for (let e3 = 1; e3 < t2.length; e3++) if (t2[0].type !== t2[e3].type) throw new Error("Input types are not matched.");
          };
        }, 5723: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.tile = void 0;
          const r = n(782), i = n(2039);
          e.tile = (t2, e2) => {
            a(e2);
            const n2 = { name: "Tile", inputNames: ["A"], inputTypes: [i.TextureType.unpacked] };
            return [t2.run(Object.assign(Object.assign({}, n2), { get: () => o(t2, e2, n2) }), e2)];
          };
          const o = (t2, e2, n2) => {
            const r2 = e2[0].dims.slice(), o2 = new Array(r2.length), a2 = [];
            for (let t3 = 0; t3 < r2.length; t3++) o2[t3] = r2[t3] * e2[1].numberData[t3], a2.push(`inputIdx[${t3}] = int(mod(float(outputIdx[${t3}]), ${r2[t3]}.));`);
            const s = o2.length, u = `
      float process(int outputIdx[${s}]) {
        int inputIdx[${s}];
        ${a2.join("\n")}
        return _A(inputIdx);
      }
    `;
            return Object.assign(Object.assign({}, n2), { output: { dims: o2, type: e2[0].type, textureType: i.TextureType.unpacked }, shaderSource: u });
          }, a = (t2) => {
            if (!t2 || 2 !== t2.length) throw new Error("Tile requires 2 input.");
            if (1 !== t2[1].dims.length) throw new Error("The second input shape must 1 dimension.");
            if (t2[1].dims[0] !== t2[0].dims.length) throw new Error("Invalid input shape.");
            if (-1 === r.NUMBER_TYPES.indexOf(t2[0].type)) throw new Error("Invalid input type.");
            if ("int32" !== t2[1].type && "int16" !== t2[1].type) throw new Error("Invalid repeat type.");
          };
        }, 3738: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseTransposeAttributes = e.transpose = void 0;
          const r = n(246), i = n(2517), o = n(2039), a = { name: "Transpose", inputNames: ["A"], inputTypes: [o.TextureType.unpacked] };
          e.transpose = (t2, e2, n2) => (p(e2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: n2.cacheKey, get: () => s(t2, e2[0], n2.perm) }), e2)]), e.parseTransposeAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ perm: t2.attributes.getInts("perm", []) });
          const s = (t2, e2, n2) => {
            const r2 = e2.dims;
            n2 = u(r2, n2);
            const i2 = c(r2, n2), s2 = r2.length, p2 = `
      ${l("perm", n2, s2)}
      float process(int indices[${s2}]) {
        int a[${s2}];
        perm(a, indices);
        return _A(a);
      }`;
            return Object.assign(Object.assign({}, a), { output: { dims: i2, type: e2.type, textureType: o.TextureType.unpacked }, shaderSource: p2 });
          }, u = (t2, e2) => (e2 && e2.length !== t2.length && (e2 = [...t2.keys()].reverse()), e2), c = (t2, e2) => (e2 = u(t2, e2), i.ShapeUtil.sortBasedOnPerm(t2, e2)), l = (t2, e2, n2) => {
            const r2 = [];
            r2.push(`void ${t2}(out int a[${n2}], int src[${n2}]) {`);
            for (let t3 = 0; t3 < n2; ++t3) r2.push(`	a[${e2[t3]}]=src[${t3}];`);
            return r2.push("	}"), r2.join("\n");
          }, p = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Transpose requires 1 input.");
            if ("float32" !== t2[0].type && "float64" !== t2[0].type) throw new Error("input should be float tensor");
          };
        }, 8710: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.encodeAsUint8 = void 0;
          const r = n(5060), i = n(2039);
          e.encodeAsUint8 = (t2, e2) => {
            const n2 = e2.shape, o = (0, r.getGlsl)(t2.session.backend.glContext.version), a = `
    const float FLOAT_MAX = 1.70141184e38;
    const float FLOAT_MIN = 1.17549435e-38;

    bool isNaN(float val) {
      return (val < 1.0 || 0.0 < val || val == 0.0) ? false : true;
    }

    highp vec4 encodeAsUint8(highp float v) {
      if (isNaN(v)) {
        return vec4(255, 255, 255, 255);
      }

      highp float av = abs(v);

      if(av < FLOAT_MIN) {
        return vec4(0.0, 0.0, 0.0, 0.0);
      } else if(v > FLOAT_MAX) {
        return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
      } else if(v < -FLOAT_MAX) {
        return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
      }

      highp vec4 c = vec4(0,0,0,0);

      highp float e = floor(log2(av));
      highp float m = exp2(fract(log2(av))) - 1.0;

      c[2] = floor(128.0 * m);
      m -= c[2] / 128.0;
      c[1] = floor(32768.0 * m);
      m -= c[1] / 32768.0;
      c[0] = floor(8388608.0 * m);

      highp float ebias = e + 127.0;
      c[3] = floor(ebias / 2.0);
      ebias -= c[3] * 2.0;
      c[2] += floor(ebias) * 128.0;

      c[3] += 128.0 * step(0.0, -v);

      return c / 255.0;
    }

    void main() {
      float value = ${o.texture2D}(X,TexCoords).r;
      ${o.output} = encodeAsUint8(value);
    }`, s = { name: "Uint8Encode", inputTypes: [i.TextureType.unpacked], inputNames: ["X"], output: { dims: n2, type: e2.tensor.type, textureType: i.TextureType.downloadUint8AsFloat }, shaderSource: a, hasMain: true };
            return t2.executeProgram(s, [e2.tensor]);
          };
        }, 4909: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.tanh = e.tan = e.sqrt = e.sin = e.sigmoid = e.relu = e.not = e.neg = e.log = e.parseLeakyReluAttributes = e.leakyRelu = e.identity = e.floor = e.exp = e.parseEluAttributes = e.elu = e.cos = e.ceil = e.clipV11 = e.parseClipAttributes = e.clip = e.atan = e.asin = e.acos = e.abs = e.glslTanh = e.glslTan = e.glslSqrt = e.glslSigmoid = e.glslRelu = e.glslSin = e.glslNot = e.glslNeg = e.glslLog = e.glslLeakyRelu = e.glslIdentity = e.glslClip = e.glslFloor = e.glslExp = e.glslElu = e.glslCos = e.glslCeil = e.glslAtan = e.glslAsin = e.glslAcos = e.glslAbs = void 0;
          const r = n(246), i = n(2517), o = n(8520), a = n(5060), s = n(2039);
          function u() {
            return P("abs");
          }
          function c() {
            return P("acos");
          }
          function l() {
            return P("asin");
          }
          function p() {
            return P("atan");
          }
          function f() {
            return P("ceil");
          }
          function d() {
            return P("cos");
          }
          function h(t2) {
            const e2 = "elu";
            return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a >= 0.0 ? a: (exp(a) - 1.0) * alpha;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
          }
          function g() {
            return P("exp");
          }
          function b() {
            return P("floor");
          }
          function m(t2, e2) {
            const n2 = "clip";
            return { body: `
  const float min = float(${t2});
  const float max = float(${e2});

  float ${n2}_(float a) {
    return clamp(a, min, max);
  }
  vec4 ${n2}_(vec4 v) {
    return clamp(v, min, max);
  }
  `, name: n2, type: o.FunctionType.ValueBased };
          }
          function y() {
            const t2 = "indentity";
            return { body: `
  float ${t2}_(float a) {
    return a;
  }
  vec4 ${t2}_(vec4 v) {
    return v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function _(t2) {
            const e2 = "leakyRelu";
            return { body: `
  const float alpha = float(${t2});

  float ${e2}_(float a) {
    return a < 0.0 ? a * alpha : a;
  }
  vec4 ${e2}_(vec4 v) {
    return vec4(${e2}_(v.x), ${e2}_(v.y), ${e2}_(v.z), ${e2}_(v.w));
  }
  `, name: e2, type: o.FunctionType.ValueBased };
          }
          function v() {
            return P("log");
          }
          function w() {
            const t2 = "neg";
            return { body: `
  float ${t2}_(float a) {
    return -a;
  }
  vec4 ${t2}_(vec4 v) {
    return -v;
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function x() {
            const t2 = "not";
            return { body: `
  float ${t2}_(float a) {
    return float( ! bool(a) );
  }
  bool ${t2}_(bool a) {
    return !a;
  }
  vec4 ${t2}_(vec4 v) {
    return vec4(!bool(v.x), !bool(v.y), !bool(v.z), !bool(v.w));
  }
  bvec4 ${t2}_(bvec4 v) {
    return bvec4(!v.x, !v.y, !v.z, !v.w);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function T() {
            return P("sin");
          }
          function S() {
            const t2 = "relu";
            return { body: `
  float ${t2}_(float a) {
    return max( a, 0.0 );
  }
  vec4 ${t2}_(vec4 v) {
    return max( v, 0.0 );
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function O() {
            const t2 = "sigmoid";
            return { body: `
  float ${t2}_(float a) {
    return 1.0 / (1.0 + exp(-a));
  }
  vec4 ${t2}_(vec4 v) {
    return 1.0 / (1.0 + exp(-v));
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function A() {
            return P("sqrt");
          }
          function E() {
            return P("tan");
          }
          function I() {
            const t2 = "tanh";
            return { body: `
  float ${t2}_(float a) {
    a = clamp(a, -10., 10.);
    a = exp(2.*a);
    return (a - 1.) / (a + 1.);
  }
  vec4 ${t2}_(vec4 v) {
    v = clamp(v, -10., 10.);
    v = exp(2.*v);
    return (v - 1.) / (v + 1.);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          function P(t2) {
            return { body: `
  float ${t2}_(float a) {
    return ${t2}(a);
  }
  vec4 ${t2}_(vec4 v) {
    return ${t2}(v);
  }
  `, name: t2, type: o.FunctionType.ValueBased };
          }
          e.glslAbs = u, e.glslAcos = c, e.glslAsin = l, e.glslAtan = p, e.glslCeil = f, e.glslCos = d, e.glslElu = h, e.glslExp = g, e.glslFloor = b, e.glslClip = m, e.glslIdentity = y, e.glslLeakyRelu = _, e.glslLog = v, e.glslNeg = w, e.glslNot = x, e.glslSin = T, e.glslRelu = S, e.glslSigmoid = O, e.glslSqrt = A, e.glslTan = E, e.glslTanh = I;
          const D = (t2, e2, n2, r2) => {
            const i2 = t2.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o2 = { name: n2.name, inputTypes: [i2], inputNames: ["A"], cacheHint: r2 };
            return Object.assign(Object.assign({}, o2), { get: () => ((t3, e3, n3, r3) => {
              const i3 = t3.session.pack ? s.TextureType.packed : s.TextureType.unpacked, o3 = (0, a.getGlsl)(t3.session.backend.glContext.version);
              return Object.assign(Object.assign({}, e3), { output: { dims: n3.dims, type: n3.type, textureType: i3 }, shaderSource: `
     ${r3.body}
     void main() {
       vec4 v = ${o3.texture2D}(A, TexCoords);
       v = ${r3.name}_(v);
       ${o3.output} = v;
     }
     `, hasMain: true });
            })(t2, o2, e2, n2) });
          };
          e.abs = (t2, e2) => [t2.run(D(t2, e2[0], u()), e2)], e.acos = (t2, e2) => [t2.run(D(t2, e2[0], c()), e2)], e.asin = (t2, e2) => [t2.run(D(t2, e2[0], l()), e2)], e.atan = (t2, e2) => [t2.run(D(t2, e2[0], p()), e2)], e.clip = (t2, e2, n2) => [t2.run(D(t2, e2[0], m(n2.min, n2.max), n2.cacheKey), e2)], e.parseClipAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ min: t2.attributes.getFloat("min", i.MIN_CLIP), max: t2.attributes.getFloat("max", i.MAX_CLIP) }), e.clipV11 = (t2, n2) => {
            const r2 = $(t2, n2);
            return (0, e.clip)(t2, [n2[0]], r2);
          };
          const $ = (t2, e2) => {
            if (e2.length >= 3 && (!t2.session.isInitializer(e2[1].dataId) || !t2.session.isInitializer(e2[2].dataId))) throw new Error("dynamic clip attributes are not allowed");
            const n2 = e2.length >= 3 ? e2[1].numberData[0] : i.MIN_CLIP, o2 = e2.length >= 3 ? e2[2].numberData[0] : i.MAX_CLIP;
            return (0, r.createAttributeWithCacheKey)({ min: n2, max: o2 });
          };
          e.ceil = (t2, e2) => [t2.run(D(t2, e2[0], f()), e2)], e.cos = (t2, e2) => [t2.run(D(t2, e2[0], d()), e2)], e.elu = (t2, e2, n2) => [t2.run(D(t2, e2[0], h(n2.alpha), n2.cacheKey), e2)], e.parseEluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 1) }), e.exp = (t2, e2) => [t2.run(D(t2, e2[0], g()), e2)], e.floor = (t2, e2) => [t2.run(D(t2, e2[0], b()), e2)], e.identity = (t2, e2) => [t2.run(D(t2, e2[0], y()), e2)], e.leakyRelu = (t2, e2, n2) => [t2.run(D(t2, e2[0], _(n2.alpha), n2.cacheKey), e2)], e.parseLeakyReluAttributes = (t2) => (0, r.createAttributeWithCacheKey)({ alpha: t2.attributes.getFloat("alpha", 0.01) }), e.log = (t2, e2) => [t2.run(D(t2, e2[0], v()), e2)], e.neg = (t2, e2) => [t2.run(D(t2, e2[0], w()), e2)], e.not = (t2, e2) => [t2.run(D(t2, e2[0], x()), e2)], e.relu = (t2, e2) => [t2.run(D(t2, e2[0], S()), e2)], e.sigmoid = (t2, e2) => [t2.run(D(t2, e2[0], O()), e2)], e.sin = (t2, e2) => [t2.run(D(t2, e2[0], T()), e2)], e.sqrt = (t2, e2) => [t2.run(D(t2, e2[0], A()), e2)], e.tan = (t2, e2) => [t2.run(D(t2, e2[0], E()), e2)], e.tanh = (t2, e2) => [t2.run(D(t2, e2[0], I()), e2)];
        }, 5611: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createUnpackProgramInfoLoader = e.createUnpackProgramInfo = void 0;
          const r = n(5060), i = n(2039), o = n(9390), a = n(2827), s = { name: "unpack", inputNames: ["A"], inputTypes: [i.TextureType.packed] };
          e.createUnpackProgramInfo = (t2, e2) => {
            const n2 = e2.dims.length, u = (0, a.getChannels)("rc", n2), c = u.slice(-2), l = (0, o.getCoordsDataType)(n2), p = (0, a.unpackFromChannel)(), f = 0 === e2.dims.length ? "" : function(t3, e3) {
              if (1 === t3) return "rc";
              let n3 = "";
              for (let r2 = 0; r2 < t3; r2++) n3 += e3[r2], r2 < t3 - 1 && (n3 += ",");
              return n3;
            }(n2, u), d = n2 <= 1 ? "rc" : `vec2(${c.join(",")})`, h = `
    ${p}
    void main() {
      ${l} rc = getOutputCoords();

       // Sample the texture with the coords to get the rgba channel value.
       vec4 packedInput = getA(${f});

       ${(0, r.getGlsl)(t2.session.backend.glContext.version).output} = vec4(getChannel(packedInput, ${d}), 0, 0, 0);
     }
   `;
            return Object.assign(Object.assign({}, s), { hasMain: true, output: { dims: e2.dims, type: e2.type, textureType: i.TextureType.unpacked }, shaderSource: h });
          }, e.createUnpackProgramInfoLoader = (t2, n2) => Object.assign(Object.assign({}, s), { get: () => (0, e.createUnpackProgramInfo)(t2, n2) });
        }, 8428: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.parseUnsqueezeAttributes = e.unsqueezeV13 = e.unsqueeze = void 0;
          const r = n(2517);
          e.unsqueeze = (t2, e2, n2) => {
            i(e2);
            const o2 = r.ShapeUtil.unsqueezeShape(e2[0].dims, n2);
            return [t2.reshapeUnpacked(e2[0], o2)];
          }, e.unsqueezeV13 = (t2, n2) => (o(n2), (0, e.unsqueeze)(t2, [n2[0]], Array.from(n2[1].integerData))), e.parseUnsqueezeAttributes = (t2) => t2.attributes.getInts("axes");
          const i = (t2) => {
            if (!t2 || 1 !== t2.length) throw new Error("Unsqueeze requires 1 input.");
            if ("string" === t2[0].type) throw new Error("invalid input tensor types.");
          }, o = (t2) => {
            if (!t2 || 2 !== t2.length) throw new Error("Unsqueeze requires 2 inputs.");
            if ("int32" !== t2[1].type) throw new Error("Invalid input type.");
          };
        }, 9793: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.scalesValidation = e.validateInputs = e.parseUpsampleAttributes = e.parseUpsampleAttributesV9 = e.parseUpsampleAttributesV7 = e.upsample = void 0;
          const r = n(246), i = n(5060), o = n(2039), a = { name: "Upsample", inputNames: ["X"], inputTypes: [o.TextureType.unpacked] };
          e.upsample = (t2, n2, r2) => ((0, e.validateInputs)(n2, r2), [t2.run(Object.assign(Object.assign({}, a), { cacheHint: r2.cacheKey, get: () => s(t2, n2, r2) }), n2)]), e.parseUpsampleAttributesV7 = (t2) => (0, e.parseUpsampleAttributes)(t2, 7), e.parseUpsampleAttributesV9 = (t2) => (0, e.parseUpsampleAttributes)(t2, 9), e.parseUpsampleAttributes = (t2, n2) => {
            const i2 = n2 >= 10, o2 = t2.attributes.getString("mode", "nearest");
            if ("nearest" !== o2 && "linear" !== o2 && (n2 < 11 || "cubic" !== o2)) throw new Error(`unrecognized mode: ${o2}`);
            let a2 = [];
            n2 < 9 && (a2 = t2.attributes.getFloats("scales"), (0, e.scalesValidation)(a2, o2, i2));
            const s2 = t2.attributes.getFloat("extrapolation_value", 0), u = n2 > 10 ? t2.attributes.getString("coordinate_transformation_mode", "half_pixel") : "asymmetric";
            if (-1 === ["asymmetric", "pytorch_half_pixel", "tf_half_pixel_for_nn", "align_corners", "tf_crop_and_resize", "half_pixel"].indexOf(u)) throw new Error(`coordinate_transform_mode '${u}' is not supported`);
            const c = "tf_crop_and_resize" === u, l = c, p = "nearest" === o2 && n2 >= 11 ? t2.attributes.getString("nearest_mode", "round_prefer_floor") : "";
            if (-1 === ["round_prefer_floor", "round_prefer_ceil", "floor", "ceil", ""].indexOf(p)) throw new Error(`nearest_mode '${p}' is not supported`);
            const f = t2.attributes.getFloat("cubic_coeff_a", -0.75), d = 0 !== t2.attributes.getInt("exclude_outside", 0);
            if (d && "cubic" !== o2) throw new Error("exclude_outside can be set to 1 only when mode is CUBIC.");
            const h = n2 < 11 || "nearest" === o2 && "asymmetric" === u && "floor" === p;
            let g = 0, b = 0, m = 0;
            return n2 > 10 ? t2.inputs.length > 2 ? (g = 1, b = 2, m = 3) : (b = 1, m = 2) : 9 === n2 && (b = 1), (0, r.createAttributeWithCacheKey)({ opset: n2, isResize: i2, mode: o2, scales: a2, extrapolationValue: s2, coordinateTransformMode: u, useExtrapolation: l, needRoiInput: c, nearestMode: p, cubicCoefficientA: f, excludeOutside: d, useNearest2xOptimization: h, roiInputIdx: g, scalesInputIdx: b, sizesInputIdx: m });
          };
          const s = (t2, e2, n2) => {
            const r2 = (0, i.getGlsl)(t2.session.backend.glContext.version), [s2, u] = t2.calculateTextureWidthAndHeight(e2[0].dims, o.TextureType.unpacked), c = e2[0].dims.map((t3, e3) => Math.floor(t3 * n2.scales[e3])), [l, p] = t2.calculateTextureWidthAndHeight(c, o.TextureType.unpacked), f = c.length, d = new Array(f), h = new Array(f);
            let g = `
      int output_pitches[${f}];
      int input_pitches[${f}];
      `;
            for (let t3 = f - 1; t3 >= 0; t3--) d[t3] = t3 === f - 1 ? 1 : d[t3 + 1] * c[t3 + 1], h[t3] = t3 === f - 1 ? 1 : h[t3 + 1] * e2[0].dims[t3 + 1], g += `
        output_pitches[${t3}] = ${d[t3]};
        input_pitches[${t3}] = ${h[t3]};
        `;
            const b = `
      float getInputFloat(int index) {
        vec2 coords = offsetToCoords(index, ${s2}, ${u});
        float value = getColorAsFloat(${r2.texture2D}(X, coords));
        return value;
      }
      `, m = "nearest" === n2.mode ? `
    ${b}
    float process(int indices[${f}]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int d, m;
      for (int dim = 0; dim < ${f}; ++dim) {
        d = output_index / output_pitches[dim];
        m = output_index - d * output_pitches[dim];
        output_index = m;

        if (scales[dim] != 1 && d > 0) {
          int d2 = d / scales[dim];
          m = d - d2 * scales[dim];
          d = d2;
        }
        input_index += input_pitches[dim] * d;
      }

      return getInputFloat(input_index);
    }` : 4 === f ? `
    ${b}
    float process(int indices[4]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1, index_of_dim2, index_of_dim3;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m / output_pitches[1];
      m = m - index_of_dim1 * output_pitches[1];
      index_of_dim2 = m / output_pitches[2];
      m = m - index_of_dim2 * output_pitches[2];
      index_of_dim3 = m;

      int index_of_input_dim2, index_of_input_dim3, x_offset, y_offset;
      index_of_input_dim2 = index_of_dim2 / scales[2];
      y_offset = index_of_dim2 - index_of_input_dim2 * scales[2];
      index_of_input_dim3 = index_of_dim3 / scales[3];
      x_offset = index_of_dim3 - index_of_input_dim3 * scales[3];

      input_index = index_of_dim0 * input_pitches[0] +
            index_of_dim1 * input_pitches[1] +
            index_of_input_dim2 * input_pitches[2] +
            index_of_input_dim3;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim2 = false;
      if (index_of_input_dim2 == (${e2[0].dims[2]} - 1)) {
        // It's the end in dimension 2
        x01 = x00;
        end_of_dim2 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[2]);
      }

      if (index_of_input_dim3 == (input_pitches[2] - 1)) {
        // It's the end in dimension 3
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim2 ? x10 : getInputFloat(input_index + input_pitches[2] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[2]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[2]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[3]);
    }` : `
    ${b}
    float process(int indices[2]) {
      int input_index = 0;
      int output_index = coordsToOffset(TexCoords, ${l}, ${p});

      ${g}

      int m;
      int index_of_dim0, index_of_dim1;
      index_of_dim0 = output_index / output_pitches[0];
      m = output_index - index_of_dim0 * output_pitches[0];
      index_of_dim1 = m;

      int index_of_input_dim0, index_of_input_dim1, x_offset, y_offset;
      index_of_input_dim0 = index_of_dim0 / scales[0];
      y_offset = index_of_dim0 - index_of_input_dim0 * scales[0];
      index_of_input_dim1 = index_of_dim1 / scales[1];
      x_offset = index_of_dim1 - index_of_input_dim1 * scales[1];

      input_index = index_of_input_dim0 * input_pitches[0] + index_of_input_dim1;

      float x00 = getInputFloat(input_index);
      float x10, x01, x11;

      bool end_of_dim0 = false;
      if (index_of_input_dim0 == (${e2[0].dims[0]} - 1)) {
        // It's the end in dimension 0
        x01 = x00;
        end_of_dim0 = true;
      } else {
        x01 = getInputFloat(input_index + input_pitches[0]);
      }

      if (index_of_input_dim1 == (input_pitches[0] - 1)) {
        // It's the end in dimension 1
        x10 = x00;
        x11 = x01;
      }
      else {
        x10 = getInputFloat(input_index + 1);
        x11 = end_of_dim0 ? x10 : getInputFloat(input_index + input_pitches[0] + 1);
      }

      float y0 = x00 + float(y_offset) * (x01 - x00) / float(scales[0]);
      float y1 = x10 + float(y_offset) * (x11 - x10) / float(scales[0]);
      return y0 + float(x_offset) * (y1 - y0) / float(scales[1]);
    }`;
            return Object.assign(Object.assign({}, a), { output: { dims: c, type: e2[0].type, textureType: o.TextureType.unpacked }, shaderSource: m, variables: [{ name: "scales", type: "int", arrayLength: n2.scales.length, data: n2.scales.map((t3) => Math.ceil(t3)) }] });
          };
          e.validateInputs = (t2, e2) => {
            if (!t2 || e2.opset < 9 && 1 !== t2.length || e2.opset >= 9 && e2.opset < 11 && 2 !== t2.length || e2.opset >= 11 && t2.length < 2) throw new Error("invalid inputs.");
            if (e2.scales.length > 0 && t2[0].dims.length !== e2.scales.length) throw new Error("Invalid input shape.");
            if ("string" === t2[0].type) throw new Error("Invalid input tensor types.");
          }, e.scalesValidation = (t2, e2, n2) => {
            if (n2) {
              for (const e3 of t2) if (e3 <= 0) throw new Error("Scale value should be greater than 0.");
            } else for (const e3 of t2) if (e3 < 1) throw new Error("Scale value should be greater than or equal to 1.");
            if (!("linear" !== e2 && "cubic" !== e2 || 2 === t2.length || 4 === t2.length && 1 === t2[0] && 1 === t2[1])) throw new Error(`'Linear' mode and 'Cubic' mode only support 2-D inputs ('Bilinear', 'Bicubic')         or 4-D inputs with the corresponding outermost 2 scale values being 1         in the ${n2 ? "Resize" : "Upsample"} opeartor.`);
          };
        }, 1958: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.ProgramManager = void 0;
          const r = n(1670), i = n(6231), o = n(8879), a = n(5060);
          e.ProgramManager = class {
            constructor(t2, e2, n2) {
              this.profiler = t2, this.glContext = e2, this.textureLayoutStrategy = n2, this.repo = /* @__PURE__ */ new Map(), this.attributesBound = false;
            }
            getArtifact(t2) {
              return this.repo.get(t2);
            }
            setArtifact(t2, e2) {
              this.repo.set(t2, e2);
            }
            run(t2, e2, n2) {
              var r2;
              this.profiler.event("op", `ProgramManager.run ${null !== (r2 = t2.programInfo.name) && void 0 !== r2 ? r2 : "unknown kernel"}`, () => {
                var r3;
                const o2 = this.glContext.gl, a2 = t2.program;
                o2.useProgram(a2);
                try {
                  this.bindOutput(n2), this.attributesBound || this.bindAttributes(t2.attribLocations), this.bindUniforms(t2.uniformLocations, null !== (r3 = t2.programInfo.variables) && void 0 !== r3 ? r3 : [], e2);
                } catch (e3) {
                  throw i.Logger.error("ProgramManager", t2.programInfo.shaderSource), e3;
                }
                this.profiler.event("backend", "GlContext.draw()", () => {
                  this.glContext.draw();
                });
              }, this.glContext);
            }
            dispose() {
              this.vertexShader && this.glContext.deleteShader(this.vertexShader), this.repo.forEach((t2) => this.glContext.deleteProgram(t2.program));
            }
            build(t2, e2, n2) {
              return this.profiler.event("backend", "ProgramManager.build", () => {
                const r2 = new o.GlslPreprocessor(this.glContext, t2, e2, n2), i2 = r2.preprocess(), a2 = this.compile(i2);
                return { programInfo: t2, program: a2, uniformLocations: this.getUniformLocations(a2, r2.context.programInfo.inputNames, r2.context.programInfo.variables), attribLocations: this.getAttribLocations(a2) };
              });
            }
            compile(t2) {
              if (!this.vertexShader) {
                i.Logger.verbose("ProrgramManager", "Compiling and caching Vertex shader for the first time");
                const t3 = (0, a.getVertexShaderSource)(this.glContext.version);
                this.vertexShader = this.glContext.compileShader(t3, this.glContext.gl.VERTEX_SHADER);
              }
              r.env.debug && i.Logger.verbose("ProrgramManager", `FragShader:
${t2}
`);
              const e2 = this.glContext.compileShader(t2, this.glContext.gl.FRAGMENT_SHADER), n2 = this.glContext.createProgram(this.vertexShader, e2);
              return this.glContext.deleteShader(e2), n2;
            }
            bindOutput(t2) {
              const e2 = t2.width, n2 = t2.height;
              i.Logger.verbose("ProrgramManager", `Binding output texture to Framebuffer: w/h=${e2}/${n2}, shape=${t2.shape}, type=${t2.tensor.type}`), this.glContext.attachFramebuffer(t2.texture, e2, n2);
            }
            bindAttributes(t2) {
              const e2 = t2.position, n2 = t2.textureCoord;
              this.glContext.setVertexAttributes(e2, n2), this.attributesBound = true;
            }
            bindUniforms(t2, e2, n2) {
              var r2;
              const i2 = this.glContext.gl;
              let o2 = 0;
              for (const { name: a2, type: s, location: u, arrayLength: c } of t2) {
                const t3 = null === (r2 = e2.find((t4) => t4.name === a2)) || void 0 === r2 ? void 0 : r2.data;
                if ("sampler2D" !== s && !t3) throw new Error(`variable '${a2}' does not have data defined in program info`);
                switch (s) {
                  case "sampler2D":
                    this.bindTexture(n2[o2], u, o2), o2++;
                    break;
                  case "float":
                    c ? i2.uniform1fv(u, t3) : i2.uniform1f(u, t3);
                    break;
                  case "int":
                    c ? i2.uniform1iv(u, t3) : i2.uniform1i(u, t3);
                    break;
                  default:
                    throw new Error(`Uniform not implemented: ${s}`);
                }
              }
            }
            bindTexture(t2, e2, n2) {
              this.glContext.bindTextureToUniform(t2.texture, n2, e2);
            }
            getAttribLocations(t2) {
              return { position: this.getAttribLocation(t2, "position"), textureCoord: this.getAttribLocation(t2, "textureCoord") };
            }
            getUniformLocations(t2, e2, n2) {
              const r2 = [];
              if (e2) for (const n3 of e2) r2.push({ name: n3, type: "sampler2D", location: this.getUniformLocation(t2, n3) });
              if (n2) for (const e3 of n2) r2.push(Object.assign(Object.assign({}, e3), { location: this.getUniformLocation(t2, e3.name) }));
              return r2;
            }
            getUniformLocation(t2, e2) {
              const n2 = this.glContext.gl.getUniformLocation(t2, e2);
              if (null === n2) throw new Error(`Uniform ${e2} not found.`);
              return n2;
            }
            getAttribLocation(t2, e2) {
              return this.glContext.gl.getAttribLocation(t2, e2);
            }
          };
        }, 6416: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLSessionHandler = void 0;
          const r = n(6231), i = n(1047), o = n(8316), a = n(1640), s = n(1958), u = n(7859), c = n(5702);
          e.WebGLSessionHandler = class {
            constructor(t2, e2) {
              this.backend = t2, this.context = e2, this.layoutStrategy = new u.PreferLogicalStrategy(t2.glContext.maxTextureSize), this.programManager = new s.ProgramManager(this.context.profiler, t2.glContext, this.layoutStrategy), this.textureManager = new c.TextureManager(t2.glContext, this.layoutStrategy, this.context.profiler, { reuseTextures: "full" === t2.textureCacheMode }), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache = /* @__PURE__ */ new Map(), this.pack = t2.pack, this.pack2unpackMap = /* @__PURE__ */ new Map(), this.unpack2packMap = /* @__PURE__ */ new Map();
            }
            createInferenceHandler() {
              return new o.WebGLInferenceHandler(this);
            }
            onGraphInitialized(t2) {
              const e2 = t2.getValues().filter((t3) => -1 === t3.from && t3.tensor).map((t3) => t3.tensor.dataId);
              this.initializers = new Set(e2);
            }
            isInitializer(t2) {
              return !!this.initializers && this.initializers.has(t2);
            }
            addInitializer(t2) {
              this.initializers.add(t2);
            }
            getTextureData(t2, e2) {
              return e2 ? this.packedTextureDataCache.get(t2) : this.unpackedTextureDataCache.get(t2);
            }
            setTextureData(t2, e2, n2 = false) {
              r.Logger.verbose("WebGLSessionHandler", "Storing Texture data in cache"), n2 ? this.packedTextureDataCache.set(t2, e2) : this.unpackedTextureDataCache.set(t2, e2);
            }
            dispose() {
              this.programManager.dispose(), this.textureManager.clearActiveTextures(), this.packedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.packedTextureDataCache = /* @__PURE__ */ new Map(), this.unpackedTextureDataCache.forEach((t2) => this.textureManager.releaseTexture(t2, true)), this.unpackedTextureDataCache = /* @__PURE__ */ new Map();
            }
            resolve(t2, e2, n2) {
              const r2 = (0, i.resolveOperator)(t2, e2, a.WEBGL_OP_RESOLVE_RULES);
              return { impl: r2.opImpl, context: r2.opInit ? r2.opInit(t2, n2) : t2 };
            }
          };
        }, 7769: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.Uint8DataEncoder = e.RGBAFloatDataEncoder = e.RedFloat32DataEncoder = void 0;
          const r = n(6231);
          e.RedFloat32DataEncoder = class {
            constructor(t2, e2 = 1) {
              if (1 === e2) this.internalFormat = t2.R32F, this.format = t2.RED, this.textureType = t2.FLOAT, this.channelSize = e2;
              else {
                if (4 !== e2) throw new Error(`Invalid number of channels: ${e2}`);
                this.internalFormat = t2.RGBA32F, this.format = t2.RGBA, this.textureType = t2.FLOAT, this.channelSize = e2;
              }
            }
            encode(t2, e2) {
              let n2, i;
              return t2.constructor !== Float32Array && (r.Logger.warning("Encoder", "data was not of type Float32; creating new Float32Array"), i = new Float32Array(t2)), e2 * this.channelSize > t2.length ? (r.Logger.warning("Encoder", "Source data too small. Allocating larger array"), i = t2, n2 = this.allocate(e2 * this.channelSize), i.forEach((t3, e3) => n2[e3] = t3)) : (i = t2, n2 = i), n2;
            }
            allocate(t2) {
              return new Float32Array(4 * t2);
            }
            decode(t2, e2) {
              return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
            }
          }, e.RGBAFloatDataEncoder = class {
            constructor(t2, e2 = 1, n2) {
              if (1 !== e2 && 4 !== e2) throw new Error(`Invalid number of channels: ${e2}`);
              this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.channelSize = e2, this.textureType = n2 || t2.FLOAT;
            }
            encode(t2, e2) {
              let n2 = t2;
              return 1 === this.channelSize && (r.Logger.verbose("Encoder", "Exploding into a larger array"), n2 = this.allocate(e2), t2.forEach((t3, e3) => n2[4 * e3] = t3)), n2;
            }
            allocate(t2) {
              return new Float32Array(4 * t2);
            }
            decode(t2, e2) {
              return 1 === this.channelSize ? t2.filter((t3, e3) => e3 % 4 == 0).subarray(0, e2) : t2.subarray(0, e2);
            }
          }, e.Uint8DataEncoder = class {
            constructor(t2, e2 = 1) {
              if (this.channelSize = 4, 1 === e2) this.internalFormat = t2.ALPHA, this.format = t2.ALPHA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
              else {
                if (4 !== e2) throw new Error(`Invalid number of channels: ${e2}`);
                this.internalFormat = t2.RGBA, this.format = t2.RGBA, this.textureType = t2.UNSIGNED_BYTE, this.channelSize = e2;
              }
            }
            encode(t2, e2) {
              return new Uint8Array(t2.buffer, t2.byteOffset, t2.byteLength);
            }
            allocate(t2) {
              return new Uint8Array(t2 * this.channelSize);
            }
            decode(t2, e2) {
              if (t2 instanceof Uint8Array) return t2.subarray(0, e2);
              throw new Error(`Invalid array type: ${t2.constructor}`);
            }
          };
        }, 7859: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.getBatchDim = e.sizeToSquarishShape = e.getRowsCols = e.sizeFromShape = e.isInt = e.parseAxisParam = e.squeezeShape = e.PreferLogicalStrategy = e.AlwaysKeepOriginalSizeStrategy = void 0;
          const r = n(6231), i = n(2517);
          function o(t2, e2) {
            const n2 = [], r2 = [], i2 = null != e2 && Array.isArray(e2) && 0 === e2.length, o2 = null == e2 || i2 ? null : a(e2, t2).sort();
            let s2 = 0;
            for (let e3 = 0; e3 < t2.length; ++e3) {
              if (null != o2) {
                if (o2[s2] === e3 && 1 !== t2[e3]) throw new Error(`Can't squeeze axis ${e3} since its dim '${t2[e3]}' is not 1`);
                (null == o2[s2] || o2[s2] > e3) && 1 === t2[e3] && (n2.push(t2[e3]), r2.push(e3)), o2[s2] <= e3 && s2++;
              }
              1 !== t2[e3] && (n2.push(t2[e3]), r2.push(e3));
            }
            return { newShape: n2, keptDims: r2 };
          }
          function a(t2, e2) {
            const n2 = e2.length;
            return t2 = null == t2 ? e2.map((t3, e3) => e3) : [].concat(t2), (0, i.assert)(t2.every((t3) => t3 >= -n2 && t3 < n2), () => `All values in axis param must be in range [-${n2}, ${n2}) but got axis ${t2}`), (0, i.assert)(t2.every(s), () => `All values in axis param must be integers but got axis ${t2}`), t2.map((t3) => t3 < 0 ? n2 + t3 : t3);
          }
          function s(t2) {
            return t2 % 1 == 0;
          }
          function u(t2) {
            if (0 === t2.length) return 1;
            let e2 = t2[0];
            for (let n2 = 1; n2 < t2.length; n2++) e2 *= t2[n2];
            return e2;
          }
          function c(t2) {
            const e2 = Math.ceil(Math.sqrt(t2));
            return [e2, Math.ceil(t2 / e2)];
          }
          e.AlwaysKeepOriginalSizeStrategy = class {
            constructor(t2) {
              this.maxTextureSize = t2;
            }
            computeTextureWH(t2, e2) {
              if (0 === t2.length) return [1, 1];
              const n2 = this.maxTextureSize;
              if (e2 && void 0 !== e2.breakAxis) {
                const i3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o3 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                if (!(i3 > n2 || o3 > n2)) return [i3, o3];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
              }
              const i2 = t2.reduce((t3, e3) => t3 * e3);
              let o2 = Math.floor(Math.sqrt(i2));
              for (; o2 < n2 && o2 < i2 && i2 % o2 != 0; o2++) ;
              if (o2 >= n2 || i2 % o2 != 0) throw new Error(`The given dimensions are outside this GPU's boundaries: ${t2}`);
              return [o2, i2 / o2];
            }
          }, e.PreferLogicalStrategy = class {
            constructor(t2) {
              this.maxTextureSize = t2;
            }
            computeTextureWH(t2, e2) {
              const n2 = this.computeTexture(t2, e2);
              return e2 && e2.isPacked && (n2[0] /= 2, n2[1] /= 2), e2 && e2.reverseWH ? [n2[1], n2[0]] : n2;
            }
            computeTexture(t2, e2) {
              const n2 = e2 && e2.isPacked;
              if (0 === t2.length) return n2 ? [2, 2] : [1, 1];
              let i2 = this.maxTextureSize;
              if (e2 && void 0 !== e2.breakAxis) {
                const n3 = e2.breakAxis >= t2.length ? 1 : t2.slice(e2.breakAxis).reduce((t3, e3) => t3 * e3), o2 = e2.breakAxis <= 0 ? 1 : t2.slice(0, e2.breakAxis).reduce((t3, e3) => t3 * e3);
                if (!(n3 > i2 || o2 > i2)) return [n3, o2];
                r.Logger.verbose("TextureLayout", `Given width/height preferences were unattainable: shape:${t2}, breakAxis:${e2.breakAxis}`);
              }
              let a2 = t2.slice(0);
              if (n2 && (i2 *= 2, a2 = a2.map((t3, e3) => e3 >= a2.length - 2 ? a2[e3] % 2 == 0 ? a2[e3] : a2[e3] + 1 : a2[e3]), 1 === a2.length && (a2 = [2, a2[0]])), 2 !== a2.length) {
                const t3 = o(a2);
                a2 = t3.newShape;
              }
              const s2 = u(a2);
              return a2.length <= 1 && s2 <= i2 ? [1, s2] : 2 === a2.length && a2[0] <= i2 && a2[1] <= i2 ? a2 : 3 === a2.length && a2[0] * a2[1] <= i2 && a2[2] <= i2 ? [a2[0] * a2[1], a2[2]] : 3 === a2.length && a2[0] <= i2 && a2[1] * a2[2] <= i2 ? [a2[0], a2[1] * a2[2]] : 4 === a2.length && a2[0] * a2[1] * a2[2] <= i2 && a2[3] <= i2 ? [a2[0] * a2[1] * a2[2], a2[3]] : 4 === a2.length && a2[0] <= i2 && a2[1] * a2[2] * a2[3] <= i2 ? [a2[0], a2[1] * a2[2] * a2[3]] : n2 ? c(s2 / 4).map((t3) => 2 * t3) : c(s2);
            }
          }, e.squeezeShape = o, e.parseAxisParam = a, e.isInt = s, e.sizeFromShape = u, e.getRowsCols = function(t2) {
            if (0 === t2.length) throw Error("Cannot get rows and columns of an empty shape array.");
            return [t2.length > 1 ? t2[t2.length - 2] : 1, t2[t2.length - 1]];
          }, e.sizeToSquarishShape = c, e.getBatchDim = function(t2, e2 = 2) {
            return u(t2.slice(0, t2.length - e2));
          };
        }, 4057: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createTextureLayoutFromShape = e.calculateTextureWidthAndHeight = e.createTextureLayoutFromTextureType = void 0;
          const r = n(2517), i = n(2039);
          e.createTextureLayoutFromTextureType = (t2, n2, r2) => {
            const o = r2 === i.TextureType.unpacked || r2 === i.TextureType.unpackedReversed ? 1 : 4, a = r2 === i.TextureType.packed, s = r2 === i.TextureType.unpackedReversed || r2 === i.TextureType.packed, u = r2 === i.TextureType.packedLastDimension ? n2.length - 1 : void 0, c = r2 === i.TextureType.packedLastDimension ? n2.map((t3, e2) => e2 === n2.length - 1 ? 4 * t3 : t3) : void 0;
            return (0, e.createTextureLayoutFromShape)(t2, n2, o, c, { isPacked: a, reverseWH: s, breakAxis: u });
          }, e.calculateTextureWidthAndHeight = (t2, n2, r2) => {
            const i2 = (0, e.createTextureLayoutFromTextureType)(t2, n2, r2);
            return [i2.width, i2.height];
          }, e.createTextureLayoutFromShape = (t2, e2, n2 = 1, i2, o) => {
            const a = !(!o || !o.isPacked), [s, u] = t2.computeTextureWH(a && i2 || e2, o), c = e2.length;
            let l = e2.slice(0);
            if (0 === c && (l = [1]), 1 === n2) i2 = e2;
            else if (a) {
              if (4 !== n2) throw new Error("a packed texture must be 4-channel");
              i2 = e2, c > 0 && (l[c - 1] = Math.ceil(l[c - 1] / 2)), c > 1 && (l[c - 2] = Math.ceil(l[c - 2] / 2));
            } else if (!i2) throw new Error("Unpacked shape is needed when using channels > 1");
            return { width: s, height: u, channels: n2, isPacked: a, shape: l, strides: r.ShapeUtil.computeStrides(l), unpackedShape: i2, reversedWH: o && o.reverseWH };
          };
        }, 5702: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.TextureManager = void 0;
          const r = n(6231);
          e.TextureManager = class {
            constructor(t2, e2, n2, r2) {
              this.glContext = t2, this.layoutStrategy = e2, this.profiler = n2, this.config = r2, this.pendingRead = /* @__PURE__ */ new Map(), r2.reuseTextures && (this.inUseTextures = /* @__PURE__ */ new Map(), this.idleTextures = /* @__PURE__ */ new Map(), this.textureLookup = /* @__PURE__ */ new Map());
            }
            createTextureFromLayout(t2, e2, n2, i) {
              const o = this.toEncoderType(t2), a = this.glContext.getEncoder(o, e2.channels || 1, i);
              if (e2.isPacked && 1 === i) throw new Error("not implemented");
              const s = e2.width, u = e2.height;
              let c, l;
              if (this.config.reuseTextures) {
                c = `${s}x${u}_${a.format}_${a.internalFormat}_${a.textureType}`, l = this.inUseTextures.get(c), l || (l = [], this.inUseTextures.set(c, l));
                const e3 = this.idleTextures.get(c);
                if (e3 && e3.length > 0) {
                  const r2 = e3.pop();
                  return l.push(r2), 1 === i && this.glContext.updateTexture(r2, s, u, a, this.toTextureData(t2, n2)), r2;
                }
              }
              r.Logger.verbose("TextureManager", `Creating new texture of size ${e2.width}x${e2.height}`);
              const p = this.glContext.allocateTexture(s, u, a, this.toTextureData(t2, n2));
              return this.config.reuseTextures && (l.push(p), this.textureLookup.set(p, c)), p;
            }
            readTexture(t2, e2, n2) {
              return n2 || (n2 = 1), this.profiler.event("backend", "TextureManager.readTexture", () => {
                const r2 = t2.shape.reduce((t3, e3) => t3 * e3) * n2, i = this.glContext.readTexture(t2.texture, t2.width, t2.height, r2, this.toEncoderType(e2), n2);
                return this.toTensorData(e2, i);
              });
            }
            readTextureAsync(t2, e2, n2) {
              return __async(this, null, function* () {
                const r2 = t2.tensor.dataId;
                if (n2 || (n2 = 1), this.pendingRead.has(r2)) {
                  const t3 = this.pendingRead.get(r2);
                  return new Promise((e3) => null == t3 ? void 0 : t3.push(e3));
                }
                return this.profiler.event("backend", "TextureManager.readTextureAsync", () => __async(this, null, function* () {
                  this.pendingRead.set(r2, []);
                  const i = t2.shape.reduce((t3, e3) => t3 * e3) * n2;
                  yield this.glContext.createAndWaitForFence();
                  const o = this.glContext.readTexture(t2.texture, t2.width, t2.height, i, this.toEncoderType(e2), n2), a = this.toTensorData(e2, o), s = this.pendingRead.get(r2);
                  return this.pendingRead.delete(r2), null == s || s.forEach((t3) => t3(a)), a;
                }));
              });
            }
            readUint8TextureAsFloat(t2) {
              return this.profiler.event("backend", "TextureManager.readUint8TextureAsFloat", () => {
                const e2 = t2.shape.reduce((t3, e3) => t3 * e3), n2 = this.glContext.readTexture(t2.texture, t2.width, t2.height, 4 * e2, "byte", 4);
                return new Float32Array(n2.buffer, n2.byteOffset, e2);
              });
            }
            releaseTexture(t2, e2) {
              let n2;
              if (this.config.reuseTextures && (n2 = this.textureLookup.get(t2.texture), n2)) {
                e2 && this.textureLookup.delete(n2);
                const r2 = this.inUseTextures.get(n2);
                if (r2) {
                  const e3 = r2.indexOf(t2.texture);
                  if (-1 !== e3) {
                    r2.splice(e3, 1);
                    let i = this.idleTextures.get(n2);
                    i || (i = [], this.idleTextures.set(n2, i)), i.push(t2.texture);
                  }
                }
              }
              n2 && !e2 || (r.Logger.verbose("TextureManager", `Deleting texture of size ${t2.width}x${t2.height}`), this.glContext.deleteTexture(t2.texture));
            }
            toTensorData(t2, e2) {
              switch (t2) {
                case "int16":
                  return e2 instanceof Int16Array ? e2 : Int16Array.from(e2);
                case "int32":
                  return e2 instanceof Int32Array ? e2 : Int32Array.from(e2);
                case "int8":
                  return e2 instanceof Int8Array ? e2 : Int8Array.from(e2);
                case "uint16":
                  return e2 instanceof Uint16Array ? e2 : Uint16Array.from(e2);
                case "uint32":
                  return e2 instanceof Uint32Array ? e2 : Uint32Array.from(e2);
                case "uint8":
                case "bool":
                  return e2 instanceof Uint8Array ? e2 : Uint8Array.from(e2);
                case "float32":
                  return e2 instanceof Float32Array ? e2 : Float32Array.from(e2);
                case "float64":
                  return e2 instanceof Float64Array ? e2 : Float64Array.from(e2);
                default:
                  throw new Error(`TensorData type ${t2} is not supported`);
              }
            }
            toTextureData(t2, e2) {
              if (e2) return e2 instanceof Float32Array ? e2 : new Float32Array(e2);
            }
            toEncoderType(t2) {
              return "float";
            }
            clearActiveTextures() {
              this.glContext.clearActiveTextures();
            }
          };
        }, 2039: (t, e) => {
          var n;
          Object.defineProperty(e, "__esModule", { value: true }), e.TextureType = void 0, (n = e.TextureType || (e.TextureType = {}))[n.unpacked = 0] = "unpacked", n[n.unpackedReversed = 1] = "unpackedReversed", n[n.packed = 2] = "packed", n[n.downloadUint8AsFloat = 3] = "downloadUint8AsFloat", n[n.packedLastDimension = 4] = "packedLastDimension";
        }, 9390: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.getGlChannels = e.getCoordsDataType = e.getSqueezedParams = e.squeezeInputShape = e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = e.generateShaderFuncNameFromInputSamplerName = e.repeatedTry = e.getPackedShape = void 0;
          const r = n(2517);
          e.getPackedShape = function(t2) {
            const e2 = t2.length;
            return t2.slice(0, e2 - 1).concat(t2[e2 - 1] / 4);
          }, e.repeatedTry = function(t2, e2 = (t3) => 0, n2) {
            return __async(this, null, function* () {
              return new Promise((r2, i) => {
                let o = 0;
                const a = () => {
                  if (t2()) return void r2();
                  o++;
                  const s = e2(o);
                  null != n2 && o >= n2 ? i() : setTimeout(a, s);
                };
                a();
              });
            });
          }, e.generateShaderFuncNameFromInputSamplerName = function(t2) {
            return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1);
          }, e.generateShaderFuncNameFromInputSamplerNameAtOutCoords = function(t2) {
            return (0, r.assert)(void 0 !== t2 && 0 !== t2.length, () => "empty string found for sampler name"), "get" + t2.charAt(0).toUpperCase() + t2.slice(1) + "AtOutCoords";
          }, e.squeezeInputShape = function(t2, e2) {
            let n2 = JSON.parse(JSON.stringify(t2));
            return n2 = e2, n2;
          }, e.getSqueezedParams = function(t2, e2) {
            return e2.map((e3) => t2[e3]).join(", ");
          }, e.getCoordsDataType = function(t2) {
            if (t2 <= 1) return "int";
            if (2 === t2) return "ivec2";
            if (3 === t2) return "ivec3";
            if (4 === t2) return "ivec4";
            if (5 === t2) return "ivec5";
            if (6 === t2) return "ivec6";
            throw Error(`GPU for rank ${t2} is not yet supported`);
          }, e.getGlChannels = function(t2 = 6) {
            return ["x", "y", "z", "w", "u", "v"].slice(0, t2);
          };
        }, 7305: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.createNewWebGLContext = e.createWebGLContext = void 0;
          const r = n(6231), i = n(1713), o = {};
          function a(t2) {
            const e2 = function() {
              if ("undefined" == typeof document) {
                if ("undefined" == typeof OffscreenCanvas) throw new TypeError("failed to create canvas: OffscreenCanvas is not supported");
                return new OffscreenCanvas(1, 1);
              }
              const t3 = document.createElement("canvas");
              return t3.width = 1, t3.height = 1, t3;
            }();
            let n2;
            const o2 = { alpha: false, depth: false, antialias: false, stencil: false, preserveDrawingBuffer: false, premultipliedAlpha: false, failIfMajorPerformanceCaveat: false };
            if ((!t2 || "webgl2" === t2) && (n2 = e2.getContext("webgl2", o2), n2)) try {
              return new i.WebGLContext(n2, 2);
            } catch (t3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl2'. Error: ${t3}`);
            }
            if ((!t2 || "webgl" === t2) && (n2 = e2.getContext("webgl", o2) || e2.getContext("experimental-webgl", o2), n2)) try {
              return new i.WebGLContext(n2, 1);
            } catch (t3) {
              r.Logger.warning("GlContextFactory", `failed to create WebGLContext using contextId 'webgl' or 'experimental-webgl'. Error: ${t3}`);
            }
            throw new Error("WebGL is not supported");
          }
          e.createWebGLContext = function t2(e2) {
            let n2;
            e2 && "webgl2" !== e2 || !("webgl2" in o) ? e2 && "webgl" !== e2 || !("webgl" in o) || (n2 = o.webgl) : n2 = o.webgl2, n2 = n2 || a(e2), e2 = e2 || 1 === n2.version ? "webgl" : "webgl2";
            const r2 = n2.gl;
            return o[e2] = n2, r2.isContextLost() ? (delete o[e2], t2(e2)) : (r2.disable(r2.DEPTH_TEST), r2.disable(r2.STENCIL_TEST), r2.disable(r2.BLEND), r2.disable(r2.DITHER), r2.disable(r2.POLYGON_OFFSET_FILL), r2.disable(r2.SAMPLE_COVERAGE), r2.enable(r2.SCISSOR_TEST), r2.enable(r2.CULL_FACE), r2.cullFace(r2.BACK), n2);
          }, e.createNewWebGLContext = a;
        }, 1713: function(t, e, n) {
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule) return t2;
            var e2 = {};
            if (null != t2) for (var n2 in t2) "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.WebGLContext = e.linearSearchLastTrue = void 0;
          const a = n(1670), s = o(n(7769)), u = n(9390);
          function c(t2) {
            let e2 = 0;
            for (; e2 < t2.length && t2[e2](); ++e2) ;
            return e2 - 1;
          }
          e.linearSearchLastTrue = c, e.WebGLContext = class {
            constructor(t2, e2) {
              this.frameBufferBound = false, this.itemsToPoll = [], this.gl = t2, this.version = e2, this.getExtensions(), this.vertexbuffer = this.createVertexbuffer(), this.framebuffer = this.createFramebuffer(), this.queryVitalParameters();
            }
            allocateTexture(t2, e2, n2, r2) {
              const i2 = this.gl, o2 = i2.createTexture();
              i2.bindTexture(i2.TEXTURE_2D, o2), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MIN_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_MAG_FILTER, i2.NEAREST), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_S, i2.CLAMP_TO_EDGE), i2.texParameteri(i2.TEXTURE_2D, i2.TEXTURE_WRAP_T, i2.CLAMP_TO_EDGE);
              const a2 = r2 ? n2.encode(r2, t2 * e2) : null;
              return i2.texImage2D(i2.TEXTURE_2D, 0, n2.internalFormat, t2, e2, 0, n2.format, n2.textureType, a2), this.checkError(), o2;
            }
            updateTexture(t2, e2, n2, r2, i2) {
              const o2 = this.gl;
              o2.bindTexture(o2.TEXTURE_2D, t2);
              const a2 = r2.encode(i2, e2 * n2);
              o2.texSubImage2D(o2.TEXTURE_2D, 0, 0, 0, e2, n2, r2.format, r2.textureType, a2), this.checkError();
            }
            attachFramebuffer(t2, e2, n2) {
              const r2 = this.gl;
              r2.bindTexture(r2.TEXTURE_2D, t2), r2.bindFramebuffer(r2.FRAMEBUFFER, this.framebuffer), r2.framebufferTexture2D(r2.FRAMEBUFFER, r2.COLOR_ATTACHMENT0, r2.TEXTURE_2D, t2, 0), this.checkError(), r2.viewport(0, 0, e2, n2), r2.scissor(0, 0, e2, n2);
            }
            readTexture(t2, e2, n2, r2, i2, o2) {
              const a2 = this.gl;
              o2 || (o2 = 1), this.frameBufferBound || this.attachFramebuffer(t2, e2, n2);
              const s2 = this.getEncoder(i2, o2), u2 = s2.allocate(e2 * n2);
              return a2.bindTexture(a2.TEXTURE_2D, t2), a2.framebufferTexture2D(a2.FRAMEBUFFER, a2.COLOR_ATTACHMENT0, a2.TEXTURE_2D, t2, 0), a2.readPixels(0, 0, e2, n2, a2.RGBA, s2.textureType, u2), this.checkError(), s2.decode(u2, r2);
            }
            isFramebufferReady() {
              return true;
            }
            getActiveTexture() {
              const t2 = this.gl;
              return "TEXTURE" + (t2.getParameter(this.gl.ACTIVE_TEXTURE) - t2.TEXTURE0);
            }
            getTextureBinding() {
              return this.gl.getParameter(this.gl.TEXTURE_BINDING_2D);
            }
            getFramebufferBinding() {
              return this.gl.getParameter(this.gl.FRAMEBUFFER_BINDING);
            }
            setVertexAttributes(t2, e2) {
              const n2 = this.gl;
              n2.vertexAttribPointer(t2, 3, n2.FLOAT, false, 20, 0), n2.enableVertexAttribArray(t2), -1 !== e2 && (n2.vertexAttribPointer(e2, 2, n2.FLOAT, false, 20, 12), n2.enableVertexAttribArray(e2)), this.checkError();
            }
            createProgram(t2, e2) {
              const n2 = this.gl, r2 = n2.createProgram();
              return n2.attachShader(r2, t2), n2.attachShader(r2, e2), n2.linkProgram(r2), r2;
            }
            compileShader(t2, e2) {
              const n2 = this.gl, r2 = n2.createShader(e2);
              if (!r2) throw new Error(`createShader() returned null with type ${e2}`);
              if (n2.shaderSource(r2, t2), n2.compileShader(r2), false === n2.getShaderParameter(r2, n2.COMPILE_STATUS)) throw new Error(`Failed to compile shader: ${n2.getShaderInfoLog(r2)}
Shader source:
${t2}`);
              return r2;
            }
            deleteShader(t2) {
              this.gl.deleteShader(t2);
            }
            bindTextureToUniform(t2, e2, n2) {
              const r2 = this.gl;
              r2.activeTexture(r2.TEXTURE0 + e2), this.checkError(), r2.bindTexture(r2.TEXTURE_2D, t2), this.checkError(), r2.uniform1i(n2, e2), this.checkError();
            }
            draw() {
              this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4), this.checkError();
            }
            checkError() {
              if (a.env.debug) {
                const t2 = this.gl, e2 = t2.getError();
                let n2 = "";
                switch (e2) {
                  case t2.NO_ERROR:
                    return;
                  case t2.INVALID_ENUM:
                    n2 = "INVALID_ENUM";
                    break;
                  case t2.INVALID_VALUE:
                    n2 = "INVALID_VALUE";
                    break;
                  case t2.INVALID_OPERATION:
                    n2 = "INVALID_OPERATION";
                    break;
                  case t2.INVALID_FRAMEBUFFER_OPERATION:
                    n2 = "INVALID_FRAMEBUFFER_OPERATION";
                    break;
                  case t2.OUT_OF_MEMORY:
                    n2 = "OUT_OF_MEMORY";
                    break;
                  case t2.CONTEXT_LOST_WEBGL:
                    n2 = "CONTEXT_LOST_WEBGL";
                    break;
                  default:
                    n2 = `Unknown WebGL Error: ${e2.toString(16)}`;
                }
                throw new Error(n2);
              }
            }
            deleteTexture(t2) {
              this.gl.deleteTexture(t2);
            }
            deleteProgram(t2) {
              this.gl.deleteProgram(t2);
            }
            getEncoder(t2, e2, n2 = 0) {
              if (2 === this.version) return new s.RedFloat32DataEncoder(this.gl, e2);
              switch (t2) {
                case "float":
                  return 1 === n2 || this.isRenderFloat32Supported ? new s.RGBAFloatDataEncoder(this.gl, e2) : new s.RGBAFloatDataEncoder(this.gl, e2, this.textureHalfFloatExtension.HALF_FLOAT_OES);
                case "int":
                  throw new Error("not implemented");
                case "byte":
                  return new s.Uint8DataEncoder(this.gl, e2);
                default:
                  throw new Error(`Invalid dataType: ${t2}`);
              }
            }
            clearActiveTextures() {
              const t2 = this.gl;
              for (let e2 = 0; e2 < this.maxTextureImageUnits; ++e2) t2.activeTexture(t2.TEXTURE0 + e2), t2.bindTexture(t2.TEXTURE_2D, null);
            }
            dispose() {
              if (this.disposed) return;
              const t2 = this.gl;
              t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(this.framebuffer), t2.bindBuffer(t2.ARRAY_BUFFER, null), t2.deleteBuffer(this.vertexbuffer), t2.bindBuffer(t2.ELEMENT_ARRAY_BUFFER, null), t2.finish(), this.disposed = true;
            }
            createDefaultGeometry() {
              return new Float32Array([-1, 1, 0, 0, 1, -1, -1, 0, 0, 0, 1, 1, 0, 1, 1, 1, -1, 0, 1, 0]);
            }
            createVertexbuffer() {
              const t2 = this.gl, e2 = t2.createBuffer();
              if (!e2) throw new Error("createBuffer() returned null");
              const n2 = this.createDefaultGeometry();
              return t2.bindBuffer(t2.ARRAY_BUFFER, e2), t2.bufferData(t2.ARRAY_BUFFER, n2, t2.STATIC_DRAW), this.checkError(), e2;
            }
            createFramebuffer() {
              const t2 = this.gl.createFramebuffer();
              if (!t2) throw new Error("createFramebuffer returned null");
              return t2;
            }
            queryVitalParameters() {
              const t2 = this.gl;
              if (this.isFloatTextureAttachableToFrameBuffer = this.checkFloatTextureAttachableToFrameBuffer(), this.isRenderFloat32Supported = this.checkRenderFloat32(), this.isFloat32DownloadSupported = this.checkFloat32Download(), 1 === this.version && !this.textureHalfFloatExtension && !this.isRenderFloat32Supported) throw new Error("both float32 and float16 TextureType are not supported");
              this.isBlendSupported = !this.isRenderFloat32Supported || this.checkFloat32Blend(), this.maxTextureSize = t2.getParameter(t2.MAX_TEXTURE_SIZE), this.maxTextureImageUnits = t2.getParameter(t2.MAX_TEXTURE_IMAGE_UNITS), this.version;
            }
            getExtensions() {
              2 === this.version ? (this.colorBufferFloatExtension = this.gl.getExtension("EXT_color_buffer_float"), this.disjointTimerQueryWebgl2Extension = this.gl.getExtension("EXT_disjoint_timer_query_webgl2")) : (this.textureFloatExtension = this.gl.getExtension("OES_texture_float"), this.textureHalfFloatExtension = this.gl.getExtension("OES_texture_half_float"));
            }
            checkFloatTextureAttachableToFrameBuffer() {
              const t2 = this.gl, e2 = t2.createTexture();
              t2.bindTexture(t2.TEXTURE_2D, e2);
              const n2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
              t2.texImage2D(t2.TEXTURE_2D, 0, n2, 1, 1, 0, t2.RGBA, t2.FLOAT, null);
              const r2 = t2.createFramebuffer();
              t2.bindFramebuffer(t2.FRAMEBUFFER, r2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0);
              const i2 = t2.checkFramebufferStatus(t2.FRAMEBUFFER) === t2.FRAMEBUFFER_COMPLETE;
              return t2.bindTexture(t2.TEXTURE_2D, null), t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteTexture(e2), t2.deleteFramebuffer(r2), i2;
            }
            checkRenderFloat32() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension) return false;
              } else if (!this.textureFloatExtension) return false;
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Download() {
              if (2 === this.version) {
                if (!this.colorBufferFloatExtension) return false;
              } else {
                if (!this.textureFloatExtension) return false;
                if (!this.gl.getExtension("WEBGL_color_buffer_float")) return false;
              }
              return this.isFloatTextureAttachableToFrameBuffer;
            }
            checkFloat32Blend() {
              const t2 = this.gl;
              let e2, n2, r2, i2, o2;
              try {
                e2 = t2.createTexture(), n2 = t2.createFramebuffer(), t2.bindTexture(t2.TEXTURE_2D, e2);
                const a2 = 2 === this.version ? t2.RGBA32F : t2.RGBA;
                return t2.texImage2D(t2.TEXTURE_2D, 0, a2, 1, 1, 0, t2.RGBA, t2.FLOAT, null), t2.bindFramebuffer(t2.FRAMEBUFFER, n2), t2.framebufferTexture2D(t2.FRAMEBUFFER, t2.COLOR_ATTACHMENT0, t2.TEXTURE_2D, e2, 0), t2.enable(t2.BLEND), r2 = t2.createShader(t2.VERTEX_SHADER), !!r2 && (t2.shaderSource(r2, "void main(){}"), t2.compileShader(r2), i2 = t2.createShader(t2.FRAGMENT_SHADER), !!i2 && (t2.shaderSource(i2, "precision highp float;void main(){gl_FragColor=vec4(0.5);}"), t2.compileShader(i2), o2 = t2.createProgram(), !!o2 && (t2.attachShader(o2, r2), t2.attachShader(o2, i2), t2.linkProgram(o2), t2.useProgram(o2), t2.drawArrays(t2.POINTS, 0, 1), t2.getError() === t2.NO_ERROR)));
              } finally {
                t2.disable(t2.BLEND), o2 && t2.deleteProgram(o2), r2 && t2.deleteShader(r2), i2 && t2.deleteShader(i2), n2 && (t2.bindFramebuffer(t2.FRAMEBUFFER, null), t2.deleteFramebuffer(n2)), e2 && (t2.bindTexture(t2.TEXTURE_2D, null), t2.deleteTexture(e2));
              }
            }
            beginTimer() {
              if (2 === this.version && this.disjointTimerQueryWebgl2Extension) {
                const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension, n2 = t2.createQuery();
                return t2.beginQuery(e2.TIME_ELAPSED_EXT, n2), n2;
              }
              throw new Error("WebGL1 profiling currently not supported.");
            }
            endTimer() {
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
              {
                const t2 = this.gl, e2 = this.disjointTimerQueryWebgl2Extension;
                t2.endQuery(e2.TIME_ELAPSED_EXT);
              }
            }
            isTimerResultAvailable(t2) {
              let e2 = false, n2 = false;
              if (2 !== this.version || !this.disjointTimerQueryWebgl2Extension) throw new Error("WebGL1 profiling currently not supported");
              {
                const r2 = this.gl, i2 = this.disjointTimerQueryWebgl2Extension;
                e2 = r2.getQueryParameter(t2, r2.QUERY_RESULT_AVAILABLE), n2 = r2.getParameter(i2.GPU_DISJOINT_EXT);
              }
              return e2 && !n2;
            }
            getTimerResult(t2) {
              let e2 = 0;
              if (2 !== this.version) throw new Error("WebGL1 profiling currently not supported");
              {
                const n2 = this.gl;
                e2 = n2.getQueryParameter(t2, n2.QUERY_RESULT), n2.deleteQuery(t2);
              }
              return e2 / 1e6;
            }
            waitForQueryAndGetTime(t2) {
              return __async(this, null, function* () {
                return yield (0, u.repeatedTry)(() => this.isTimerResultAvailable(t2)), this.getTimerResult(t2);
              });
            }
            createAndWaitForFence() {
              return __async(this, null, function* () {
                const t2 = this.createFence(this.gl);
                return this.pollFence(t2);
              });
            }
            createFence(t2) {
              let e2;
              const n2 = t2, r2 = n2.fenceSync(n2.SYNC_GPU_COMMANDS_COMPLETE, 0);
              return t2.flush(), e2 = null === r2 ? () => true : () => {
                const t3 = n2.clientWaitSync(r2, 0, 0);
                return t3 === n2.ALREADY_SIGNALED || t3 === n2.CONDITION_SATISFIED;
              }, { query: r2, isFencePassed: e2 };
            }
            pollFence(t2) {
              return __async(this, null, function* () {
                return new Promise((e2) => {
                  this.addItemToPoll(() => t2.isFencePassed(), () => e2());
                });
              });
            }
            pollItems() {
              const t2 = c(this.itemsToPoll.map((t3) => t3.isDoneFn));
              for (let e2 = 0; e2 <= t2; ++e2) {
                const { resolveFn: t3 } = this.itemsToPoll[e2];
                t3();
              }
              this.itemsToPoll = this.itemsToPoll.slice(t2 + 1);
            }
            addItemToPoll(t2, e2) {
              return __async(this, null, function* () {
                this.itemsToPoll.push({ isDoneFn: t2, resolveFn: e2 }), this.itemsToPoll.length > 1 || (yield (0, u.repeatedTry)(() => (this.pollItems(), 0 === this.itemsToPoll.length)));
              });
            }
          };
        }, 1036: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.ExecutionPlan = void 0;
          const r = n(6231);
          class i {
            constructor(t2, e2) {
              this.op = t2, this.node = e2;
            }
          }
          e.ExecutionPlan = class {
            constructor(t2, e2, n2) {
              this.graph = t2, this.profiler = n2, this.initialize(e2);
            }
            initialize(t2) {
              this.profiler.event("session", "ExecutionPlan.initialize", () => {
                const e2 = this.graph.getNodes();
                if (e2.length !== t2.length) throw new Error("The size of nodes and OPs do not match.");
                this._ops = t2.map((t3, n2) => new i(t3, e2[n2])), this.reset(), this._starter = [], this._ops.forEach((t3, e3) => {
                  let n2 = true;
                  for (const e4 of t3.node.inputs) if (!this._values[e4] && -1 === this.graph.getInputIndices().indexOf(e4)) {
                    n2 = false;
                    break;
                  }
                  n2 && this._starter.push(e3);
                });
              });
            }
            reset() {
              this._values = this.graph.getValues().map((t2) => t2.tensor);
            }
            execute(t2, e2) {
              return __async(this, null, function* () {
                return this.profiler.event("session", "ExecutionPlan.execute", () => __async(this, null, function* () {
                  this.reset();
                  const n2 = t2.createInferenceHandler(), i2 = this.graph.getInputIndices();
                  if (e2.length !== i2.length) throw new Error(`number of input tensors don't match the number of inputs to the model: actual: ${e2.length} expected: ${i2.length}`);
                  e2.forEach((t3, e3) => {
                    const n3 = i2[e3];
                    this._values[n3] = t3;
                  });
                  const o = this._starter.slice(0), a = this.graph.getValues(), s = this.graph.getNodes();
                  let u = 0;
                  for (; u < o.length; ) {
                    const t3 = o[u++], e3 = this._ops[t3], i3 = e3.node.inputs.map((t4) => this._values[t4]);
                    if (-1 !== i3.indexOf(void 0)) throw new Error(`unresolved input detected: op: ${e3.node}`);
                    const c2 = i3;
                    r.Logger.verbose("ExecPlan", `Runing op:${e3.node.name} (${c2.map((t4, n3) => `'${e3.node.inputs[n3]}': ${t4.type}[${t4.dims.join(",")}]`).join(", ")})`);
                    const l = yield this.profiler.event("node", e3.node.name, () => __async(this, null, function* () {
                      return e3.op.impl(n2, c2, e3.op.context);
                    }));
                    if (l.length !== e3.node.outputs.length) throw new Error("the size of output does not match model definition.");
                    l.forEach((t4, n3) => {
                      const r2 = e3.node.outputs[n3];
                      if (this._values[r2]) throw new Error(`output [${r2}] already has value: op:${e3.node.name}`);
                      this._values[r2] = t4;
                    });
                    const p = /* @__PURE__ */ new Set();
                    l.forEach((t4, n3) => {
                      const r2 = e3.node.outputs[n3];
                      for (const t5 of a[r2].to) {
                        const e4 = s[t5];
                        let n4 = true;
                        for (const t6 of e4.inputs) if (!this._values[t6]) {
                          n4 = false;
                          break;
                        }
                        n4 && p.add(t5);
                      }
                    }), o.push(...p);
                  }
                  const c = [];
                  for (let t3 = 0; t3 < this.graph.getOutputIndices().length; t3++) {
                    const e3 = this.graph.getOutputIndices()[t3], n3 = this._values[e3];
                    if (void 0 === n3) throw new Error(`required output [${e3}] does not have value`);
                    0 === e3 ? yield n3.getData() : n3.data, c.push(n3);
                  }
                  return r.Logger.verbose("ExecPlan", "disposing of inferenceHandler"), n2.dispose(), c;
                }));
              });
            }
          };
        }, 7070: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.Graph = void 0;
          const r = n(1446), i = n(7778), o = n(9395), a = n(9162), s = n(2517);
          var u = o.onnxruntime.experimental.fbs;
          e.Graph = { from: (t2, e2) => new p(t2, e2) };
          class c {
            constructor(t2) {
              this._from = void 0, this._to = [], this.tensor = void 0, this.type = void 0, t2 && (this.type = s.ProtoUtil.tensorValueTypeFromProto(t2.type.tensorType));
            }
            get from() {
              return this._from;
            }
            get to() {
              return this._to;
            }
          }
          class l {
            constructor(t2, e2) {
              t2 instanceof r.onnx.NodeProto ? (this.name = t2.name, this.opType = t2.opType, this.attributes = new i.Attribute(t2.attribute)) : t2 instanceof u.Node && (this.name = null != e2 ? e2 : t2.name(), this.opType = t2.opType(), this.attributes = new i.Attribute(s.ProtoUtil.tensorAttributesFromORTFormat(t2))), this.inputs = [], this.outputs = [], this.executeNode = true;
            }
          }
          class p {
            constructor(t2, e2) {
              if (!t2) throw new TypeError("graph is empty");
              this.buildGraph(t2), this.transformGraph(e2), this.checkIsAcyclic();
            }
            getInputIndices() {
              return this._allInputIndices;
            }
            getInputNames() {
              return this._allInputNames;
            }
            getOutputIndices() {
              return this._allOutputIndices;
            }
            getOutputNames() {
              return this._allOutputNames;
            }
            getValues() {
              return this._allData;
            }
            getNodes() {
              return this._nodes;
            }
            buildGraph(t2) {
              if (t2 instanceof r.onnx.GraphProto) this.buildGraphFromOnnxFormat(t2);
              else {
                if (!(t2 instanceof u.Graph)) throw new TypeError("Graph type is not supported.");
                this.buildGraphFromOrtFormat(t2);
              }
            }
            buildGraphFromOnnxFormat(t2) {
              const e2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const n2 = /* @__PURE__ */ new Map();
              if (!t2.input) throw new Error("missing information in graph: input");
              const r2 = [];
              for (const n3 of t2.input) {
                if (e2.has(n3.name)) throw new Error(`duplicated input name: ${n3.name}`);
                const t3 = this._allData.push(new c(n3)) - 1;
                e2.set(n3.name, t3), r2.push(n3.name);
              }
              if (!t2.initializer) throw new Error("missing information in graph: initializer");
              for (const n3 of t2.initializer) {
                let t3 = e2.get(n3.name);
                if (void 0 === t3) {
                  const r3 = new c();
                  r3.type = { shape: { dims: s.ProtoUtil.tensorDimsFromProto(n3.dims) }, tensorType: s.ProtoUtil.tensorDataTypeFromProto(n3.dataType) }, t3 = this._allData.push(r3) - 1, e2.set(n3.name, t3);
                }
                this._allData[t3]._from = -1, this._allData[t3].tensor = a.Tensor.fromProto(n3);
              }
              for (let t3 = 0; t3 < this._allData.length; t3++) this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(r2[t3]));
              if (!t2.output) throw new Error("missing information in graph: output");
              for (const n3 of t2.output) {
                if (e2.has(n3.name)) throw new Error(`duplicated output name: ${n3.name}`);
                const t3 = this._allData.push(new c(n3)) - 1;
                e2.set(n3.name, t3), this._allOutputIndices.push(t3), this._allOutputNames.push(n3.name);
              }
              if (!t2.node) throw new Error("missing information in graph: node");
              for (const e3 of t2.node) {
                if (!e3.name) for (let t4 = 0; ; t4++) {
                  const r3 = `unnamed_${e3.opType}_${t4}`;
                  if (!n2.has(r3)) {
                    e3.name = r3;
                    break;
                  }
                }
                if (n2.has(e3.name)) throw new Error(`duplicated node name: ${e3.name}`);
                const t3 = this._nodes.push(new l(e3)) - 1;
                n2.set(e3.name, t3);
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], i2 = t2.node[n3];
                if (!i2.output) throw new Error(`missing output for node: ${i2.name}`);
                for (const t3 of i2.output) {
                  let o2 = e2.get(t3);
                  if (void 0 === o2 && (o2 = this._allData.push(new c()) - 1, e2.set(t3, o2)), r3.outputs.push(o2), void 0 !== this._allData[o2]._from) throw new Error(`multiple nodes output to one data value: ${o2}`);
                  if (this._allData[o2]._from = n3, "Constant" === i2.opType) {
                    if (!i2.attribute || 1 !== i2.attribute.length || !i2.attribute[0].t) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (!i2.output || 1 !== i2.output.length) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    r3.outputs.pop(), r3.executeNode = false, this._allData[o2]._from = -1, this._allData[o2].tensor = a.Tensor.fromProto(i2.attribute[0].t);
                  }
                }
              }
              for (let n3 = 0; n3 < this._nodes.length; n3++) {
                const r3 = this._nodes[n3], i2 = t2.node[n3];
                if (!i2.input) throw new Error(`missing input for node: ${i2.name}`);
                for (const t3 of i2.input) {
                  const o2 = e2.get(t3);
                  if (void 0 === o2) {
                    if ("" === t3 && 3 === i2.input.length && "Resize" === i2.opType) continue;
                    throw new Error(`unrecognized input '${t3}' for node: ${i2.name}`);
                  }
                  r3.inputs.push(o2), this._allData[o2]._to.push(n3);
                }
              }
              return true;
            }
            buildGraphFromOrtFormat(t2) {
              var e2, n2, r2;
              const i2 = /* @__PURE__ */ new Map();
              this._allData = [], this._allInputIndices = [], this._allInputNames = [], this._allOutputIndices = [], this._allOutputNames = [], this._nodes = [];
              const o2 = /* @__PURE__ */ new Map(), p2 = [];
              for (let o3 = 0; o3 < t2.inputsLength(); o3++) {
                const a2 = t2.inputs(o3);
                if (i2.has(a2)) throw new Error(`duplicated input name: ${a2}`);
                for (let o4 = 0; o4 < t2.nodeArgsLength(); o4++) if ((null === (e2 = t2.nodeArgs(o4)) || void 0 === e2 ? void 0 : e2.name()) === a2) {
                  const e3 = new c();
                  if ((null === (r2 = null === (n2 = t2.nodeArgs(o4)) || void 0 === n2 ? void 0 : n2.type()) || void 0 === r2 ? void 0 : r2.valueType()) !== u.TypeInfoValue.tensor_type) throw new Error("Unexpected value type for the nodeArg.");
                  const l2 = t2.nodeArgs(o4).type().value(new u.TensorTypeAndShape()), f = s.ProtoUtil.tensorDataTypeFromProto(l2.elemType()), d = l2.shape(), h = [];
                  for (let t3 = 0; t3 < d.dimLength(); t3++) h.push(s.LongUtil.longToNumber(d.dim(t3).value().dimValue()));
                  e3.type = { shape: { dims: h }, tensorType: f };
                  const g = this._allData.push(e3) - 1;
                  i2.set(a2, g), p2.push(a2);
                }
              }
              for (let e3 = 0; e3 < t2.initializersLength(); e3++) {
                const n3 = t2.initializers(e3);
                let r3 = i2.get(n3.name());
                if (void 0 === r3) {
                  const t3 = new c(), e4 = s.ProtoUtil.tensorDimsFromORTFormat(n3), o3 = s.ProtoUtil.tensorDataTypeFromProto(n3.dataType());
                  t3.type = { shape: { dims: e4 }, tensorType: o3 }, r3 = this._allData.push(t3) - 1, i2.set(n3.name(), r3);
                }
                this._allData[r3]._from = -1, this._allData[r3].tensor = a.Tensor.fromOrtTensor(n3);
              }
              for (let t3 = 0; t3 < this._allData.length; t3++) this._allData[t3].tensor || (this._allInputIndices.push(t3), this._allInputNames.push(p2[t3]));
              for (let e3 = 0; e3 < t2.outputsLength(); e3++) {
                const n3 = t2.outputs(e3);
                if (i2.has(n3)) throw new Error(`duplicated output name: ${n3}`);
                const r3 = this._allData.push(new c()) - 1;
                i2.set(n3, r3), this._allOutputIndices.push(r3), this._allOutputNames.push(n3);
              }
              if (!t2.nodes) throw new Error("missing information in graph: node");
              for (let e3 = 0; e3 < t2.nodesLength(); e3++) {
                const n3 = t2.nodes(e3);
                let r3 = n3.name();
                if (!r3) for (let t3 = 0; r3 = `unnamed_${n3.opType()}_${t3}`, o2.has(r3); t3++) ;
                if (o2.has(r3)) throw new Error(`duplicated node name: ${r3}`);
                const i3 = this._nodes.push(new l(n3, r3)) - 1;
                o2.set(r3, i3);
              }
              for (let e3 = 0; e3 < this._nodes.length; e3++) {
                const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                if (null == r3) throw new Error(`No node exists at index ${e3}`);
                if (0 === (null == r3 ? void 0 : r3.outputsLength())) throw new Error(`missing output for node: ${r3.name}`);
                for (let t3 = 0; t3 < (null == r3 ? void 0 : r3.outputsLength()); t3++) {
                  const o3 = null == r3 ? void 0 : r3.outputs(t3);
                  let s2 = i2.get(o3);
                  if (void 0 === s2 && (s2 = this._allData.push(new c()) - 1, i2.set(o3, s2)), n3.outputs.push(s2), void 0 !== this._allData[s2]._from) throw new Error(`multiple nodes output to one data value: ${s2}`);
                  if (this._allData[s2]._from = e3, "Constant" === r3.opType()) {
                    if (1 !== r3.attributesLength() || !r3.attributes(0).t()) throw new Error("missing attributes or missing tensor value in attributes for this Constant operator");
                    if (1 !== r3.outputsLength()) throw new Error("missing output or incorrect number of outputs for this Constant operator");
                    n3.outputs.pop(), n3.executeNode = false, this._allData[s2]._from = -1, this._allData[s2].tensor = a.Tensor.fromOrtTensor(r3.attributes(0).t());
                  }
                }
              }
              for (let e3 = 0; e3 < this._nodes.length; e3++) {
                const n3 = this._nodes[e3], r3 = t2.nodes(e3);
                if (0 === r3.inputsLength()) throw new Error(`missing input for node: ${r3.name}`);
                for (let t3 = 0; t3 < r3.inputsLength(); t3++) {
                  const o3 = r3.inputs(t3), a2 = i2.get(o3);
                  if (void 0 === a2) throw new Error(`unrecognized input '${o3}' for node: ${r3.name()}`);
                  n3.inputs.push(a2), this._allData[a2]._to.push(e3);
                }
              }
            }
            checkIsAcyclic() {
              const t2 = /* @__PURE__ */ new Set();
              this._allInputIndices.forEach((e3) => {
                this._allData[e3]._to.forEach((e4) => {
                  t2.add(e4);
                });
              });
              const e2 = Array.from(t2), n2 = new Array(this._nodes.length).fill("white");
              for (; e2.length > 0; ) {
                const t3 = e2.pop();
                "gray" === n2[t3] ? n2[t3] = "black" : (e2.push(t3), n2[t3] = "gray", this._nodes[t3].outputs.forEach((r2) => {
                  const i2 = this._allData[r2];
                  if (void 0 !== i2.tensor) throw new Error("node outputs should not be initialized");
                  if (i2._from !== t3) throw new Error("from property of the Value object doesn't match index of Node being processed");
                  i2._to.forEach((t4) => {
                    if ("gray" === n2[t4]) throw new Error("model graph is cyclic");
                    "white" === n2[t4] && e2.push(t4);
                  });
                }));
              }
            }
            transformGraph(t2) {
              this.removeAllIdentityNodes(), this.removeAllDropoutNodes(), this.fuseConvActivationNodes(), t2 && t2.transformGraph(this), this.finalizeGraph();
            }
            finalizeGraph() {
              let t2 = 0;
              for (let e2 = 0; e2 < this._nodes.length; e2++) this._nodes[e2].executeNode ? t2 > 0 && (this._nodes[e2].inputs.forEach((n2) => {
                const r2 = this._allData[n2]._to.indexOf(e2 + t2);
                -1 !== r2 && (this._allData[n2]._to[r2] = e2);
              }), this._nodes[e2].outputs.forEach((n2) => {
                this._allData[n2]._from && this._allData[n2]._from === e2 + t2 && (this._allData[n2]._from = e2);
              })) : (t2++, this._nodes[e2].outputs.forEach((t3) => {
                this._allData[t3]._from = -2;
              }), this._nodes.splice(e2, 1), e2--);
              t2 = 0;
              for (let e2 = 0; e2 < this._allData.length; e2++) if (-2 !== this._allData[e2].from || -1 !== this._allOutputIndices.indexOf(e2 + t2)) {
                if (t2 > 0) {
                  let n2 = -1;
                  void 0 !== this._allData[e2].from && -1 !== this._allData[e2].from ? (n2 = this._nodes[this._allData[e2].from].outputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[this._allData[e2].from].outputs[n2] = e2)) : (n2 = this._allInputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allInputIndices[n2] = e2)), this._allData[e2].to.forEach((r2) => {
                    n2 = this._nodes[r2].inputs.indexOf(e2 + t2), -1 !== n2 && (this._nodes[r2].inputs[n2] = e2);
                  }), 0 === this._allData[e2].to.length && (n2 = this._allOutputIndices.indexOf(e2 + t2), -1 !== n2 && (this._allOutputIndices[n2] = e2));
                }
              } else t2++, this._allData.splice(e2, 1), e2--;
            }
            deleteNode(t2) {
              const e2 = this._nodes[t2];
              if (e2.outputs.length > 1) {
                for (let t3 = 1; t3 < e2.outputs.length; t3++) if (this._allData[e2.outputs[t3]].to.length > 0) throw new Error("Node deletion with more than one output connected to other nodes is not supported. ");
              }
              e2.executeNode = false;
              const n2 = e2.inputs[0], r2 = e2.outputs[0], i2 = this._allData[r2].to, o2 = this._allData[n2].to.indexOf(t2);
              if (-1 === o2) throw new Error("The Value object doesn't have the current Node in it's 'to' property ");
              this._allData[n2].to.splice(o2, 1), this._allData[r2]._to = [];
              const a2 = this._allOutputIndices.indexOf(r2);
              if (-1 !== a2 && (this._allOutputIndices[a2] = n2), i2 && i2.length > 0) for (const t3 of i2) {
                const e3 = this._nodes[t3].inputs.indexOf(r2);
                if (-1 === e3) throw new Error("The Node object doesn't have the output Value in it's 'inputs' property ");
                this._nodes[t3].inputs[e3] = n2, this._allData[n2].to.push(t3);
              }
            }
            removeAllDropoutNodes() {
              let t2 = 0;
              for (const e2 of this._nodes) {
                if ("Dropout" === e2.opType) {
                  if (1 !== e2.inputs.length) throw new Error("Dropout nodes should only contain one input. ");
                  if (1 !== e2.outputs.length && 2 !== e2.outputs.length) throw new Error("Dropout nodes should contain either 1 or 2 output(s)");
                  if (2 === e2.outputs.length && 0 !== this._allData[e2.outputs[1]]._to.length) throw new Error("Dropout nodes's second output should not be referenced by other nodes");
                  this.deleteNode(t2);
                }
                t2++;
              }
            }
            removeAllIdentityNodes() {
              let t2 = 0;
              for (const e2 of this._nodes) "Identity" === e2.opType && this.deleteNode(t2), t2++;
            }
            isActivation(t2) {
              switch (t2.opType) {
                case "Relu":
                case "Sigmoid":
                case "Clip":
                  return true;
                default:
                  return false;
              }
            }
            fuseConvActivationNodes() {
              for (const t2 of this._nodes) if ("Conv" === t2.opType) {
                const e2 = this._allData[t2.outputs[0]]._to;
                if (1 === e2.length && this.isActivation(this._nodes[e2[0]])) {
                  const n2 = this._nodes[e2[0]];
                  if ("Clip" === n2.opType) if (1 === n2.inputs.length) try {
                    t2.attributes.set("activation_params", "floats", [n2.attributes.getFloat("min"), n2.attributes.getFloat("max")]);
                  } catch (e3) {
                    t2.attributes.set("activation_params", "floats", [s.MIN_CLIP, s.MAX_CLIP]);
                  }
                  else {
                    if (!(n2.inputs.length >= 3 && void 0 !== this._allData[n2.inputs[1]].tensor && void 0 !== this._allData[n2.inputs[2]].tensor)) continue;
                    t2.attributes.set("activation_params", "floats", [this._allData[n2.inputs[1]].tensor.floatData[0], this._allData[n2.inputs[2]].tensor.floatData[0]]);
                  }
                  t2.attributes.set("activation", "string", n2.opType), this.deleteNode(e2[0]);
                }
              }
            }
          }
        }, 6231: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.now = e.Profiler = e.Logger = void 0;
          const n = { verbose: 1e3, info: 2e3, warning: 4e3, error: 5e3, fatal: 6e3 }, r = { none: new class {
            log(t2, e2, n2) {
            }
          }(), console: new class {
            log(t2, e2, n2) {
              console.log(`${this.color(t2)} ${n2 ? "\x1B[35m" + n2 + "\x1B[0m " : ""}${e2}`);
            }
            color(t2) {
              switch (t2) {
                case "verbose":
                  return "\x1B[34;40mv\x1B[0m";
                case "info":
                  return "\x1B[32mi\x1B[0m";
                case "warning":
                  return "\x1B[30;43mw\x1B[0m";
                case "error":
                  return "\x1B[31;40me\x1B[0m";
                case "fatal":
                  return "\x1B[101mf\x1B[0m";
                default:
                  throw new Error(`unsupported severity: ${t2}`);
              }
            }
          }() }, i = { provider: "console", minimalSeverity: "warning", logDateTime: true, logSourceLocation: false };
          let o = { "": i };
          function a(t2, e2, n2, r2) {
            if (void 0 === e2) return i2 = t2, { verbose: a.verbose.bind(null, i2), info: a.info.bind(null, i2), warning: a.warning.bind(null, i2), error: a.error.bind(null, i2), fatal: a.fatal.bind(null, i2) };
            if (void 0 === n2) s(t2, e2);
            else if ("number" == typeof n2 && void 0 === r2) s(t2, e2);
            else if ("string" == typeof n2 && void 0 === r2) s(t2, n2, 0, e2);
            else {
              if ("string" != typeof n2 || "number" != typeof r2) throw new TypeError("input is valid");
              s(t2, n2, 0, e2);
            }
            var i2;
          }
          function s(t2, e2, i2, a2) {
            const s2 = o[a2 || ""] || o[""];
            n[t2] < n[s2.minimalSeverity] || (s2.logDateTime && (e2 = `${(/* @__PURE__ */ new Date()).toISOString()}|${e2}`), s2.logSourceLocation, r[s2.provider].log(t2, e2, a2));
          }
          !function(t2) {
            function e2(t3) {
              o = {}, n2("", t3 || {});
            }
            function n2(t3, n3) {
              if ("*" === t3) e2(n3);
              else {
                const e3 = o[t3] || i;
                o[t3] = { provider: n3.provider || e3.provider, minimalSeverity: n3.minimalSeverity || e3.minimalSeverity, logDateTime: void 0 === n3.logDateTime ? e3.logDateTime : n3.logDateTime, logSourceLocation: void 0 === n3.logSourceLocation ? e3.logSourceLocation : n3.logSourceLocation };
              }
            }
            t2.verbose = function(e3, n3) {
              t2("verbose", e3, n3);
            }, t2.info = function(e3, n3) {
              t2("info", e3, n3);
            }, t2.warning = function(e3, n3) {
              t2("warning", e3, n3);
            }, t2.error = function(e3, n3) {
              t2("error", e3, n3);
            }, t2.fatal = function(e3, n3) {
              t2("fatal", e3, n3);
            }, t2.reset = e2, t2.set = n2, t2.setWithEnv = function(t3) {
              const e3 = {};
              t3.logLevel && (e3.minimalSeverity = t3.logLevel), n2("", e3);
            };
          }(a || (a = {})), e.Logger = a;
          class u {
            constructor(t2, e2, n2, r2, i2, o2) {
              this.category = t2, this.name = e2, this.startTime = n2, this.endCallback = r2, this.timer = i2, this.ctx = o2;
            }
            end() {
              return this.endCallback(this);
            }
            checkTimer() {
              return __async(this, null, function* () {
                if (void 0 === this.ctx || void 0 === this.timer) throw new Error("No webgl timer found");
                return this.ctx.endTimer(), this.ctx.waitForQueryAndGetTime(this.timer);
              });
            }
          }
          class c {
            constructor(t2, e2, n2, r2) {
              this.category = t2, this.name = e2, this.startTime = n2, this.endTime = r2;
            }
          }
          e.Profiler = class {
            static create(t2) {
              return void 0 === t2 ? new this() : new this(t2.maxNumberEvents, t2.flushBatchSize, t2.flushIntervalInMilliseconds);
            }
            constructor(t2, e2, n2) {
              this._started = false, this._flushPointer = 0, this._started = false, this._maxNumberEvents = void 0 === t2 ? 1e4 : t2, this._flushBatchSize = void 0 === e2 ? 10 : e2, this._flushIntervalInMilliseconds = void 0 === n2 ? 5e3 : n2;
            }
            start() {
              this._started = true, this._timingEvents = [], this._flushTime = (0, e.now)(), this._flushPointer = 0;
            }
            stop() {
              for (this._started = false; this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
            }
            event(t2, e2, n2, r2) {
              const i2 = this._started ? this.begin(t2, e2, r2) : void 0;
              let o2 = false;
              const a2 = n2();
              if (a2 && "function" == typeof a2.then) return o2 = true, new Promise((t3, e3) => {
                a2.then((e4) => __async(this, null, function* () {
                  i2 && (yield i2.end()), t3(e4);
                }), (t4) => __async(this, null, function* () {
                  i2 && (yield i2.end()), e3(t4);
                }));
              });
              if (!o2 && i2) {
                const t3 = i2.end();
                if (t3 && "function" == typeof t3.then) return new Promise((e3, n3) => {
                  t3.then(() => {
                    e3(a2);
                  }, (t4) => {
                    n3(t4);
                  });
                });
              }
              return a2;
            }
            begin(t2, n2, r2) {
              if (!this._started) throw new Error("profiler is not started yet");
              if (void 0 === r2) {
                const r3 = (0, e.now)();
                return this.flush(r3), new u(t2, n2, r3, (t3) => this.endSync(t3));
              }
              {
                const e2 = r2.beginTimer();
                return new u(t2, n2, 0, (t3) => __async(this, null, function* () {
                  return this.end(t3);
                }), e2, r2);
              }
            }
            end(t2) {
              return __async(this, null, function* () {
                const e2 = yield t2.checkTimer();
                this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, e2)), this.flush(e2));
              });
            }
            endSync(t2) {
              const n2 = (0, e.now)();
              this._timingEvents.length < this._maxNumberEvents && (this._timingEvents.push(new c(t2.category, t2.name, t2.startTime, n2)), this.flush(n2));
            }
            logOneEvent(t2) {
              e.Logger.verbose(`Profiler.${t2.category}`, `${(t2.endTime - t2.startTime).toFixed(2)}ms on event '${t2.name}' at ${t2.endTime.toFixed(2)}`);
            }
            flush(t2) {
              if (this._timingEvents.length - this._flushPointer >= this._flushBatchSize || t2 - this._flushTime >= this._flushIntervalInMilliseconds) {
                for (const t3 = this._flushPointer; this._flushPointer < t3 + this._flushBatchSize && this._flushPointer < this._timingEvents.length; this._flushPointer++) this.logOneEvent(this._timingEvents[this._flushPointer]);
                this._flushTime = (0, e.now)();
              }
            }
            get started() {
              return this._started;
            }
          }, e.now = "undefined" != typeof performance && performance.now ? () => performance.now() : Date.now;
        }, 2644: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.Model = void 0;
          const r = n(5686), i = n(1446), o = n(7070), a = n(9395), s = n(2517);
          var u = a.onnxruntime.experimental.fbs;
          e.Model = class {
            constructor() {
            }
            load(t2, e2, n2) {
              if (!n2) try {
                return void this.loadFromOnnxFormat(t2, e2);
              } catch (t3) {
                if (void 0 !== n2) throw t3;
              }
              this.loadFromOrtFormat(t2, e2);
            }
            loadFromOnnxFormat(t2, e2) {
              const n2 = i.onnx.ModelProto.decode(t2);
              if (s.LongUtil.longToNumber(n2.irVersion) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = n2.opsetImport.map((t3) => ({ domain: t3.domain, version: s.LongUtil.longToNumber(t3.version) })), this._graph = o.Graph.from(n2.graph, e2);
            }
            loadFromOrtFormat(t2, e2) {
              const n2 = new r.flatbuffers.ByteBuffer(t2), i2 = u.InferenceSession.getRootAsInferenceSession(n2).model();
              if (s.LongUtil.longToNumber(i2.irVersion()) < 3) throw new Error("only support ONNX model with IR_VERSION>=3");
              this._opsets = [];
              for (let t3 = 0; t3 < i2.opsetImportLength(); t3++) {
                const e3 = i2.opsetImport(t3);
                this._opsets.push({ domain: null == e3 ? void 0 : e3.domain(), version: s.LongUtil.longToNumber(e3.version()) });
              }
              this._graph = o.Graph.from(i2.graph(), e2);
            }
            get graph() {
              return this._graph;
            }
            get opsets() {
              return this._opsets;
            }
          };
        }, 782: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.FLOAT_TYPES = e.INT_TYPES = e.NUMBER_TYPES = void 0, e.NUMBER_TYPES = ["float32", "float64", "int32", "int16", "int8", "uint16", "uint32", "uint8"], e.INT_TYPES = ["int32", "int16", "int8", "uint16", "uint32", "uint8"], e.FLOAT_TYPES = ["float32", "float64"];
        }, 1047: (t, e) => {
          function n(t2, e2) {
            if (e2.endsWith("+")) {
              const n2 = Number.parseInt(e2.substring(0, e2.length - 1), 10);
              return !isNaN(n2) && n2 <= t2;
            }
            if (2 === e2.split("-").length) {
              const n2 = e2.split("-"), r = Number.parseInt(n2[0], 10), i = Number.parseInt(n2[1], 10);
              return !isNaN(r) && !isNaN(i) && r <= t2 && t2 <= i;
            }
            return Number.parseInt(e2, 10) === t2;
          }
          Object.defineProperty(e, "__esModule", { value: true }), e.resolveOperator = void 0, e.resolveOperator = function(t2, e2, r) {
            for (const i of r) {
              const r2 = i[0], o = i[1], a = i[2], s = i[3], u = i[4];
              if (t2.opType === r2) {
                for (const t3 of e2) if ((t3.domain === o || "ai.onnx" === t3.domain && "" === o) && n(t3.version, a)) return { opImpl: s, opInit: u };
              }
            }
            throw new TypeError(`cannot resolve operator '${t2.opType}' with opsets: ${e2.map((t3) => `${t3.domain || "ai.onnx"} v${t3.version}`).join(", ")}`);
          };
        }, 9395: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.onnxruntime = void 0;
          const r = n(5686);
          var i, o;
          i = e.onnxruntime || (e.onnxruntime = {}), function(t2) {
            !function(t3) {
              t3[t3.UNDEFINED = 0] = "UNDEFINED", t3[t3.FLOAT = 1] = "FLOAT", t3[t3.INT = 2] = "INT", t3[t3.STRING = 3] = "STRING", t3[t3.TENSOR = 4] = "TENSOR", t3[t3.GRAPH = 5] = "GRAPH", t3[t3.FLOATS = 6] = "FLOATS", t3[t3.INTS = 7] = "INTS", t3[t3.STRINGS = 8] = "STRINGS", t3[t3.TENSORS = 9] = "TENSORS", t3[t3.GRAPHS = 10] = "GRAPHS", t3[t3.SPARSE_TENSOR = 11] = "SPARSE_TENSOR", t3[t3.SPARSE_TENSORS = 12] = "SPARSE_TENSORS";
            }(t2.AttributeType || (t2.AttributeType = {}));
          }((o = i.experimental || (i.experimental = {})).fbs || (o.fbs = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                !function(t5) {
                  t5[t5.UNKNOWN = 0] = "UNKNOWN", t5[t5.VALUE = 1] = "VALUE", t5[t5.PARAM = 2] = "PARAM";
                }(t4.DimensionValueType || (t4.DimensionValueType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                !function(t5) {
                  t5[t5.UNDEFINED = 0] = "UNDEFINED", t5[t5.FLOAT = 1] = "FLOAT", t5[t5.UINT8 = 2] = "UINT8", t5[t5.INT8 = 3] = "INT8", t5[t5.UINT16 = 4] = "UINT16", t5[t5.INT16 = 5] = "INT16", t5[t5.INT32 = 6] = "INT32", t5[t5.INT64 = 7] = "INT64", t5[t5.STRING = 8] = "STRING", t5[t5.BOOL = 9] = "BOOL", t5[t5.FLOAT16 = 10] = "FLOAT16", t5[t5.DOUBLE = 11] = "DOUBLE", t5[t5.UINT32 = 12] = "UINT32", t5[t5.UINT64 = 13] = "UINT64", t5[t5.COMPLEX64 = 14] = "COMPLEX64", t5[t5.COMPLEX128 = 15] = "COMPLEX128", t5[t5.BFLOAT16 = 16] = "BFLOAT16";
                }(t4.TensorDataType || (t4.TensorDataType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                !function(t5) {
                  t5[t5.Primitive = 0] = "Primitive", t5[t5.Fused = 1] = "Fused";
                }(t4.NodeType || (t4.NodeType = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                !function(t5) {
                  t5[t5.NONE = 0] = "NONE", t5[t5.tensor_type = 1] = "tensor_type", t5[t5.sequence_type = 2] = "sequence_type", t5[t5.map_type = 3] = "map_type";
                }(t4.TypeInfoValue || (t4.TypeInfoValue = {}));
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsShape(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsShape(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  dim(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new t2.experimental.fbs.Dimension()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  dimLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startShape(t3) {
                    t3.startObject(1);
                  }
                  static addDim(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static createDimVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endShape(t3) {
                    return t3.endObject();
                  }
                  static createShape(t3, e4) {
                    return n2.startShape(t3), n2.addDim(t3, e4), n2.endShape(t3);
                  }
                }
                e3.Shape = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsDimension(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsDimension(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  value(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.DimensionValue()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  denotation(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startDimension(t3) {
                    t3.startObject(2);
                  }
                  static addValue(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDenotation(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endDimension(t3) {
                    return t3.endObject();
                  }
                  static createDimension(t3, e4, r2) {
                    return n2.startDimension(t3), n2.addValue(t3, e4), n2.addDenotation(t3, r2), n2.endDimension(t3);
                  }
                }
                e3.Dimension = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsDimensionValue(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsDimensionValue(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  dimType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt8(this.bb_pos + e4) : t2.experimental.fbs.DimensionValueType.UNKNOWN;
                  }
                  dimValue() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  dimParam(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startDimensionValue(t3) {
                    t3.startObject(3);
                  }
                  static addDimType(e4, n3) {
                    e4.addFieldInt8(0, n3, t2.experimental.fbs.DimensionValueType.UNKNOWN);
                  }
                  static addDimValue(t3, e4) {
                    t3.addFieldInt64(1, e4, t3.createLong(0, 0));
                  }
                  static addDimParam(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endDimensionValue(t3) {
                    return t3.endObject();
                  }
                  static createDimensionValue(t3, e4, r2, i2) {
                    return n2.startDimensionValue(t3), n2.addDimType(t3, e4), n2.addDimValue(t3, r2), n2.addDimParam(t3, i2), n2.endDimensionValue(t3);
                  }
                }
                e3.DimensionValue = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTensorTypeAndShape(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTensorTypeAndShape(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  elemType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  shape(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Shape()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startTensorTypeAndShape(t3) {
                    t3.startObject(2);
                  }
                  static addElemType(e4, n3) {
                    e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addShape(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endTensorTypeAndShape(t3) {
                    return t3.endObject();
                  }
                  static createTensorTypeAndShape(t3, e4, r2) {
                    return n2.startTensorTypeAndShape(t3), n2.addElemType(t3, e4), n2.addShape(t3, r2), n2.endTensorTypeAndShape(t3);
                  }
                }
                e3.TensorTypeAndShape = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsMapType(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsMapType(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  keyType() {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  valueType(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startMapType(t3) {
                    t3.startObject(2);
                  }
                  static addKeyType(e4, n3) {
                    e4.addFieldInt32(0, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addValueType(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endMapType(t3) {
                    return t3.endObject();
                  }
                  static createMapType(t3, e4, r2) {
                    return n2.startMapType(t3), n2.addKeyType(t3, e4), n2.addValueType(t3, r2), n2.endMapType(t3);
                  }
                }
                e3.MapType = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSequenceType(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSequenceType(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  elemType(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSequenceType(t3) {
                    t3.startObject(1);
                  }
                  static addElemType(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static endSequenceType(t3) {
                    return t3.endObject();
                  }
                  static createSequenceType(t3, e4) {
                    return n2.startSequenceType(t3), n2.addElemType(t3, e4), n2.endSequenceType(t3);
                  }
                }
                e3.SequenceType = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              (t3.fbs || (t3.fbs = {})).EdgeEnd = class {
                constructor() {
                  this.bb = null, this.bb_pos = 0;
                }
                __init(t4, e2) {
                  return this.bb_pos = t4, this.bb = e2, this;
                }
                nodeIndex() {
                  return this.bb.readUint32(this.bb_pos);
                }
                srcArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 4);
                }
                dstArgIndex() {
                  return this.bb.readInt32(this.bb_pos + 8);
                }
                static createEdgeEnd(t4, e2, n2, r2) {
                  return t4.prep(4, 12), t4.writeInt32(r2), t4.writeInt32(n2), t4.writeInt32(e2), t4.offset();
                }
              };
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsNodeEdge(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsNodeEdge(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  nodeIndex() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  inputEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                  }
                  inputEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new t2.experimental.fbs.EdgeEnd()).__init(this.bb.__vector(this.bb_pos + r2) + 12 * e4, this.bb) : null;
                  }
                  outputEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startNodeEdge(t3) {
                    t3.startObject(3);
                  }
                  static addNodeIndex(t3, e4) {
                    t3.addFieldInt32(0, e4, 0);
                  }
                  static addInputEdges(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static startInputEdgesVector(t3, e4) {
                    t3.startVector(12, e4, 4);
                  }
                  static addOutputEdges(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static startOutputEdgesVector(t3, e4) {
                    t3.startVector(12, e4, 4);
                  }
                  static endNodeEdge(t3) {
                    return t3.endObject();
                  }
                  static createNodeEdge(t3, e4, r2, i2) {
                    return n2.startNodeEdge(t3), n2.addNodeIndex(t3, e4), n2.addInputEdges(t3, r2), n2.addOutputEdges(t3, i2), n2.endNodeEdge(t3);
                  }
                }
                e3.NodeEdge = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsNode(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsNode(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  domain(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  sinceVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readInt32(this.bb_pos + t3) : 0;
                  }
                  index() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  opType(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type() {
                    let e4 = this.bb.__offset(this.bb_pos, 16);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.NodeType.Primitive;
                  }
                  executionProviderType(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 18);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  inputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 20);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  inputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 22);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  outputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 22);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  attributes(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 24);
                    return r2 ? (n3 || new t2.experimental.fbs.Attribute()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  attributesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 24);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputArgCounts(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 26);
                    return e4 ? this.bb.readInt32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                  }
                  inputArgCountsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputArgCountsArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? new Int32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  implicitInputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 28);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  implicitInputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 28);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startNode(t3) {
                    t3.startObject(13);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDomain(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static addSinceVersion(t3, e4) {
                    t3.addFieldInt32(3, e4, 0);
                  }
                  static addIndex(t3, e4) {
                    t3.addFieldInt32(4, e4, 0);
                  }
                  static addOpType(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static addType(e4, n3) {
                    e4.addFieldInt32(6, n3, t2.experimental.fbs.NodeType.Primitive);
                  }
                  static addExecutionProviderType(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addInputs(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static createInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addOutputs(t3, e4) {
                    t3.addFieldOffset(9, e4, 0);
                  }
                  static createOutputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOutputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addAttributes(t3, e4) {
                    t3.addFieldOffset(10, e4, 0);
                  }
                  static createAttributesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startAttributesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInputArgCounts(t3, e4) {
                    t3.addFieldOffset(11, e4, 0);
                  }
                  static createInputArgCountsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addInt32(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputArgCountsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addImplicitInputs(t3, e4) {
                    t3.addFieldOffset(12, e4, 0);
                  }
                  static createImplicitInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startImplicitInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endNode(t3) {
                    return t3.endObject();
                  }
                  static createNode(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                    return n2.startNode(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDomain(t3, i2), n2.addSinceVersion(t3, o2), n2.addIndex(t3, a), n2.addOpType(t3, s), n2.addType(t3, u), n2.addExecutionProviderType(t3, c), n2.addInputs(t3, l), n2.addOutputs(t3, p), n2.addAttributes(t3, f), n2.addInputArgCounts(t3, d), n2.addImplicitInputs(t3, h), n2.endNode(t3);
                  }
                }
                e3.Node = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsValueInfo(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsValueInfo(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (e4 || new t2.experimental.fbs.TypeInfo()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startValueInfo(t3) {
                    t3.startObject(3);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addType(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endValueInfo(t3) {
                    return t3.endObject();
                  }
                  static createValueInfo(t3, e4, r2, i2) {
                    return n2.startValueInfo(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.endValueInfo(t3);
                  }
                }
                e3.ValueInfo = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTypeInfo(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTypeInfo(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  denotation(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  valueType() {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.readUint8(this.bb_pos + e4) : t2.experimental.fbs.TypeInfoValue.NONE;
                  }
                  value(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__union(t3, this.bb_pos + e4) : null;
                  }
                  static startTypeInfo(t3) {
                    t3.startObject(3);
                  }
                  static addDenotation(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addValueType(e4, n3) {
                    e4.addFieldInt8(1, n3, t2.experimental.fbs.TypeInfoValue.NONE);
                  }
                  static addValue(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endTypeInfo(t3) {
                    return t3.endObject();
                  }
                  static createTypeInfo(t3, e4, r2, i2) {
                    return n2.startTypeInfo(t3), n2.addDenotation(t3, e4), n2.addValueType(t3, r2), n2.addValue(t3, i2), n2.endTypeInfo(t3);
                  }
                }
                e3.TypeInfo = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                class e2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t5, e3) {
                    return this.bb_pos = t5, this.bb = e3, this;
                  }
                  static getRootAsOperatorSetId(t5, n2) {
                    return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  static getSizePrefixedRootAsOperatorSetId(t5, n2) {
                    return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  domain(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 4);
                    return e3 ? this.bb.__string(this.bb_pos + e3, t5) : null;
                  }
                  version() {
                    let t5 = this.bb.__offset(this.bb_pos, 6);
                    return t5 ? this.bb.readInt64(this.bb_pos + t5) : this.bb.createLong(0, 0);
                  }
                  static startOperatorSetId(t5) {
                    t5.startObject(2);
                  }
                  static addDomain(t5, e3) {
                    t5.addFieldOffset(0, e3, 0);
                  }
                  static addVersion(t5, e3) {
                    t5.addFieldInt64(1, e3, t5.createLong(0, 0));
                  }
                  static endOperatorSetId(t5) {
                    return t5.endObject();
                  }
                  static createOperatorSetId(t5, n2, r2) {
                    return e2.startOperatorSetId(t5), e2.addDomain(t5, n2), e2.addVersion(t5, r2), e2.endOperatorSetId(t5);
                  }
                }
                t4.OperatorSetId = e2;
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsTensor(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsTensor(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  dims(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  dataType() {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.TensorDataType.UNDEFINED;
                  }
                  rawData(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.readUint8(this.bb.__vector(this.bb_pos + e4) + t3) : 0;
                  }
                  rawDataLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  rawDataArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? new Uint8Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  stringData(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  stringDataLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startTensor(t3) {
                    t3.startObject(6);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDims(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createDimsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static addDataType(e4, n3) {
                    e4.addFieldInt32(3, n3, t2.experimental.fbs.TensorDataType.UNDEFINED);
                  }
                  static addRawData(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static createRawDataVector(t3, e4) {
                    t3.startVector(1, e4.length, 1);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addInt8(e4[n3]);
                    return t3.endVector();
                  }
                  static startRawDataVector(t3, e4) {
                    t3.startVector(1, e4, 1);
                  }
                  static addStringData(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static createStringDataVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startStringDataVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endTensor(t3) {
                    return t3.endObject();
                  }
                  static createTensor(t3, e4, r2, i2, o2, a, s) {
                    return n2.startTensor(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addDims(t3, i2), n2.addDataType(t3, o2), n2.addRawData(t3, a), n2.addStringData(t3, s), n2.endTensor(t3);
                  }
                }
                e3.Tensor = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSparseTensor(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSparseTensor(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  values(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  indices(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  dims(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  dimsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startSparseTensor(t3) {
                    t3.startObject(3);
                  }
                  static addValues(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addIndices(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addDims(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createDimsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startDimsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static endSparseTensor(t3) {
                    return t3.endObject();
                  }
                  static createSparseTensor(t3, e4, r2, i2) {
                    return n2.startSparseTensor(t3), n2.addValues(t3, e4), n2.addIndices(t3, r2), n2.addDims(t3, i2), n2.endSparseTensor(t3);
                  }
                }
                e3.SparseTensor = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsAttribute(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsAttribute(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  name(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 6);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  type() {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.readInt32(this.bb_pos + e4) : t2.experimental.fbs.AttributeType.UNDEFINED;
                  }
                  f() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readFloat32(this.bb_pos + t3) : 0;
                  }
                  i() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  s(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 14);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  t(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? (e4 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  g(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  floats(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.readFloat32(this.bb.__vector(this.bb_pos + e4) + 4 * t3) : 0;
                  }
                  floatsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  floatsArray() {
                    let t3 = this.bb.__offset(this.bb_pos, 20);
                    return t3 ? new Float32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t3), this.bb.__vector_len(this.bb_pos + t3)) : null;
                  }
                  ints(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 22);
                    return e4 ? this.bb.readInt64(this.bb.__vector(this.bb_pos + e4) + 8 * t3) : this.bb.createLong(0, 0);
                  }
                  intsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 22);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  strings(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 24);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  stringsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 24);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  tensors(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 26);
                    return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  tensorsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 26);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  graphs(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 28);
                    return r2 ? (n3 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  graphsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 28);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startAttribute(t3) {
                    t3.startObject(13);
                  }
                  static addName(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addType(e4, n3) {
                    e4.addFieldInt32(2, n3, t2.experimental.fbs.AttributeType.UNDEFINED);
                  }
                  static addF(t3, e4) {
                    t3.addFieldFloat32(3, e4, 0);
                  }
                  static addI(t3, e4) {
                    t3.addFieldInt64(4, e4, t3.createLong(0, 0));
                  }
                  static addS(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static addT(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static addG(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addFloats(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static createFloatsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addFloat32(e4[n3]);
                    return t3.endVector();
                  }
                  static startFloatsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInts(t3, e4) {
                    t3.addFieldOffset(9, e4, 0);
                  }
                  static createIntsVector(t3, e4) {
                    t3.startVector(8, e4.length, 8);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addInt64(e4[n3]);
                    return t3.endVector();
                  }
                  static startIntsVector(t3, e4) {
                    t3.startVector(8, e4, 8);
                  }
                  static addStrings(t3, e4) {
                    t3.addFieldOffset(10, e4, 0);
                  }
                  static createStringsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startStringsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addTensors(t3, e4) {
                    t3.addFieldOffset(11, e4, 0);
                  }
                  static createTensorsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startTensorsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addGraphs(t3, e4) {
                    t3.addFieldOffset(12, e4, 0);
                  }
                  static createGraphsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startGraphsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endAttribute(t3) {
                    return t3.endObject();
                  }
                  static createAttribute(t3, e4, r2, i2, o2, a, s, u, c, l, p, f, d, h) {
                    return n2.startAttribute(t3), n2.addName(t3, e4), n2.addDocString(t3, r2), n2.addType(t3, i2), n2.addF(t3, o2), n2.addI(t3, a), n2.addS(t3, s), n2.addT(t3, u), n2.addG(t3, c), n2.addFloats(t3, l), n2.addInts(t3, p), n2.addStrings(t3, f), n2.addTensors(t3, d), n2.addGraphs(t3, h), n2.endAttribute(t3);
                  }
                }
                e3.Attribute = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsGraph(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsGraph(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  initializers(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 4);
                    return r2 ? (n3 || new t2.experimental.fbs.Tensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  initializersLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  nodeArgs(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.ValueInfo()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodeArgsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  nodes(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 8);
                    return r2 ? (n3 || new t2.experimental.fbs.Node()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 8);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  maxNodeIndex() {
                    let t3 = this.bb.__offset(this.bb_pos, 10);
                    return t3 ? this.bb.readUint32(this.bb_pos + t3) : 0;
                  }
                  nodeEdges(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 12);
                    return r2 ? (n3 || new t2.experimental.fbs.NodeEdge()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  nodeEdgesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 12);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  inputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 14);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  inputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  outputs(t3, e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 16);
                    return n3 ? this.bb.__string(this.bb.__vector(this.bb_pos + n3) + 4 * t3, e4) : null;
                  }
                  outputsLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 16);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  sparseInitializers(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 18);
                    return r2 ? (n3 || new t2.experimental.fbs.SparseTensor()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  sparseInitializersLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 18);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startGraph(t3) {
                    t3.startObject(8);
                  }
                  static addInitializers(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static createInitializersVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInitializersVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addNodeArgs(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createNodeArgsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodeArgsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addNodes(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static createNodesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addMaxNodeIndex(t3, e4) {
                    t3.addFieldInt32(3, e4, 0);
                  }
                  static addNodeEdges(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static createNodeEdgesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startNodeEdgesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addInputs(t3, e4) {
                    t3.addFieldOffset(5, e4, 0);
                  }
                  static createInputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startInputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addOutputs(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static createOutputsVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOutputsVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addSparseInitializers(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static createSparseInitializersVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startSparseInitializersVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endGraph(t3) {
                    return t3.endObject();
                  }
                  static createGraph(t3, e4, r2, i2, o2, a, s, u, c) {
                    return n2.startGraph(t3), n2.addInitializers(t3, e4), n2.addNodeArgs(t3, r2), n2.addNodes(t3, i2), n2.addMaxNodeIndex(t3, o2), n2.addNodeEdges(t3, a), n2.addInputs(t3, s), n2.addOutputs(t3, u), n2.addSparseInitializers(t3, c), n2.endGraph(t3);
                  }
                }
                e3.Graph = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsModel(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsModel(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  irVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 4);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  opsetImport(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.OperatorSetId()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  opsetImportLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  producerName(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 8);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  producerVersion(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 10);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  domain(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 12);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  modelVersion() {
                    let t3 = this.bb.__offset(this.bb_pos, 14);
                    return t3 ? this.bb.readInt64(this.bb_pos + t3) : this.bb.createLong(0, 0);
                  }
                  docString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 16);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  graph(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 18);
                    return n3 ? (e4 || new t2.experimental.fbs.Graph()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  graphDocString(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 20);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  static startModel(t3) {
                    t3.startObject(9);
                  }
                  static addIrVersion(t3, e4) {
                    t3.addFieldInt64(0, e4, t3.createLong(0, 0));
                  }
                  static addOpsetImport(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createOpsetImportVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startOpsetImportVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static addProducerName(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static addProducerVersion(t3, e4) {
                    t3.addFieldOffset(3, e4, 0);
                  }
                  static addDomain(t3, e4) {
                    t3.addFieldOffset(4, e4, 0);
                  }
                  static addModelVersion(t3, e4) {
                    t3.addFieldInt64(5, e4, t3.createLong(0, 0));
                  }
                  static addDocString(t3, e4) {
                    t3.addFieldOffset(6, e4, 0);
                  }
                  static addGraph(t3, e4) {
                    t3.addFieldOffset(7, e4, 0);
                  }
                  static addGraphDocString(t3, e4) {
                    t3.addFieldOffset(8, e4, 0);
                  }
                  static endModel(t3) {
                    return t3.endObject();
                  }
                  static createModel(t3, e4, r2, i2, o2, a, s, u, c, l) {
                    return n2.startModel(t3), n2.addIrVersion(t3, e4), n2.addOpsetImport(t3, r2), n2.addProducerName(t3, i2), n2.addProducerVersion(t3, o2), n2.addDomain(t3, a), n2.addModelVersion(t3, s), n2.addDocString(t3, u), n2.addGraph(t3, c), n2.addGraphDocString(t3, l), n2.endModel(t3);
                  }
                }
                e3.Model = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(t3) {
              !function(t4) {
                class e2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t5, e3) {
                    return this.bb_pos = t5, this.bb = e3, this;
                  }
                  static getRootAsKernelCreateInfos(t5, n2) {
                    return (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  static getSizePrefixedRootAsKernelCreateInfos(t5, n2) {
                    return t5.setPosition(t5.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (n2 || new e2()).__init(t5.readInt32(t5.position()) + t5.position(), t5);
                  }
                  nodeIndices(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 4);
                    return e3 ? this.bb.readUint32(this.bb.__vector(this.bb_pos + e3) + 4 * t5) : 0;
                  }
                  nodeIndicesLength() {
                    let t5 = this.bb.__offset(this.bb_pos, 4);
                    return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                  }
                  nodeIndicesArray() {
                    let t5 = this.bb.__offset(this.bb_pos, 4);
                    return t5 ? new Uint32Array(this.bb.bytes().buffer, this.bb.bytes().byteOffset + this.bb.__vector(this.bb_pos + t5), this.bb.__vector_len(this.bb_pos + t5)) : null;
                  }
                  kernelDefHashes(t5) {
                    let e3 = this.bb.__offset(this.bb_pos, 6);
                    return e3 ? this.bb.readUint64(this.bb.__vector(this.bb_pos + e3) + 8 * t5) : this.bb.createLong(0, 0);
                  }
                  kernelDefHashesLength() {
                    let t5 = this.bb.__offset(this.bb_pos, 6);
                    return t5 ? this.bb.__vector_len(this.bb_pos + t5) : 0;
                  }
                  static startKernelCreateInfos(t5) {
                    t5.startObject(2);
                  }
                  static addNodeIndices(t5, e3) {
                    t5.addFieldOffset(0, e3, 0);
                  }
                  static createNodeIndicesVector(t5, e3) {
                    t5.startVector(4, e3.length, 4);
                    for (let n2 = e3.length - 1; n2 >= 0; n2--) t5.addInt32(e3[n2]);
                    return t5.endVector();
                  }
                  static startNodeIndicesVector(t5, e3) {
                    t5.startVector(4, e3, 4);
                  }
                  static addKernelDefHashes(t5, e3) {
                    t5.addFieldOffset(1, e3, 0);
                  }
                  static createKernelDefHashesVector(t5, e3) {
                    t5.startVector(8, e3.length, 8);
                    for (let n2 = e3.length - 1; n2 >= 0; n2--) t5.addInt64(e3[n2]);
                    return t5.endVector();
                  }
                  static startKernelDefHashesVector(t5, e3) {
                    t5.startVector(8, e3, 8);
                  }
                  static endKernelCreateInfos(t5) {
                    return t5.endObject();
                  }
                  static createKernelCreateInfos(t5, n2, r2) {
                    return e2.startKernelCreateInfos(t5), e2.addNodeIndices(t5, n2), e2.addKernelDefHashes(t5, r2), e2.endKernelCreateInfos(t5);
                  }
                }
                t4.KernelCreateInfos = e2;
              }(t3.fbs || (t3.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSubGraphSessionState(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSubGraphSessionState(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  graphId(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  sessionState(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startSubGraphSessionState(t3) {
                    t3.startObject(2);
                  }
                  static addGraphId(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addSessionState(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static endSubGraphSessionState(t3) {
                    let e4 = t3.endObject();
                    return t3.requiredField(e4, 4), e4;
                  }
                  static createSubGraphSessionState(t3, e4, r2) {
                    return n2.startSubGraphSessionState(t3), n2.addGraphId(t3, e4), n2.addSessionState(t3, r2), n2.endSubGraphSessionState(t3);
                  }
                }
                e3.SubGraphSessionState = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsSessionState(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsSessionState(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  kernels(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 4);
                    return n3 ? (e4 || new t2.experimental.fbs.KernelCreateInfos()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  subGraphSessionStates(e4, n3) {
                    let r2 = this.bb.__offset(this.bb_pos, 6);
                    return r2 ? (n3 || new t2.experimental.fbs.SubGraphSessionState()).__init(this.bb.__indirect(this.bb.__vector(this.bb_pos + r2) + 4 * e4), this.bb) : null;
                  }
                  subGraphSessionStatesLength() {
                    let t3 = this.bb.__offset(this.bb_pos, 6);
                    return t3 ? this.bb.__vector_len(this.bb_pos + t3) : 0;
                  }
                  static startSessionState(t3) {
                    t3.startObject(2);
                  }
                  static addKernels(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addSubGraphSessionStates(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static createSubGraphSessionStatesVector(t3, e4) {
                    t3.startVector(4, e4.length, 4);
                    for (let n3 = e4.length - 1; n3 >= 0; n3--) t3.addOffset(e4[n3]);
                    return t3.endVector();
                  }
                  static startSubGraphSessionStatesVector(t3, e4) {
                    t3.startVector(4, e4, 4);
                  }
                  static endSessionState(t3) {
                    return t3.endObject();
                  }
                  static createSessionState(t3, e4, r2) {
                    return n2.startSessionState(t3), n2.addKernels(t3, e4), n2.addSubGraphSessionStates(t3, r2), n2.endSessionState(t3);
                  }
                }
                e3.SessionState = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {})), function(t2) {
            !function(e2) {
              !function(e3) {
                class n2 {
                  constructor() {
                    this.bb = null, this.bb_pos = 0;
                  }
                  __init(t3, e4) {
                    return this.bb_pos = t3, this.bb = e4, this;
                  }
                  static getRootAsInferenceSession(t3, e4) {
                    return (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static getSizePrefixedRootAsInferenceSession(t3, e4) {
                    return t3.setPosition(t3.position() + r.flatbuffers.SIZE_PREFIX_LENGTH), (e4 || new n2()).__init(t3.readInt32(t3.position()) + t3.position(), t3);
                  }
                  static bufferHasIdentifier(t3) {
                    return t3.__has_identifier("ORTM");
                  }
                  ortVersion(t3) {
                    let e4 = this.bb.__offset(this.bb_pos, 4);
                    return e4 ? this.bb.__string(this.bb_pos + e4, t3) : null;
                  }
                  model(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 6);
                    return n3 ? (e4 || new t2.experimental.fbs.Model()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  sessionState(e4) {
                    let n3 = this.bb.__offset(this.bb_pos, 8);
                    return n3 ? (e4 || new t2.experimental.fbs.SessionState()).__init(this.bb.__indirect(this.bb_pos + n3), this.bb) : null;
                  }
                  static startInferenceSession(t3) {
                    t3.startObject(3);
                  }
                  static addOrtVersion(t3, e4) {
                    t3.addFieldOffset(0, e4, 0);
                  }
                  static addModel(t3, e4) {
                    t3.addFieldOffset(1, e4, 0);
                  }
                  static addSessionState(t3, e4) {
                    t3.addFieldOffset(2, e4, 0);
                  }
                  static endInferenceSession(t3) {
                    return t3.endObject();
                  }
                  static finishInferenceSessionBuffer(t3, e4) {
                    t3.finish(e4, "ORTM");
                  }
                  static finishSizePrefixedInferenceSessionBuffer(t3, e4) {
                    t3.finish(e4, "ORTM", true);
                  }
                  static createInferenceSession(t3, e4, r2, i2) {
                    return n2.startInferenceSession(t3), n2.addOrtVersion(t3, e4), n2.addModel(t3, r2), n2.addSessionState(t3, i2), n2.endInferenceSession(t3);
                  }
                }
                e3.InferenceSession = n2;
              }(e2.fbs || (e2.fbs = {}));
            }(t2.experimental || (t2.experimental = {}));
          }(e.onnxruntime || (e.onnxruntime = {}));
        }, 7448: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.OnnxjsSessionHandler = void 0;
          const r = n(1670), i = n(9162);
          e.OnnxjsSessionHandler = class {
            constructor(t2) {
              this.session = t2, this.inputNames = this.session.inputNames, this.outputNames = this.session.outputNames;
            }
            dispose() {
              return __async(this, null, function* () {
              });
            }
            run(t2, e2, n2) {
              return __async(this, null, function* () {
                const o = /* @__PURE__ */ new Map();
                for (const e3 in t2) if (Object.hasOwnProperty.call(t2, e3)) {
                  const n3 = t2[e3];
                  o.set(e3, new i.Tensor(n3.dims, n3.type, void 0, void 0, n3.data));
                }
                const a = yield this.session.run(o), s = {};
                return a.forEach((t3, e3) => {
                  s[e3] = new r.Tensor(t3.type, t3.data, t3.dims);
                }), s;
              });
            }
            startProfiling() {
              this.session.startProfiling();
            }
            endProfiling() {
              this.session.endProfiling();
            }
          };
        }, 6919: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.Session = void 0;
          const r = n(7067), i = n(1296), o = n(7091), a = n(1036), s = n(6231), u = n(2644);
          e.Session = class {
            constructor(t2 = {}) {
              this._initialized = false, this.backendHint = t2.backendHint, this.profiler = s.Profiler.create(t2.profiler), this.context = { profiler: this.profiler, graphInputTypes: [], graphInputDims: [] };
            }
            get inputNames() {
              return this._model.graph.getInputNames();
            }
            get outputNames() {
              return this._model.graph.getOutputNames();
            }
            startProfiling() {
              this.profiler.start();
            }
            endProfiling() {
              this.profiler.stop();
            }
            loadModel(t2, e2, n2) {
              return __async(this, null, function* () {
                yield this.profiler.event("session", "Session.loadModel", () => __async(this, null, function* () {
                  const a2 = yield (0, o.resolveBackend)(this.backendHint);
                  if (this.sessionHandler = a2.createSessionHandler(this.context), this._model = new u.Model(), "string" == typeof t2) {
                    const e3 = t2.endsWith(".ort");
                    if ("undefined" == typeof fetch) {
                      const n3 = yield (0, i.promisify)(r.readFile)(t2);
                      this.initialize(n3, e3);
                    } else {
                      const n3 = yield fetch(t2), r2 = yield n3.arrayBuffer();
                      this.initialize(new Uint8Array(r2), e3);
                    }
                  } else if (ArrayBuffer.isView(t2)) this.initialize(t2);
                  else {
                    const r2 = new Uint8Array(t2, e2 || 0, n2 || t2.byteLength);
                    this.initialize(r2);
                  }
                }));
              });
            }
            initialize(t2, e2) {
              if (this._initialized) throw new Error("already initialized");
              this.profiler.event("session", "Session.initialize", () => {
                const n2 = this.sessionHandler.transformGraph ? this.sessionHandler : void 0;
                this._model.load(t2, n2, e2), this.sessionHandler.onGraphInitialized && this.sessionHandler.onGraphInitialized(this._model.graph), this.initializeOps(this._model.graph), this._executionPlan = new a.ExecutionPlan(this._model.graph, this._ops, this.profiler);
              }), this._initialized = true;
            }
            run(t2) {
              return __async(this, null, function* () {
                if (!this._initialized) throw new Error("session not initialized yet");
                return this.profiler.event("session", "Session.run", () => __async(this, null, function* () {
                  const e2 = this.normalizeAndValidateInputs(t2), n2 = yield this._executionPlan.execute(this.sessionHandler, e2);
                  return this.createOutput(n2);
                }));
              });
            }
            normalizeAndValidateInputs(t2) {
              const e2 = this._model.graph.getInputNames();
              if (Array.isArray(t2)) {
                if (t2.length !== e2.length) throw new Error(`incorrect input array length: expected ${e2.length} but got ${t2.length}`);
              } else {
                if (t2.size !== e2.length) throw new Error(`incorrect input map size: expected ${e2.length} but got ${t2.size}`);
                const n2 = new Array(t2.size);
                let r2 = 0;
                for (let i2 = 0; i2 < e2.length; ++i2) {
                  const o2 = t2.get(e2[i2]);
                  if (!o2) throw new Error(`missing input tensor for: '${name}'`);
                  n2[r2++] = o2;
                }
                t2 = n2;
              }
              if (this.context.graphInputTypes && 0 !== this.context.graphInputTypes.length && this.context.graphInputDims && 0 !== this.context.graphInputDims.length) this.validateInputTensorDims(this.context.graphInputDims, t2, false);
              else {
                const e3 = this._model.graph.getInputIndices(), n2 = this._model.graph.getValues(), r2 = new Array(e3.length);
                for (let i2 = 0; i2 < e3.length; ++i2) {
                  const o2 = n2[e3[i2]];
                  r2[i2] = o2.type.shape.dims, this.context.graphInputTypes.push(o2.type.tensorType), this.context.graphInputDims.push(t2[i2].dims);
                }
                this.validateInputTensorDims(r2, t2, true);
              }
              return this.validateInputTensorTypes(this.context.graphInputTypes, t2), t2;
            }
            validateInputTensorTypes(t2, e2) {
              for (let n2 = 0; n2 < e2.length; n2++) {
                const r2 = t2[n2], i2 = e2[n2].type;
                if (r2 !== i2) throw new Error(`input tensor[${n2}] check failed: expected type '${r2}' but got ${i2}`);
              }
            }
            validateInputTensorDims(t2, e2, n2) {
              for (let r2 = 0; r2 < e2.length; r2++) {
                const i2 = t2[r2], o2 = e2[r2].dims;
                if (!this.compareTensorDims(i2, o2, n2)) throw new Error(`input tensor[${r2}] check failed: expected shape '[${i2.join(",")}]' but got [${o2.join(",")}]`);
              }
            }
            compareTensorDims(t2, e2, n2) {
              if (t2.length !== e2.length) return false;
              for (let r2 = 0; r2 < t2.length; ++r2) if (t2[r2] !== e2[r2] && (!n2 || 0 !== t2[r2])) return false;
              return true;
            }
            createOutput(t2) {
              const e2 = this._model.graph.getOutputNames();
              if (t2.length !== e2.length) throw new Error("expected number of outputs do not match number of generated outputs");
              const n2 = /* @__PURE__ */ new Map();
              for (let r2 = 0; r2 < e2.length; ++r2) n2.set(e2[r2], t2[r2]);
              return n2;
            }
            initializeOps(t2) {
              const e2 = t2.getNodes();
              this._ops = new Array(e2.length);
              for (let n2 = 0; n2 < e2.length; n2++) this._ops[n2] = this.sessionHandler.resolve(e2[n2], this._model.opsets, t2);
            }
          };
        }, 9162: function(t, e, n) {
          var r = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.Tensor = void 0;
          const i = n(3442), o = r(n(3720)), a = n(1446), s = n(9395), u = n(2517);
          var c = s.onnxruntime.experimental.fbs;
          class l {
            get data() {
              if (void 0 === this.cache) {
                const t2 = this.dataProvider(this.dataId);
                if (t2.length !== this.size) throw new Error("Length of data provided by the Data Provider is inconsistent with the dims of this Tensor.");
                this.cache = t2;
              }
              return this.cache;
            }
            get stringData() {
              if ("string" !== this.type) throw new TypeError("data type is not string");
              return this.data;
            }
            get integerData() {
              switch (this.type) {
                case "uint8":
                case "int8":
                case "uint16":
                case "int16":
                case "int32":
                case "uint32":
                case "bool":
                  return this.data;
                default:
                  throw new TypeError("data type is not integer (uint8, int8, uint16, int16, int32, uint32, bool)");
              }
            }
            get floatData() {
              switch (this.type) {
                case "float32":
                case "float64":
                  return this.data;
                default:
                  throw new TypeError("data type is not float (float32, float64)");
              }
            }
            get numberData() {
              if ("string" !== this.type) return this.data;
              throw new TypeError("type cannot be non-number (string)");
            }
            get(t2) {
              return this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)];
            }
            set(t2, e2) {
              this.data[u.ShapeUtil.indicesToOffset(t2, this.strides)] = e2;
            }
            getData() {
              return __async(this, null, function* () {
                return void 0 === this.cache && (this.cache = yield this.asyncDataProvider(this.dataId)), this.cache;
              });
            }
            get strides() {
              return this._strides || (this._strides = u.ShapeUtil.computeStrides(this.dims)), this._strides;
            }
            constructor(t2, e2, n2, r2, o2, a2 = i.Guid.create()) {
              this.dims = t2, this.type = e2, this.dataProvider = n2, this.asyncDataProvider = r2, this.cache = o2, this.dataId = a2, this.size = u.ShapeUtil.validateDimsAndCalcSize(t2);
              const s2 = this.size, c2 = void 0 === n2 && void 0 === r2 && void 0 === o2;
              if (void 0 !== o2 && o2.length !== s2) throw new RangeError("Input dims doesn't match data length.");
              if ("string" === e2) {
                if (!(void 0 === o2 || Array.isArray(o2) && o2.every((t3) => "string" == typeof t3))) throw new TypeError("cache should be a string array");
                c2 && (this.cache = new Array(s2));
              } else {
                if (void 0 !== o2) {
                  const t3 = f(e2);
                  if (!(o2 instanceof t3)) throw new TypeError(`cache should be type ${t3.name}`);
                }
                if (c2) {
                  const t3 = new ArrayBuffer(s2 * function(t4) {
                    switch (t4) {
                      case "bool":
                      case "int8":
                      case "uint8":
                        return 1;
                      case "int16":
                      case "uint16":
                        return 2;
                      case "int32":
                      case "uint32":
                      case "float32":
                        return 4;
                      case "float64":
                        return 8;
                      default:
                        throw new Error(`cannot calculate sizeof() on type ${t4}`);
                    }
                  }(e2));
                  this.cache = function(t4, e3) {
                    return new (f(e3))(t4);
                  }(t3, e2);
                }
              }
            }
            static fromProto(t2) {
              if (!t2) throw new Error("cannot construct Value from an empty tensor");
              const e2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType), n2 = u.ProtoUtil.tensorDimsFromProto(t2.dims), r2 = new l(n2, e2);
              if ("string" === e2) t2.stringData.forEach((t3, e3) => {
                r2.data[e3] = (0, u.decodeUtf8String)(t3);
              });
              else if (t2.rawData && "number" == typeof t2.rawData.byteLength && t2.rawData.byteLength > 0) {
                const e3 = r2.data, n3 = new DataView(t2.rawData.buffer, t2.rawData.byteOffset, t2.rawData.byteLength), i2 = p(t2.dataType), o2 = t2.rawData.byteLength / i2;
                if (t2.rawData.byteLength % i2 != 0) throw new Error("invalid buffer length");
                if (e3.length !== o2) throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < o2; r3++) {
                  const o3 = h(n3, t2.dataType, r3 * i2);
                  e3[r3] = o3;
                }
              } else {
                let e3;
                switch (t2.dataType) {
                  case a.onnx.TensorProto.DataType.FLOAT:
                    e3 = t2.floatData;
                    break;
                  case a.onnx.TensorProto.DataType.INT32:
                  case a.onnx.TensorProto.DataType.INT16:
                  case a.onnx.TensorProto.DataType.UINT16:
                  case a.onnx.TensorProto.DataType.INT8:
                  case a.onnx.TensorProto.DataType.UINT8:
                  case a.onnx.TensorProto.DataType.BOOL:
                    e3 = t2.int32Data;
                    break;
                  case a.onnx.TensorProto.DataType.INT64:
                    e3 = t2.int64Data;
                    break;
                  case a.onnx.TensorProto.DataType.DOUBLE:
                    e3 = t2.doubleData;
                    break;
                  case a.onnx.TensorProto.DataType.UINT32:
                  case a.onnx.TensorProto.DataType.UINT64:
                    e3 = t2.uint64Data;
                    break;
                  default:
                    throw new Error("unspecific error");
                }
                if (null == e3) throw new Error("failed to populate data from a tensorproto value");
                const n3 = r2.data;
                if (n3.length !== e3.length) throw new Error("array length mismatch");
                for (let r3 = 0; r3 < e3.length; r3++) {
                  const i2 = e3[r3];
                  o.default.isLong(i2) ? n3[r3] = d(i2, t2.dataType) : n3[r3] = i2;
                }
              }
              return r2;
            }
            static fromData(t2, e2, n2) {
              return new l(e2, n2, void 0, void 0, t2);
            }
            static fromOrtTensor(t2) {
              if (!t2) throw new Error("cannot construct Value from an empty tensor");
              const e2 = u.ProtoUtil.tensorDimsFromORTFormat(t2), n2 = u.ProtoUtil.tensorDataTypeFromProto(t2.dataType()), r2 = new l(e2, n2);
              if ("string" === n2) for (let e3 = 0; e3 < t2.stringDataLength(); e3++) r2.data[e3] = t2.stringData(e3);
              else if (t2.rawDataArray() && "number" == typeof t2.rawDataLength() && t2.rawDataLength() > 0) {
                const e3 = r2.data, n3 = new DataView(t2.rawDataArray().buffer, t2.rawDataArray().byteOffset, t2.rawDataLength()), i2 = p(t2.dataType()), o2 = t2.rawDataLength() / i2;
                if (t2.rawDataLength() % i2 != 0) throw new Error("invalid buffer length");
                if (e3.length !== o2) throw new Error("buffer length mismatch");
                for (let r3 = 0; r3 < o2; r3++) {
                  const o3 = h(n3, t2.dataType(), r3 * i2);
                  e3[r3] = o3;
                }
              }
              return r2;
            }
          }
          function p(t2) {
            switch (t2) {
              case a.onnx.TensorProto.DataType.UINT8:
              case a.onnx.TensorProto.DataType.INT8:
              case a.onnx.TensorProto.DataType.BOOL:
                return 1;
              case a.onnx.TensorProto.DataType.UINT16:
              case a.onnx.TensorProto.DataType.INT16:
                return 2;
              case a.onnx.TensorProto.DataType.FLOAT:
              case a.onnx.TensorProto.DataType.INT32:
              case a.onnx.TensorProto.DataType.UINT32:
                return 4;
              case a.onnx.TensorProto.DataType.INT64:
              case a.onnx.TensorProto.DataType.DOUBLE:
              case a.onnx.TensorProto.DataType.UINT64:
                return 8;
              default:
                throw new Error(`cannot calculate sizeof() on type ${a.onnx.TensorProto.DataType[t2]}`);
            }
          }
          function f(t2) {
            switch (t2) {
              case "bool":
              case "uint8":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "int16":
                return Int16Array;
              case "uint16":
                return Uint16Array;
              case "int32":
                return Int32Array;
              case "uint32":
                return Uint32Array;
              case "float32":
                return Float32Array;
              case "float64":
                return Float64Array;
              default:
                throw new Error("unspecified error");
            }
          }
          function d(t2, e2) {
            if (e2 === a.onnx.TensorProto.DataType.INT64 || e2 === c.TensorDataType.INT64) {
              if (t2.greaterThanOrEqual(2147483648) || t2.lessThan(-2147483648)) throw new TypeError("int64 is not supported");
            } else {
              if (e2 !== a.onnx.TensorProto.DataType.UINT32 && e2 !== c.TensorDataType.UINT32 && e2 !== a.onnx.TensorProto.DataType.UINT64 && e2 !== c.TensorDataType.UINT64) throw new TypeError(`not a LONG type: ${a.onnx.TensorProto.DataType[e2]}`);
              if (t2.greaterThanOrEqual(4294967296) || t2.lessThan(0)) throw new TypeError("uint64 is not supported");
            }
            return t2.toNumber();
          }
          function h(t2, e2, n2) {
            switch (e2) {
              case a.onnx.TensorProto.DataType.BOOL:
              case a.onnx.TensorProto.DataType.UINT8:
                return t2.getUint8(n2);
              case a.onnx.TensorProto.DataType.INT8:
                return t2.getInt8(n2);
              case a.onnx.TensorProto.DataType.UINT16:
                return t2.getUint16(n2, true);
              case a.onnx.TensorProto.DataType.INT16:
                return t2.getInt16(n2, true);
              case a.onnx.TensorProto.DataType.FLOAT:
                return t2.getFloat32(n2, true);
              case a.onnx.TensorProto.DataType.INT32:
                return t2.getInt32(n2, true);
              case a.onnx.TensorProto.DataType.UINT32:
                return t2.getUint32(n2, true);
              case a.onnx.TensorProto.DataType.INT64:
                return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), false), e2);
              case a.onnx.TensorProto.DataType.DOUBLE:
                return t2.getFloat64(n2, true);
              case a.onnx.TensorProto.DataType.UINT64:
                return d(o.default.fromBits(t2.getUint32(n2, true), t2.getUint32(n2 + 4, true), true), e2);
              default:
                throw new Error(`cannot read from DataView for type ${a.onnx.TensorProto.DataType[e2]}`);
            }
          }
          e.Tensor = l;
        }, 2517: function(t, e, n) {
          var r = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.decodeUtf8String = e.MAX_CLIP = e.MIN_CLIP = e.PoolConvUtil = e.ReduceUtil = e.SplitUtil = e.MathUtil = e.ShapeUtil = e.LongUtil = e.ProtoUtil = e.GemmUtil = e.arrayCopyHelper = e.BroadcastUtil = e.MatMulUtil = e.ArrayUtil = e.assert = e.checkInputsShape = void 0;
          const i = n(5686), o = r(n(3720)), a = n(1446), s = n(9162);
          e.checkInputsShape = function(t2, ...e2) {
            if (!t2 || t2.length !== e2.length) return false;
            for (let n2 = 0; n2 < t2.length; n2++) if (!t2[n2].dims || t2[n2].dims.length !== e2[n2]) return false;
            return true;
          }, e.assert = function(t2, e2) {
            if (!t2) throw new Error("string" == typeof e2 ? e2 : e2());
          }, e.ArrayUtil = class {
            static arraysEqual(t2, e2) {
              if (t2.length !== e2.length) return false;
              for (let n2 = 0; n2 < t2.length; n2++) if (t2[n2] !== e2[n2]) return false;
              return true;
            }
          };
          class u {
            static preprocessInputShapes(t2, e2) {
              return [1 === t2.length ? [1, t2[0]] : t2, 1 === e2.length ? [e2[0], 1] : e2];
            }
            static postprocessOutputShape(t2, e2, n2) {
              1 === e2 && t2.splice(t2.length - 2, 1), 1 === n2 && t2.pop();
            }
            static calcMatMulShape(t2, e2) {
              return t2[1] !== e2[0] ? void 0 : [t2[0], e2[1]];
            }
          }
          e.MatMulUtil = u;
          class c {
            static calcShape(t2, e2, n2 = false) {
              const r2 = t2.length, i2 = e2.length;
              if (0 === r2) return e2;
              if (0 === i2) return t2;
              const o2 = Math.max(t2.length, e2.length), a2 = new Array(o2);
              if (n2) {
                if (r2 < 2 || i2 < 2) return;
                const n3 = u.calcMatMulShape([t2[r2 - 2], t2[r2 - 1]], [e2[i2 - 2], e2[i2 - 1]]);
                if (void 0 === n3) return;
                [a2[o2 - 2], a2[o2 - 1]] = n3;
              }
              for (let s2 = n2 ? 3 : 1; s2 <= o2; s2++) {
                const n3 = r2 - s2 < 0 ? 1 : t2[r2 - s2], u2 = i2 - s2 < 0 ? 1 : e2[i2 - s2];
                if (n3 !== u2 && n3 > 1 && u2 > 1) return;
                a2[o2 - s2] = Math.max(n3, u2);
              }
              return a2;
            }
            static index(t2, e2) {
              const n2 = new Array(e2.length);
              return c.fillIndex(t2, e2, n2), n2;
            }
            static fillIndex(t2, e2, n2) {
              const r2 = t2.length - e2.length;
              for (let i2 = 0; i2 < e2.length; i2++) n2[i2] = t2[r2 + i2] % e2[i2];
            }
            static calc(t2, e2, n2, r2, i2) {
              const o2 = c.calcShape(t2.dims, e2.dims);
              if (o2) {
                if (r2 && !f.areEqual(o2, t2.dims)) return;
                const a2 = f.size(o2), u2 = r2 ? t2 : new s.Tensor(o2, i2 || t2.type);
                if (0 === o2.length) u2.set([], n2(t2.get([]), e2.get([])));
                else {
                  const r3 = new Array(o2.length), i3 = new Array(t2.dims.length), s2 = new Array(e2.dims.length);
                  let l2, p2 = 0, f2 = 0, d2 = false, h2 = false;
                  0 === t2.dims.length && (p2 = t2.get([]), d2 = true), 0 === e2.dims.length && (f2 = e2.get([]), h2 = true);
                  for (let g2 = 0; g2 < a2; g2++) {
                    l2 = g2;
                    for (let t3 = o2.length - 1; t3 >= 0; t3--) r3[t3] = l2 % o2[t3], l2 = Math.floor(l2 / o2[t3]);
                    d2 || (c.fillIndex(r3, t2.dims, i3), p2 = t2.get(i3)), h2 || (c.fillIndex(r3, e2.dims, s2), f2 = e2.get(s2)), u2.set(r3, n2(p2, f2));
                  }
                }
                return u2;
              }
            }
            static isValidBroadcast(t2, e2) {
              const n2 = t2.length, r2 = e2.length;
              if (n2 > r2) return false;
              for (let i2 = 1; i2 <= n2; i2++) if (1 !== t2[n2 - i2] && t2[n2 - i2] !== e2[r2 - i2]) return false;
              return true;
            }
            static getBroadcastDims(t2, e2) {
              const n2 = t2.length, r2 = [];
              for (let i2 = 0; i2 < n2; i2++) {
                const o2 = n2 - 1 - i2, a2 = t2[o2] || 1;
                (e2[e2.length - 1 - i2] || 1) > 1 && 1 === a2 && r2.unshift(o2);
              }
              return r2;
            }
          }
          e.BroadcastUtil = c, e.arrayCopyHelper = function(t2, e2, n2, r2, i2) {
            if (r2 < 0 || r2 >= e2.length) throw new Error("sourceIndex out of bounds");
            if (n2 < 0 || n2 >= t2.length) throw new Error("targetIndex out of bounds");
            if (r2 + i2 > e2.length) throw new Error("source indices to be copied are outside bounds");
            if (n2 + i2 > t2.length) throw new Error("target array is too small to hold result");
            for (let o2 = 0; o2 < i2; o2++) t2[n2 + o2] = e2[r2 + o2];
          }, e.GemmUtil = class {
            static getShapeOfGemmResult(t2, e2, n2, r2, i2) {
              if (2 !== t2.length || 2 !== n2.length) throw new Error("shape need to be of size 2");
              let o2, a2, s2;
              e2 ? (o2 = t2[1], a2 = t2[0]) : (o2 = t2[0], a2 = t2[1]);
              let u2 = -1;
              if (r2 ? (s2 = n2[0], u2 = 1) : (s2 = n2[1], u2 = 0), n2[u2] !== a2) throw new Error("dimension mismatch");
              if (o2 <= 0 || s2 <= 0 || a2 <= 0) throw new Error("invalid shape specified");
              if (i2 && !c.isValidBroadcast(i2, [o2, s2])) throw new Error("gemm: invalid bias shape for broadcast");
              return [o2, s2, a2];
            }
          };
          class l {
            static tensorDataTypeFromProto(t2) {
              switch (t2) {
                case a.onnx.TensorProto.DataType.INT8:
                  return "int8";
                case a.onnx.TensorProto.DataType.UINT8:
                  return "uint8";
                case a.onnx.TensorProto.DataType.BOOL:
                  return "bool";
                case a.onnx.TensorProto.DataType.INT16:
                  return "int16";
                case a.onnx.TensorProto.DataType.UINT16:
                  return "uint16";
                case a.onnx.TensorProto.DataType.INT32:
                  return "int32";
                case a.onnx.TensorProto.DataType.UINT32:
                  return "uint32";
                case a.onnx.TensorProto.DataType.FLOAT:
                  return "float32";
                case a.onnx.TensorProto.DataType.DOUBLE:
                  return "float64";
                case a.onnx.TensorProto.DataType.STRING:
                  return "string";
                case a.onnx.TensorProto.DataType.INT64:
                  return "int32";
                case a.onnx.TensorProto.DataType.UINT64:
                  return "uint32";
                default:
                  throw new Error(`unsupported data type: ${a.onnx.TensorProto.DataType[t2]}`);
              }
            }
            static tensorDataTypeStringToEnum(t2) {
              switch (t2) {
                case "int8":
                  return a.onnx.TensorProto.DataType.INT8;
                case "uint8":
                  return a.onnx.TensorProto.DataType.UINT8;
                case "bool":
                  return a.onnx.TensorProto.DataType.BOOL;
                case "int16":
                  return a.onnx.TensorProto.DataType.INT16;
                case "uint16":
                  return a.onnx.TensorProto.DataType.UINT16;
                case "int32":
                  return a.onnx.TensorProto.DataType.INT32;
                case "uint32":
                  return a.onnx.TensorProto.DataType.UINT32;
                case "float32":
                  return a.onnx.TensorProto.DataType.FLOAT;
                case "float64":
                  return a.onnx.TensorProto.DataType.DOUBLE;
                case "string":
                  return a.onnx.TensorProto.DataType.STRING;
                case "int64":
                  return a.onnx.TensorProto.DataType.INT64;
                case "uint64":
                  return a.onnx.TensorProto.DataType.UINT64;
                default:
                  throw new Error(`unsupported data type: ${t2}`);
              }
            }
            static tensorDimsFromProto(t2) {
              return t2.map((t3) => o.default.isLong(t3) ? t3.toNumber() : t3);
            }
            static tensorValueTypeFromProto(t2) {
              return { tensorType: l.tensorDataTypeFromProto(t2.elemType), shape: { dims: l.tensorDimsFromProto(t2.shape.dim.map((t3) => t3.dimValue)) } };
            }
            static tensorDimsFromORTFormat(t2) {
              const e2 = [];
              for (let n2 = 0; n2 < t2.dimsLength(); n2++) e2.push(p.longToNumber(t2.dims(n2)));
              return e2;
            }
            static tensorAttributesFromORTFormat(t2) {
              const e2 = [];
              for (let n2 = 0; n2 < t2.attributesLength(); n2++) e2.push(t2.attributes(n2));
              return e2;
            }
          }
          e.ProtoUtil = l;
          class p {
            static longToNumber(t2, e2) {
              return o.default.isLong(t2) ? t2.toNumber() : t2 instanceof i.flatbuffers.Long ? o.default.fromValue({ low: t2.low, high: t2.high, unsigned: null != e2 && e2 }).toNumber() : t2;
            }
            static isLong(t2) {
              return o.default.isLong(t2) || t2 instanceof i.flatbuffers.Long;
            }
          }
          e.LongUtil = p;
          class f {
            static size(t2) {
              return f.getSizeFromDimensionRange(t2, 0, t2.length);
            }
            static sizeFromDimension(t2, e2) {
              if (e2 < 0 || e2 > t2.length) throw new Error(`invalid dimension of ${e2} for sizeFromDimension as Tensor has ${t2.length} dimensions.`);
              return f.getSizeFromDimensionRange(t2, e2, t2.length);
            }
            static sizeToDimension(t2, e2) {
              if (e2 < 0 || e2 > t2.length) throw new Error(`invalid dimension of ${e2} for sizeToDimension as Tensor has ${t2.length} dimensions.`);
              return f.getSizeFromDimensionRange(t2, 0, e2);
            }
            static getSizeFromDimensionRange(t2, e2, n2) {
              let r2 = 1;
              for (let i2 = e2; i2 < n2; i2++) {
                if (t2[i2] <= 0) throw new Error("cannot get valid size from specified dimension range. Most likely the range contains 0 or negative values in them.");
                r2 *= t2[i2];
              }
              return r2;
            }
            static computeStrides(t2) {
              const e2 = t2.length;
              if (0 === e2) return [];
              if (1 === e2) return [1];
              const n2 = new Array(e2);
              n2[e2 - 1] = 1, n2[e2 - 2] = t2[e2 - 1];
              for (let r2 = e2 - 3; r2 >= 0; --r2) n2[r2] = n2[r2 + 1] * t2[r2 + 1];
              return n2;
            }
            static transpose(t2) {
              return t2.slice().reverse();
            }
            static indicesToOffset(t2, e2, n2) {
              void 0 === n2 && (n2 = t2.length);
              let r2 = 0;
              for (let i2 = 0; i2 < n2; ++i2) r2 += e2[i2] * t2[i2];
              return r2;
            }
            static offsetToIndices(t2, e2) {
              const n2 = e2.length;
              if (0 === n2) return [];
              if (1 === n2) return [t2 * e2[0]];
              const r2 = new Array(e2.length);
              for (let n3 = 0; n3 < r2.length - 1; ++n3) r2[n3] = Math.floor(t2 / e2[n3]), t2 -= r2[n3] * e2[n3];
              return r2[r2.length - 1] = t2, r2;
            }
            static normalizeAxis(t2, e2) {
              if (t2 < -e2 && t2 >= e2) throw new Error("unsupported axis for this operation.");
              return t2 < 0 ? t2 + e2 : t2;
            }
            static normalizeAxes(t2, e2) {
              return t2.map((t3) => this.normalizeAxis(t3, e2));
            }
            static incrementIndex(t2, e2, n2) {
              if (0 === e2.length || 0 === t2.length) throw new Error("Index incrementing unsupported for scalar Tensor");
              if (void 0 === n2) n2 = e2.length;
              else if (n2 <= 0 || n2 > e2.length) throw new Error("Incorrect axis to increment on");
              for (let r2 = n2 - 1; r2 >= 0 && (t2[r2]++, !(t2[r2] < e2[r2])); --r2) t2[r2] = 0;
            }
            static calculateReshapedDims(t2, e2) {
              if (0 === e2.length) {
                if (0 === t2.length || 1 === f.size(t2)) return [];
                throw new Error("cannot reshape to a scalar Tensor");
              }
              const n2 = e2.length, r2 = new Array(n2);
              let i2 = -1, o2 = 1;
              for (let a3 = 0; a3 < n2; a3++) {
                if (e2[a3] < -1) throw new Error("a dimension in shape hints cannot be less than -1");
                if (-1 === e2[a3]) {
                  if (-1 !== i2) throw new Error("at most one dimension in shape hints can be -1");
                  i2 = a3;
                } else {
                  if (0 === e2[a3]) {
                    if (a3 >= t2.length) throw new Error("the dimension with value zero exceeds the dimension size of the input tensor");
                    r2[a3] = t2[a3];
                  } else r2[a3] = e2[a3];
                  o2 *= r2[a3];
                }
              }
              const a2 = f.size(t2);
              if (-1 !== i2) {
                if (a2 % o2 != 0) throw new Error(`the input tensor cannot be reshaped to the requested shape. Input shape: [${t2}] Output shape: [${e2}]`);
                r2[i2] = a2 / o2;
              } else if (o2 !== a2) throw new Error("reshapedDims and originalDims don't have matching sizes");
              return r2;
            }
            static sortBasedOnPerm(t2, e2) {
              return e2 ? e2.map((e3) => t2[e3]) : t2.slice().reverse();
            }
            static padShape(t2, e2) {
              const n2 = t2.length;
              return t2.map((t3, r2) => t3 + e2[r2] + e2[r2 + n2]);
            }
            static areEqual(t2, e2) {
              return t2.length === e2.length && t2.every((t3, n2) => t3 === e2[n2]);
            }
            static validateDimsAndCalcSize(t2) {
              if (t2.length > 6) throw new TypeError("Only rank 0 to 6 is supported for tensor shape.");
              let e2 = 1;
              for (const n2 of t2) {
                if (!Number.isInteger(n2)) throw new TypeError(`Invalid shape: ${n2} is not an integer`);
                if (n2 < 0 || n2 > 2147483647) throw new TypeError(`Invalid shape: length ${n2} is not allowed`);
                e2 *= n2;
              }
              return e2;
            }
            static flattenShape(t2, e2) {
              e2 < 0 && (e2 += t2.length);
              const n2 = t2.reduce((t3, e3) => t3 * e3, 1), r2 = t2.slice(e2).reduce((t3, e3) => t3 * e3, 1);
              return [n2 / r2, r2];
            }
            static squeezeShape(t2, e2) {
              const n2 = new Array();
              e2 = f.normalizeAxes(e2, t2.length);
              for (let r2 = 0; r2 < t2.length; r2++) {
                const i2 = e2.indexOf(r2) >= 0;
                if (i2 && 1 !== t2[r2]) throw new Error("squeeze an axis of size different than 1");
                (0 === e2.length && t2[r2] > 1 || e2.length > 0 && !i2) && n2.push(t2[r2]);
              }
              return n2;
            }
            static unsqueezeShape(t2, e2) {
              const n2 = new Array(t2.length + e2.length);
              n2.fill(0);
              for (let t3 = 0; t3 < e2.length; t3++) {
                const r3 = f.normalizeAxis(e2[t3], n2.length);
                if (r3 >= n2.length) throw new Error("'axes' has an out of range axis");
                if (0 !== n2[r3]) throw new Error("'axes' has a duplicate axis");
                n2[r3] = 1;
              }
              let r2 = 0;
              for (let e3 = 0; e3 < n2.length; e3++) 0 === n2[e3] && (n2[e3] = t2[r2++]);
              if (r2 !== t2.length) throw new Error("the unsqueezed dimension could not be established");
              return n2;
            }
          }
          e.ShapeUtil = f, e.MathUtil = class {
            static sqr(t2, e2, n2, r2, i2) {
              if (r2 < 0 || r2 >= e2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length) throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length) throw new Error("target array is too small to hold result");
              for (let o2 = 0; o2 < i2; o2++) t2[n2 + o2] += Math.pow(e2[r2 + o2], 2);
            }
            static axpy(t2, e2, n2, r2, i2, o2) {
              if (r2 < 0 || r2 >= e2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length) throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length) throw new Error("target array is too small to hold result");
              for (let a2 = 0; a2 < i2; a2++) t2[n2 + a2] += o2 * e2[r2 + a2];
            }
            static powx(t2, e2, n2, r2, i2, o2) {
              if (r2 < 0 || r2 >= e2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length) throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length) throw new Error("target array is too small to hold result");
              for (let a2 = 0; a2 < i2; a2++) t2[n2 + a2] = Math.pow(e2[r2 + a2], o2);
            }
            static mul(t2, e2, n2, r2, i2) {
              if (r2 < 0 || r2 >= e2.length) throw new Error("sourceIndex out of bounds");
              if (n2 < 0 || n2 >= t2.length) throw new Error("targetIndex out of bounds");
              if (r2 + i2 > e2.length) throw new Error("source indices to be copied are outside bounds");
              if (n2 + i2 > t2.length) throw new Error("target array is too small to hold result");
              for (let o2 = 0; o2 < i2; o2++) t2[n2 + o2] = e2[r2 + o2] * t2[n2 + o2];
            }
          };
          class d {
            static splitShape(t2, e2, n2, r2) {
              if (0 === n2.length) {
                if (!r2) throw new Error("need to know number of outputs when the 'split' attribute is not specified");
                d.determineSplit(t2[e2], r2, n2);
              }
              const i2 = [], o2 = [0];
              for (let r3 = 0; r3 < n2.length; ++r3) {
                0 !== r3 && o2.push(o2[r3 - 1] + n2[r3 - 1]);
                const a2 = t2.slice();
                a2[e2] = n2[r3], i2.push(a2);
              }
              return [i2, o2];
            }
            static determineSplit(t2, e2, n2) {
              if (t2 % e2 != 0) throw new Error("cannot split tensor to equal sized parts");
              for (let r2 = 0; r2 < e2; ++r2) n2.push(t2 / e2);
            }
          }
          e.SplitUtil = d;
          class h {
            static calcReduce(t2, e2, n2, r2, i2) {
              const o2 = t2.dims.slice(0);
              0 === e2.length && o2.forEach((t3, n3) => e2.push(n3));
              const a2 = h.calcReduceShape(o2, e2, true), u2 = f.size(a2), l2 = new s.Tensor(a2, t2.type), p2 = f.computeStrides(a2), d2 = f.computeStrides(o2), g2 = new Array(o2.length);
              for (let n3 = 0; n3 < u2; n3++) {
                const a3 = f.offsetToIndices(n3, p2);
                c.fillIndex(a3, o2, g2), l2.set(a3, h.calcReduceByAxis(t2.numberData, e2, o2, 0, f.indicesToOffset(g2, d2), r2, i2));
              }
              return n2 ? l2 : new s.Tensor(h.calcReduceShape(o2, e2, n2), l2.type, void 0, void 0, l2.data, l2.dataId);
            }
            static calcReduceByAxis(t2, e2, n2, r2, i2, o2, a2) {
              let s2 = 0;
              if (r2 >= e2.length) return o2(t2[i2]);
              const u2 = e2[r2], c2 = u2 >= n2.length ? 1 : f.size(n2.slice(u2 + 1));
              for (let l2 = 0; l2 < n2[u2]; l2++) s2 = 0 === l2 ? h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2) : a2(s2, h.calcReduceByAxis(t2, e2, n2, r2 + 1, i2, o2, a2)), i2 += c2;
              return s2;
            }
            static calcReduceShape(t2, e2, n2) {
              const r2 = t2.slice();
              for (let t3 = 0; t3 < e2.length; t3++) r2[e2[t3]] = n2 ? 1 : 0;
              return r2.filter((t3) => 0 !== t3);
            }
          }
          e.ReduceUtil = h;
          class g {
            static adjustPoolAttributes(t2, e2, n2, r2, i2, o2) {
              if (!t2 && n2.length !== e2.length - 2) throw new Error("length of specified kernel shapes should be 2 less than length of input dimensions");
              if (t2) for (let t3 = 0; t3 < e2.length - 2; t3++) t3 >= n2.length ? n2.push(e2[t3 + 2]) : n2[t3] = e2[t3 + 2];
              for (let t3 = 0; t3 < n2.length; t3++) if (t3 < r2.length) {
                if (r2[t3] < 0) throw new Error("strides should be greater than or equal to 1");
              } else r2.push(1);
              for (let t3 = 0; t3 < n2.length; t3++) if (t3 < i2.length) {
                if (i2[t3] < 0) throw new Error("dilations should be greater than or equal to 1");
              } else i2.push(1);
              for (let t3 = 0; t3 < 2 * n2.length; t3++) if (t3 < o2.length) {
                if (o2[t3] < 0) throw new Error("pad should be greater than or equal to 1");
              } else o2.push(0);
              for (let t3 = 0; t3 < n2.length; t3++) {
                if (n2[t3] <= 0) throw new Error("kernel shapes need to be greater than 0");
                if (o2[t3] >= n2[t3] || o2[t3 + n2.length] >= n2[t3]) throw new Error("pads should be smaller than kernel");
              }
            }
            static adjustPadsBasedOnAutoPad(t2, e2, n2, r2, i2, o2) {
              if (o2) {
                if (i2.length !== 2 * (t2.length - 2)) throw new Error("length of pads should be twice the length of data dimensions");
                if (e2.length !== t2.length - 2) throw new Error("length of strides should be the length of data dimensions");
                if (r2.length !== t2.length - 2) throw new Error("length of kernel shapes should be the length of data dimensions");
                for (let a2 = 0; a2 < t2.length - 2; a2++) g.adjustPadAndReturnShape(t2[a2 + 2], e2[a2], n2[a2], r2[a2], i2, a2, a2 + t2.length - 2, o2);
              }
            }
            static computePoolOutputShape(t2, e2, n2, r2, i2, o2, a2) {
              if (e2.length <= 0) throw new Error("input shape must be of size greater than 0");
              const s2 = [e2[0], e2[1]];
              return g.computeShapeHelper(t2, e2, s2, n2, r2, i2, o2, a2), s2;
            }
            static computeConvOutputShape(t2, e2, n2, r2, i2, o2, a2) {
              if (t2.length <= 0 || e2.length <= 0) throw new Error("invalid input tensor dims or invalid filter tensor dims");
              const s2 = [t2[0], e2[0]];
              return g.computeShapeHelper(false, t2, s2, n2, r2, i2, o2, a2), s2;
            }
            static computeShapeHelper(t2, e2, n2, r2, i2, o2, a2, s2) {
              if (t2) for (let t3 = 0; t3 < e2.length - 2; t3++) n2.push(1);
              else for (let t3 = 0; t3 < e2.length - 2; t3++) n2.push(g.adjustPadAndReturnShape(e2[t3 + 2], r2[t3], i2[t3], o2[t3], a2, t3, t3 + e2.length - 2, s2));
            }
            static adjustPadAndReturnShape(t2, e2, n2, r2, i2, o2, a2, s2) {
              const u2 = n2 * (r2 - 1) + 1;
              if (!s2 || "NOTSET" === s2) return Math.floor((t2 + i2[o2] + i2[a2] - u2) / e2 + 1);
              switch (s2) {
                case "VALID":
                  return i2[o2] = 0, i2[a2] = 0, Math.floor((t2 - u2) / e2 + 1);
                case "SAME_LOWER":
                case "SAME_UPPER":
                  if (1 !== n2) throw new Error("Dilation not supported for SAME_UPPER or SAME_LOWER");
                  {
                    const n3 = ((t2 + e2 - 1) / e2 - 1) * e2 + r2 - t2;
                    return i2[o2] = "SAME_LOWER" === s2 ? Math.floor((n3 + 1) / 2) : Math.floor(n3 / 2), i2[a2] = n3 - i2[o2], Math.floor((t2 + n3 - r2) / e2 + 1);
                  }
                default:
                  throw new Error("Unsupported AutoPad type");
              }
            }
          }
          e.PoolConvUtil = g, e.MIN_CLIP = -34028234663852886e22, e.MAX_CLIP = 34028234663852886e22, e.decodeUtf8String = function(t2) {
            return new TextDecoder().decode(t2);
          };
        }, 7967: (t, e) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.iterateExtraOptions = void 0, e.iterateExtraOptions = (t2, n, r, i) => {
            if ("object" == typeof t2 && null !== t2) {
              if (r.has(t2)) throw new Error("Circular reference in options");
              r.add(t2);
            }
            Object.entries(t2).forEach(([t3, o]) => {
              const a = n ? n + t3 : t3;
              if ("object" == typeof o) (0, e.iterateExtraOptions)(o, a + ".", r, i);
              else if ("string" == typeof o || "number" == typeof o) i(a, o.toString());
              else {
                if ("boolean" != typeof o) throw new Error("Can't handle extra config type: " + typeof o);
                i(a, o ? "1" : "0");
              }
            });
          };
        }, 2157: function(t, e, n) {
          var r, i = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), o = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), a = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule) return t2;
            var e2 = {};
            if (null != t2) for (var n2 in t2) "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && i(e2, t2, n2);
            return o(e2, t2), e2;
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = e.initWasm = void 0;
          const s = n(1670), u = a(n(349)), c = n(6361), l = () => !!s.env.wasm.proxy && "undefined" != typeof document;
          let p, f, d, h = false, g = false, b = false;
          const m = [], y = [], _ = [], v = [], w = [], x = [], T = () => {
            if (h || !g || b || !p) throw new Error("worker not ready");
          }, S = (t2) => {
            switch (t2.data.type) {
              case "init-wasm":
                h = false, t2.data.err ? (b = true, f[1](t2.data.err)) : (g = true, f[0]());
                break;
              case "init-ort":
                t2.data.err ? d[1](t2.data.err) : d[0]();
                break;
              case "create_allocate":
                t2.data.err ? m.shift()[1](t2.data.err) : m.shift()[0](t2.data.out);
                break;
              case "create_finalize":
                t2.data.err ? y.shift()[1](t2.data.err) : y.shift()[0](t2.data.out);
                break;
              case "create":
                t2.data.err ? _.shift()[1](t2.data.err) : _.shift()[0](t2.data.out);
                break;
              case "release":
                t2.data.err ? v.shift()[1](t2.data.err) : v.shift()[0]();
                break;
              case "run":
                t2.data.err ? w.shift()[1](t2.data.err) : w.shift()[0](t2.data.out);
                break;
              case "end-profiling":
                t2.data.err ? x.shift()[1](t2.data.err) : x.shift()[0]();
            }
          }, O = "undefined" != typeof document ? null === (r = null === document || void 0 === document ? void 0 : document.currentScript) || void 0 === r ? void 0 : r.src : void 0;
          e.initWasm = () => __async(this, null, function* () {
            if (l()) {
              if (g) return;
              if (h) throw new Error("multiple calls to 'initWasm()' detected.");
              if (b) throw new Error("previous call to 'initWasm()' failed.");
              return h = true, void 0 === s.env.wasm.wasmPaths && O && 0 !== O.indexOf("blob:") && (s.env.wasm.wasmPaths = O.substr(0, +O.lastIndexOf("/") + 1)), new Promise((t2, e2) => {
                null == p || p.terminate(), p = n(9710).Z(), p.onmessage = S, f = [t2, e2];
                const r2 = { type: "init-wasm", in: s.env.wasm };
                p.postMessage(r2);
              });
            }
            return (0, c.initializeWebAssembly)(s.env.wasm);
          }), e.initOrt = (t2, e2) => __async(this, null, function* () {
            if (l()) return T(), new Promise((n2, r2) => {
              d = [n2, r2];
              const i2 = { type: "init-ort", in: { numThreads: t2, loggingLevel: e2 } };
              p.postMessage(i2);
            });
            u.initOrt(t2, e2);
          }), e.createSessionAllocate = (t2) => __async(this, null, function* () {
            return l() ? (T(), new Promise((e2, n2) => {
              m.push([e2, n2]);
              const r2 = { type: "create_allocate", in: { model: t2 } };
              p.postMessage(r2, [t2.buffer]);
            })) : u.createSessionAllocate(t2);
          }), e.createSessionFinalize = (t2, e2) => __async(this, null, function* () {
            return l() ? (T(), new Promise((n2, r2) => {
              y.push([n2, r2]);
              const i2 = { type: "create_finalize", in: { modeldata: t2, options: e2 } };
              p.postMessage(i2);
            })) : u.createSessionFinalize(t2, e2);
          }), e.createSession = (t2, e2) => __async(this, null, function* () {
            return l() ? (T(), new Promise((n2, r2) => {
              _.push([n2, r2]);
              const i2 = { type: "create", in: { model: t2, options: e2 } };
              p.postMessage(i2, [t2.buffer]);
            })) : u.createSession(t2, e2);
          }), e.releaseSession = (t2) => __async(this, null, function* () {
            if (l()) return T(), new Promise((e2, n2) => {
              v.push([e2, n2]);
              const r2 = { type: "release", in: t2 };
              p.postMessage(r2);
            });
            u.releaseSession(t2);
          }), e.run = (t2, e2, n2, r2, i2) => __async(this, null, function* () {
            return l() ? (T(), new Promise((o2, a2) => {
              w.push([o2, a2]);
              const s2 = { type: "run", in: { sessionId: t2, inputIndices: e2, inputs: n2, outputIndices: r2, options: i2 } };
              p.postMessage(s2, u.extractTransferableBuffers(n2));
            })) : u.run(t2, e2, n2, r2, i2);
          }), e.endProfiling = (t2) => __async(this, null, function* () {
            if (l()) return T(), new Promise((e2, n2) => {
              x.push([e2, n2]);
              const r2 = { type: "end-profiling", in: t2 };
              p.postMessage(r2);
            });
            u.endProfiling(t2);
          });
        }, 586: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.setRunOptions = void 0;
          const r = n(7967), i = n(4983), o = n(6361);
          e.setRunOptions = (t2) => {
            const e2 = (0, o.getInstance)();
            let n2 = 0;
            const a = [], s = t2 || {};
            try {
              if (void 0 === (null == t2 ? void 0 : t2.logSeverityLevel)) s.logSeverityLevel = 2;
              else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel)) s.logVerbosityLevel = 0;
              else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
              void 0 === (null == t2 ? void 0 : t2.terminate) && (s.terminate = false);
              let o2 = 0;
              if (void 0 !== (null == t2 ? void 0 : t2.tag) && (o2 = (0, i.allocWasmString)(t2.tag, a)), n2 = e2._OrtCreateRunOptions(s.logSeverityLevel, s.logVerbosityLevel, !!s.terminate, o2), 0 === n2) throw new Error("Can't create run options");
              return void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                const o3 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                if (0 !== e2._OrtAddRunConfigEntry(n2, o3, s2)) throw new Error(`Can't set a run config entry: ${t3} - ${r2}`);
              }), [n2, a];
            } catch (t3) {
              throw 0 !== n2 && e2._OrtReleaseRunOptions(n2), a.forEach(e2._free), t3;
            }
          };
        }, 2306: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.OnnxruntimeWebAssemblySessionHandler = void 0;
          const r = n(2806), i = n(1670), o = n(2850), a = n(2157);
          let s;
          e.OnnxruntimeWebAssemblySessionHandler = class {
            createSessionAllocate(t2) {
              return __async(this, null, function* () {
                const e2 = yield fetch(t2), n2 = yield e2.arrayBuffer();
                return (0, a.createSessionAllocate)(new Uint8Array(n2));
              });
            }
            loadModel(t2, e2) {
              return __async(this, null, function* () {
                if (s || (yield (0, a.initOrt)(i.env.wasm.numThreads, ((t3) => {
                  switch (t3) {
                    case "verbose":
                      return 0;
                    case "info":
                      return 1;
                    case "warning":
                      return 2;
                    case "error":
                      return 3;
                    case "fatal":
                      return 4;
                    default:
                      throw new Error(`unsupported logging level: ${t3}`);
                  }
                })(i.env.logLevel)), s = true), "string" == typeof t2) if ("undefined" == typeof fetch) {
                  const n2 = yield (0, o.promisify)(r.readFile)(t2);
                  [this.sessionId, this.inputNames, this.outputNames] = yield (0, a.createSession)(n2, e2);
                } else {
                  const n2 = yield this.createSessionAllocate(t2);
                  [this.sessionId, this.inputNames, this.outputNames] = yield (0, a.createSessionFinalize)(n2, e2);
                }
                else [this.sessionId, this.inputNames, this.outputNames] = yield (0, a.createSession)(t2, e2);
              });
            }
            dispose() {
              return __async(this, null, function* () {
                return (0, a.releaseSession)(this.sessionId);
              });
            }
            run(t2, e2, n2) {
              return __async(this, null, function* () {
                const r2 = [], o2 = [];
                Object.entries(t2).forEach((t3) => {
                  const e3 = t3[0], n3 = t3[1], i2 = this.inputNames.indexOf(e3);
                  if (-1 === i2) throw new Error(`invalid input '${e3}'`);
                  r2.push(n3), o2.push(i2);
                });
                const s2 = [];
                Object.entries(e2).forEach((t3) => {
                  const e3 = t3[0], n3 = this.outputNames.indexOf(e3);
                  if (-1 === n3) throw new Error(`invalid output '${e3}'`);
                  s2.push(n3);
                });
                const u = yield (0, a.run)(this.sessionId, o2, r2.map((t3) => [t3.type, t3.dims, t3.data]), s2, n2), c = {};
                for (let t3 = 0; t3 < u.length; t3++) c[this.outputNames[s2[t3]]] = new i.Tensor(u[t3][0], u[t3][2], u[t3][1]);
                return c;
              });
            }
            startProfiling() {
            }
            endProfiling() {
              (0, a.endProfiling)(this.sessionId);
            }
          };
        }, 4919: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.setSessionOptions = void 0;
          const r = n(7967), i = n(4983), o = n(6361);
          e.setSessionOptions = (t2) => {
            const e2 = (0, o.getInstance)();
            let n2 = 0;
            const a = [], s = t2 || {};
            ((t3) => {
              t3.extra || (t3.extra = {}), t3.extra.session || (t3.extra.session = {});
              const e3 = t3.extra.session;
              e3.use_ort_model_bytes_directly || (e3.use_ort_model_bytes_directly = "1");
            })(s);
            try {
              void 0 === (null == t2 ? void 0 : t2.graphOptimizationLevel) && (s.graphOptimizationLevel = "all");
              const u = ((t3) => {
                switch (t3) {
                  case "disabled":
                    return 0;
                  case "basic":
                    return 1;
                  case "extended":
                    return 2;
                  case "all":
                    return 99;
                  default:
                    throw new Error(`unsupported graph optimization level: ${t3}`);
                }
              })(s.graphOptimizationLevel);
              void 0 === (null == t2 ? void 0 : t2.enableCpuMemArena) && (s.enableCpuMemArena = true), void 0 === (null == t2 ? void 0 : t2.enableMemPattern) && (s.enableMemPattern = true), void 0 === (null == t2 ? void 0 : t2.executionMode) && (s.executionMode = "sequential");
              const c = ((t3) => {
                switch (t3) {
                  case "sequential":
                    return 0;
                  case "parallel":
                    return 1;
                  default:
                    throw new Error(`unsupported execution mode: ${t3}`);
                }
              })(s.executionMode);
              let l = 0;
              if (void 0 !== (null == t2 ? void 0 : t2.logId) && (l = (0, i.allocWasmString)(t2.logId, a)), void 0 === (null == t2 ? void 0 : t2.logSeverityLevel)) s.logSeverityLevel = 2;
              else if ("number" != typeof t2.logSeverityLevel || !Number.isInteger(t2.logSeverityLevel) || t2.logSeverityLevel < 0 || t2.logSeverityLevel > 4) throw new Error(`log serverity level is not valid: ${t2.logSeverityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.logVerbosityLevel)) s.logVerbosityLevel = 0;
              else if ("number" != typeof t2.logVerbosityLevel || !Number.isInteger(t2.logVerbosityLevel)) throw new Error(`log verbosity level is not valid: ${t2.logVerbosityLevel}`);
              if (void 0 === (null == t2 ? void 0 : t2.enableProfiling) && (s.enableProfiling = false), n2 = e2._OrtCreateSessionOptions(u, !!s.enableCpuMemArena, !!s.enableMemPattern, c, !!s.enableProfiling, 0, l, s.logSeverityLevel, s.logVerbosityLevel), 0 === n2) throw new Error("Can't create session options");
              return (null == t2 ? void 0 : t2.executionProviders) && ((t3, e3, n3) => {
                for (const r2 of e3) {
                  let e4 = "string" == typeof r2 ? r2 : r2.name;
                  switch (e4) {
                    case "xnnpack":
                      e4 = "XNNPACK";
                      break;
                    case "wasm":
                    case "cpu":
                      continue;
                    default:
                      throw new Error(`not supported EP: ${e4}`);
                  }
                  const a2 = (0, i.allocWasmString)(e4, n3);
                  if (0 !== (0, o.getInstance)()._OrtAppendExecutionProvider(t3, a2)) throw new Error(`Can't append execution provider: ${e4}`);
                }
              })(n2, t2.executionProviders, a), void 0 !== (null == t2 ? void 0 : t2.extra) && (0, r.iterateExtraOptions)(t2.extra, "", /* @__PURE__ */ new WeakSet(), (t3, r2) => {
                const o2 = (0, i.allocWasmString)(t3, a), s2 = (0, i.allocWasmString)(r2, a);
                if (0 !== e2._OrtAddSessionConfigEntry(n2, o2, s2)) throw new Error(`Can't set a session config entry: ${t3} - ${r2}`);
              }), [n2, a];
            } catch (t3) {
              throw 0 !== n2 && e2._OrtReleaseSessionOptions(n2), a.forEach(e2._free), t3;
            }
          };
        }, 4983: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.allocWasmString = void 0;
          const r = n(6361);
          e.allocWasmString = (t2, e2) => {
            const n2 = (0, r.getInstance)(), i = n2.lengthBytesUTF8(t2) + 1, o = n2._malloc(i);
            return n2.stringToUTF8(t2, o, i), e2.push(o), o;
          };
        }, 349: (t, e, n) => {
          Object.defineProperty(e, "__esModule", { value: true }), e.extractTransferableBuffers = e.endProfiling = e.run = e.releaseSession = e.createSession = e.createSessionFinalize = e.createSessionAllocate = e.initOrt = void 0;
          const r = n(586), i = n(4919), o = n(4983), a = n(6361);
          e.initOrt = (t2, e2) => {
            const n2 = (0, a.getInstance)()._OrtInit(t2, e2);
            if (0 !== n2) throw new Error(`Can't initialize onnxruntime. error code = ${n2}`);
          };
          const s = /* @__PURE__ */ new Map();
          e.createSessionAllocate = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = e2._malloc(t2.byteLength);
            return e2.HEAPU8.set(t2, n2), [n2, t2.byteLength];
          }, e.createSessionFinalize = (t2, e2) => {
            const n2 = (0, a.getInstance)();
            let r2 = 0, o2 = 0, u2 = [];
            try {
              if ([o2, u2] = (0, i.setSessionOptions)(e2), r2 = n2._OrtCreateSession(t2[0], t2[1], o2), 0 === r2) throw new Error("Can't create a session");
            } finally {
              n2._free(t2[0]), n2._OrtReleaseSessionOptions(o2), u2.forEach(n2._free);
            }
            const c2 = n2._OrtGetInputCount(r2), l2 = n2._OrtGetOutputCount(r2), p = [], f = [], d = [], h = [];
            for (let t3 = 0; t3 < c2; t3++) {
              const e3 = n2._OrtGetInputName(r2, t3);
              if (0 === e3) throw new Error("Can't get an input name");
              f.push(e3), p.push(n2.UTF8ToString(e3));
            }
            for (let t3 = 0; t3 < l2; t3++) {
              const e3 = n2._OrtGetOutputName(r2, t3);
              if (0 === e3) throw new Error("Can't get an output name");
              h.push(e3), d.push(n2.UTF8ToString(e3));
            }
            return s.set(r2, [r2, f, h]), [r2, p, d];
          }, e.createSession = (t2, n2) => {
            const r2 = (0, e.createSessionAllocate)(t2);
            return (0, e.createSessionFinalize)(r2, n2);
          }, e.releaseSession = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = s.get(t2);
            if (!n2) throw new Error("invalid session id");
            const r2 = n2[0], i2 = n2[1], o2 = n2[2];
            i2.forEach(e2._OrtFree), o2.forEach(e2._OrtFree), e2._OrtReleaseSession(r2), s.delete(t2);
          };
          const u = (t2) => {
            switch (t2) {
              case "int8":
                return 3;
              case "uint8":
                return 2;
              case "bool":
                return 9;
              case "int16":
                return 5;
              case "uint16":
                return 4;
              case "int32":
                return 6;
              case "uint32":
                return 12;
              case "float32":
                return 1;
              case "float64":
                return 11;
              case "string":
                return 8;
              case "int64":
                return 7;
              case "uint64":
                return 13;
              default:
                throw new Error(`unsupported data type: ${t2}`);
            }
          }, c = (t2) => {
            switch (t2) {
              case 3:
                return "int8";
              case 2:
                return "uint8";
              case 9:
                return "bool";
              case 5:
                return "int16";
              case 4:
                return "uint16";
              case 6:
                return "int32";
              case 12:
                return "uint32";
              case 1:
                return "float32";
              case 11:
                return "float64";
              case 8:
                return "string";
              case 7:
                return "int64";
              case 13:
                return "uint64";
              default:
                throw new Error(`unsupported data type: ${t2}`);
            }
          }, l = (t2) => {
            switch (t2) {
              case "float32":
                return Float32Array;
              case "uint8":
              case "bool":
                return Uint8Array;
              case "int8":
                return Int8Array;
              case "uint16":
                return Uint16Array;
              case "int16":
                return Int16Array;
              case "int32":
                return Int32Array;
              case "float64":
                return Float64Array;
              case "uint32":
                return Uint32Array;
              case "int64":
                return BigInt64Array;
              case "uint64":
                return BigUint64Array;
              default:
                throw new Error(`unsupported type: ${t2}`);
            }
          };
          e.run = (t2, e2, n2, i2, p) => {
            const f = (0, a.getInstance)(), d = s.get(t2);
            if (!d) throw new Error("invalid session id");
            const h = d[0], g = d[1], b = d[2], m = e2.length, y = i2.length;
            let _ = 0, v = [];
            const w = [], x = [];
            try {
              [_, v] = (0, r.setRunOptions)(p);
              for (let t4 = 0; t4 < m; t4++) {
                const e3 = n2[t4][0], r2 = n2[t4][1], i3 = n2[t4][2];
                let a3, s3;
                if (Array.isArray(i3)) {
                  s3 = 4 * i3.length, a3 = f._malloc(s3), x.push(a3);
                  let t5 = a3 / 4;
                  for (let e4 = 0; e4 < i3.length; e4++) {
                    if ("string" != typeof i3[e4]) throw new TypeError(`tensor data at index ${e4} is not a string`);
                    f.HEAPU32[t5++] = (0, o.allocWasmString)(i3[e4], x);
                  }
                } else s3 = i3.byteLength, a3 = f._malloc(s3), x.push(a3), f.HEAPU8.set(new Uint8Array(i3.buffer, i3.byteOffset, s3), a3);
                const c2 = f.stackSave(), l2 = f.stackAlloc(4 * r2.length);
                try {
                  let t5 = l2 / 4;
                  r2.forEach((e4) => f.HEAP32[t5++] = e4);
                  const n3 = f._OrtCreateTensor(u(e3), a3, s3, l2, r2.length);
                  if (0 === n3) throw new Error("Can't create a tensor");
                  w.push(n3);
                } finally {
                  f.stackRestore(c2);
                }
              }
              const t3 = f.stackSave(), a2 = f.stackAlloc(4 * m), s2 = f.stackAlloc(4 * m), d2 = f.stackAlloc(4 * y), T = f.stackAlloc(4 * y);
              try {
                let n3 = a2 / 4, r2 = s2 / 4, o2 = d2 / 4, u2 = T / 4;
                for (let t4 = 0; t4 < m; t4++) f.HEAPU32[n3++] = w[t4], f.HEAPU32[r2++] = g[e2[t4]];
                for (let t4 = 0; t4 < y; t4++) f.HEAPU32[o2++] = 0, f.HEAPU32[u2++] = b[i2[t4]];
                let p2 = f._OrtRun(h, s2, a2, m, T, y, d2, _);
                const v2 = [];
                if (0 === p2) for (let t4 = 0; t4 < y; t4++) {
                  const e3 = f.HEAPU32[d2 / 4 + t4], n4 = f.stackSave(), r3 = f.stackAlloc(16);
                  let i3, o3 = 0;
                  try {
                    if (p2 = f._OrtGetTensorData(e3, r3, r3 + 4, r3 + 8, r3 + 12), 0 !== p2) throw new Error(`Can't access output tensor data. error code = ${p2}`);
                    let t5 = r3 / 4;
                    const a3 = f.HEAPU32[t5++];
                    o3 = f.HEAPU32[t5++];
                    const s3 = f.HEAPU32[t5++], u3 = f.HEAPU32[t5++], d3 = [];
                    for (let t6 = 0; t6 < u3; t6++) d3.push(f.HEAPU32[s3 / 4 + t6]);
                    f._OrtFree(s3);
                    const h2 = 0 === d3.length ? 1 : d3.reduce((t6, e4) => t6 * e4);
                    if (i3 = c(a3), "string" === i3) {
                      const t6 = [];
                      let e4 = o3 / 4;
                      for (let n5 = 0; n5 < h2; n5++) {
                        const r4 = f.HEAPU32[e4++], i4 = n5 === h2 - 1 ? void 0 : f.HEAPU32[e4] - r4;
                        t6.push(f.UTF8ToString(r4, i4));
                      }
                      v2.push([i3, d3, t6]);
                    } else {
                      const t6 = new (l(i3))(h2);
                      new Uint8Array(t6.buffer, t6.byteOffset, t6.byteLength).set(f.HEAPU8.subarray(o3, o3 + t6.byteLength)), v2.push([i3, d3, t6]);
                    }
                  } finally {
                    f.stackRestore(n4), "string" === i3 && o3 && f._free(o3), f._OrtReleaseTensor(e3);
                  }
                }
                if (0 === p2) return v2;
                throw new Error(`failed to call OrtRun(). error code = ${p2}.`);
              } finally {
                f.stackRestore(t3);
              }
            } finally {
              w.forEach(f._OrtReleaseTensor), x.forEach(f._free), f._OrtReleaseRunOptions(_), v.forEach(f._free);
            }
          }, e.endProfiling = (t2) => {
            const e2 = (0, a.getInstance)(), n2 = s.get(t2);
            if (!n2) throw new Error("invalid session id");
            const r2 = n2[0], i2 = e2._OrtEndProfiling(r2);
            if (0 === i2) throw new Error("Can't get an profile file name");
            e2._OrtFree(i2);
          }, e.extractTransferableBuffers = (t2) => {
            const e2 = [];
            for (const n2 of t2) {
              const t3 = n2[2];
              !Array.isArray(t3) && t3.buffer && e2.push(t3.buffer);
            }
            return e2;
          };
        }, 6361: function(t, e, n) {
          var r = this && this.__createBinding || (Object.create ? function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2);
            var i2 = Object.getOwnPropertyDescriptor(e2, n2);
            i2 && !("get" in i2 ? !e2.__esModule : i2.writable || i2.configurable) || (i2 = { enumerable: true, get: function() {
              return e2[n2];
            } }), Object.defineProperty(t2, r2, i2);
          } : function(t2, e2, n2, r2) {
            void 0 === r2 && (r2 = n2), t2[r2] = e2[n2];
          }), i = this && this.__setModuleDefault || (Object.create ? function(t2, e2) {
            Object.defineProperty(t2, "default", { enumerable: true, value: e2 });
          } : function(t2, e2) {
            t2.default = e2;
          }), o = this && this.__importStar || function(t2) {
            if (t2 && t2.__esModule) return t2;
            var e2 = {};
            if (null != t2) for (var n2 in t2) "default" !== n2 && Object.prototype.hasOwnProperty.call(t2, n2) && r(e2, t2, n2);
            return i(e2, t2), e2;
          }, a = this && this.__importDefault || function(t2) {
            return t2 && t2.__esModule ? t2 : { default: t2 };
          };
          Object.defineProperty(e, "__esModule", { value: true }), e.dispose = e.getInstance = e.initializeWebAssembly = void 0;
          const s = o(n(6449)), u = a(n(932)), c = n(3474);
          let l, p = false, f = false, d = false;
          const h = (t2, e2) => e2 ? t2 ? "ort-wasm-simd-threaded.wasm" : "ort-wasm-threaded.wasm" : t2 ? "ort-wasm-simd.wasm" : "ort-wasm.wasm";
          e.initializeWebAssembly = (t2) => __async(this, null, function* () {
            if (p) return Promise.resolve();
            if (f) throw new Error("multiple calls to 'initializeWebAssembly()' detected.");
            if (d) throw new Error("previous call to 'initializeWebAssembly()' failed.");
            f = true;
            const e2 = t2.initTimeout, r2 = t2.numThreads, i2 = t2.simd, o2 = r2 > 1 && (() => {
              try {
                return "undefined" != typeof SharedArrayBuffer && ("undefined" != typeof MessageChannel && new MessageChannel().port1.postMessage(new SharedArrayBuffer(1)), WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 5, 4, 1, 3, 1, 1, 10, 11, 1, 9, 0, 65, 0, 254, 16, 2, 0, 26, 11])));
              } catch (t3) {
                return false;
              }
            })(), a2 = i2 && (() => {
              try {
                return WebAssembly.validate(new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 2, 1, 0, 10, 30, 1, 28, 0, 65, 0, 253, 15, 253, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 253, 186, 1, 26, 11]));
              } catch (t3) {
                return false;
              }
            })(), g = "string" == typeof t2.wasmPaths ? t2.wasmPaths : void 0, b = h(false, o2), m = h(a2, o2), y = "object" == typeof t2.wasmPaths ? t2.wasmPaths[m] : void 0;
            let _ = false;
            const v = [];
            if (e2 > 0 && v.push(new Promise((t3) => {
              setTimeout(() => {
                _ = true, t3();
              }, e2);
            })), v.push(new Promise((t3, e3) => {
              const r3 = o2 ? c : u.default, i3 = { locateFile: (t4, e4) => o2 && t4.endsWith(".worker.js") && "undefined" != typeof Blob ? URL.createObjectURL(new Blob([n(4154)], { type: "text/javascript" })) : t4 === b ? null != y ? y : (null != g ? g : e4) + m : e4 + t4 };
              if (o2) if ("undefined" == typeof Blob) i3.mainScriptUrlOrBlob = s.join("/", "ort-wasm-threaded.js");
              else {
                const t4 = `var ortWasmThreaded=(function(){var _scriptDir;return ${r3.toString()}})();`;
                i3.mainScriptUrlOrBlob = new Blob([t4], { type: "text/javascript" });
              }
              r3(i3).then((e4) => {
                f = false, p = true, l = e4, t3();
              }, (t4) => {
                f = false, d = true, e3(t4);
              });
            })), yield Promise.race(v), _) throw new Error(`WebAssembly backend initializing failed due to timeout: ${e2}ms`);
          }), e.getInstance = () => {
            if (p && l) return l;
            throw new Error("WebAssembly is not initialized yet.");
          }, e.dispose = () => {
            var t2;
            !p || f || d || (f = true, null === (t2 = l.PThread) || void 0 === t2 || t2.terminateAllThreads(), l = void 0, f = false, p = false, d = true);
          };
        }, 9710: (t, e, n) => {
          n.d(e, { Z: () => o });
          var r = n(477), i = n.n(r);
          function o() {
            return i()('/*!\n* ONNX Runtime Web v1.14.0\n* Copyright (c) Microsoft Corporation. All rights reserved.\n* Licensed under the MIT License.\n*/\n(()=>{var t={474:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){function e(){return j.buffer!=D&&N(j.buffer),P}function r(){return j.buffer!=D&&N(j.buffer),U}function a(){return j.buffer!=D&&N(j.buffer),F}function i(){return j.buffer!=D&&N(j.buffer),I}function o(){return j.buffer!=D&&N(j.buffer),W}var u,c,s;t=t||{},u||(u=void 0!==t?t:{}),u.ready=new Promise((function(t,e){c=t,s=e}));var l,f,p,h,d,y,b=Object.assign({},u),m="./this.program",g=(t,e)=>{throw e},v="object"==typeof window,w="function"==typeof importScripts,_="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,O=u.ENVIRONMENT_IS_PTHREAD||!1,A="";function S(t){return u.locateFile?u.locateFile(t,A):A+t}if(_){let e;A=w?n(908).dirname(A)+"/":"//",y=()=>{d||(h=n(384),d=n(908))},l=function(t,e){return y(),t=d.normalize(t),h.readFileSync(t,e?void 0:"utf8")},p=t=>((t=l(t,!0)).buffer||(t=new Uint8Array(t)),t),f=(t,e,n)=>{y(),t=d.normalize(t),h.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(m=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof ct))throw t})),process.on("unhandledRejection",(function(t){throw t})),g=(t,e)=>{if(Q())throw process.exitCode=t,e;e instanceof ct||x("exiting due to exception: "+e),process.exit(t)},u.inspect=function(){return"[Emscripten Module object]"};try{e=n(925)}catch(t){throw console.error(\'The "worker_threads" module is not supported in this node.js build - perhaps a newer version is needed?\'),t}n.g.Worker=e.Worker}else(v||w)&&(w?A=self.location.href:"undefined"!=typeof document&&document.currentScript&&(A=document.currentScript.src),_scriptDir&&(A=_scriptDir),A=0!==A.indexOf("blob:")?A.substr(0,A.replace(/[?#].*/,"").lastIndexOf("/")+1):"",_||(l=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},w&&(p=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),f=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)}));_&&"undefined"==typeof performance&&(n.g.performance=n(953).performance);var T=console.log.bind(console),E=console.warn.bind(console);_&&(y(),T=t=>h.writeSync(1,t+"\\n"),E=t=>h.writeSync(2,t+"\\n"));var M,C=u.print||T,x=u.printErr||E;Object.assign(u,b),b=null,u.thisProgram&&(m=u.thisProgram),u.quit&&(g=u.quit),u.wasmBinary&&(M=u.wasmBinary);var R=u.noExitRuntime||!1;"object"!=typeof WebAssembly&&at("no native wasm support detected");var j,k,D,P,U,F,I,W,H=!1,L="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function z(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&L)return L.decode(t.buffer instanceof SharedArrayBuffer?t.slice(e,n):t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function Y(t,e){return(t>>>=0)?z(r(),t,e):""}function B(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function G(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function N(t){D=t,u.HEAP8=P=new Int8Array(t),u.HEAP16=new Int16Array(t),u.HEAP32=F=new Int32Array(t),u.HEAPU8=U=new Uint8Array(t),u.HEAPU16=new Uint16Array(t),u.HEAPU32=I=new Uint32Array(t),u.HEAPF32=new Float32Array(t),u.HEAPF64=W=new Float64Array(t)}O&&(D=u.buffer);var V=u.INITIAL_MEMORY||16777216;if(O)j=u.wasmMemory,D=u.buffer;else if(u.wasmMemory)j=u.wasmMemory;else if(!((j=new WebAssembly.Memory({initial:V/65536,maximum:65536,shared:!0})).buffer instanceof SharedArrayBuffer))throw x("requested a shared WebAssembly.Memory but the returned buffer is not a SharedArrayBuffer, indicating that while the browser has SharedArrayBuffer it does not have WebAssembly threads support - you may need to set a flag"),_&&console.log("(on node you may need: --experimental-wasm-threads --experimental-wasm-bulk-memory and also use a recent version)"),Error("bad memory");j&&(D=j.buffer),V=D.byteLength,N(D);var $,q=[],X=[],J=[],Z=[];function Q(){return R||!1}function K(){var t=u.preRun.shift();q.unshift(t)}var tt,et=0,nt=null,rt=null;function at(t){throw O?postMessage({cmd:"onAbort",arg:t}):u.onAbort&&u.onAbort(t),x(t="Aborted("+t+")"),H=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),s(t),t}function it(){return tt.startsWith("data:application/octet-stream;base64,")}function ot(){var t=tt;try{if(t==tt&&M)return new Uint8Array(M);if(p)return p(t);throw"both async and sync fetching of the wasm failed"}catch(t){at(t)}}tt="ort-wasm-threaded.wasm",it()||(tt=S(tt));var ut={};function ct(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function st(t){(t=ht.Vb[t])||at(),ht.mc(t)}function lt(t){var e=ht.Cc();if(!e)return 6;ht.ac.push(e),ht.Vb[t.Ub]=e,e.Ub=t.Ub;var n={cmd:"run",start_routine:t.Ic,arg:t.zc,pthread_ptr:t.Ub};return e.$b=()=>{n.time=performance.now(),e.postMessage(n,t.Nc)},e.loaded&&(e.$b(),delete e.$b),0}function ft(t){if(O)return $t(1,1,t);Q()||(ht.oc(),u.onExit&&u.onExit(t),H=!0),g(t,new ct(t))}function pt(t,e){if(!e&&O)throw bt(t),"unwind";Q()||O||(me(),dt(J),be(0),re[1].length&&ae(1,10),re[2].length&&ae(2,10),ht.oc()),ft(t)}var ht={Yb:[],ac:[],qc:[],Vb:{},fc:function(){O&&ht.Ec()},Pc:function(){},Ec:function(){ht.receiveObjectTransfer=ht.Gc,ht.threadInitTLS=ht.pc,ht.setExitStatus=ht.nc,R=!1},nc:function(){},oc:function(){for(var t of Object.values(ht.Vb))ht.mc(t);for(t of ht.Yb)t.terminate();ht.Yb=[]},mc:function(t){var e=t.Ub;delete ht.Vb[e],ht.Yb.push(t),ht.ac.splice(ht.ac.indexOf(t),1),t.Ub=0,Oe(e)},Gc:function(){},pc:function(){ht.qc.forEach((t=>t()))},Fc:function(t,e){t.onmessage=n=>{var r=(n=n.data).cmd;if(t.Ub&&(ht.Bc=t.Ub),n.targetThread&&n.targetThread!=he()){var a=ht.Vb[n.Qc];a?a.postMessage(n,n.transferList):x(\'Internal error! Worker sent a message "\'+r+\'" to target pthread \'+n.targetThread+", but that thread no longer exists!")}else"processProxyingQueue"===r?zt(n.queue):"spawnThread"===r?lt(n):"cleanupThread"===r?st(n.thread):"killThread"===r?(n=n.thread,r=ht.Vb[n],delete ht.Vb[n],r.terminate(),Oe(n),ht.ac.splice(ht.ac.indexOf(r),1),r.Ub=0):"cancelThread"===r?ht.Vb[n.thread].postMessage({cmd:"cancel"}):"loaded"===r?(t.loaded=!0,e&&e(t),t.$b&&(t.$b(),delete t.$b)):"print"===r?C("Thread "+n.threadId+": "+n.text):"printErr"===r?x("Thread "+n.threadId+": "+n.text):"alert"===r?alert("Thread "+n.threadId+": "+n.text):"setimmediate"===n.target?t.postMessage(n):"onAbort"===r?u.onAbort&&u.onAbort(n.arg):r&&x("worker sent an unknown command "+r);ht.Bc=void 0},t.onerror=t=>{throw x("worker sent an error! "+t.filename+":"+t.lineno+": "+t.message),t},_&&(t.on("message",(function(e){t.onmessage({data:e})})),t.on("error",(function(e){t.onerror(e)})),t.on("detachedExit",(function(){}))),t.postMessage({cmd:"load",urlOrBlob:u.mainScriptUrlOrBlob||_scriptDir,wasmMemory:j,wasmModule:k})},yc:function(){var t=S("ort-wasm-threaded.worker.js");ht.Yb.push(new Worker(t))},Cc:function(){return 0==ht.Yb.length&&(ht.yc(),ht.Fc(ht.Yb[0])),ht.Yb.pop()}};function dt(t){for(;0<t.length;)t.shift()(u)}function yt(t){var e=Ee();return t=t(),Me(e),t}function bt(t){if(O)return $t(2,0,t);try{pt(t)}catch(t){t instanceof ct||"unwind"==t||g(1,t)}}u.PThread=ht,u.establishStackSpace=function(){var t=he(),e=a()[t+44>>2>>>0];t=a()[t+48>>2>>>0],Te(e,e-t),Me(e)};var mt=[];function gt(t){var e=mt[t];return e||(t>=mt.length&&(mt.length=t+1),mt[t]=e=$.get(t)),e}u.invokeEntryPoint=function(t,e){t=gt(t)(e),Q()?ht.nc(t):Ae(t)};var vt,wt,_t=[],Ot=0,At=0;function St(t){this.Zb=t,this.Sb=t-24,this.xc=function(t){i()[this.Sb+4>>2>>>0]=t},this.bc=function(){return i()[this.Sb+4>>2>>>0]},this.wc=function(t){i()[this.Sb+8>>2>>>0]=t},this.Dc=function(){return i()[this.Sb+8>>2>>>0]},this.rc=function(){a()[this.Sb>>2>>>0]=0},this.hc=function(t){t=t?1:0,e()[this.Sb+12>>0>>>0]=t},this.uc=function(){return 0!=e()[this.Sb+12>>0>>>0]},this.ic=function(t){t=t?1:0,e()[this.Sb+13>>0>>>0]=t},this.kc=function(){return 0!=e()[this.Sb+13>>0>>>0]},this.fc=function(t,e){this.cc(0),this.xc(t),this.wc(e),this.rc(),this.hc(!1),this.ic(!1)},this.sc=function(){Atomics.add(a(),this.Sb>>2,1)},this.Hc=function(){return 1===Atomics.sub(a(),this.Sb>>2,1)},this.cc=function(t){i()[this.Sb+16>>2>>>0]=t},this.tc=function(){return i()[this.Sb+16>>2>>>0]},this.vc=function(){if(Re(this.bc()))return i()[this.Zb>>2>>>0];var t=this.tc();return 0!==t?t:this.Zb}}function Tt(t){return ye(new St(t).Sb)}function Et(t,e,n,r){return O?$t(3,1,t,e,n,r):Mt(t,e,n,r)}function Mt(t,e,n,r){if("undefined"==typeof SharedArrayBuffer)return x("Current environment does not support SharedArrayBuffer, pthreads are not available!"),6;var a=[];return O&&0===a.length?Et(t,e,n,r):(t={Ic:n,Ub:t,zc:r,Nc:a},O?(t.Oc="spawnThread",postMessage(t,a),0):lt(t))}function Ct(t,e,n){return O?$t(4,1,t,e,n):0}function xt(t,e){if(O)return $t(5,1,t,e)}function Rt(t,e){if(O)return $t(6,1,t,e)}function jt(t,e,n){if(O)return $t(7,1,t,e,n)}function kt(t,e,n){return O?$t(8,1,t,e,n):0}function Dt(t,e){if(O)return $t(9,1,t,e)}function Pt(t,e,n){if(O)return $t(10,1,t,e,n)}function Ut(t,e,n,r){if(O)return $t(11,1,t,e,n,r)}function Ft(t,e,n,r){if(O)return $t(12,1,t,e,n,r)}function It(t,e,n,r){if(O)return $t(13,1,t,e,n,r)}function Wt(t){if(O)return $t(14,1,t)}function Ht(t,e){if(O)return $t(15,1,t,e)}function Lt(t,e,n){if(O)return $t(16,1,t,e,n)}function zt(t){Atomics.store(a(),t>>2,1),he()&&_e(t),Atomics.compareExchange(a(),t>>2,1,0)}function Yt(t){return i()[t>>>2]+4294967296*a()[t+4>>>2]}function Bt(t,e,n,r,a,i){return O?$t(17,1,t,e,n,r,a,i):-52}function Gt(t,e,n,r,a,i){if(O)return $t(18,1,t,e,n,r,a,i)}function Nt(t){var n=G(t)+1,r=de(n);return r&&B(t,e(),r,n),r}function Vt(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}if(O)return $t(19,1,t,e,n);var o=(new Date).getFullYear(),u=new Date(o,0,1),c=new Date(o,6,1);o=u.getTimezoneOffset();var s=c.getTimezoneOffset(),l=Math.max(o,s);a()[t>>2>>>0]=60*l,a()[e>>2>>>0]=Number(o!=s),t=r(u),e=r(c),t=Nt(t),e=Nt(e),s<o?(i()[n>>2>>>0]=t,i()[n+4>>2>>>0]=e):(i()[n>>2>>>0]=e,i()[n+4>>2>>>0]=t)}function $t(t,e){var n=arguments.length-2,r=arguments;return yt((()=>{for(var a=Ce(8*n),i=a>>3,u=0;u<n;u++){var c=r[2+u];o()[i+u>>>0]=c}return we(t,n,a,e)}))}u.executeNotifiedProxyingQueue=zt,wt=_?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:O?()=>performance.now()-u.__performance_now_clock_drift:()=>performance.now();var qt,Xt=[],Jt={};function Zt(){if(!qt){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:m||"./this.program"};for(t in Jt)void 0===Jt[t]?delete e[t]:e[t]=Jt[t];var n=[];for(t in e)n.push(t+"="+e[t]);qt=n}return qt}function Qt(t,n){if(O)return $t(20,1,t,n);var r=0;return Zt().forEach((function(a,o){var u=n+r;for(o=i()[t+4*o>>2>>>0]=u,u=0;u<a.length;++u)e()[o++>>0>>>0]=a.charCodeAt(u);e()[o>>0>>>0]=0,r+=a.length+1})),0}function Kt(t,e){if(O)return $t(21,1,t,e);var n=Zt();i()[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),i()[e>>2>>>0]=r,0}function te(t){return O?$t(22,1,t):52}function ee(t,e,n,r){return O?$t(23,1,t,e,n,r):52}function ne(t,e,n,r,a){return O?$t(24,1,t,e,n,r,a):70}var re=[null,[],[]];function ae(t,e){var n=re[t];0===e||10===e?((1===t?C:x)(z(n,0)),n.length=0):n.push(e)}function ie(t,e,n,a){if(O)return $t(25,1,t,e,n,a);for(var o=0,u=0;u<n;u++){var c=i()[e>>2>>>0],s=i()[e+4>>2>>>0];e+=8;for(var l=0;l<s;l++)ae(t,r()[c+l>>>0]);o+=s}return i()[a>>2>>>0]=o,0}var oe=0;function ue(t){return 0==t%4&&(0!=t%100||0==t%400)}var ce=[31,29,31,30,31,30,31,31,30,31,30,31],se=[31,28,31,30,31,30,31,31,30,31,30,31];function le(t,n,r,i){function o(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function u(t,e){return o(t,e,"0")}function c(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function s(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function l(t){var e=t.Wb;for(t=new Date(new Date(t.Xb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(ue(t.getFullYear())?ce:se)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=s(new Date(t.getFullYear(),0,4)),n=s(n),0>=c(e,t)?0>=c(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var f=a()[i+40>>2>>>0];for(var p in i={Lc:a()[i>>2>>>0],Kc:a()[i+4>>2>>>0],dc:a()[i+8>>2>>>0],jc:a()[i+12>>2>>>0],ec:a()[i+16>>2>>>0],Xb:a()[i+20>>2>>>0],Tb:a()[i+24>>2>>>0],Wb:a()[i+28>>2>>>0],Rc:a()[i+32>>2>>>0],Jc:a()[i+36>>2>>>0],Mc:f?Y(f):""},r=Y(r),f={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})r=r.replace(new RegExp(p,"g"),f[p]);var h="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),d="January February March April May June July August September October November December".split(" ");for(p in f={"%a":function(t){return h[t.Tb].substring(0,3)},"%A":function(t){return h[t.Tb]},"%b":function(t){return d[t.ec].substring(0,3)},"%B":function(t){return d[t.ec]},"%C":function(t){return u((t.Xb+1900)/100|0,2)},"%d":function(t){return u(t.jc,2)},"%e":function(t){return o(t.jc,2," ")},"%g":function(t){return l(t).toString().substring(2)},"%G":function(t){return l(t)},"%H":function(t){return u(t.dc,2)},"%I":function(t){return 0==(t=t.dc)?t=12:12<t&&(t-=12),u(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.ec-1;e+=(ue(t.Xb+1900)?ce:se)[n++]);return u(t.jc+e,3)},"%m":function(t){return u(t.ec+1,2)},"%M":function(t){return u(t.Kc,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.dc&&12>t.dc?"AM":"PM"},"%S":function(t){return u(t.Lc,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Tb||7},"%U":function(t){return u(Math.floor((t.Wb+7-t.Tb)/7),2)},"%V":function(t){var e=Math.floor((t.Wb+7-(t.Tb+6)%7)/7);if(2>=(t.Tb+371-t.Wb-2)%7&&e++,e)53==e&&(4==(n=(t.Tb+371-t.Wb)%7)||3==n&&ue(t.Xb)||(e=1));else{e=52;var n=(t.Tb+7-t.Wb-1)%7;(4==n||5==n&&ue(t.Xb%400-1))&&e++}return u(e,2)},"%w":function(t){return t.Tb},"%W":function(t){return u(Math.floor((t.Wb+7-(t.Tb+6)%7)/7),2)},"%y":function(t){return(t.Xb+1900).toString().substring(2)},"%Y":function(t){return t.Xb+1900},"%z":function(t){var e=0<=(t=t.Jc);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.Mc},"%%":function(){return"%"}},r=r.replace(/%%/g,"\\0\\0"),f)r.includes(p)&&(r=r.replace(new RegExp(p,"g"),f[p](i)));return p=function(t){var e=Array(G(t)+1);return B(t,e,0,e.length),e}(r=r.replace(/\\0\\0/g,"%")),p.length>n?0:(function(t,n){e().set(t,n>>>0)}(p,t),p.length-1)}ht.fc();var fe=[null,ft,bt,Et,Ct,xt,Rt,jt,kt,Dt,Pt,Ut,Ft,It,Wt,Ht,Lt,Bt,Gt,Vt,Qt,Kt,te,ee,ne,ie],pe={b:function(t){return de(t+24)+24},n:function(t){return(t=new St(t)).uc()||(t.hc(!0),Ot--),t.ic(!1),_t.push(t),t.sc(),t.vc()},ma:function(t){throw x("Unexpected exception thrown, this is not properly supported - aborting"),H=!0,t},x:function(){Se(0);var t=_t.pop();if(t.Hc()&&!t.kc()){var e=t.Dc();e&&gt(e)(t.Zb),Tt(t.Zb)}At=0},e:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},l:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},h:function(){var t=At;if(!t)return oe=0;var e=new St(t);e.cc(t);var n=e.bc();if(!n)return oe=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(xe(i,n,e.Sb+16))return oe=i,t}return oe=n,t},t:Tt,M:function(){var t=_t.pop();t||at("no exception to throw");var e=t.Zb;throw t.kc()||(_t.push(t),t.ic(!0),t.hc(!1),Ot++),At=e,e},c:function(t,e,n){throw new St(t).fc(e,n),At=t,Ot++,t},pa:function(){return Ot},Fa:function(t){ge(t,!w,1,!v),ht.pc()},T:function(t){O?postMessage({cmd:"cleanupThread",thread:t}):st(t)},xa:Mt,j:function(t){throw At||(At=t),t},H:Ct,Ma:xt,ua:Rt,wa:jt,oa:kt,Ka:Dt,Ca:Pt,Ja:Ut,V:Ft,va:It,sa:Wt,La:Ht,ta:Lt,Ta:function(){},X:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ua:function(){at("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},W:function(){return Date.now()},ya:function(){return 2097152},Oa:function(){return!0},za:function(t,e,n,r){if(t==e)setTimeout((()=>zt(r)));else if(O)postMessage({targetThread:t,cmd:"processProxyingQueue",queue:r});else{if(!(t=ht.Vb[t]))return;t.postMessage({cmd:"processProxyingQueue",queue:r})}return 1},Ea:function(){return-1},Pa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getUTCSeconds(),a()[e+4>>2>>>0]=t.getUTCMinutes(),a()[e+8>>2>>>0]=t.getUTCHours(),a()[e+12>>2>>>0]=t.getUTCDate(),a()[e+16>>2>>>0]=t.getUTCMonth(),a()[e+20>>2>>>0]=t.getUTCFullYear()-1900,a()[e+24>>2>>>0]=t.getUTCDay(),t=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0,a()[e+28>>2>>>0]=t},Qa:function(t,e){t=new Date(1e3*Yt(t)),a()[e>>2>>>0]=t.getSeconds(),a()[e+4>>2>>>0]=t.getMinutes(),a()[e+8>>2>>>0]=t.getHours(),a()[e+12>>2>>>0]=t.getDate(),a()[e+16>>2>>>0]=t.getMonth(),a()[e+20>>2>>>0]=t.getFullYear()-1900,a()[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1),r=(t.getTime()-n.getTime())/864e5|0;a()[e+28>>2>>>0]=r,a()[e+36>>2>>>0]=-60*t.getTimezoneOffset(),r=new Date(t.getFullYear(),6,1).getTimezoneOffset(),t=0|(r!=(n=n.getTimezoneOffset())&&t.getTimezoneOffset()==Math.min(n,r)),a()[e+32>>2>>>0]=t},Ra:function(t){var e=new Date(a()[t+20>>2>>>0]+1900,a()[t+16>>2>>>0],a()[t+12>>2>>>0],a()[t+8>>2>>>0],a()[t+4>>2>>>0],a()[t>>2>>>0],0),n=a()[t+32>>2>>>0],r=e.getTimezoneOffset(),i=new Date(e.getFullYear(),0,1),o=new Date(e.getFullYear(),6,1).getTimezoneOffset(),u=i.getTimezoneOffset(),c=Math.min(u,o);return 0>n?a()[t+32>>2>>>0]=Number(o!=u&&c==r):0<n!=(c==r)&&(o=Math.max(u,o),e.setTime(e.getTime()+6e4*((0<n?c:o)-r))),a()[t+24>>2>>>0]=e.getDay(),n=(e.getTime()-i.getTime())/864e5|0,a()[t+28>>2>>>0]=n,a()[t>>2>>>0]=e.getSeconds(),a()[t+4>>2>>>0]=e.getMinutes(),a()[t+8>>2>>>0]=e.getHours(),a()[t+12>>2>>>0]=e.getDate(),a()[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},Aa:Bt,Ba:Gt,Sa:function t(e,n,r){t.Ac||(t.Ac=!0,Vt(e,n,r))},y:function(){at("")},U:function(){if(!_&&!w){var t="Blocking on the main thread is very dangerous, see https://emscripten.org/docs/porting/pthreads.html#blocking-on-the-main-browser-thread";vt||(vt={}),vt[t]||(vt[t]=1,_&&(t="warning: "+t),x(t))}},ra:function(){return 4294901760},B:wt,Ia:function(t,e,n){r().copyWithin(t>>>0,e>>>0,e+n>>>0)},F:function(){return _?n(993).cpus().length:navigator.hardwareConcurrency},Da:function(t,e,n){Xt.length=e,n>>=3;for(var r=0;r<e;r++)Xt[r]=o()[n+r>>>0];return(0>t?ut[-t-1]:fe[t]).apply(null,Xt)},qa:function(t){var e=r().length;if((t>>>=0)<=e||4294901760<t)return!1;for(var n=1;4>=n;n*=2){var a=e*(1+.2/n);a=Math.min(a,t+100663296);var i=Math;a=Math.max(t,a),i=i.min.call(i,4294901760,a+(65536-a%65536)%65536);t:{try{j.grow(i-D.byteLength+65535>>>16),N(j.buffer);var o=1;break t}catch(t){}o=void 0}if(o)return!0}return!1},Na:function(){throw"unwind"},Ga:Qt,Ha:Kt,J:pt,I:te,S:ee,ga:ne,R:ie,d:function(){return oe},na:function t(r,a){t.lc||(t.lc=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(_)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>at("randomDevice")}());for(var i=0;i<a;i++)e()[r+i>>0>>>0]=t.lc();return 0},ia:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ja:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},K:function(t){var e=Ee();try{return gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},f:function(t,e){var n=Ee();try{return gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},P:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},Q:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},k:function(t,e,n){var r=Ee();try{return gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},p:function(t,e,n,r){var a=Ee();try{return gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},q:function(t,e,n,r,a){var i=Ee();try{return gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},N:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},s:function(t,e,n,r,a,i){var o=Ee();try{return gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},w:function(t,e,n,r,a,i,o){var u=Ee();try{return gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},L:function(t,e,n,r,a,i,o,u){var c=Ee();try{return gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},E:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{return gt(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=Ee();try{return He(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},_:function(t,e,n,r,a,i,o){var u=Ee();try{return ke(t,e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},Z:function(t,e,n,r,a){var i=Ee();try{return Le(t,e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},ca:function(t,e,n,r){var a=Ee();try{return Ie(t,e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},$:function(t){var e=Ee();try{return je(t)}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},ba:function(t,e){var n=Ee();try{return We(t,e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},Y:function(t,e,n){var r=Ee();try{return De(t,e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},g:function(t){var e=Ee();try{gt(t)()}catch(t){if(Me(e),t!==t+0)throw t;Se(1,0)}},r:function(t,e){var n=Ee();try{gt(t)(e)}catch(t){if(Me(n),t!==t+0)throw t;Se(1,0)}},i:function(t,e,n){var r=Ee();try{gt(t)(e,n)}catch(t){if(Me(r),t!==t+0)throw t;Se(1,0)}},ha:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},m:function(t,e,n,r){var a=Ee();try{gt(t)(e,n,r)}catch(t){if(Me(a),t!==t+0)throw t;Se(1,0)}},v:function(t,e,n,r,a){var i=Ee();try{gt(t)(e,n,r,a)}catch(t){if(Me(i),t!==t+0)throw t;Se(1,0)}},u:function(t,e,n,r,a,i){var o=Ee();try{gt(t)(e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},O:function(t,e,n,r,a,i,o){var u=Ee();try{gt(t)(e,n,r,a,i,o)}catch(t){if(Me(u),t!==t+0)throw t;Se(1,0)}},A:function(t,e,n,r,a,i,o,u){var c=Ee();try{gt(t)(e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},ka:function(t,e,n,r,a,i,o,u,c){var s=Ee();try{gt(t)(e,n,r,a,i,o,u,c)}catch(t){if(Me(s),t!==t+0)throw t;Se(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l){var f=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(Me(f),t!==t+0)throw t;Se(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=Ee();try{gt(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(Me(b),t!==t+0)throw t;Se(1,0)}},fa:function(t,e,n,r,a,i,o,u){var c=Ee();try{Pe(t,e,n,r,a,i,o,u)}catch(t){if(Me(c),t!==t+0)throw t;Se(1,0)}},da:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=Ee();try{Fe(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(Me(p),t!==t+0)throw t;Se(1,0)}},ea:function(t,e,n,r,a,i){var o=Ee();try{Ue(t,e,n,r,a,i)}catch(t){if(Me(o),t!==t+0)throw t;Se(1,0)}},o:function(t){return t},a:j||u.wasmMemory,G:function(t){oe=t},la:le,z:function(t,e,n,r){return le(t,e,n,r)}};!function(){function t(t,e){u.asm=t.exports,ht.qc.push(u.asm.sb),$=u.asm.ub,X.unshift(u.asm.Va),k=e,O||(et--,u.monitorRunDependencies&&u.monitorRunDependencies(et),0==et&&(null!==nt&&(clearInterval(nt),nt=null),rt&&(t=rt,rt=null,t())))}function e(e){t(e.instance,e.module)}function n(t){return function(){if(!M&&(v||w)){if("function"==typeof fetch&&!tt.startsWith("file://"))return fetch(tt,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+tt+"\'";return t.arrayBuffer()})).catch((function(){return ot()}));if(f)return new Promise((function(t,e){f(tt,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return ot()}))}().then((function(t){return WebAssembly.instantiate(t,r)})).then((function(t){return t})).then(t,(function(t){x("failed to asynchronously prepare wasm: "+t),at(t)}))}var r={a:pe};if(O||(et++,u.monitorRunDependencies&&u.monitorRunDependencies(et)),u.instantiateWasm)try{return u.instantiateWasm(r,t)}catch(t){return x("Module.instantiateWasm callback failed with error: "+t),!1}(M||"function"!=typeof WebAssembly.instantiateStreaming||it()||tt.startsWith("file://")||_||"function"!=typeof fetch?n(e):fetch(tt,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,r).then(e,(function(t){return x("wasm streaming compile failed: "+t),x("falling back to ArrayBuffer instantiation"),n(e)}))}))).catch(s)}(),u.___wasm_call_ctors=function(){return(u.___wasm_call_ctors=u.asm.Va).apply(null,arguments)},u._OrtInit=function(){return(u._OrtInit=u.asm.Wa).apply(null,arguments)},u._OrtCreateSessionOptions=function(){return(u._OrtCreateSessionOptions=u.asm.Xa).apply(null,arguments)},u._OrtAppendExecutionProvider=function(){return(u._OrtAppendExecutionProvider=u.asm.Ya).apply(null,arguments)},u._OrtAddSessionConfigEntry=function(){return(u._OrtAddSessionConfigEntry=u.asm.Za).apply(null,arguments)},u._OrtReleaseSessionOptions=function(){return(u._OrtReleaseSessionOptions=u.asm._a).apply(null,arguments)},u._OrtCreateSession=function(){return(u._OrtCreateSession=u.asm.$a).apply(null,arguments)},u._OrtReleaseSession=function(){return(u._OrtReleaseSession=u.asm.ab).apply(null,arguments)},u._OrtGetInputCount=function(){return(u._OrtGetInputCount=u.asm.bb).apply(null,arguments)},u._OrtGetOutputCount=function(){return(u._OrtGetOutputCount=u.asm.cb).apply(null,arguments)},u._OrtGetInputName=function(){return(u._OrtGetInputName=u.asm.db).apply(null,arguments)},u._OrtGetOutputName=function(){return(u._OrtGetOutputName=u.asm.eb).apply(null,arguments)},u._OrtFree=function(){return(u._OrtFree=u.asm.fb).apply(null,arguments)},u._OrtCreateTensor=function(){return(u._OrtCreateTensor=u.asm.gb).apply(null,arguments)},u._OrtGetTensorData=function(){return(u._OrtGetTensorData=u.asm.hb).apply(null,arguments)},u._OrtReleaseTensor=function(){return(u._OrtReleaseTensor=u.asm.ib).apply(null,arguments)},u._OrtCreateRunOptions=function(){return(u._OrtCreateRunOptions=u.asm.jb).apply(null,arguments)},u._OrtAddRunConfigEntry=function(){return(u._OrtAddRunConfigEntry=u.asm.kb).apply(null,arguments)},u._OrtReleaseRunOptions=function(){return(u._OrtReleaseRunOptions=u.asm.lb).apply(null,arguments)},u._OrtRun=function(){return(u._OrtRun=u.asm.mb).apply(null,arguments)},u._OrtEndProfiling=function(){return(u._OrtEndProfiling=u.asm.nb).apply(null,arguments)};var he=u._pthread_self=function(){return(he=u._pthread_self=u.asm.ob).apply(null,arguments)},de=u._malloc=function(){return(de=u._malloc=u.asm.pb).apply(null,arguments)},ye=u._free=function(){return(ye=u._free=u.asm.qb).apply(null,arguments)},be=u._fflush=function(){return(be=u._fflush=u.asm.rb).apply(null,arguments)};u.__emscripten_tls_init=function(){return(u.__emscripten_tls_init=u.asm.sb).apply(null,arguments)};var me=u.___funcs_on_exit=function(){return(me=u.___funcs_on_exit=u.asm.tb).apply(null,arguments)},ge=u.__emscripten_thread_init=function(){return(ge=u.__emscripten_thread_init=u.asm.vb).apply(null,arguments)};u.__emscripten_thread_crashed=function(){return(u.__emscripten_thread_crashed=u.asm.wb).apply(null,arguments)};var ve,we=u._emscripten_run_in_main_runtime_thread_js=function(){return(we=u._emscripten_run_in_main_runtime_thread_js=u.asm.xb).apply(null,arguments)},_e=u.__emscripten_proxy_execute_task_queue=function(){return(_e=u.__emscripten_proxy_execute_task_queue=u.asm.yb).apply(null,arguments)},Oe=u.__emscripten_thread_free_data=function(){return(Oe=u.__emscripten_thread_free_data=u.asm.zb).apply(null,arguments)},Ae=u.__emscripten_thread_exit=function(){return(Ae=u.__emscripten_thread_exit=u.asm.Ab).apply(null,arguments)},Se=u._setThrew=function(){return(Se=u._setThrew=u.asm.Bb).apply(null,arguments)},Te=u._emscripten_stack_set_limits=function(){return(Te=u._emscripten_stack_set_limits=u.asm.Cb).apply(null,arguments)},Ee=u.stackSave=function(){return(Ee=u.stackSave=u.asm.Db).apply(null,arguments)},Me=u.stackRestore=function(){return(Me=u.stackRestore=u.asm.Eb).apply(null,arguments)},Ce=u.stackAlloc=function(){return(Ce=u.stackAlloc=u.asm.Fb).apply(null,arguments)},xe=u.___cxa_can_catch=function(){return(xe=u.___cxa_can_catch=u.asm.Gb).apply(null,arguments)},Re=u.___cxa_is_pointer_type=function(){return(Re=u.___cxa_is_pointer_type=u.asm.Hb).apply(null,arguments)},je=u.dynCall_j=function(){return(je=u.dynCall_j=u.asm.Ib).apply(null,arguments)},ke=u.dynCall_iiiiij=function(){return(ke=u.dynCall_iiiiij=u.asm.Jb).apply(null,arguments)},De=u.dynCall_jii=function(){return(De=u.dynCall_jii=u.asm.Kb).apply(null,arguments)},Pe=u.dynCall_viiiiij=function(){return(Pe=u.dynCall_viiiiij=u.asm.Lb).apply(null,arguments)},Ue=u.dynCall_vjji=function(){return(Ue=u.dynCall_vjji=u.asm.Mb).apply(null,arguments)},Fe=u.dynCall_viiijjjii=function(){return(Fe=u.dynCall_viiijjjii=u.asm.Nb).apply(null,arguments)},Ie=u.dynCall_iij=function(){return(Ie=u.dynCall_iij=u.asm.Ob).apply(null,arguments)},We=u.dynCall_ji=function(){return(We=u.dynCall_ji=u.asm.Pb).apply(null,arguments)},He=u.dynCall_iiiiiij=function(){return(He=u.dynCall_iiiiiij=u.asm.Qb).apply(null,arguments)},Le=u.dynCall_iiij=function(){return(Le=u.dynCall_iiij=u.asm.Rb).apply(null,arguments)};function ze(){function t(){if(!ve&&(ve=!0,u.calledRun=!0,!H)&&(O||dt(X),c(u),u.onRuntimeInitialized&&u.onRuntimeInitialized(),!O)){if(u.postRun)for("function"==typeof u.postRun&&(u.postRun=[u.postRun]);u.postRun.length;){var t=u.postRun.shift();Z.unshift(t)}dt(Z)}}if(!(0<et))if(O)c(u),O||dt(X),postMessage({cmd:"loaded"});else{if(u.preRun)for("function"==typeof u.preRun&&(u.preRun=[u.preRun]);u.preRun.length;)K();dt(q),0<et||(u.setStatus?(u.setStatus("Running..."),setTimeout((function(){setTimeout((function(){u.setStatus("")}),1),t()}),1)):t())}}if(u.UTF8ToString=Y,u.stringToUTF8=function(t,e,n){return B(t,r(),e,n)},u.lengthBytesUTF8=G,u.keepRuntimeAlive=Q,u.wasmMemory=j,u.stackSave=Ee,u.stackRestore=Me,u.stackAlloc=Ce,u.ExitStatus=ct,u.PThread=ht,rt=function t(){ve||ze(),ve||(rt=t)},u.preInit)for("function"==typeof u.preInit&&(u.preInit=[u.preInit]);0<u.preInit.length;)u.preInit.pop()();return ze(),t.ready});t.exports=r},932:(t,e,n)=>{var _scriptDir,r=(_scriptDir=(_scriptDir="undefined"!=typeof document&&document.currentScript?document.currentScript.src:void 0)||"/index.js",function(t){var e,r,a;t=t||{},e||(e=void 0!==t?t:{}),e.ready=new Promise((function(t,e){r=t,a=e}));var i,o,u,c,s,l,f=Object.assign({},e),p="./this.program",h=(t,e)=>{throw e},d="object"==typeof window,y="function"==typeof importScripts,b="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node,m="";b?(m=y?n(908).dirname(m)+"/":"//",l=()=>{s||(c=n(384),s=n(908))},i=function(t,e){return l(),t=s.normalize(t),c.readFileSync(t,e?void 0:"utf8")},u=t=>((t=i(t,!0)).buffer||(t=new Uint8Array(t)),t),o=(t,e,n)=>{l(),t=s.normalize(t),c.readFile(t,(function(t,r){t?n(t):e(r.buffer)}))},1<process.argv.length&&(p=process.argv[1].replace(/\\\\/g,"/")),process.argv.slice(2),process.on("uncaughtException",(function(t){if(!(t instanceof J))throw t})),process.on("unhandledRejection",(function(t){throw t})),h=(t,e)=>{if(_||0<L)throw process.exitCode=t,e;e instanceof J||w("exiting due to exception: "+e),process.exit(t)},e.inspect=function(){return"[Emscripten Module object]"}):(d||y)&&(y?m=self.location.href:"undefined"!=typeof document&&document.currentScript&&(m=document.currentScript.src),_scriptDir&&(m=_scriptDir),m=0!==m.indexOf("blob:")?m.substr(0,m.replace(/[?#].*/,"").lastIndexOf("/")+1):"",i=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.send(null),e.responseText},y&&(u=t=>{var e=new XMLHttpRequest;return e.open("GET",t,!1),e.responseType="arraybuffer",e.send(null),new Uint8Array(e.response)}),o=(t,e,n)=>{var r=new XMLHttpRequest;r.open("GET",t,!0),r.responseType="arraybuffer",r.onload=()=>{200==r.status||0==r.status&&r.response?e(r.response):n()},r.onerror=n,r.send(null)});var g,v=e.print||console.log.bind(console),w=e.printErr||console.warn.bind(console);Object.assign(e,f),f=null,e.thisProgram&&(p=e.thisProgram),e.quit&&(h=e.quit),e.wasmBinary&&(g=e.wasmBinary);var _=e.noExitRuntime||!1;"object"!=typeof WebAssembly&&V("no native wasm support detected");var O,A,S,T,E,M,C=!1,x="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;function R(t,e,n){var r=(e>>>=0)+n;for(n=e;t[n]&&!(n>=r);)++n;if(16<n-e&&t.buffer&&x)return x.decode(t.subarray(e,n));for(r="";e<n;){var a=t[e++];if(128&a){var i=63&t[e++];if(192==(224&a))r+=String.fromCharCode((31&a)<<6|i);else{var o=63&t[e++];65536>(a=224==(240&a)?(15&a)<<12|i<<6|o:(7&a)<<18|i<<12|o<<6|63&t[e++])?r+=String.fromCharCode(a):(a-=65536,r+=String.fromCharCode(55296|a>>10,56320|1023&a))}}else r+=String.fromCharCode(a)}return r}function j(t,e){return(t>>>=0)?R(T,t,e):""}function k(t,e,n,r){if(!(0<r))return 0;var a=n>>>=0;r=n+r-1;for(var i=0;i<t.length;++i){var o=t.charCodeAt(i);if(55296<=o&&57343>=o&&(o=65536+((1023&o)<<10)|1023&t.charCodeAt(++i)),127>=o){if(n>=r)break;e[n++>>>0]=o}else{if(2047>=o){if(n+1>=r)break;e[n++>>>0]=192|o>>6}else{if(65535>=o){if(n+2>=r)break;e[n++>>>0]=224|o>>12}else{if(n+3>=r)break;e[n++>>>0]=240|o>>18,e[n++>>>0]=128|o>>12&63}e[n++>>>0]=128|o>>6&63}e[n++>>>0]=128|63&o}}return e[n>>>0]=0,n-a}function D(t){for(var e=0,n=0;n<t.length;++n){var r=t.charCodeAt(n);127>=r?e++:2047>=r?e+=2:55296<=r&&57343>=r?(e+=4,++n):e+=3}return e}function P(){var t=O.buffer;A=t,e.HEAP8=S=new Int8Array(t),e.HEAP16=new Int16Array(t),e.HEAP32=E=new Int32Array(t),e.HEAPU8=T=new Uint8Array(t),e.HEAPU16=new Uint16Array(t),e.HEAPU32=M=new Uint32Array(t),e.HEAPF32=new Float32Array(t),e.HEAPF64=new Float64Array(t)}var U,F=[],I=[],W=[],H=[],L=0;function z(){var t=e.preRun.shift();F.unshift(t)}var Y,B=0,G=null,N=null;function V(t){throw e.onAbort&&e.onAbort(t),w(t="Aborted("+t+")"),C=!0,t=new WebAssembly.RuntimeError(t+". Build with -sASSERTIONS for more info."),a(t),t}function $(){return Y.startsWith("data:application/octet-stream;base64,")}if(Y="ort-wasm.wasm",!$()){var q=Y;Y=e.locateFile?e.locateFile(q,m):m+q}function X(){var t=Y;try{if(t==Y&&g)return new Uint8Array(g);if(u)return u(t);throw"both async and sync fetching of the wasm failed"}catch(t){V(t)}}function J(t){this.name="ExitStatus",this.message="Program terminated with exit("+t+")",this.status=t}function Z(t){for(;0<t.length;)t.shift()(e)}var Q=[],K=0,tt=0;function et(t){this.Db=t,this.zb=t-24,this.Ub=function(t){M[this.zb+4>>2>>>0]=t},this.Eb=function(){return M[this.zb+4>>2>>>0]},this.Sb=function(t){M[this.zb+8>>2>>>0]=t},this.Wb=function(){return M[this.zb+8>>2>>>0]},this.Tb=function(){E[this.zb>>2>>>0]=0},this.Ib=function(t){S[this.zb+12>>0>>>0]=t?1:0},this.Pb=function(){return 0!=S[this.zb+12>>0>>>0]},this.Jb=function(t){S[this.zb+13>>0>>>0]=t?1:0},this.Lb=function(){return 0!=S[this.zb+13>>0>>>0]},this.Rb=function(t,e){this.Fb(0),this.Ub(t),this.Sb(e),this.Tb(),this.Ib(!1),this.Jb(!1)},this.Nb=function(){E[this.zb>>2>>>0]+=1},this.Xb=function(){var t=E[this.zb>>2>>>0];return E[this.zb>>2>>>0]=t-1,1===t},this.Fb=function(t){M[this.zb+16>>2>>>0]=t},this.Ob=function(){return M[this.zb+16>>2>>>0]},this.Qb=function(){if(Mt(this.Eb()))return M[this.Db>>2>>>0];var t=this.Ob();return 0!==t?t:this.Db}}function nt(t){return vt(new et(t).zb)}var rt=[];function at(t){var e=rt[t];return e||(t>=rt.length&&(rt.length=t+1),rt[t]=e=U.get(t)),e}function it(t){var e=D(t)+1,n=gt(e);return n&&k(t,S,n,e),n}var ot={};function ut(){if(!ct){var t,e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:("object"==typeof navigator&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:p||"./this.program"};for(t in ot)void 0===ot[t]?delete e[t]:e[t]=ot[t];var n=[];for(t in e)n.push(t+"="+e[t]);ct=n}return ct}var ct,st=[null,[],[]];function lt(t,e){var n=st[t];0===e||10===e?((1===t?v:w)(R(n,0)),n.length=0):n.push(e)}var ft=0;function pt(t){return 0==t%4&&(0!=t%100||0==t%400)}var ht=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31];function yt(t,e,n,r){function a(t,e,n){for(t="number"==typeof t?t.toString():t||"";t.length<e;)t=n[0]+t;return t}function i(t,e){return a(t,e,"0")}function o(t,e){function n(t){return 0>t?-1:0<t?1:0}var r;return 0===(r=n(t.getFullYear()-e.getFullYear()))&&0===(r=n(t.getMonth()-e.getMonth()))&&(r=n(t.getDate()-e.getDate())),r}function u(t){switch(t.getDay()){case 0:return new Date(t.getFullYear()-1,11,29);case 1:return t;case 2:return new Date(t.getFullYear(),0,3);case 3:return new Date(t.getFullYear(),0,2);case 4:return new Date(t.getFullYear(),0,1);case 5:return new Date(t.getFullYear()-1,11,31);case 6:return new Date(t.getFullYear()-1,11,30)}}function c(t){var e=t.Bb;for(t=new Date(new Date(t.Cb+1900,0,1).getTime());0<e;){var n=t.getMonth(),r=(pt(t.getFullYear())?ht:dt)[n];if(!(e>r-t.getDate())){t.setDate(t.getDate()+e);break}e-=r-t.getDate()+1,t.setDate(1),11>n?t.setMonth(n+1):(t.setMonth(0),t.setFullYear(t.getFullYear()+1))}return n=new Date(t.getFullYear()+1,0,4),e=u(new Date(t.getFullYear(),0,4)),n=u(n),0>=o(e,t)?0>=o(n,t)?t.getFullYear()+1:t.getFullYear():t.getFullYear()-1}var s=E[r+40>>2>>>0];for(var l in r={$b:E[r>>2>>>0],Zb:E[r+4>>2>>>0],Gb:E[r+8>>2>>>0],Kb:E[r+12>>2>>>0],Hb:E[r+16>>2>>>0],Cb:E[r+20>>2>>>0],Ab:E[r+24>>2>>>0],Bb:E[r+28>>2>>>0],bc:E[r+32>>2>>>0],Yb:E[r+36>>2>>>0],ac:s?j(s):""},n=j(n),s={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"})n=n.replace(new RegExp(l,"g"),s[l]);var f="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),p="January February March April May June July August September October November December".split(" ");for(l in s={"%a":function(t){return f[t.Ab].substring(0,3)},"%A":function(t){return f[t.Ab]},"%b":function(t){return p[t.Hb].substring(0,3)},"%B":function(t){return p[t.Hb]},"%C":function(t){return i((t.Cb+1900)/100|0,2)},"%d":function(t){return i(t.Kb,2)},"%e":function(t){return a(t.Kb,2," ")},"%g":function(t){return c(t).toString().substring(2)},"%G":function(t){return c(t)},"%H":function(t){return i(t.Gb,2)},"%I":function(t){return 0==(t=t.Gb)?t=12:12<t&&(t-=12),i(t,2)},"%j":function(t){for(var e=0,n=0;n<=t.Hb-1;e+=(pt(t.Cb+1900)?ht:dt)[n++]);return i(t.Kb+e,3)},"%m":function(t){return i(t.Hb+1,2)},"%M":function(t){return i(t.Zb,2)},"%n":function(){return"\\n"},"%p":function(t){return 0<=t.Gb&&12>t.Gb?"AM":"PM"},"%S":function(t){return i(t.$b,2)},"%t":function(){return"\\t"},"%u":function(t){return t.Ab||7},"%U":function(t){return i(Math.floor((t.Bb+7-t.Ab)/7),2)},"%V":function(t){var e=Math.floor((t.Bb+7-(t.Ab+6)%7)/7);if(2>=(t.Ab+371-t.Bb-2)%7&&e++,e)53==e&&(4==(n=(t.Ab+371-t.Bb)%7)||3==n&&pt(t.Cb)||(e=1));else{e=52;var n=(t.Ab+7-t.Bb-1)%7;(4==n||5==n&&pt(t.Cb%400-1))&&e++}return i(e,2)},"%w":function(t){return t.Ab},"%W":function(t){return i(Math.floor((t.Bb+7-(t.Ab+6)%7)/7),2)},"%y":function(t){return(t.Cb+1900).toString().substring(2)},"%Y":function(t){return t.Cb+1900},"%z":function(t){var e=0<=(t=t.Yb);return t=Math.abs(t)/60,(e?"+":"-")+String("0000"+(t/60*100+t%60)).slice(-4)},"%Z":function(t){return t.ac},"%%":function(){return"%"}},n=n.replace(/%%/g,"\\0\\0"),s)n.includes(l)&&(n=n.replace(new RegExp(l,"g"),s[l](r)));return l=function(t){var e=Array(D(t)+1);return k(t,e,0,e.length),e}(n=n.replace(/\\0\\0/g,"%")),l.length>e?0:(S.set(l,t>>>0),l.length-1)}var bt={a:function(t){return gt(t+24)+24},m:function(t){return(t=new et(t)).Pb()||(t.Ib(!0),K--),t.Jb(!1),Q.push(t),t.Nb(),t.Qb()},ia:function(t){throw w("Unexpected exception thrown, this is not properly supported - aborting"),C=!0,t},w:function(){Ot(0);var t=Q.pop();if(t.Xb()&&!t.Lb()){var e=t.Wb();e&&at(e)(t.Db),nt(t.Db)}tt=0},d:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},k:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},g:function(){var t=tt;if(!t)return ft=0;var e=new et(t);e.Fb(t);var n=e.Eb();if(!n)return ft=0,t;for(var r=Array.prototype.slice.call(arguments),a=0;a<r.length;a++){var i=r[a];if(0===i||i===n)break;if(Et(i,n,e.zb+16))return ft=i,t}return ft=n,t},s:nt,L:function(){var t=Q.pop();t||V("no exception to throw");var e=t.Db;throw t.Lb()||(Q.push(t),t.Jb(!0),t.Ib(!1),K++),tt=e,e},b:function(t,e,n){throw new et(t).Rb(e,n),tt=t,K++,t},la:function(){return K},i:function(t){throw tt||(tt=t),t},H:function(){return 0},Ba:function(){},pa:function(){},ra:function(){},ka:function(){return 0},za:function(){},ua:function(){},ya:function(){},R:function(){},qa:function(){},na:function(){},Aa:function(){},oa:function(){},Ha:function(){},Ja:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},Ia:function(){V("To use dlopen, you need enable dynamic linking, see https://github.com/emscripten-core/emscripten/wiki/Linking")},S:function(){return Date.now()},Ca:function(){return!0},Da:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getUTCSeconds(),E[e+4>>2>>>0]=t.getUTCMinutes(),E[e+8>>2>>>0]=t.getUTCHours(),E[e+12>>2>>>0]=t.getUTCDate(),E[e+16>>2>>>0]=t.getUTCMonth(),E[e+20>>2>>>0]=t.getUTCFullYear()-1900,E[e+24>>2>>>0]=t.getUTCDay(),E[e+28>>2>>>0]=(t.getTime()-Date.UTC(t.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},Ea:function(t,e){t=new Date(1e3*(M[t>>>2]+4294967296*E[t+4>>>2])),E[e>>2>>>0]=t.getSeconds(),E[e+4>>2>>>0]=t.getMinutes(),E[e+8>>2>>>0]=t.getHours(),E[e+12>>2>>>0]=t.getDate(),E[e+16>>2>>>0]=t.getMonth(),E[e+20>>2>>>0]=t.getFullYear()-1900,E[e+24>>2>>>0]=t.getDay();var n=new Date(t.getFullYear(),0,1);E[e+28>>2>>>0]=(t.getTime()-n.getTime())/864e5|0,E[e+36>>2>>>0]=-60*t.getTimezoneOffset();var r=new Date(t.getFullYear(),6,1).getTimezoneOffset();n=n.getTimezoneOffset(),E[e+32>>2>>>0]=0|(r!=n&&t.getTimezoneOffset()==Math.min(n,r))},Fa:function(t){var e=new Date(E[t+20>>2>>>0]+1900,E[t+16>>2>>>0],E[t+12>>2>>>0],E[t+8>>2>>>0],E[t+4>>2>>>0],E[t>>2>>>0],0),n=E[t+32>>2>>>0],r=e.getTimezoneOffset(),a=new Date(e.getFullYear(),0,1),i=new Date(e.getFullYear(),6,1).getTimezoneOffset(),o=a.getTimezoneOffset(),u=Math.min(o,i);return 0>n?E[t+32>>2>>>0]=Number(i!=o&&u==r):0<n!=(u==r)&&(i=Math.max(o,i),e.setTime(e.getTime()+6e4*((0<n?u:i)-r))),E[t+24>>2>>>0]=e.getDay(),E[t+28>>2>>>0]=(e.getTime()-a.getTime())/864e5|0,E[t>>2>>>0]=e.getSeconds(),E[t+4>>2>>>0]=e.getMinutes(),E[t+8>>2>>>0]=e.getHours(),E[t+12>>2>>>0]=e.getDate(),E[t+16>>2>>>0]=e.getMonth(),e.getTime()/1e3|0},sa:function(){return-52},ta:function(){},Ga:function t(e,n,r){t.Vb||(t.Vb=!0,function(t,e,n){function r(t){return(t=t.toTimeString().match(/\\(([A-Za-z ]+)\\)$/))?t[1]:"GMT"}var a=(new Date).getFullYear(),i=new Date(a,0,1),o=new Date(a,6,1);a=i.getTimezoneOffset();var u=o.getTimezoneOffset();E[t>>2>>>0]=60*Math.max(a,u),E[e>>2>>>0]=Number(a!=u),t=r(i),e=r(o),t=it(t),e=it(e),u<a?(M[n>>2>>>0]=t,M[n+4>>2>>>0]=e):(M[n>>2>>>0]=e,M[n+4>>2>>>0]=t)}(e,n,r))},B:function(){V("")},ma:function(){return 4294901760},I:b?()=>{var t=process.hrtime();return 1e3*t[0]+t[1]/1e6}:()=>performance.now(),xa:function(t,e,n){T.copyWithin(t>>>0,e>>>0,e+n>>>0)},G:function(t){var e=T.length;if(4294901760<(t>>>=0))return!1;for(var n=1;4>=n;n*=2){var r=e*(1+.2/n);r=Math.min(r,t+100663296);var a=Math;r=Math.max(t,r),a=a.min.call(a,4294901760,r+(65536-r%65536)%65536);t:{try{O.grow(a-A.byteLength+65535>>>16),P();var i=1;break t}catch(t){}i=void 0}if(i)return!0}return!1},va:function(t,e){var n=0;return ut().forEach((function(r,a){var i=e+n;for(a=M[t+4*a>>2>>>0]=i,i=0;i<r.length;++i)S[a++>>0>>>0]=r.charCodeAt(i);S[a>>0>>>0]=0,n+=r.length+1})),0},wa:function(t,e){var n=ut();M[t>>2>>>0]=n.length;var r=0;return n.forEach((function(t){r+=t.length+1})),M[e>>2>>>0]=r,0},ba:function(t){_||0<L||(_t(),Z(W),wt(0),st[1].length&&lt(1,10),st[2].length&&lt(2,10)),_||0<L||(e.onExit&&e.onExit(t),C=!0),h(t,new J(t))},E:function(){return 52},Q:function(){return 52},ca:function(){return 70},P:function(t,e,n,r){for(var a=0,i=0;i<n;i++){var o=M[e>>2>>>0],u=M[e+4>>2>>>0];e+=8;for(var c=0;c<u;c++)lt(t,T[o+c>>>0]);a+=u}return M[r>>2>>>0]=a,0},c:function(){return ft},ja:function t(e,r){t.Mb||(t.Mb=function(){if("object"==typeof crypto&&"function"==typeof crypto.getRandomValues){var t=new Uint8Array(1);return()=>(crypto.getRandomValues(t),t[0])}if(b)try{var e=n(Object(function(){var t=new Error("Cannot find module \'crypto\'");throw t.code="MODULE_NOT_FOUND",t}()));return()=>e.randomBytes(1)[0]}catch(t){}return()=>V("randomDevice")}());for(var a=0;a<r;a++)S[e+a>>0>>>0]=t.Mb();return 0},ea:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},fa:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},J:function(t){var e=At();try{return at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},e:function(t,e){var n=At();try{return at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},N:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},O:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},j:function(t,e,n){var r=At();try{return at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},o:function(t,e,n,r){var a=At();try{return at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},p:function(t,e,n,r,a){var i=At();try{return at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},M:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},r:function(t,e,n,r,a,i){var o=At();try{return at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},v:function(t,e,n,r,a,i,o){var u=At();try{return at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},K:function(t,e,n,r,a,i,o,u){var c=At();try{return at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},D:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{return at(t)(e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},X:function(t,e,n,r,a,i,o,u){var c=At();try{return Ft(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},V:function(t,e,n,r,a,i,o){var u=At();try{return xt(t,e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},U:function(t,e,n,r,a){var i=At();try{return It(t,e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},Z:function(t,e,n,r){var a=At();try{return Pt(t,e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},W:function(t){var e=At();try{return Ct(t)}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},Y:function(t,e){var n=At();try{return Ut(t,e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},T:function(t,e,n){var r=At();try{return Rt(t,e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},f:function(t){var e=At();try{at(t)()}catch(t){if(St(e),t!==t+0)throw t;Ot(1,0)}},q:function(t,e){var n=At();try{at(t)(e)}catch(t){if(St(n),t!==t+0)throw t;Ot(1,0)}},h:function(t,e,n){var r=At();try{at(t)(e,n)}catch(t){if(St(r),t!==t+0)throw t;Ot(1,0)}},da:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},l:function(t,e,n,r){var a=At();try{at(t)(e,n,r)}catch(t){if(St(a),t!==t+0)throw t;Ot(1,0)}},t:function(t,e,n,r,a){var i=At();try{at(t)(e,n,r,a)}catch(t){if(St(i),t!==t+0)throw t;Ot(1,0)}},u:function(t,e,n,r,a,i){var o=At();try{at(t)(e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},x:function(t,e,n,r,a,i,o){var u=At();try{at(t)(e,n,r,a,i,o)}catch(t){if(St(u),t!==t+0)throw t;Ot(1,0)}},z:function(t,e,n,r,a,i,o,u){var c=At();try{at(t)(e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},ga:function(t,e,n,r,a,i,o,u,c){var s=At();try{at(t)(e,n,r,a,i,o,u,c)}catch(t){if(St(s),t!==t+0)throw t;Ot(1,0)}},A:function(t,e,n,r,a,i,o,u,c,s,l){var f=At();try{at(t)(e,n,r,a,i,o,u,c,s,l)}catch(t){if(St(f),t!==t+0)throw t;Ot(1,0)}},C:function(t,e,n,r,a,i,o,u,c,s,l,f,p,h,d,y){var b=At();try{at(t)(e,n,r,a,i,o,u,c,s,l,f,p,h,d,y)}catch(t){if(St(b),t!==t+0)throw t;Ot(1,0)}},aa:function(t,e,n,r,a,i,o,u){var c=At();try{jt(t,e,n,r,a,i,o,u)}catch(t){if(St(c),t!==t+0)throw t;Ot(1,0)}},_:function(t,e,n,r,a,i,o,u,c,s,l,f){var p=At();try{Dt(t,e,n,r,a,i,o,u,c,s,l,f)}catch(t){if(St(p),t!==t+0)throw t;Ot(1,0)}},$:function(t,e,n,r,a,i){var o=At();try{kt(t,e,n,r,a,i)}catch(t){if(St(o),t!==t+0)throw t;Ot(1,0)}},n:function(t){return t},F:function(t){ft=t},ha:yt,y:function(t,e,n,r){return yt(t,e,n,r)}};!function(){function t(t){e.asm=t.exports,O=e.asm.Ka,P(),U=e.asm.ib,I.unshift(e.asm.La),B--,e.monitorRunDependencies&&e.monitorRunDependencies(B),0==B&&(null!==G&&(clearInterval(G),G=null),N&&(t=N,N=null,t()))}function n(e){t(e.instance)}function r(t){return function(){if(!g&&(d||y)){if("function"==typeof fetch&&!Y.startsWith("file://"))return fetch(Y,{credentials:"same-origin"}).then((function(t){if(!t.ok)throw"failed to load wasm binary file at \'"+Y+"\'";return t.arrayBuffer()})).catch((function(){return X()}));if(o)return new Promise((function(t,e){o(Y,(function(e){t(new Uint8Array(e))}),e)}))}return Promise.resolve().then((function(){return X()}))}().then((function(t){return WebAssembly.instantiate(t,i)})).then((function(t){return t})).then(t,(function(t){w("failed to asynchronously prepare wasm: "+t),V(t)}))}var i={a:bt};if(B++,e.monitorRunDependencies&&e.monitorRunDependencies(B),e.instantiateWasm)try{return e.instantiateWasm(i,t)}catch(t){return w("Module.instantiateWasm callback failed with error: "+t),!1}(g||"function"!=typeof WebAssembly.instantiateStreaming||$()||Y.startsWith("file://")||b||"function"!=typeof fetch?r(n):fetch(Y,{credentials:"same-origin"}).then((function(t){return WebAssembly.instantiateStreaming(t,i).then(n,(function(t){return w("wasm streaming compile failed: "+t),w("falling back to ArrayBuffer instantiation"),r(n)}))}))).catch(a)}(),e.___wasm_call_ctors=function(){return(e.___wasm_call_ctors=e.asm.La).apply(null,arguments)},e._OrtInit=function(){return(e._OrtInit=e.asm.Ma).apply(null,arguments)},e._OrtCreateSessionOptions=function(){return(e._OrtCreateSessionOptions=e.asm.Na).apply(null,arguments)},e._OrtAppendExecutionProvider=function(){return(e._OrtAppendExecutionProvider=e.asm.Oa).apply(null,arguments)},e._OrtAddSessionConfigEntry=function(){return(e._OrtAddSessionConfigEntry=e.asm.Pa).apply(null,arguments)},e._OrtReleaseSessionOptions=function(){return(e._OrtReleaseSessionOptions=e.asm.Qa).apply(null,arguments)},e._OrtCreateSession=function(){return(e._OrtCreateSession=e.asm.Ra).apply(null,arguments)},e._OrtReleaseSession=function(){return(e._OrtReleaseSession=e.asm.Sa).apply(null,arguments)},e._OrtGetInputCount=function(){return(e._OrtGetInputCount=e.asm.Ta).apply(null,arguments)},e._OrtGetOutputCount=function(){return(e._OrtGetOutputCount=e.asm.Ua).apply(null,arguments)},e._OrtGetInputName=function(){return(e._OrtGetInputName=e.asm.Va).apply(null,arguments)},e._OrtGetOutputName=function(){return(e._OrtGetOutputName=e.asm.Wa).apply(null,arguments)},e._OrtFree=function(){return(e._OrtFree=e.asm.Xa).apply(null,arguments)},e._OrtCreateTensor=function(){return(e._OrtCreateTensor=e.asm.Ya).apply(null,arguments)},e._OrtGetTensorData=function(){return(e._OrtGetTensorData=e.asm.Za).apply(null,arguments)},e._OrtReleaseTensor=function(){return(e._OrtReleaseTensor=e.asm._a).apply(null,arguments)},e._OrtCreateRunOptions=function(){return(e._OrtCreateRunOptions=e.asm.$a).apply(null,arguments)},e._OrtAddRunConfigEntry=function(){return(e._OrtAddRunConfigEntry=e.asm.ab).apply(null,arguments)},e._OrtReleaseRunOptions=function(){return(e._OrtReleaseRunOptions=e.asm.bb).apply(null,arguments)},e._OrtRun=function(){return(e._OrtRun=e.asm.cb).apply(null,arguments)},e._OrtEndProfiling=function(){return(e._OrtEndProfiling=e.asm.db).apply(null,arguments)};var mt,gt=e._malloc=function(){return(gt=e._malloc=e.asm.eb).apply(null,arguments)},vt=e._free=function(){return(vt=e._free=e.asm.fb).apply(null,arguments)},wt=e._fflush=function(){return(wt=e._fflush=e.asm.gb).apply(null,arguments)},_t=e.___funcs_on_exit=function(){return(_t=e.___funcs_on_exit=e.asm.hb).apply(null,arguments)},Ot=e._setThrew=function(){return(Ot=e._setThrew=e.asm.jb).apply(null,arguments)},At=e.stackSave=function(){return(At=e.stackSave=e.asm.kb).apply(null,arguments)},St=e.stackRestore=function(){return(St=e.stackRestore=e.asm.lb).apply(null,arguments)},Tt=e.stackAlloc=function(){return(Tt=e.stackAlloc=e.asm.mb).apply(null,arguments)},Et=e.___cxa_can_catch=function(){return(Et=e.___cxa_can_catch=e.asm.nb).apply(null,arguments)},Mt=e.___cxa_is_pointer_type=function(){return(Mt=e.___cxa_is_pointer_type=e.asm.ob).apply(null,arguments)},Ct=e.dynCall_j=function(){return(Ct=e.dynCall_j=e.asm.pb).apply(null,arguments)},xt=e.dynCall_iiiiij=function(){return(xt=e.dynCall_iiiiij=e.asm.qb).apply(null,arguments)},Rt=e.dynCall_jii=function(){return(Rt=e.dynCall_jii=e.asm.rb).apply(null,arguments)},jt=e.dynCall_viiiiij=function(){return(jt=e.dynCall_viiiiij=e.asm.sb).apply(null,arguments)},kt=e.dynCall_vjji=function(){return(kt=e.dynCall_vjji=e.asm.tb).apply(null,arguments)},Dt=e.dynCall_viiijjjii=function(){return(Dt=e.dynCall_viiijjjii=e.asm.ub).apply(null,arguments)},Pt=e.dynCall_iij=function(){return(Pt=e.dynCall_iij=e.asm.vb).apply(null,arguments)},Ut=e.dynCall_ji=function(){return(Ut=e.dynCall_ji=e.asm.wb).apply(null,arguments)},Ft=e.dynCall_iiiiiij=function(){return(Ft=e.dynCall_iiiiiij=e.asm.xb).apply(null,arguments)},It=e.dynCall_iiij=function(){return(It=e.dynCall_iiij=e.asm.yb).apply(null,arguments)};function Wt(){function t(){if(!mt&&(mt=!0,e.calledRun=!0,!C)){if(Z(I),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),e.postRun)for("function"==typeof e.postRun&&(e.postRun=[e.postRun]);e.postRun.length;){var t=e.postRun.shift();H.unshift(t)}Z(H)}}if(!(0<B)){if(e.preRun)for("function"==typeof e.preRun&&(e.preRun=[e.preRun]);e.preRun.length;)z();Z(F),0<B||(e.setStatus?(e.setStatus("Running..."),setTimeout((function(){setTimeout((function(){e.setStatus("")}),1),t()}),1)):t())}}if(e.UTF8ToString=j,e.stringToUTF8=function(t,e,n){return k(t,T,e,n)},e.lengthBytesUTF8=D,e.stackSave=At,e.stackRestore=St,e.stackAlloc=Tt,N=function t(){mt||Wt(),mt||(N=t)},e.preInit)for("function"==typeof e.preInit&&(e.preInit=[e.preInit]);0<e.preInit.length;)e.preInit.pop()();return Wt(),t.ready});t.exports=r},967:(t,e)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.iterateExtraOptions=void 0,e.iterateExtraOptions=(t,n,r,a)=>{if("object"==typeof t&&null!==t){if(r.has(t))throw new Error("Circular reference in options");r.add(t)}Object.entries(t).forEach((([t,i])=>{const o=n?n+t:t;if("object"==typeof i)(0,e.iterateExtraOptions)(i,o+".",r,a);else if("string"==typeof i||"number"==typeof i)a(o,i.toString());else{if("boolean"!=typeof i)throw new Error("Can\'t handle extra config type: "+typeof i);a(o,i?"1":"0")}}))}},586:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setRunOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setRunOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};try{if(void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);void 0===(null==t?void 0:t.terminate)&&(u.terminate=!1);let i=0;if(void 0!==(null==t?void 0:t.tag)&&(i=(0,a.allocWasmString)(t.tag,o)),n=e._OrtCreateRunOptions(u.logSeverityLevel,u.logVerbosityLevel,!!u.terminate,i),0===n)throw new Error("Can\'t create run options");return void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddRunConfigEntry(n,i,u))throw new Error(`Can\'t set a run config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseRunOptions(n),o.forEach(e._free),t}}},919:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.setSessionOptions=void 0;const r=n(967),a=n(983),i=n(361);e.setSessionOptions=t=>{const e=(0,i.getInstance)();let n=0;const o=[],u=t||{};(t=>{t.extra||(t.extra={}),t.extra.session||(t.extra.session={});const e=t.extra.session;e.use_ort_model_bytes_directly||(e.use_ort_model_bytes_directly="1")})(u);try{void 0===(null==t?void 0:t.graphOptimizationLevel)&&(u.graphOptimizationLevel="all");const c=(t=>{switch(t){case"disabled":return 0;case"basic":return 1;case"extended":return 2;case"all":return 99;default:throw new Error(`unsupported graph optimization level: ${t}`)}})(u.graphOptimizationLevel);void 0===(null==t?void 0:t.enableCpuMemArena)&&(u.enableCpuMemArena=!0),void 0===(null==t?void 0:t.enableMemPattern)&&(u.enableMemPattern=!0),void 0===(null==t?void 0:t.executionMode)&&(u.executionMode="sequential");const s=(t=>{switch(t){case"sequential":return 0;case"parallel":return 1;default:throw new Error(`unsupported execution mode: ${t}`)}})(u.executionMode);let l=0;if(void 0!==(null==t?void 0:t.logId)&&(l=(0,a.allocWasmString)(t.logId,o)),void 0===(null==t?void 0:t.logSeverityLevel))u.logSeverityLevel=2;else if("number"!=typeof t.logSeverityLevel||!Number.isInteger(t.logSeverityLevel)||t.logSeverityLevel<0||t.logSeverityLevel>4)throw new Error(`log serverity level is not valid: ${t.logSeverityLevel}`);if(void 0===(null==t?void 0:t.logVerbosityLevel))u.logVerbosityLevel=0;else if("number"!=typeof t.logVerbosityLevel||!Number.isInteger(t.logVerbosityLevel))throw new Error(`log verbosity level is not valid: ${t.logVerbosityLevel}`);if(void 0===(null==t?void 0:t.enableProfiling)&&(u.enableProfiling=!1),n=e._OrtCreateSessionOptions(c,!!u.enableCpuMemArena,!!u.enableMemPattern,s,!!u.enableProfiling,0,l,u.logSeverityLevel,u.logVerbosityLevel),0===n)throw new Error("Can\'t create session options");return(null==t?void 0:t.executionProviders)&&((t,e,n)=>{for(const r of e){let e="string"==typeof r?r:r.name;switch(e){case"xnnpack":e="XNNPACK";break;case"wasm":case"cpu":continue;default:throw new Error(`not supported EP: ${e}`)}const o=(0,a.allocWasmString)(e,n);if(0!==(0,i.getInstance)()._OrtAppendExecutionProvider(t,o))throw new Error(`Can\'t append execution provider: ${e}`)}})(n,t.executionProviders,o),void 0!==(null==t?void 0:t.extra)&&(0,r.iterateExtraOptions)(t.extra,"",new WeakSet,((t,r)=>{const i=(0,a.allocWasmString)(t,o),u=(0,a.allocWasmString)(r,o);if(0!==e._OrtAddSessionConfigEntry(n,i,u))throw new Error(`Can\'t set a session config entry: ${t} - ${r}`)})),[n,o]}catch(t){throw 0!==n&&e._OrtReleaseSessionOptions(n),o.forEach(e._free),t}}},983:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.allocWasmString=void 0;const r=n(361);e.allocWasmString=(t,e)=>{const n=(0,r.getInstance)(),a=n.lengthBytesUTF8(t)+1,i=n._malloc(a);return n.stringToUTF8(t,i,a),e.push(i),i}},349:(t,e,n)=>{"use strict";Object.defineProperty(e,"__esModule",{value:!0}),e.extractTransferableBuffers=e.endProfiling=e.run=e.releaseSession=e.createSession=e.createSessionFinalize=e.createSessionAllocate=e.initOrt=void 0;const r=n(586),a=n(919),i=n(983),o=n(361);e.initOrt=(t,e)=>{const n=(0,o.getInstance)()._OrtInit(t,e);if(0!==n)throw new Error(`Can\'t initialize onnxruntime. error code = ${n}`)};const u=new Map;e.createSessionAllocate=t=>{const e=(0,o.getInstance)(),n=e._malloc(t.byteLength);return e.HEAPU8.set(t,n),[n,t.byteLength]},e.createSessionFinalize=(t,e)=>{const n=(0,o.getInstance)();let r=0,i=0,c=[];try{if([i,c]=(0,a.setSessionOptions)(e),r=n._OrtCreateSession(t[0],t[1],i),0===r)throw new Error("Can\'t create a session")}finally{n._free(t[0]),n._OrtReleaseSessionOptions(i),c.forEach(n._free)}const s=n._OrtGetInputCount(r),l=n._OrtGetOutputCount(r),f=[],p=[],h=[],d=[];for(let t=0;t<s;t++){const e=n._OrtGetInputName(r,t);if(0===e)throw new Error("Can\'t get an input name");p.push(e),f.push(n.UTF8ToString(e))}for(let t=0;t<l;t++){const e=n._OrtGetOutputName(r,t);if(0===e)throw new Error("Can\'t get an output name");d.push(e),h.push(n.UTF8ToString(e))}return u.set(r,[r,p,d]),[r,f,h]},e.createSession=(t,n)=>{const r=(0,e.createSessionAllocate)(t);return(0,e.createSessionFinalize)(r,n)},e.releaseSession=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=n[1],i=n[2];a.forEach(e._OrtFree),i.forEach(e._OrtFree),e._OrtReleaseSession(r),u.delete(t)};const c=t=>{switch(t){case"int8":return 3;case"uint8":return 2;case"bool":return 9;case"int16":return 5;case"uint16":return 4;case"int32":return 6;case"uint32":return 12;case"float32":return 1;case"float64":return 11;case"string":return 8;case"int64":return 7;case"uint64":return 13;default:throw new Error(`unsupported data type: ${t}`)}},s=t=>{switch(t){case 3:return"int8";case 2:return"uint8";case 9:return"bool";case 5:return"int16";case 4:return"uint16";case 6:return"int32";case 12:return"uint32";case 1:return"float32";case 11:return"float64";case 8:return"string";case 7:return"int64";case 13:return"uint64";default:throw new Error(`unsupported data type: ${t}`)}},l=t=>{switch(t){case"float32":return Float32Array;case"uint8":case"bool":return Uint8Array;case"int8":return Int8Array;case"uint16":return Uint16Array;case"int16":return Int16Array;case"int32":return Int32Array;case"float64":return Float64Array;case"uint32":return Uint32Array;case"int64":return BigInt64Array;case"uint64":return BigUint64Array;default:throw new Error(`unsupported type: ${t}`)}};e.run=(t,e,n,a,f)=>{const p=(0,o.getInstance)(),h=u.get(t);if(!h)throw new Error("invalid session id");const d=h[0],y=h[1],b=h[2],m=e.length,g=a.length;let v=0,w=[];const _=[],O=[];try{[v,w]=(0,r.setRunOptions)(f);for(let t=0;t<m;t++){const e=n[t][0],r=n[t][1],a=n[t][2];let o,u;if(Array.isArray(a)){u=4*a.length,o=p._malloc(u),O.push(o);let t=o/4;for(let e=0;e<a.length;e++){if("string"!=typeof a[e])throw new TypeError(`tensor data at index ${e} is not a string`);p.HEAPU32[t++]=(0,i.allocWasmString)(a[e],O)}}else u=a.byteLength,o=p._malloc(u),O.push(o),p.HEAPU8.set(new Uint8Array(a.buffer,a.byteOffset,u),o);const s=p.stackSave(),l=p.stackAlloc(4*r.length);try{let t=l/4;r.forEach((e=>p.HEAP32[t++]=e));const n=p._OrtCreateTensor(c(e),o,u,l,r.length);if(0===n)throw new Error("Can\'t create a tensor");_.push(n)}finally{p.stackRestore(s)}}const t=p.stackSave(),o=p.stackAlloc(4*m),u=p.stackAlloc(4*m),h=p.stackAlloc(4*g),A=p.stackAlloc(4*g);try{let n=o/4,r=u/4,i=h/4,c=A/4;for(let t=0;t<m;t++)p.HEAPU32[n++]=_[t],p.HEAPU32[r++]=y[e[t]];for(let t=0;t<g;t++)p.HEAPU32[i++]=0,p.HEAPU32[c++]=b[a[t]];let f=p._OrtRun(d,u,o,m,A,g,h,v);const w=[];if(0===f)for(let t=0;t<g;t++){const e=p.HEAPU32[h/4+t],n=p.stackSave(),r=p.stackAlloc(16);let a,i=0;try{if(f=p._OrtGetTensorData(e,r,r+4,r+8,r+12),0!==f)throw new Error(`Can\'t access output tensor data. error code = ${f}`);let t=r/4;const o=p.HEAPU32[t++];i=p.HEAPU32[t++];const u=p.HEAPU32[t++],c=p.HEAPU32[t++],h=[];for(let t=0;t<c;t++)h.push(p.HEAPU32[u/4+t]);p._OrtFree(u);const d=0===h.length?1:h.reduce(((t,e)=>t*e));if(a=s(o),"string"===a){const t=[];let e=i/4;for(let n=0;n<d;n++){const r=p.HEAPU32[e++],a=n===d-1?void 0:p.HEAPU32[e]-r;t.push(p.UTF8ToString(r,a))}w.push([a,h,t])}else{const t=new(l(a))(d);new Uint8Array(t.buffer,t.byteOffset,t.byteLength).set(p.HEAPU8.subarray(i,i+t.byteLength)),w.push([a,h,t])}}finally{p.stackRestore(n),"string"===a&&i&&p._free(i),p._OrtReleaseTensor(e)}}if(0===f)return w;throw new Error(`failed to call OrtRun(). error code = ${f}.`)}finally{p.stackRestore(t)}}finally{_.forEach(p._OrtReleaseTensor),O.forEach(p._free),p._OrtReleaseRunOptions(v),w.forEach(p._free)}},e.endProfiling=t=>{const e=(0,o.getInstance)(),n=u.get(t);if(!n)throw new Error("invalid session id");const r=n[0],a=e._OrtEndProfiling(r);if(0===a)throw new Error("Can\'t get an profile file name");e._OrtFree(a)},e.extractTransferableBuffers=t=>{const e=[];for(const n of t){const t=n[2];!Array.isArray(t)&&t.buffer&&e.push(t.buffer)}return e}},361:function(t,e,n){"use strict";var r=this&&this.__createBinding||(Object.create?function(t,e,n,r){void 0===r&&(r=n);var a=Object.getOwnPropertyDescriptor(e,n);a&&!("get"in a?!e.__esModule:a.writable||a.configurable)||(a={enumerable:!0,get:function(){return e[n]}}),Object.defineProperty(t,r,a)}:function(t,e,n,r){void 0===r&&(r=n),t[r]=e[n]}),a=this&&this.__setModuleDefault||(Object.create?function(t,e){Object.defineProperty(t,"default",{enumerable:!0,value:e})}:function(t,e){t.default=e}),i=this&&this.__importStar||function(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)"default"!==n&&Object.prototype.hasOwnProperty.call(t,n)&&r(e,t,n);return a(e,t),e},o=this&&this.__importDefault||function(t){return t&&t.__esModule?t:{default:t}};Object.defineProperty(e,"__esModule",{value:!0}),e.dispose=e.getInstance=e.initializeWebAssembly=void 0;const u=i(n(449)),c=o(n(932)),s=n(474);let l,f=!1,p=!1,h=!1;const d=(t,e)=>e?t?"ort-wasm-simd-threaded.wasm":"ort-wasm-threaded.wasm":t?"ort-wasm-simd.wasm":"ort-wasm.wasm";e.initializeWebAssembly=async t=>{if(f)return Promise.resolve();if(p)throw new Error("multiple calls to \'initializeWebAssembly()\' detected.");if(h)throw new Error("previous call to \'initializeWebAssembly()\' failed.");p=!0;const e=t.initTimeout,r=t.numThreads,a=t.simd,i=r>1&&(()=>{try{return"undefined"!=typeof SharedArrayBuffer&&("undefined"!=typeof MessageChannel&&(new MessageChannel).port1.postMessage(new SharedArrayBuffer(1)),WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,5,4,1,3,1,1,10,11,1,9,0,65,0,254,16,2,0,26,11])))}catch(t){return!1}})(),o=a&&(()=>{try{return WebAssembly.validate(new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,2,1,0,10,30,1,28,0,65,0,253,15,253,12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,253,186,1,26,11]))}catch(t){return!1}})(),y="string"==typeof t.wasmPaths?t.wasmPaths:void 0,b=d(!1,i),m=d(o,i),g="object"==typeof t.wasmPaths?t.wasmPaths[m]:void 0;let v=!1;const w=[];if(e>0&&w.push(new Promise((t=>{setTimeout((()=>{v=!0,t()}),e)}))),w.push(new Promise(((t,e)=>{const r=i?s:c.default,a={locateFile:(t,e)=>i&&t.endsWith(".worker.js")&&"undefined"!=typeof Blob?URL.createObjectURL(new Blob([n(154)],{type:"text/javascript"})):t===b?null!=g?g:(null!=y?y:e)+m:e+t};if(i)if("undefined"==typeof Blob)a.mainScriptUrlOrBlob=u.join("/","ort-wasm-threaded.js");else{const t=`var ortWasmThreaded=(function(){var _scriptDir;return ${r.toString()}})();`;a.mainScriptUrlOrBlob=new Blob([t],{type:"text/javascript"})}r(a).then((e=>{p=!1,f=!0,l=e,t()}),(t=>{p=!1,h=!0,e(t)}))}))),await Promise.race(w),v)throw new Error(`WebAssembly backend initializing failed due to timeout: ${e}ms`)},e.getInstance=()=>{if(f&&l)return l;throw new Error("WebAssembly is not initialized yet.")},e.dispose=()=>{var t;!f||p||h||(p=!0,null===(t=l.PThread)||void 0===t||t.terminateAllThreads(),l=void 0,p=!1,f=!1,h=!0)}},154:t=>{"use strict";t.exports=\'"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\\n\'},384:()=>{},993:()=>{},908:()=>{},953:()=>{},925:()=>{},449:()=>{}},e={};function n(r){var a=e[r];if(void 0!==a)return a.exports;var i=e[r]={exports:{}};return t[r].call(i.exports,i,i.exports,n),i.exports}n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(t){if("object"==typeof window)return window}}(),(()=>{"use strict";const t=n(349),e=n(361);self.onmessage=n=>{switch(n.data.type){case"init-wasm":(0,e.initializeWebAssembly)(n.data.in).then((()=>postMessage({type:"init-wasm"})),(t=>postMessage({type:"init-wasm",err:t})));break;case"init-ort":try{const{numThreads:e,loggingLevel:r}=n.data.in;(0,t.initOrt)(e,r),postMessage({type:"init-ort"})}catch(t){postMessage({type:"init-ort",err:t})}break;case"create_allocate":try{const{model:e}=n.data.in,r=(0,t.createSessionAllocate)(e);postMessage({type:"create_allocate",out:r})}catch(t){postMessage({type:"create_allocate",err:t})}break;case"create_finalize":try{const{modeldata:e,options:r}=n.data.in,a=(0,t.createSessionFinalize)(e,r);postMessage({type:"create_finalize",out:a})}catch(t){postMessage({type:"create_finalize",err:t})}break;case"create":try{const{model:e,options:r}=n.data.in,a=(0,t.createSession)(e,r);postMessage({type:"create",out:a})}catch(t){postMessage({type:"create",err:t})}break;case"release":try{const e=n.data.in;(0,t.releaseSession)(e),postMessage({type:"release"})}catch(t){postMessage({type:"release",err:t})}break;case"run":try{const{sessionId:e,inputIndices:r,inputs:a,outputIndices:i,options:o}=n.data.in,u=(0,t.run)(e,r,a,i,o);postMessage({type:"run",out:u},(0,t.extractTransferableBuffers)(u))}catch(t){postMessage({type:"run",err:t})}break;case"end-profiling":try{const e=n.data.in;(0,t.endProfiling)(e),postMessage({type:"end-profiling"})}catch(t){postMessage({type:"end-profiling",err:t})}}}})()})();\n', "Worker", void 0, void 0);
          }
        }, 477: (t) => {
          t.exports = function(t2, e, n, r) {
            var i = self || window;
            try {
              try {
                var o;
                try {
                  o = new i.Blob([t2]);
                } catch (e2) {
                  (o = new (i.BlobBuilder || i.WebKitBlobBuilder || i.MozBlobBuilder || i.MSBlobBuilder)()).append(t2), o = o.getBlob();
                }
                var a = i.URL || i.webkitURL, s = a.createObjectURL(o), u = new i[e](s, n);
                return a.revokeObjectURL(s), u;
              } catch (r2) {
                return new i[e]("data:application/javascript,".concat(encodeURIComponent(t2)), n);
              }
            } catch (t3) {
              if (!r) throw Error("Inline worker is not supported");
              return new i[e](r, n);
            }
          };
        }, 4154: (t) => {
          t.exports = '"use strict";var e={},t="object"==typeof process&&"object"==typeof process.versions&&"string"==typeof process.versions.node;if(t){var r=require("worker_threads"),a=r.parentPort;a.on("message",(e=>onmessage({data:e})));var o=require("fs");Object.assign(global,{self:global,require:require,Module:e,location:{href:__filename},Worker:r.Worker,importScripts:function(e){(0,eval)(o.readFileSync(e,"utf8"))},postMessage:function(e){a.postMessage(e)},performance:global.performance||{now:function(){return Date.now()}}})}var s=!1,n=[],i=function(){var e=Array.prototype.slice.call(arguments).join(" ");t?o.writeSync(2,e+"\\n"):console.error(e)};self.alert=function(){var t=Array.prototype.slice.call(arguments).join(" ");postMessage({cmd:"alert",text:t,threadId:e._pthread_self()})},e.instantiateWasm=(t,r)=>{var a=new WebAssembly.Instance(e.wasmModule,t);return r(a),e.wasmModule=null,a.exports},self.onunhandledrejection=e=>{throw e.reason??e},self.onmessage=t=>{try{if("load"===t.data.cmd){if(e.wasmModule=t.data.wasmModule,e.wasmMemory=t.data.wasmMemory,e.buffer=e.wasmMemory.buffer,e.ENVIRONMENT_IS_PTHREAD=!0,"string"==typeof t.data.urlOrBlob)importScripts(t.data.urlOrBlob);else{var r=URL.createObjectURL(t.data.urlOrBlob);importScripts(r),URL.revokeObjectURL(r)}ortWasmThreaded(e).then((function(t){e=t}))}else if("run"===t.data.cmd){e.__performance_now_clock_drift=performance.now()-t.data.time,e.__emscripten_thread_init(t.data.pthread_ptr,0,0,1),e.establishStackSpace(),e.PThread.receiveObjectTransfer(t.data),e.PThread.threadInitTLS(),s||(n.forEach((t=>{e.executeNotifiedProxyingQueue(t)})),n=[],s=!0);try{e.invokeEntryPoint(t.data.start_routine,t.data.arg)}catch(t){if("unwind"!=t){if(!(t instanceof e.ExitStatus))throw t;e.keepRuntimeAlive()||e.__emscripten_thread_exit(t.status)}}}else"cancel"===t.data.cmd?e._pthread_self()&&e.__emscripten_thread_exit(-1):"setimmediate"===t.data.target||("processProxyingQueue"===t.data.cmd?s?e.executeNotifiedProxyingQueue(t.data.queue):n.push(t.data.queue):(i("worker.js received unknown command "+t.data.cmd),i(t.data)))}catch(t){throw i("worker.js onmessage() captured an uncaught exception: "+t),t&&t.stack&&i(t.stack),e.__emscripten_thread_crashed&&e.__emscripten_thread_crashed(),t}};\n';
        }, 1670: (t) => {
          t.exports = __WEBPACK_EXTERNAL_MODULE__1670__;
        }, 7067: () => {
        }, 1296: () => {
        }, 1384: () => {
        }, 3993: () => {
        }, 908: () => {
        }, 6953: () => {
        }, 9925: () => {
        }, 2806: () => {
        }, 6449: () => {
        }, 2850: () => {
        }, 5381: () => {
        }, 5686: (t, e, n) => {
          n.r(e), n.d(e, { flatbuffers: () => r });
          var r = {};
          r.Offset, r.Table, r.SIZEOF_SHORT = 2, r.SIZEOF_INT = 4, r.FILE_IDENTIFIER_LENGTH = 4, r.SIZE_PREFIX_LENGTH = 4, r.Encoding = { UTF8_BYTES: 1, UTF16_STRING: 2 }, r.int32 = new Int32Array(2), r.float32 = new Float32Array(r.int32.buffer), r.float64 = new Float64Array(r.int32.buffer), r.isLittleEndian = 1 === new Uint16Array(new Uint8Array([1, 0]).buffer)[0], r.Long = function(t2, e2) {
            this.low = 0 | t2, this.high = 0 | e2;
          }, r.Long.create = function(t2, e2) {
            return 0 == t2 && 0 == e2 ? r.Long.ZERO : new r.Long(t2, e2);
          }, r.Long.prototype.toFloat64 = function() {
            return (this.low >>> 0) + 4294967296 * this.high;
          }, r.Long.prototype.equals = function(t2) {
            return this.low == t2.low && this.high == t2.high;
          }, r.Long.ZERO = new r.Long(0, 0), r.Builder = function(t2) {
            if (t2) e2 = t2;
            else var e2 = 1024;
            this.bb = r.ByteBuffer.allocate(e2), this.space = e2, this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.clear = function() {
            this.bb.clear(), this.space = this.bb.capacity(), this.minalign = 1, this.vtable = null, this.vtable_in_use = 0, this.isNested = false, this.object_start = 0, this.vtables = [], this.vector_num_elems = 0, this.force_defaults = false;
          }, r.Builder.prototype.forceDefaults = function(t2) {
            this.force_defaults = t2;
          }, r.Builder.prototype.dataBuffer = function() {
            return this.bb;
          }, r.Builder.prototype.asUint8Array = function() {
            return this.bb.bytes().subarray(this.bb.position(), this.bb.position() + this.offset());
          }, r.Builder.prototype.prep = function(t2, e2) {
            t2 > this.minalign && (this.minalign = t2);
            for (var n2 = 1 + ~(this.bb.capacity() - this.space + e2) & t2 - 1; this.space < n2 + t2 + e2; ) {
              var i = this.bb.capacity();
              this.bb = r.Builder.growByteBuffer(this.bb), this.space += this.bb.capacity() - i;
            }
            this.pad(n2);
          }, r.Builder.prototype.pad = function(t2) {
            for (var e2 = 0; e2 < t2; e2++) this.bb.writeInt8(--this.space, 0);
          }, r.Builder.prototype.writeInt8 = function(t2) {
            this.bb.writeInt8(this.space -= 1, t2);
          }, r.Builder.prototype.writeInt16 = function(t2) {
            this.bb.writeInt16(this.space -= 2, t2);
          }, r.Builder.prototype.writeInt32 = function(t2) {
            this.bb.writeInt32(this.space -= 4, t2);
          }, r.Builder.prototype.writeInt64 = function(t2) {
            this.bb.writeInt64(this.space -= 8, t2);
          }, r.Builder.prototype.writeFloat32 = function(t2) {
            this.bb.writeFloat32(this.space -= 4, t2);
          }, r.Builder.prototype.writeFloat64 = function(t2) {
            this.bb.writeFloat64(this.space -= 8, t2);
          }, r.Builder.prototype.addInt8 = function(t2) {
            this.prep(1, 0), this.writeInt8(t2);
          }, r.Builder.prototype.addInt16 = function(t2) {
            this.prep(2, 0), this.writeInt16(t2);
          }, r.Builder.prototype.addInt32 = function(t2) {
            this.prep(4, 0), this.writeInt32(t2);
          }, r.Builder.prototype.addInt64 = function(t2) {
            this.prep(8, 0), this.writeInt64(t2);
          }, r.Builder.prototype.addFloat32 = function(t2) {
            this.prep(4, 0), this.writeFloat32(t2);
          }, r.Builder.prototype.addFloat64 = function(t2) {
            this.prep(8, 0), this.writeFloat64(t2);
          }, r.Builder.prototype.addFieldInt8 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt8(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt16 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt16(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt32 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addInt32(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldInt64 = function(t2, e2, n2) {
            !this.force_defaults && e2.equals(n2) || (this.addInt64(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldFloat32 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addFloat32(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldFloat64 = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addFloat64(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldOffset = function(t2, e2, n2) {
            (this.force_defaults || e2 != n2) && (this.addOffset(e2), this.slot(t2));
          }, r.Builder.prototype.addFieldStruct = function(t2, e2, n2) {
            e2 != n2 && (this.nested(e2), this.slot(t2));
          }, r.Builder.prototype.nested = function(t2) {
            if (t2 != this.offset()) throw new Error("FlatBuffers: struct must be serialized inline.");
          }, r.Builder.prototype.notNested = function() {
            if (this.isNested) throw new Error("FlatBuffers: object serialization must not be nested.");
          }, r.Builder.prototype.slot = function(t2) {
            this.vtable[t2] = this.offset();
          }, r.Builder.prototype.offset = function() {
            return this.bb.capacity() - this.space;
          }, r.Builder.growByteBuffer = function(t2) {
            var e2 = t2.capacity();
            if (3221225472 & e2) throw new Error("FlatBuffers: cannot grow buffer beyond 2 gigabytes.");
            var n2 = e2 << 1, i = r.ByteBuffer.allocate(n2);
            return i.setPosition(n2 - e2), i.bytes().set(t2.bytes(), n2 - e2), i;
          }, r.Builder.prototype.addOffset = function(t2) {
            this.prep(r.SIZEOF_INT, 0), this.writeInt32(this.offset() - t2 + r.SIZEOF_INT);
          }, r.Builder.prototype.startObject = function(t2) {
            this.notNested(), null == this.vtable && (this.vtable = []), this.vtable_in_use = t2;
            for (var e2 = 0; e2 < t2; e2++) this.vtable[e2] = 0;
            this.isNested = true, this.object_start = this.offset();
          }, r.Builder.prototype.endObject = function() {
            if (null == this.vtable || !this.isNested) throw new Error("FlatBuffers: endObject called without startObject");
            this.addInt32(0);
            for (var t2 = this.offset(), e2 = this.vtable_in_use - 1; e2 >= 0 && 0 == this.vtable[e2]; e2--) ;
            for (var n2 = e2 + 1; e2 >= 0; e2--) this.addInt16(0 != this.vtable[e2] ? t2 - this.vtable[e2] : 0);
            this.addInt16(t2 - this.object_start);
            var i = (n2 + 2) * r.SIZEOF_SHORT;
            this.addInt16(i);
            var o = 0, a = this.space;
            t: for (e2 = 0; e2 < this.vtables.length; e2++) {
              var s = this.bb.capacity() - this.vtables[e2];
              if (i == this.bb.readInt16(s)) {
                for (var u = r.SIZEOF_SHORT; u < i; u += r.SIZEOF_SHORT) if (this.bb.readInt16(a + u) != this.bb.readInt16(s + u)) continue t;
                o = this.vtables[e2];
                break;
              }
            }
            return o ? (this.space = this.bb.capacity() - t2, this.bb.writeInt32(this.space, o - t2)) : (this.vtables.push(this.offset()), this.bb.writeInt32(this.bb.capacity() - t2, this.offset() - t2)), this.isNested = false, t2;
          }, r.Builder.prototype.finish = function(t2, e2, n2) {
            var i = n2 ? r.SIZE_PREFIX_LENGTH : 0;
            if (e2) {
              var o = e2;
              if (this.prep(this.minalign, r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH + i), o.length != r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
              for (var a = r.FILE_IDENTIFIER_LENGTH - 1; a >= 0; a--) this.writeInt8(o.charCodeAt(a));
            }
            this.prep(this.minalign, r.SIZEOF_INT + i), this.addOffset(t2), i && this.addInt32(this.bb.capacity() - this.space), this.bb.setPosition(this.space);
          }, r.Builder.prototype.finishSizePrefixed = function(t2, e2) {
            this.finish(t2, e2, true);
          }, r.Builder.prototype.requiredField = function(t2, e2) {
            var n2 = this.bb.capacity() - t2, r2 = n2 - this.bb.readInt32(n2);
            if (0 == this.bb.readInt16(r2 + e2)) throw new Error("FlatBuffers: field " + e2 + " must be set");
          }, r.Builder.prototype.startVector = function(t2, e2, n2) {
            this.notNested(), this.vector_num_elems = e2, this.prep(r.SIZEOF_INT, t2 * e2), this.prep(n2, t2 * e2);
          }, r.Builder.prototype.endVector = function() {
            return this.writeInt32(this.vector_num_elems), this.offset();
          }, r.Builder.prototype.createString = function(t2) {
            if (t2 instanceof Uint8Array) var e2 = t2;
            else {
              e2 = [];
              for (var n2 = 0; n2 < t2.length; ) {
                var r2, i = t2.charCodeAt(n2++);
                (r2 = i < 55296 || i >= 56320 ? i : (i << 10) + t2.charCodeAt(n2++) + -56613888) < 128 ? e2.push(r2) : (r2 < 2048 ? e2.push(r2 >> 6 & 31 | 192) : (r2 < 65536 ? e2.push(r2 >> 12 & 15 | 224) : e2.push(r2 >> 18 & 7 | 240, r2 >> 12 & 63 | 128), e2.push(r2 >> 6 & 63 | 128)), e2.push(63 & r2 | 128));
              }
            }
            this.addInt8(0), this.startVector(1, e2.length, 1), this.bb.setPosition(this.space -= e2.length), n2 = 0;
            for (var o = this.space, a = this.bb.bytes(); n2 < e2.length; n2++) a[o++] = e2[n2];
            return this.endVector();
          }, r.Builder.prototype.createLong = function(t2, e2) {
            return r.Long.create(t2, e2);
          }, r.ByteBuffer = function(t2) {
            this.bytes_ = t2, this.position_ = 0;
          }, r.ByteBuffer.allocate = function(t2) {
            return new r.ByteBuffer(new Uint8Array(t2));
          }, r.ByteBuffer.prototype.clear = function() {
            this.position_ = 0;
          }, r.ByteBuffer.prototype.bytes = function() {
            return this.bytes_;
          }, r.ByteBuffer.prototype.position = function() {
            return this.position_;
          }, r.ByteBuffer.prototype.setPosition = function(t2) {
            this.position_ = t2;
          }, r.ByteBuffer.prototype.capacity = function() {
            return this.bytes_.length;
          }, r.ByteBuffer.prototype.readInt8 = function(t2) {
            return this.readUint8(t2) << 24 >> 24;
          }, r.ByteBuffer.prototype.readUint8 = function(t2) {
            return this.bytes_[t2];
          }, r.ByteBuffer.prototype.readInt16 = function(t2) {
            return this.readUint16(t2) << 16 >> 16;
          }, r.ByteBuffer.prototype.readUint16 = function(t2) {
            return this.bytes_[t2] | this.bytes_[t2 + 1] << 8;
          }, r.ByteBuffer.prototype.readInt32 = function(t2) {
            return this.bytes_[t2] | this.bytes_[t2 + 1] << 8 | this.bytes_[t2 + 2] << 16 | this.bytes_[t2 + 3] << 24;
          }, r.ByteBuffer.prototype.readUint32 = function(t2) {
            return this.readInt32(t2) >>> 0;
          }, r.ByteBuffer.prototype.readInt64 = function(t2) {
            return new r.Long(this.readInt32(t2), this.readInt32(t2 + 4));
          }, r.ByteBuffer.prototype.readUint64 = function(t2) {
            return new r.Long(this.readUint32(t2), this.readUint32(t2 + 4));
          }, r.ByteBuffer.prototype.readFloat32 = function(t2) {
            return r.int32[0] = this.readInt32(t2), r.float32[0];
          }, r.ByteBuffer.prototype.readFloat64 = function(t2) {
            return r.int32[r.isLittleEndian ? 0 : 1] = this.readInt32(t2), r.int32[r.isLittleEndian ? 1 : 0] = this.readInt32(t2 + 4), r.float64[0];
          }, r.ByteBuffer.prototype.writeInt8 = function(t2, e2) {
            this.bytes_[t2] = e2;
          }, r.ByteBuffer.prototype.writeUint8 = function(t2, e2) {
            this.bytes_[t2] = e2;
          }, r.ByteBuffer.prototype.writeInt16 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
          }, r.ByteBuffer.prototype.writeUint16 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8;
          }, r.ByteBuffer.prototype.writeInt32 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
          }, r.ByteBuffer.prototype.writeUint32 = function(t2, e2) {
            this.bytes_[t2] = e2, this.bytes_[t2 + 1] = e2 >> 8, this.bytes_[t2 + 2] = e2 >> 16, this.bytes_[t2 + 3] = e2 >> 24;
          }, r.ByteBuffer.prototype.writeInt64 = function(t2, e2) {
            this.writeInt32(t2, e2.low), this.writeInt32(t2 + 4, e2.high);
          }, r.ByteBuffer.prototype.writeUint64 = function(t2, e2) {
            this.writeUint32(t2, e2.low), this.writeUint32(t2 + 4, e2.high);
          }, r.ByteBuffer.prototype.writeFloat32 = function(t2, e2) {
            r.float32[0] = e2, this.writeInt32(t2, r.int32[0]);
          }, r.ByteBuffer.prototype.writeFloat64 = function(t2, e2) {
            r.float64[0] = e2, this.writeInt32(t2, r.int32[r.isLittleEndian ? 0 : 1]), this.writeInt32(t2 + 4, r.int32[r.isLittleEndian ? 1 : 0]);
          }, r.ByteBuffer.prototype.getBufferIdentifier = function() {
            if (this.bytes_.length < this.position_ + r.SIZEOF_INT + r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: ByteBuffer is too short to contain an identifier.");
            for (var t2 = "", e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++) t2 += String.fromCharCode(this.readInt8(this.position_ + r.SIZEOF_INT + e2));
            return t2;
          }, r.ByteBuffer.prototype.__offset = function(t2, e2) {
            var n2 = t2 - this.readInt32(t2);
            return e2 < this.readInt16(n2) ? this.readInt16(n2 + e2) : 0;
          }, r.ByteBuffer.prototype.__union = function(t2, e2) {
            return t2.bb_pos = e2 + this.readInt32(e2), t2.bb = this, t2;
          }, r.ByteBuffer.prototype.__string = function(t2, e2) {
            t2 += this.readInt32(t2);
            var n2 = this.readInt32(t2), i = "", o = 0;
            if (t2 += r.SIZEOF_INT, e2 === r.Encoding.UTF8_BYTES) return this.bytes_.subarray(t2, t2 + n2);
            for (; o < n2; ) {
              var a, s = this.readUint8(t2 + o++);
              if (s < 192) a = s;
              else {
                var u = this.readUint8(t2 + o++);
                if (s < 224) a = (31 & s) << 6 | 63 & u;
                else {
                  var c = this.readUint8(t2 + o++);
                  a = s < 240 ? (15 & s) << 12 | (63 & u) << 6 | 63 & c : (7 & s) << 18 | (63 & u) << 12 | (63 & c) << 6 | 63 & this.readUint8(t2 + o++);
                }
              }
              a < 65536 ? i += String.fromCharCode(a) : (a -= 65536, i += String.fromCharCode(55296 + (a >> 10), 56320 + (1023 & a)));
            }
            return i;
          }, r.ByteBuffer.prototype.__indirect = function(t2) {
            return t2 + this.readInt32(t2);
          }, r.ByteBuffer.prototype.__vector = function(t2) {
            return t2 + this.readInt32(t2) + r.SIZEOF_INT;
          }, r.ByteBuffer.prototype.__vector_len = function(t2) {
            return this.readInt32(t2 + this.readInt32(t2));
          }, r.ByteBuffer.prototype.__has_identifier = function(t2) {
            if (t2.length != r.FILE_IDENTIFIER_LENGTH) throw new Error("FlatBuffers: file identifier must be length " + r.FILE_IDENTIFIER_LENGTH);
            for (var e2 = 0; e2 < r.FILE_IDENTIFIER_LENGTH; e2++) if (t2.charCodeAt(e2) != this.readInt8(this.position_ + r.SIZEOF_INT + e2)) return false;
            return true;
          }, r.ByteBuffer.prototype.createLong = function(t2, e2) {
            return r.Long.create(t2, e2);
          };
        } }, __webpack_module_cache__ = {};
        function __webpack_require__(t) {
          var e = __webpack_module_cache__[t];
          if (void 0 !== e) return e.exports;
          var n = __webpack_module_cache__[t] = { exports: {} };
          return __webpack_modules__[t].call(n.exports, n, n.exports, __webpack_require__), n.exports;
        }
        __webpack_require__.n = (t) => {
          var e = t && t.__esModule ? () => t.default : () => t;
          return __webpack_require__.d(e, { a: e }), e;
        }, __webpack_require__.d = (t, e) => {
          for (var n in e) __webpack_require__.o(e, n) && !__webpack_require__.o(t, n) && Object.defineProperty(t, n, { enumerable: true, get: e[n] });
        }, __webpack_require__.g = function() {
          if ("object" == typeof globalThis) return globalThis;
          try {
            return this || new Function("return this")();
          } catch (t) {
            if ("object" == typeof window) return window;
          }
        }(), __webpack_require__.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), __webpack_require__.r = (t) => {
          "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: true });
        };
        var __webpack_exports__ = __webpack_require__(6018);
        return __webpack_exports__;
      })());
    })(ortWeb_min$1);
    return ortWeb_min$1.exports;
  }
  var ortWeb_minExports = requireOrtWeb_min();
  const ortWeb_min = /* @__PURE__ */ getDefaultExportFromCjs(ortWeb_minExports);
  const ONNX_WEB = /* @__PURE__ */ _mergeNamespaces({
    __proto__: null,
    default: ortWeb_min
  }, [ortWeb_minExports]);
  let ONNX;
  const executionProviders = [
    // 'webgpu',
    "wasm"
  ];
  if (typeof process !== "undefined" && ((_a = process == null ? void 0 : process.release) == null ? void 0 : _a.name) === "node") {
    ONNX = sharp != null ? sharp : ONNX_NODE;
    executionProviders.unshift("cpu");
  } else {
    ONNX = ortWeb_min != null ? ortWeb_min : ONNX_WEB;
    const isIOS = typeof navigator !== "undefined" && /iP(hone|od|ad).+16_4.+AppleWebKit/.test(navigator.userAgent);
    if (isIOS) {
      ONNX.env.wasm.simd = false;
    }
  }
  const { env: onnx_env } = ONNX;
  const VERSION = "2.17.2";
  const WEB_CACHE_AVAILABLE = typeof self !== "undefined" && "caches" in self;
  const FS_AVAILABLE = !isEmpty(sharp);
  const PATH_AVAILABLE = !isEmpty(sharp);
  const RUNNING_LOCALLY = FS_AVAILABLE && PATH_AVAILABLE;
  const __dirname = RUNNING_LOCALLY ? sharp.dirname(sharp.dirname(sharp.fileURLToPath(self.location.href))) : "./";
  const DEFAULT_CACHE_DIR = RUNNING_LOCALLY ? sharp.join(__dirname, "/.cache/") : null;
  const DEFAULT_LOCAL_MODEL_PATH = "/models/";
  const localModelPath = RUNNING_LOCALLY ? sharp.join(__dirname, DEFAULT_LOCAL_MODEL_PATH) : DEFAULT_LOCAL_MODEL_PATH;
  if (onnx_env == null ? void 0 : onnx_env.wasm) {
    onnx_env.wasm.wasmPaths = RUNNING_LOCALLY ? sharp.join(__dirname, "/dist/") : `https://cdn.jsdelivr.net/npm/@xenova/transformers@${VERSION}/dist/`;
  }
  const env$1 = {
    version: VERSION,
    remoteHost: "https://huggingface.co/",
    remotePathTemplate: "{model}/resolve/{revision}/",
    localModelPath,
    useFS: FS_AVAILABLE,
    /////////////////// Cache settings ///////////////////
    useBrowserCache: WEB_CACHE_AVAILABLE,
    useFSCache: FS_AVAILABLE,
    cacheDir: DEFAULT_CACHE_DIR
  };
  function isEmpty(obj) {
    return Object.keys(obj).length === 0;
  }
  class FileResponse {
    /**
     * Creates a new `FileResponse` object.
     * @param {string|URL} filePath
     */
    constructor(filePath) {
      /**
       * Mapping from file extensions to MIME types.
       */
      __publicField2(this, "_CONTENT_TYPE_MAP", {
        "txt": "text/plain",
        "html": "text/html",
        "css": "text/css",
        "js": "text/javascript",
        "json": "application/json",
        "png": "image/png",
        "jpg": "image/jpeg",
        "jpeg": "image/jpeg",
        "gif": "image/gif"
      });
      this.filePath = filePath;
      this.headers = new Headers();
      this.exists = sharp.existsSync(filePath);
      if (this.exists) {
        this.status = 200;
        this.statusText = "OK";
        let stats = sharp.statSync(filePath);
        this.headers.set("content-length", stats.size.toString());
        this.updateContentType();
        let self2 = this;
        this.body = new ReadableStream({
          start(controller) {
            self2.arrayBuffer().then((buffer) => {
              controller.enqueue(new Uint8Array(buffer));
              controller.close();
            });
          }
        });
      } else {
        this.status = 404;
        this.statusText = "Not Found";
        this.body = null;
      }
    }
    /**
     * Updates the 'content-type' header property of the response based on the extension of
     * the file specified by the filePath property of the current object.
     * @returns {void}
     */
    updateContentType() {
      var _a2;
      const extension = this.filePath.toString().split(".").pop().toLowerCase();
      this.headers.set("content-type", (_a2 = this._CONTENT_TYPE_MAP[extension]) != null ? _a2 : "application/octet-stream");
    }
    /**
     * Clone the current FileResponse object.
     * @returns {FileResponse} A new FileResponse object with the same properties as the current object.
     */
    clone() {
      let response = new FileResponse(this.filePath);
      response.exists = this.exists;
      response.status = this.status;
      response.statusText = this.statusText;
      response.headers = new Headers(this.headers);
      return response;
    }
    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with an ArrayBuffer containing the file's contents.
     * @returns {Promise<ArrayBuffer>} A Promise that resolves with an ArrayBuffer containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    arrayBuffer() {
      return __async(this, null, function* () {
        const data = yield sharp.promises.readFile(this.filePath);
        return data.buffer;
      });
    }
    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a Blob containing the file's contents.
     * @returns {Promise<Blob>} A Promise that resolves with a Blob containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    blob() {
      return __async(this, null, function* () {
        const data = yield sharp.promises.readFile(this.filePath);
        return new Blob([data], { type: this.headers.get("content-type") });
      });
    }
    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a string containing the file's contents.
     * @returns {Promise<string>} A Promise that resolves with a string containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    text() {
      return __async(this, null, function* () {
        const data = yield sharp.promises.readFile(this.filePath, "utf8");
        return data;
      });
    }
    /**
     * Reads the contents of the file specified by the filePath property and returns a Promise that
     * resolves with a parsed JavaScript object containing the file's contents.
     * 
     * @returns {Promise<Object>} A Promise that resolves with a parsed JavaScript object containing the file's contents.
     * @throws {Error} If the file cannot be read.
     */
    json() {
      return __async(this, null, function* () {
        return JSON.parse(yield this.text());
      });
    }
  }
  function isValidUrl(string, protocols = null, validHosts = null) {
    let url;
    try {
      url = new URL(string);
    } catch (_) {
      return false;
    }
    if (protocols && !protocols.includes(url.protocol)) {
      return false;
    }
    if (validHosts && !validHosts.includes(url.hostname)) {
      return false;
    }
    return true;
  }
  function getFile(urlOrPath) {
    return __async(this, null, function* () {
      var _a2, _b2, _c2, _d, _e;
      if (env$1.useFS && !isValidUrl(urlOrPath, ["http:", "https:", "blob:"])) {
        return new FileResponse(urlOrPath);
      } else if (typeof process !== "undefined" && ((_a2 = process == null ? void 0 : process.release) == null ? void 0 : _a2.name) === "node") {
        const IS_CI = !!((_b2 = process.env) == null ? void 0 : _b2.TESTING_REMOTELY);
        const version = env$1.version;
        const headers = new Headers();
        headers.set("User-Agent", `transformers.js/${version}; is_ci/${IS_CI};`);
        const isHFURL = isValidUrl(urlOrPath, ["http:", "https:"], ["huggingface.co", "hf.co"]);
        if (isHFURL) {
          const token = (_e = (_c2 = process.env) == null ? void 0 : _c2.HF_TOKEN) != null ? _e : (_d = process.env) == null ? void 0 : _d.HF_ACCESS_TOKEN;
          if (token) {
            headers.set("Authorization", `Bearer ${token}`);
          }
        }
        return fetch(urlOrPath, { headers });
      } else {
        return fetch(urlOrPath);
      }
    });
  }
  const ERROR_MAPPING = {
    // 4xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#client_error_responses)
    400: "Bad request error occurred while trying to load file",
    401: "Unauthorized access to file",
    403: "Forbidden access to file",
    404: "Could not locate file",
    408: "Request timeout error occurred while trying to load file",
    // 5xx errors (https://developer.mozilla.org/en-US/docs/Web/HTTP/Status#server_error_responses)
    500: "Internal server error error occurred while trying to load file",
    502: "Bad gateway error occurred while trying to load file",
    503: "Service unavailable error occurred while trying to load file",
    504: "Gateway timeout error occurred while trying to load file"
  };
  function handleError(status, remoteURL, fatal) {
    var _a2;
    if (!fatal) {
      return null;
    }
    const message2 = (_a2 = ERROR_MAPPING[status]) != null ? _a2 : `Error (${status}) occurred while trying to load file`;
    throw Error(`${message2}: "${remoteURL}".`);
  }
  class FileCache {
    /**
     * Instantiate a `FileCache` object.
     * @param {string} path 
     */
    constructor(path) {
      this.path = path;
    }
    /**
     * Checks whether the given request is in the cache.
     * @param {string} request 
     * @returns {Promise<FileResponse | undefined>}
     */
    match(request) {
      return __async(this, null, function* () {
        let filePath = sharp.join(this.path, request);
        let file = new FileResponse(filePath);
        if (file.exists) {
          return file;
        } else {
          return void 0;
        }
      });
    }
    /**
     * Adds the given response to the cache.
     * @param {string} request 
     * @param {Response|FileResponse} response 
     * @returns {Promise<void>}
     */
    put(request, response) {
      return __async(this, null, function* () {
        const buffer = Buffer.from(yield response.arrayBuffer());
        let outputPath = sharp.join(this.path, request);
        try {
          yield sharp.promises.mkdir(sharp.dirname(outputPath), { recursive: true });
          yield sharp.promises.writeFile(outputPath, buffer);
        } catch (err) {
          console.warn("An error occurred while writing the file to cache:", err);
        }
      });
    }
    // TODO add the rest?
    // addAll(requests: RequestInfo[]): Promise<void>;
    // delete(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<boolean>;
    // keys(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Request>>;
    // match(request: RequestInfo | URL, options?: CacheQueryOptions): Promise<Response | undefined>;
    // matchAll(request?: RequestInfo | URL, options?: CacheQueryOptions): Promise<ReadonlyArray<Response>>;
  }
  function tryCache(cache, ...names) {
    return __async(this, null, function* () {
      for (let name2 of names) {
        try {
          let result2 = yield cache.match(name2);
          if (result2) return result2;
        } catch (e) {
          continue;
        }
      }
      return void 0;
    });
  }
  function getModelFile(_0, _1) {
    return __async(this, arguments, function* (path_or_repo_id, filename, fatal = true, options = {}) {
      var _a2, _b2;
      dispatchCallback(options.progress_callback, {
        status: "initiate",
        name: path_or_repo_id,
        file: filename
      });
      let cache;
      if (!cache && env$1.useBrowserCache) {
        if (typeof caches === "undefined") {
          throw Error("Browser cache is not available in this environment.");
        }
        try {
          cache = yield caches.open("transformers-cache");
        } catch (e) {
          console.warn("An error occurred while opening the browser cache:", e);
        }
      }
      if (!cache && env$1.useFSCache) {
        cache = new FileCache((_a2 = options.cache_dir) != null ? _a2 : env$1.cacheDir);
      }
      const revision = (_b2 = options.revision) != null ? _b2 : "main";
      let requestURL = pathJoin(path_or_repo_id, filename);
      let localPath = pathJoin(env$1.localModelPath, requestURL);
      let remoteURL = pathJoin(
        env$1.remoteHost,
        env$1.remotePathTemplate.replaceAll("{model}", path_or_repo_id).replaceAll("{revision}", encodeURIComponent(revision)),
        filename
      );
      let fsCacheKey = revision === "main" ? requestURL : pathJoin(path_or_repo_id, revision, filename);
      let cacheKey;
      let proposedCacheKey = cache instanceof FileCache ? fsCacheKey : remoteURL;
      let toCacheResponse = false;
      let response;
      if (cache) {
        response = yield tryCache(cache, localPath, proposedCacheKey);
      }
      const cacheHit = response !== void 0;
      if (response === void 0) {
        {
          const isURL = isValidUrl(requestURL, ["http:", "https:"]);
          if (!isURL) {
            try {
              response = yield getFile(localPath);
              cacheKey = localPath;
            } catch (e) {
              console.warn(`Unable to load from local path "${localPath}": "${e}"`);
            }
          } else if (options.local_files_only) {
            throw new Error(`\`local_files_only=true\`, but attempted to load a remote file from: ${requestURL}.`);
          } else ;
        }
        if (response === void 0 || response.status === 404) {
          if (options.local_files_only || false) {
            if (fatal) {
              throw Error(`\`local_files_only=true\` or \`env.allowRemoteModels=false\` and file was not found locally at "${localPath}".`);
            } else {
              return null;
            }
          }
          response = yield getFile(remoteURL);
          if (response.status !== 200) {
            return handleError(response.status, remoteURL, fatal);
          }
          cacheKey = proposedCacheKey;
        }
        toCacheResponse = cache && typeof Response !== "undefined" && response instanceof Response && response.status === 200;
      }
      dispatchCallback(options.progress_callback, {
        status: "download",
        name: path_or_repo_id,
        file: filename
      });
      const progressInfo = {
        status: "progress",
        name: path_or_repo_id,
        file: filename
      };
      let buffer;
      if (!options.progress_callback) {
        buffer = new Uint8Array(yield response.arrayBuffer());
      } else if (cacheHit && typeof navigator !== "undefined" && /firefox/i.test(navigator.userAgent)) {
        buffer = new Uint8Array(yield response.arrayBuffer());
        dispatchCallback(options.progress_callback, __spreadProps(__spreadValues({}, progressInfo), {
          progress: 100,
          loaded: buffer.length,
          total: buffer.length
        }));
      } else {
        buffer = yield readResponse(response, (data) => {
          dispatchCallback(options.progress_callback, __spreadValues(__spreadValues({}, progressInfo), data));
        });
      }
      if (
        // Only cache web responses
        // i.e., do not cache FileResponses (prevents duplication)
        toCacheResponse && cacheKey && // Check again whether request is in cache. If not, we add the response to the cache
        (yield cache.match(cacheKey)) === void 0
      ) {
        yield cache.put(cacheKey, new Response(buffer, {
          headers: response.headers
        })).catch((err) => {
          console.warn(`Unable to add response to browser cache: ${err}.`);
        });
      }
      dispatchCallback(options.progress_callback, {
        status: "done",
        name: path_or_repo_id,
        file: filename
      });
      return buffer;
    });
  }
  function getModelJSON(_0, _1) {
    return __async(this, arguments, function* (modelPath, fileName, fatal = true, options = {}) {
      let buffer = yield getModelFile(modelPath, fileName, fatal, options);
      if (buffer === null) {
        return {};
      }
      let decoder = new TextDecoder("utf-8");
      let jsonData = decoder.decode(buffer);
      return JSON.parse(jsonData);
    });
  }
  function readResponse(response, progress_callback) {
    return __async(this, null, function* () {
      const contentLength = response.headers.get("Content-Length");
      if (contentLength === null) {
        console.warn("Unable to determine content-length from response headers. Will expand buffer when needed.");
      }
      let total = parseInt(contentLength != null ? contentLength : "0");
      let buffer = new Uint8Array(total);
      let loaded = 0;
      const reader = response.body.getReader();
      function read() {
        return __async(this, null, function* () {
          const { done, value } = yield reader.read();
          if (done) return;
          let newLoaded = loaded + value.length;
          if (newLoaded > total) {
            total = newLoaded;
            let newBuffer = new Uint8Array(total);
            newBuffer.set(buffer);
            buffer = newBuffer;
          }
          buffer.set(value, loaded);
          loaded = newLoaded;
          const progress = loaded / total * 100;
          progress_callback({
            progress,
            loaded,
            total
          });
          return read();
        });
      }
      yield read();
      return buffer;
    });
  }
  function pathJoin(...parts) {
    parts = parts.map((part, index) => {
      if (index) {
        part = part.replace(new RegExp("^/"), "");
      }
      if (index !== parts.length - 1) {
        part = part.replace(new RegExp("/$"), "");
      }
      return part;
    });
    return parts.join("/");
  }
  function permute_data(array, dims, axes) {
    const shape = new Array(axes.length);
    const stride = new Array(axes.length);
    for (let i = axes.length - 1, s = 1; i >= 0; --i) {
      stride[i] = s;
      shape[i] = dims[axes[i]];
      s *= shape[i];
    }
    const invStride = axes.map((_, i) => stride[axes.indexOf(i)]);
    const permutedData = new array.constructor(array.length);
    for (let i = 0; i < array.length; ++i) {
      let newIndex = 0;
      for (let j = dims.length - 1, k = i; j >= 0; --j) {
        newIndex += k % dims[j] * invStride[j];
        k = Math.floor(k / dims[j]);
      }
      permutedData[newIndex] = array[i];
    }
    return [permutedData, shape];
  }
  function softmax(arr) {
    const maxVal = max(arr)[0];
    const exps = arr.map((x) => Math.exp(x - maxVal));
    const sumExps = exps.reduce((acc, val) => acc + val, 0);
    const softmaxArr = exps.map((x) => x / sumExps);
    return (
      /** @type {T} */
      softmaxArr
    );
  }
  function log_softmax(arr) {
    const softmaxArr = softmax(arr);
    const logSoftmaxArr = softmaxArr.map((x) => Math.log(x));
    return (
      /** @type {T} */
      logSoftmaxArr
    );
  }
  function getTopItems(items, top_k = 0) {
    items = Array.from(items).map((x, i) => [i, x]).sort((a, b) => b[1] - a[1]);
    if (top_k !== null && top_k > 0) {
      items = items.slice(0, top_k);
    }
    return items;
  }
  function max(arr) {
    if (arr.length === 0) throw Error("Array must not be empty");
    let max2 = arr[0];
    let indexOfMax = 0;
    for (let i = 1; i < arr.length; ++i) {
      if (arr[i] > max2) {
        max2 = arr[i];
        indexOfMax = i;
      }
    }
    return [Number(max2), indexOfMax];
  }
  function medianFilter(data, windowSize) {
    if (windowSize % 2 === 0 || windowSize <= 0) {
      throw new Error("Window size must be a positive odd number");
    }
    const outputArray = new data.constructor(data.length);
    const buffer = new data.constructor(windowSize);
    const halfWindowSize = Math.floor(windowSize / 2);
    for (let i = 0; i < data.length; ++i) {
      let valuesIndex = 0;
      for (let j = -halfWindowSize; j <= halfWindowSize; ++j) {
        let index = i + j;
        if (index < 0) {
          index = Math.abs(index);
        } else if (index >= data.length) {
          index = 2 * (data.length - 1) - index;
        }
        buffer[valuesIndex++] = data[index];
      }
      buffer.sort();
      outputArray[i] = buffer[halfWindowSize];
    }
    return outputArray;
  }
  const DataTypeMap = Object.freeze({
    float32: Float32Array,
    float64: Float64Array,
    string: Array,
    // string[]
    int8: Int8Array,
    uint8: Uint8Array,
    int16: Int16Array,
    uint16: Uint16Array,
    int32: Int32Array,
    uint32: Uint32Array,
    int64: BigInt64Array,
    uint64: BigUint64Array,
    bool: Uint8Array
  });
  const ONNXTensor$1 = ONNX.Tensor;
  class Tensor {
    /**
     * Create a new Tensor or copy an existing Tensor.
     * @param {[DataType, DataArray, number[]]|[import('onnxruntime-common').Tensor]} args
     */
    constructor(...args) {
      /** @type {number[]} Dimensions of the tensor. */
      __publicField2(this, "dims");
      /** @type {DataType} Type of the tensor. */
      __publicField2(this, "type");
      /** @type {DataArray} The data stored in the tensor. */
      __publicField2(this, "data");
      /** @type {number} The number of elements in the tensor. */
      __publicField2(this, "size");
      if (args[0] instanceof ONNXTensor$1) {
        Object.assign(this, args[0]);
      } else {
        Object.assign(this, new ONNXTensor$1(
          /** @type {DataType} */
          args[0],
          /** @type {Exclude<import('./maths.js').AnyTypedArray, Uint8ClampedArray>} */
          args[1],
          args[2]
        ));
      }
      return new Proxy(this, {
        get: (obj, key) => {
          if (typeof key === "string") {
            let index = Number(key);
            if (Number.isInteger(index)) {
              return obj._getitem(index);
            }
          }
          return obj[key];
        },
        set: (obj, key, value) => {
          return obj[key] = value;
        }
      });
    }
    /**
     * Returns an iterator object for iterating over the tensor data in row-major order.
     * If the tensor has more than one dimension, the iterator will yield subarrays.
     * @returns {Iterator} An iterator object for iterating over the tensor data in row-major order.
     */
    *[Symbol.iterator]() {
      const [iterLength, ...iterDims] = this.dims;
      if (iterDims.length > 0) {
        const iterSize = iterDims.reduce((a, b) => a * b);
        for (let i = 0; i < iterLength; ++i) {
          yield this._subarray(i, iterSize, iterDims);
        }
      } else {
        yield* __yieldStar(this.data);
      }
    }
    /**
     * Index into a Tensor object.
     * @param {number} index The index to access.
     * @returns {Tensor} The data at the specified index.
     */
    _getitem(index) {
      const [iterLength, ...iterDims] = this.dims;
      index = safeIndex(index, iterLength);
      if (iterDims.length > 0) {
        const iterSize = iterDims.reduce((a, b) => a * b);
        return this._subarray(index, iterSize, iterDims);
      } else {
        return new Tensor(this.type, [this.data[index]], iterDims);
      }
    }
    /**
     * @param {number|bigint} item The item to search for in the tensor
     * @returns {number} The index of the first occurrence of item in the tensor data.
     */
    indexOf(item) {
      for (let index = 0; index < this.data.length; ++index) {
        if (this.data[index] == item) {
          return index;
        }
      }
      return -1;
    }
    /**
     * @param {number} index 
     * @param {number} iterSize 
     * @param {any} iterDims 
     * @returns {Tensor}
     */
    _subarray(index, iterSize, iterDims) {
      const o1 = index * iterSize;
      const o2 = (index + 1) * iterSize;
      const data = "subarray" in this.data ? this.data.subarray(o1, o2) : this.data.slice(o1, o2);
      return new Tensor(this.type, data, iterDims);
    }
    /**
     * Returns the value of this tensor as a standard JavaScript Number. This only works
     * for tensors with one element. For other cases, see `Tensor.tolist()`.
     * @returns {number|bigint} The value of this tensor as a standard JavaScript Number.
     * @throws {Error} If the tensor has more than one element.
     */
    item() {
      if (this.data.length !== 1) {
        throw new Error(`a Tensor with ${this.data.length} elements cannot be converted to Scalar`);
      }
      return this.data[0];
    }
    /**
     * Convert tensor data to a n-dimensional JS list
     * @returns {Array}
     */
    tolist() {
      return reshape(this.data, this.dims);
    }
    /**
     * Return a new Tensor with the sigmoid function applied to each element.
     * @returns {Tensor} The tensor with the sigmoid function applied.
     */
    sigmoid() {
      return this.clone().sigmoid_();
    }
    /**
     * Applies the sigmoid function to the tensor in place.
     * @returns {Tensor} Returns `this`.
     */
    sigmoid_() {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] = 1 / (1 + Math.exp(-this.data[i]));
      }
      return this;
    }
    /**
     * Return a new Tensor with every element multiplied by a constant.
     * @param {number} val The value to multiply by.
     * @returns {Tensor} The new tensor.
     */
    mul(val) {
      return this.clone().mul_(val);
    }
    /**
     * Multiply the tensor by a constant in place.
     * @param {number} val The value to multiply by.
     * @returns {Tensor} Returns `this`.
     */
    mul_(val) {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] *= val;
      }
      return this;
    }
    /**
     * Return a new Tensor with every element added by a constant.
     * @param {number} val The value to add by.
     * @returns {Tensor} The new tensor.
     */
    add(val) {
      return this.clone().add_(val);
    }
    /**
     * Add the tensor by a constant in place.
     * @param {number} val The value to add by.
     * @returns {Tensor} Returns `this`.
     */
    add_(val) {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] += val;
      }
      return this;
    }
    clone() {
      return new Tensor(this.type, this.data.slice(), this.dims.slice());
    }
    slice(...slices) {
      let newTensorDims = [];
      let newOffsets = [];
      for (let sliceIndex = 0; sliceIndex < this.dims.length; ++sliceIndex) {
        let slice = slices[sliceIndex];
        if (slice === null || slice === void 0) {
          newOffsets.push([0, this.dims[sliceIndex]]);
          newTensorDims.push(this.dims[sliceIndex]);
        } else if (typeof slice === "number") {
          slice = safeIndex(slice, this.dims[sliceIndex], sliceIndex);
          newOffsets.push([slice, slice + 1]);
        } else if (Array.isArray(slice) && slice.length === 2) {
          if (slice[0] > slice[1]) {
            throw new Error(`Invalid slice: ${slice}`);
          }
          let offsets = [
            Math.max(slice[0], 0),
            Math.min(slice[1], this.dims[sliceIndex])
          ];
          newOffsets.push(offsets);
          newTensorDims.push(offsets[1] - offsets[0]);
        } else {
          throw new Error(`Invalid slice: ${slice}`);
        }
      }
      let newDims = newOffsets.map(([start, end]) => end - start);
      let newBufferSize = newDims.reduce((a, b) => a * b);
      let data = new this.data.constructor(newBufferSize);
      const stride = this.stride();
      for (let i = 0; i < newBufferSize; ++i) {
        let originalIndex = 0;
        for (let j = newDims.length - 1, num = i; j >= 0; --j) {
          const size = newDims[j];
          originalIndex += (num % size + newOffsets[j][0]) * stride[j];
          num = Math.floor(num / size);
        }
        data[i] = this.data[originalIndex];
      }
      return new Tensor(this.type, data, newTensorDims);
    }
    /**
     * Return a permuted version of this Tensor, according to the provided dimensions.
     * @param  {...number} dims Dimensions to permute.
     * @returns {Tensor} The permuted tensor.
     */
    permute(...dims) {
      return permute(this, dims);
    }
    // TODO: implement transpose. For now (backwards compatibility), it's just an alias for permute()
    transpose(...dims) {
      return this.permute(...dims);
    }
    // TODO add .max() and .min() methods
    /**
     * Returns the sum of each row of the input tensor in the given dimension dim.
     * 
     * @param {number} [dim=null] The dimension or dimensions to reduce. If `null`, all dimensions are reduced.
     * @param {boolean} keepdim Whether the output tensor has `dim` retained or not.
     * @returns The summed tensor
     */
    sum(dim = null, keepdim = false) {
      return this.norm(1, dim, keepdim);
    }
    /**
     * Returns the matrix norm or vector norm of a given tensor.
     * @param {number|string} [p='fro'] The order of norm
     * @param {number} [dim=null] Specifies which dimension of the tensor to calculate the norm across.
     * If dim is None, the norm will be calculated across all dimensions of input.
     * @param {boolean} [keepdim=false] Whether the output tensors have dim retained or not.
     * @returns {Tensor} The norm of the tensor.
     */
    norm(p = "fro", dim = null, keepdim = false) {
      if (p === "fro") {
        p = 2;
      } else if (typeof p === "string") {
        throw Error(`Unsupported norm: ${p}`);
      }
      if (dim === null) {
        let val = __pow(this.data.reduce((a, b) => a + __pow(b, p), 0), 1 / p);
        return new Tensor(this.type, [val], []);
      }
      dim = safeIndex(dim, this.dims.length);
      const resultDims = this.dims.slice();
      resultDims[dim] = 1;
      const result2 = new this.data.constructor(this.data.length / this.dims[dim]);
      for (let i = 0; i < this.data.length; ++i) {
        let resultIndex = 0;
        for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
          const size = this.dims[j];
          if (j !== dim) {
            const index = num % size;
            resultIndex += index * resultMultiplier;
            resultMultiplier *= resultDims[j];
          }
          num = Math.floor(num / size);
        }
        result2[resultIndex] += __pow(this.data[i], p);
      }
      if (p !== 1) {
        for (let i = 0; i < result2.length; ++i) {
          result2[i] = __pow(result2[i], 1 / p);
        }
      }
      if (!keepdim) {
        resultDims.splice(dim, 1);
      }
      return new Tensor(this.type, result2, resultDims);
    }
    /**
     * Performs `L_p` normalization of inputs over specified dimension. Operates in place.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} `this` for operation chaining.
     */
    normalize_(p = 2, dim = 1) {
      dim = safeIndex(dim, this.dims.length);
      const norm = this.norm(p, dim, true);
      for (let i = 0; i < this.data.length; ++i) {
        let resultIndex = 0;
        for (let j = this.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
          const size = this.dims[j];
          if (j !== dim) {
            const index = num % size;
            resultIndex += index * resultMultiplier;
            resultMultiplier *= this.dims[j];
          }
          num = Math.floor(num / size);
        }
        this.data[i] /= norm.data[resultIndex];
      }
      return this;
    }
    /**
     * Performs `L_p` normalization of inputs over specified dimension.
     * @param {number} [p=2] The exponent value in the norm formulation
     * @param {number} [dim=1] The dimension to reduce
     * @returns {Tensor} The normalized tensor.
     */
    normalize(p = 2, dim = 1) {
      return this.clone().normalize_(p, dim);
    }
    /**
     * Compute and return the stride of this tensor.
     * Stride is the jump necessary to go from one element to the next one in the specified dimension dim.
     * @returns {number[]} The stride of this tensor.
     */
    stride() {
      return dimsToStride(this.dims);
    }
    /**
     * Returns a tensor with all specified dimensions of input of size 1 removed.
     * 
     * NOTE: The returned tensor shares the storage with the input tensor, so changing the contents of one will change the contents of the other.
     * If you would like a copy, use `tensor.clone()` before squeezing.
     * 
     * @param {number} [dim=null] If given, the input will be squeezed only in the specified dimensions.
     * @returns The squeezed tensor
     */
    squeeze(dim = null) {
      return new Tensor(
        this.type,
        this.data,
        calc_squeeze_dims(this.dims, dim)
      );
    }
    /**
     * In-place version of @see {@link Tensor.squeeze}
     */
    squeeze_(dim = null) {
      this.dims = calc_squeeze_dims(this.dims, dim);
      return this;
    }
    /**
     * Returns a new tensor with a dimension of size one inserted at the specified position.
     * 
     * NOTE: The returned tensor shares the same underlying data with this tensor.
     * 
     * @param {number} dim The index at which to insert the singleton dimension
     * @returns The unsqueezed tensor
     */
    unsqueeze(dim = null) {
      return new Tensor(
        this.type,
        this.data,
        calc_unsqueeze_dims(this.dims, dim)
      );
    }
    /**
     * In-place version of @see {@link Tensor.unsqueeze}
     */
    unsqueeze_(dim = null) {
      this.dims = calc_unsqueeze_dims(this.dims, dim);
      return this;
    }
    /**
     * In-place version of @see {@link Tensor.flatten}
     */
    flatten_(start_dim = 0, end_dim = -1) {
      end_dim = (end_dim + this.dims.length) % this.dims.length;
      let dimsToKeepBefore = this.dims.slice(0, start_dim);
      let dimsToFlatten = this.dims.slice(start_dim, end_dim + 1);
      let dimsToKeepAfter = this.dims.slice(end_dim + 1);
      this.dims = [...dimsToKeepBefore, dimsToFlatten.reduce((a, b) => a * b, 1), ...dimsToKeepAfter];
      return this;
    }
    /**
     * Flattens input by reshaping it into a one-dimensional tensor.
     * If `start_dim` or `end_dim` are passed, only dimensions starting with `start_dim`
     * and ending with `end_dim` are flattened. The order of elements in input is unchanged.
     * @param {number} start_dim the first dim to flatten
     * @param {number} end_dim the last dim to flatten
     * @returns The flattened tensor.
     */
    flatten(start_dim = 0, end_dim = -1) {
      return this.clone().flatten_(start_dim, end_dim);
    }
    /**
     * Returns a new tensor with the same data as the `self` tensor but of a different `shape`.
     * @param  {...number} dims the desired size
     * @returns {Tensor} The tensor with the same data but different shape
     */
    view(...dims) {
      let inferredIndex = -1;
      for (let i = 0; i < dims.length; ++i) {
        if (dims[i] === -1) {
          if (inferredIndex !== -1) {
            throw new Error("Only one dimension can be inferred");
          }
          inferredIndex = i;
        }
      }
      if (inferredIndex !== -1) {
        const productOther = dims.reduce((product, curr, index) => {
          return index !== inferredIndex ? product * curr : product;
        }, 1);
        dims[inferredIndex] = this.data.length / productOther;
      }
      return new Tensor(this.type, this.data, dims);
    }
    neg_() {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] = -this.data[i];
      }
      return this;
    }
    neg() {
      return this.clone().neg_();
    }
    /**
     * In-place version of @see {@link Tensor.clamp}
     */
    clamp_(min, max2) {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] = Math.min(Math.max(this.data[i], min), max2);
      }
      return this;
    }
    /**
     * Clamps all elements in input into the range [ min, max ]
     * @param {number} min lower-bound of the range to be clamped to
     * @param {number} max upper-bound of the range to be clamped to
     * @returns the output tensor.
     */
    clamp(min, max2) {
      return this.clone().clamp_(min, max2);
    }
    /**
     * In-place version of @see {@link Tensor.round}
     */
    round_() {
      for (let i = 0; i < this.data.length; ++i) {
        this.data[i] = Math.round(this.data[i]);
      }
      return this;
    }
    /**
     * Rounds elements of input to the nearest integer.
     * @returns the output tensor.
     */
    round() {
      return this.clone().round_();
    }
    /**
     * Performs Tensor dtype conversion.
     * @param {DataType} type The desired data type.
     * @returns {Tensor} The converted tensor.
     */
    to(type) {
      if (this.type === type) return this;
      if (!DataTypeMap.hasOwnProperty(type)) {
        throw new Error(`Unsupported type: ${type}`);
      }
      return new Tensor(type, DataTypeMap[type].from(this.data), this.dims);
    }
  }
  function reshape(data, dimensions) {
    const totalElements = data.length;
    const dimensionSize = dimensions.reduce((a, b) => a * b);
    if (totalElements !== dimensionSize) {
      throw Error(`cannot reshape array of size ${totalElements} into shape (${dimensions})`);
    }
    let reshapedArray = data;
    for (let i = dimensions.length - 1; i >= 0; i--) {
      reshapedArray = reshapedArray.reduce((acc, val) => {
        let lastArray = acc[acc.length - 1];
        if (lastArray.length < dimensions[i]) {
          lastArray.push(val);
        } else {
          acc.push([val]);
        }
        return acc;
      }, [[]]);
    }
    return reshapedArray[0];
  }
  function permute(tensor, axes) {
    const [permutedData, shape] = permute_data(tensor.data, tensor.dims, axes);
    return new Tensor(tensor.type, permutedData, shape);
  }
  function calc_squeeze_dims(dims, dim) {
    dims = dims.slice();
    if (dim === null) {
      dims = dims.filter((d) => d !== 1);
    } else if (typeof dim === "number") {
      if (dims[dim] === 1) {
        dims.splice(dim, 1);
      }
    } else if (Array.isArray(dim)) {
      dims = dims.filter((x, i) => {
        return x !== 1 || !dim.includes(i);
      });
    }
    return dims;
  }
  function calc_unsqueeze_dims(dims, dim) {
    dim = safeIndex(dim, dims.length + 1);
    dims = dims.slice();
    dims.splice(dim, 0, 1);
    return dims;
  }
  function safeIndex(index, size, dimension = null) {
    if (index < -size || index >= size) {
      throw new Error(`IndexError: index ${index} is out of bounds for dimension${dimension === null ? "" : " " + dimension} with size ${size}`);
    }
    if (index < 0) {
      index = (index % size + size) % size;
    }
    return index;
  }
  function cat(tensors, dim = 0) {
    dim = safeIndex(dim, tensors[0].dims.length);
    const resultDims = tensors[0].dims.slice();
    resultDims[dim] = tensors.reduce((a, b) => a + b.dims[dim], 0);
    const resultSize = resultDims.reduce((a, b) => a * b, 1);
    const result2 = new tensors[0].data.constructor(resultSize);
    const resultType = tensors[0].type;
    if (dim === 0) {
      let offset = 0;
      for (let t of tensors) {
        result2.set(t.data, offset);
        offset += t.data.length;
      }
    } else {
      let currentDim = 0;
      for (let t = 0; t < tensors.length; ++t) {
        let tensor = tensors[t];
        for (let i = 0; i < tensor.data.length; ++i) {
          let resultIndex = 0;
          for (let j = tensor.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
            const size = tensor.dims[j];
            let index = num % size;
            if (j === dim) {
              index += currentDim;
            }
            resultIndex += index * resultMultiplier;
            resultMultiplier *= resultDims[j];
            num = Math.floor(num / size);
          }
          result2[resultIndex] = tensor.data[i];
        }
        currentDim += tensor.dims[dim];
      }
    }
    return new Tensor(resultType, result2, resultDims);
  }
  function stack(tensors, dim = 0) {
    return cat(tensors.map((t) => t.unsqueeze(dim)), dim);
  }
  function std_mean(input, dim = null, correction = 1, keepdim = false) {
    if (dim === null) {
      const sum = input.data.reduce((a, b) => a + b, 0);
      const mean2 = sum / input.data.length;
      const std = Math.sqrt(input.data.reduce((a, b) => a + __pow(b - mean2, 2), 0) / (input.data.length - correction));
      const meanTensor2 = new Tensor(input.type, [mean2], [
        /* scalar */
      ]);
      const stdTensor2 = new Tensor(input.type, [std], [
        /* scalar */
      ]);
      return [stdTensor2, meanTensor2];
    }
    dim = safeIndex(dim, input.dims.length);
    const meanTensor = mean(input, dim, keepdim);
    const resultDims = input.dims.slice();
    resultDims[dim] = 1;
    const result2 = new input.data.constructor(input.data.length / input.dims[dim]);
    for (let i = 0; i < input.data.length; ++i) {
      let resultIndex = 0;
      for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
        const size = input.dims[j];
        if (j !== dim) {
          const index = num % size;
          resultIndex += index * resultMultiplier;
          resultMultiplier *= resultDims[j];
        }
        num = Math.floor(num / size);
      }
      result2[resultIndex] += __pow(input.data[i] - meanTensor.data[resultIndex], 2);
    }
    for (let i = 0; i < result2.length; ++i) {
      result2[i] = Math.sqrt(result2[i] / (input.dims[dim] - correction));
    }
    if (!keepdim) {
      resultDims.splice(dim, 1);
    }
    const stdTensor = new Tensor(input.type, result2, resultDims);
    return [stdTensor, meanTensor];
  }
  function mean(input, dim = null, keepdim = false) {
    if (dim === null) {
      let val = input.data.reduce((a, b) => a + b, 0);
      return new Tensor(input.type, [val / input.data.length], [
        /* scalar */
      ]);
    }
    dim = safeIndex(dim, input.dims.length);
    const resultDims = input.dims.slice();
    resultDims[dim] = 1;
    const result2 = new input.data.constructor(input.data.length / input.dims[dim]);
    for (let i = 0; i < input.data.length; ++i) {
      let resultIndex = 0;
      for (let j = input.dims.length - 1, num = i, resultMultiplier = 1; j >= 0; --j) {
        const size = input.dims[j];
        if (j !== dim) {
          const index = num % size;
          resultIndex += index * resultMultiplier;
          resultMultiplier *= resultDims[j];
        }
        num = Math.floor(num / size);
      }
      result2[resultIndex] += input.data[i];
    }
    if (input.dims[dim] !== 1) {
      for (let i = 0; i < result2.length; ++i) {
        result2[i] = result2[i] / input.dims[dim];
      }
    }
    if (!keepdim) {
      resultDims.splice(dim, 1);
    }
    return new Tensor(input.type, result2, resultDims);
  }
  function dynamicTimeWarping(matrix) {
    const [output_length, input_length] = matrix.dims;
    const outputShape = [output_length + 1, input_length + 1];
    const cost = new Tensor(
      "float32",
      new Float32Array(outputShape[0] * outputShape[1]).fill(Infinity),
      outputShape
    );
    const trace = new Tensor(
      "float32",
      new Float32Array(outputShape[0] * outputShape[1]).fill(-1),
      outputShape
    );
    cost[0].data[0] = 0;
    for (let j2 = 1; j2 < input_length + 1; ++j2) {
      for (let i2 = 1; i2 < output_length + 1; ++i2) {
        const c0 = cost[i2 - 1][j2 - 1].item();
        const c1 = cost[i2 - 1][j2].item();
        const c2 = cost[i2][j2 - 1].item();
        let c, t;
        if (c0 < c1 && c0 < c2) {
          c = c0;
          t = 0;
        } else if (c1 < c0 && c1 < c2) {
          c = c1;
          t = 1;
        } else {
          c = c2;
          t = 2;
        }
        cost[i2].data[j2] = matrix[i2 - 1][j2 - 1].item() + c;
        trace[i2].data[j2] = t;
      }
    }
    let i = output_length;
    let j = input_length;
    trace.data.fill(2, 0, outputShape[1]);
    for (let i2 = 0; i2 < outputShape[0]; ++i2) {
      trace[i2].data[0] = 1;
    }
    let text_indices = [];
    let time_indices = [];
    while (i > 0 || j > 0) {
      text_indices.push(i - 1);
      time_indices.push(j - 1);
      const t = trace[i][j].item();
      switch (t) {
        case 0:
          --i;
          --j;
          break;
        case 1:
          --i;
          break;
        case 2:
          --j;
          break;
        default:
          throw new Error(
            `Internal error in dynamic time warping. Unexpected trace[${i}, ${j}]. Please file a bug report.`
          );
      }
    }
    text_indices.reverse();
    time_indices.reverse();
    return [text_indices, time_indices];
  }
  function dimsToStride(dims) {
    const stride = new Array(dims.length);
    for (let i = dims.length - 1, s2 = 1; i >= 0; --i) {
      stride[i] = s2;
      s2 *= dims[i];
    }
    return stride;
  }
  function ones(size) {
    const numElements = size.reduce((a, b) => a * b, 1);
    return new Tensor(
      "int64",
      new BigInt64Array(numElements).fill(/* @__PURE__ */ BigInt("1")),
      size
    );
  }
  function ones_like(tensor) {
    return ones(tensor.dims);
  }
  var TOKEN_TYPES = Object.freeze({
    Text: "Text",
    // The text between Jinja statements or expressions
    NumericLiteral: "NumericLiteral",
    // e.g., 123
    BooleanLiteral: "BooleanLiteral",
    // true or false
    StringLiteral: "StringLiteral",
    // 'string'
    Identifier: "Identifier",
    // Variables, functions, etc.
    Equals: "Equals",
    // =
    OpenParen: "OpenParen",
    // (
    CloseParen: "CloseParen",
    // )
    OpenStatement: "OpenStatement",
    // {%
    CloseStatement: "CloseStatement",
    // %}
    OpenExpression: "OpenExpression",
    // {{
    CloseExpression: "CloseExpression",
    // }}
    OpenSquareBracket: "OpenSquareBracket",
    // [
    CloseSquareBracket: "CloseSquareBracket",
    // ]
    OpenCurlyBracket: "OpenCurlyBracket",
    // {
    CloseCurlyBracket: "CloseCurlyBracket",
    // }
    Comma: "Comma",
    // ,
    Dot: "Dot",
    // .
    Colon: "Colon",
    // :
    Pipe: "Pipe",
    // |
    CallOperator: "CallOperator",
    // ()
    AdditiveBinaryOperator: "AdditiveBinaryOperator",
    // + -
    MultiplicativeBinaryOperator: "MultiplicativeBinaryOperator",
    // * / %
    ComparisonBinaryOperator: "ComparisonBinaryOperator",
    // < > <= >= == !=
    UnaryOperator: "UnaryOperator",
    // ! - +
    // Keywords
    Set: "Set",
    If: "If",
    For: "For",
    In: "In",
    Is: "Is",
    NotIn: "NotIn",
    Else: "Else",
    EndIf: "EndIf",
    ElseIf: "ElseIf",
    EndFor: "EndFor",
    And: "And",
    Or: "Or",
    Not: "UnaryOperator"
  });
  Object.freeze({
    set: TOKEN_TYPES.Set,
    for: TOKEN_TYPES.For,
    in: TOKEN_TYPES.In,
    is: TOKEN_TYPES.Is,
    if: TOKEN_TYPES.If,
    else: TOKEN_TYPES.Else,
    endif: TOKEN_TYPES.EndIf,
    elif: TOKEN_TYPES.ElseIf,
    endfor: TOKEN_TYPES.EndFor,
    and: TOKEN_TYPES.And,
    or: TOKEN_TYPES.Or,
    not: TOKEN_TYPES.Not,
    "not in": TOKEN_TYPES.NotIn,
    // Literals
    true: TOKEN_TYPES.BooleanLiteral,
    false: TOKEN_TYPES.BooleanLiteral
  });
  [
    // Control sequences
    ["{%", TOKEN_TYPES.OpenStatement],
    ["%}", TOKEN_TYPES.CloseStatement],
    ["{{", TOKEN_TYPES.OpenExpression],
    ["}}", TOKEN_TYPES.CloseExpression],
    // Single character tokens
    ["(", TOKEN_TYPES.OpenParen],
    [")", TOKEN_TYPES.CloseParen],
    ["{", TOKEN_TYPES.OpenCurlyBracket],
    ["}", TOKEN_TYPES.CloseCurlyBracket],
    ["[", TOKEN_TYPES.OpenSquareBracket],
    ["]", TOKEN_TYPES.CloseSquareBracket],
    [",", TOKEN_TYPES.Comma],
    [".", TOKEN_TYPES.Dot],
    [":", TOKEN_TYPES.Colon],
    ["|", TOKEN_TYPES.Pipe],
    // Comparison operators
    ["<=", TOKEN_TYPES.ComparisonBinaryOperator],
    [">=", TOKEN_TYPES.ComparisonBinaryOperator],
    ["==", TOKEN_TYPES.ComparisonBinaryOperator],
    ["!=", TOKEN_TYPES.ComparisonBinaryOperator],
    ["<", TOKEN_TYPES.ComparisonBinaryOperator],
    [">", TOKEN_TYPES.ComparisonBinaryOperator],
    // Arithmetic operators
    ["+", TOKEN_TYPES.AdditiveBinaryOperator],
    ["-", TOKEN_TYPES.AdditiveBinaryOperator],
    ["*", TOKEN_TYPES.MultiplicativeBinaryOperator],
    ["/", TOKEN_TYPES.MultiplicativeBinaryOperator],
    ["%", TOKEN_TYPES.MultiplicativeBinaryOperator],
    // Assignment operator
    ["=", TOKEN_TYPES.Equals]
  ];
  const BYTES_TO_UNICODE = (() => {
    const bs = [
      ...Array.from({ length: "~".charCodeAt(0) - "!".charCodeAt(0) + 1 }, (_, i) => i + "!".charCodeAt(0)),
      ...Array.from({ length: "¬".charCodeAt(0) - "¡".charCodeAt(0) + 1 }, (_, i) => i + "¡".charCodeAt(0)),
      ...Array.from({ length: "ÿ".charCodeAt(0) - "®".charCodeAt(0) + 1 }, (_, i) => i + "®".charCodeAt(0))
    ];
    const cs = bs.slice();
    let n = 0;
    for (let b = 0; b < 256; ++b) {
      if (!bs.includes(b)) {
        bs.push(b);
        cs.push(256 + n);
        n += 1;
      }
    }
    const ccs = cs.map((n2) => String.fromCharCode(n2));
    return Object.fromEntries(bs.map((b, i) => [b, ccs[i]]));
  })();
  reverseDictionary(BYTES_TO_UNICODE);
  const WHISPER_LANGUAGES = [
    ["en", "english"],
    ["zh", "chinese"],
    ["de", "german"],
    ["es", "spanish"],
    ["ru", "russian"],
    ["ko", "korean"],
    ["fr", "french"],
    ["ja", "japanese"],
    ["pt", "portuguese"],
    ["tr", "turkish"],
    ["pl", "polish"],
    ["ca", "catalan"],
    ["nl", "dutch"],
    ["ar", "arabic"],
    ["sv", "swedish"],
    ["it", "italian"],
    ["id", "indonesian"],
    ["hi", "hindi"],
    ["fi", "finnish"],
    ["vi", "vietnamese"],
    ["he", "hebrew"],
    ["uk", "ukrainian"],
    ["el", "greek"],
    ["ms", "malay"],
    ["cs", "czech"],
    ["ro", "romanian"],
    ["da", "danish"],
    ["hu", "hungarian"],
    ["ta", "tamil"],
    ["no", "norwegian"],
    ["th", "thai"],
    ["ur", "urdu"],
    ["hr", "croatian"],
    ["bg", "bulgarian"],
    ["lt", "lithuanian"],
    ["la", "latin"],
    ["mi", "maori"],
    ["ml", "malayalam"],
    ["cy", "welsh"],
    ["sk", "slovak"],
    ["te", "telugu"],
    ["fa", "persian"],
    ["lv", "latvian"],
    ["bn", "bengali"],
    ["sr", "serbian"],
    ["az", "azerbaijani"],
    ["sl", "slovenian"],
    ["kn", "kannada"],
    ["et", "estonian"],
    ["mk", "macedonian"],
    ["br", "breton"],
    ["eu", "basque"],
    ["is", "icelandic"],
    ["hy", "armenian"],
    ["ne", "nepali"],
    ["mn", "mongolian"],
    ["bs", "bosnian"],
    ["kk", "kazakh"],
    ["sq", "albanian"],
    ["sw", "swahili"],
    ["gl", "galician"],
    ["mr", "marathi"],
    ["pa", "punjabi"],
    ["si", "sinhala"],
    ["km", "khmer"],
    ["sn", "shona"],
    ["yo", "yoruba"],
    ["so", "somali"],
    ["af", "afrikaans"],
    ["oc", "occitan"],
    ["ka", "georgian"],
    ["be", "belarusian"],
    ["tg", "tajik"],
    ["sd", "sindhi"],
    ["gu", "gujarati"],
    ["am", "amharic"],
    ["yi", "yiddish"],
    ["lo", "lao"],
    ["uz", "uzbek"],
    ["fo", "faroese"],
    ["ht", "haitian creole"],
    ["ps", "pashto"],
    ["tk", "turkmen"],
    ["nn", "nynorsk"],
    ["mt", "maltese"],
    ["sa", "sanskrit"],
    ["lb", "luxembourgish"],
    ["my", "myanmar"],
    ["bo", "tibetan"],
    ["tl", "tagalog"],
    ["mg", "malagasy"],
    ["as", "assamese"],
    ["tt", "tatar"],
    ["haw", "hawaiian"],
    ["ln", "lingala"],
    ["ha", "hausa"],
    ["ba", "bashkir"],
    ["jw", "javanese"],
    ["su", "sundanese"]
  ];
  new Map(WHISPER_LANGUAGES);
  new Map([
    ...WHISPER_LANGUAGES.map(([k, v]) => [v, k]),
    ...[
      ["burmese", "my"],
      ["valencian", "ca"],
      ["flemish", "nl"],
      ["haitian", "ht"],
      ["letzeburgesch", "lb"],
      ["pushto", "ps"],
      ["panjabi", "pa"],
      ["moldavian", "ro"],
      ["moldovan", "ro"],
      ["sinhalese", "si"],
      ["castilian", "es"]
    ]
  ]);
  function loadConfig(pretrained_model_name_or_path, options) {
    return __async(this, null, function* () {
      let info = yield getModelJSON(pretrained_model_name_or_path, "config.json", true, options);
      return info;
    });
  }
  class PretrainedConfig {
    // NOTE: Typo in original
    /**
     * Create a new PreTrainedTokenizer instance.
     * @param {Object} configJSON The JSON of the config.
     */
    constructor(configJSON) {
      this.model_type = null;
      this.is_encoder_decoder = false;
      Object.assign(this, configJSON);
    }
    /**
     * Loads a pre-trained config from the given `pretrained_model_name_or_path`. 
     * 
     * @param {string} pretrained_model_name_or_path The path to the pre-trained config.
     * @param {PretrainedOptions} options Additional options for loading the config.
     * @throws {Error} Throws an error if the config.json is not found in the `pretrained_model_name_or_path`.
     * 
     * @returns {Promise<PretrainedConfig>} A new instance of the `PretrainedConfig` class.
     */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, {
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main"
      } = {}) {
        let data = config != null ? config : yield loadConfig(pretrained_model_name_or_path, {
          progress_callback,
          cache_dir,
          local_files_only,
          revision
        });
        return new this(data);
      });
    }
  }
  class AutoConfig {
    /** @type {PretrainedConfig.from_pretrained} */
    static from_pretrained(...args) {
      return __async(this, null, function* () {
        return PretrainedConfig.from_pretrained(...args);
      });
    }
  }
  class LogitsProcessorList extends Callable {
    /**
     * Constructs a new instance of `LogitsProcessorList`.
     */
    constructor() {
      super();
      this.processors = [];
    }
    /**
     * Adds a new logits processor to the list.
     *
     * @param {LogitsProcessor} item The logits processor function to add.
     */
    push(item) {
      this.processors.push(item);
    }
    /**
     * Adds multiple logits processors to the list.
     *
     * @param {LogitsProcessor[]} items The logits processor functions to add.
     */
    extend(items) {
      this.processors.push(...items);
    }
    /**
     * Applies all logits processors in the list to a batch of logits, modifying them in-place.
     *
     * @param {number[]} input_ids The input IDs for the language model.
     * @param {number[][]} batchedLogits A 2D array of logits, where each row corresponds to a single
     *                                                input sequence in the batch.
     */
    _call(input_ids, batchedLogits) {
      for (let logits of batchedLogits) {
        this.processors.forEach(
          (func) => func(input_ids, logits)
        );
      }
    }
    [Symbol.iterator]() {
      return this.processors.values();
    }
  }
  class LogitsProcessor extends Callable {
    /**
     * Apply the processor to the input logits.
     *
     * @abstract
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @throws {Error} Throws an error if `_call` is not implemented in the subclass.
     */
    _call(input_ids, logits) {
      throw Error("`_call` should be implemented in a subclass");
    }
  }
  class ForceTokensLogitsProcessor extends LogitsProcessor {
    /**
     * Constructs a new instance of `ForceTokensLogitsProcessor`.
     * 
     * @param {Array} forced_decoder_ids The ids of tokens that should be forced.
     */
    constructor(forced_decoder_ids) {
      super();
      this.force_token_map = Object.fromEntries(forced_decoder_ids != null ? forced_decoder_ids : []);
    }
    /**
     * Apply the processor to the input logits.
     *
     * @param {Array} input_ids The input ids.
     * @param {Tensor} logits The logits to process.
     * @returns {Tensor} The processed logits.
     */
    _call(input_ids, logits) {
      let map = this.force_token_map[input_ids.length];
      if (exists(map)) {
        logits.data.fill(-Infinity);
        logits.data[map] = 0;
      }
      return logits;
    }
  }
  class ForcedBOSTokenLogitsProcessor extends LogitsProcessor {
    /**
     * Create a ForcedBOSTokenLogitsProcessor.
     * @param {number} bos_token_id The ID of the beginning-of-sequence token to be forced.
     */
    constructor(bos_token_id) {
      super();
      this.bos_token_id = bos_token_id;
    }
    /**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */
    _call(input_ids, logits) {
      if (input_ids.length === 1) {
        logits.data.fill(-Infinity);
        logits.data[this.bos_token_id] = 0;
      }
      return logits;
    }
  }
  class ForcedEOSTokenLogitsProcessor extends LogitsProcessor {
    /**
     * Create a ForcedEOSTokenLogitsProcessor.
     * @param {number} max_length Max length of the sequence.
     * @param {number|number[]} forced_eos_token_id The ID of the end-of-sequence token to be forced.
     */
    constructor(max_length, forced_eos_token_id) {
      super();
      this.max_length = max_length;
      this.forced_eos_token_id = forced_eos_token_id;
    }
    /**
     * Apply the processor to input_ids and logits.
     * 
     * @param {number[]} input_ids The input ids.
     * @param {Tensor} logits The logits tensor.
     */
    _call(input_ids, logits) {
    }
  }
  class SuppressTokensAtBeginLogitsProcessor extends LogitsProcessor {
    /**
     * Create a SuppressTokensAtBeginLogitsProcessor.
     * @param {number[]} begin_suppress_tokens The IDs of the tokens to suppress.
     * @param {number} begin_index The number of tokens to generate before suppressing tokens.
     */
    constructor(begin_suppress_tokens, begin_index) {
      super();
      this.begin_suppress_tokens = begin_suppress_tokens;
      this.begin_index = begin_index;
    }
    /**
     * Apply the BOS token forcing to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with BOS token forcing.
     */
    _call(input_ids, logits) {
      if (input_ids.length === this.begin_index) {
        for (let token_id of this.begin_suppress_tokens) {
          logits.data[token_id] = -Infinity;
        }
      }
      return logits;
    }
  }
  class WhisperTimeStampLogitsProcessor extends LogitsProcessor {
    /**
     * Constructs a new WhisperTimeStampLogitsProcessor.
     * @param {Object} generate_config The config object passed to the `generate()` method of a transformer model.
     * @param {number} generate_config.eos_token_id The ID of the end-of-sequence token.
     * @param {number} generate_config.no_timestamps_token_id The ID of the token used to indicate that a token should not have a timestamp.
     * @param {number[][]} [generate_config.forced_decoder_ids] An array of two-element arrays representing decoder IDs that are forced to appear in the output. The second element of each array indicates whether the token is a timestamp.
     * @param {number} [generate_config.max_initial_timestamp_index] The maximum index at which an initial timestamp can appear.
     */
    constructor(generate_config) {
      super();
      this.eos_token_id = generate_config.eos_token_id;
      this.no_timestamps_token_id = generate_config.no_timestamps_token_id;
      this.timestamp_begin = this.no_timestamps_token_id + 1;
      this.begin_index = (generate_config.forced_decoder_ids || []).length + 2;
      if (generate_config.forced_decoder_ids.slice(-1)[0][1] === this.no_timestamps_token_id) {
        this.begin_index -= 1;
      }
      this.max_initial_timestamp_index = generate_config.max_initial_timestamp_index;
    }
    /**
     * Modify the logits to handle timestamp tokens.
     * @param {Array} input_ids The input sequence of tokens.
     * @param {Tensor} logits The logits output by the model.
     * @returns {Tensor} The modified logits.
     */
    _call(input_ids, logits) {
      const logitsData = (
        /** @type {Float32Array} */
        logits.data
      );
      logitsData[this.no_timestamps_token_id] = -Infinity;
      if (input_ids.length === this.begin_index - 1) {
        logitsData.fill(-Infinity);
        logitsData[this.timestamp_begin] = 0;
        return logits;
      }
      const seq = input_ids.slice(this.begin_index);
      const last_was_timestamp = seq.length >= 1 && seq[seq.length - 1] >= this.timestamp_begin;
      const penultimate_was_timestamp = seq.length < 2 || seq[seq.length - 2] >= this.timestamp_begin;
      if (last_was_timestamp) {
        if (penultimate_was_timestamp) {
          logitsData.subarray(this.timestamp_begin).fill(-Infinity);
        } else {
          logitsData.subarray(0, this.eos_token_id).fill(-Infinity);
        }
      }
      if (input_ids.length === this.begin_index && this.max_initial_timestamp_index !== null) {
        const last_allowed = this.timestamp_begin + this.max_initial_timestamp_index;
        logitsData.subarray(last_allowed + 1).fill(-Infinity);
      }
      const logprobs = log_softmax(logitsData);
      const timestamp_logprob = Math.log(logprobs.subarray(this.timestamp_begin).map(Math.exp).reduce((a, b) => a + b));
      const max_text_token_logprob = max(logprobs.subarray(0, this.timestamp_begin))[0];
      if (timestamp_logprob > max_text_token_logprob) {
        logitsData.subarray(0, this.timestamp_begin).fill(-Infinity);
      }
      return logits;
    }
  }
  class NoRepeatNGramLogitsProcessor extends LogitsProcessor {
    /**
     * Create a NoRepeatNGramLogitsProcessor.
     * @param {number} no_repeat_ngram_size The no-repeat-ngram size. All ngrams of this size can only occur once.
     */
    constructor(no_repeat_ngram_size) {
      super();
      this.no_repeat_ngram_size = no_repeat_ngram_size;
    }
    /**
     * Generate n-grams from a sequence of token ids.
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {Map<string, number[]>} Map of generated n-grams
     */
    getNgrams(prevInputIds) {
      var _a2;
      const curLen = prevInputIds.length;
      const ngrams = [];
      for (let j = 0; j < curLen + 1 - this.no_repeat_ngram_size; ++j) {
        const ngram = [];
        for (let k = 0; k < this.no_repeat_ngram_size; ++k) {
          ngram.push(prevInputIds[j + k]);
        }
        ngrams.push(ngram);
      }
      const generatedNgram = /* @__PURE__ */ new Map();
      for (const ngram of ngrams) {
        const prevNgram = ngram.slice(0, ngram.length - 1);
        const prevNgramKey = JSON.stringify(prevNgram);
        const prevNgramValue = (_a2 = generatedNgram.get(prevNgramKey)) != null ? _a2 : [];
        prevNgramValue.push(ngram[ngram.length - 1]);
        generatedNgram.set(prevNgramKey, prevNgramValue);
      }
      return generatedNgram;
    }
    /**
     * Generate n-grams from a sequence of token ids.
     * @param {Map<string, number[]>} bannedNgrams Map of banned n-grams
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */
    getGeneratedNgrams(bannedNgrams, prevInputIds) {
      var _a2;
      const ngramIdx = prevInputIds.slice(prevInputIds.length + 1 - this.no_repeat_ngram_size, prevInputIds.length);
      const banned = (_a2 = bannedNgrams.get(JSON.stringify(ngramIdx))) != null ? _a2 : [];
      return banned;
    }
    /**
     * Calculate banned n-gram tokens
     * @param {number[]} prevInputIds List of previous input ids
     * @returns {number[]} Map of generated n-grams
     */
    calcBannedNgramTokens(prevInputIds) {
      const bannedTokens = [];
      if (prevInputIds.length + 1 < this.no_repeat_ngram_size) {
        return bannedTokens;
      } else {
        const generatedNgrams = this.getNgrams(prevInputIds);
        const bannedTokens2 = this.getGeneratedNgrams(generatedNgrams, prevInputIds);
        return bannedTokens2;
      }
    }
    /**
     * Apply the no-repeat-ngram processor to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with no-repeat-ngram processing.
     */
    _call(input_ids, logits) {
      const bannedTokens = this.calcBannedNgramTokens(input_ids);
      for (const token of bannedTokens) {
        logits.data[token] = -Infinity;
      }
      return logits;
    }
  }
  class RepetitionPenaltyLogitsProcessor extends LogitsProcessor {
    /**
     * Create a RepetitionPenaltyLogitsProcessor.
     * @param {number} penalty The penalty to apply for repeated tokens.
     */
    constructor(penalty) {
      super();
      this.penalty = penalty;
    }
    /**
     * Apply the repetition penalty to the logits.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The logits with repetition penalty processing.
     */
    _call(input_ids, logits) {
      for (const input_id of input_ids) {
        if (logits.data[input_id] < 0) {
          logits.data[input_id] *= this.penalty;
        } else {
          logits.data[input_id] /= this.penalty;
        }
      }
      return logits;
    }
  }
  class MinLengthLogitsProcessor extends LogitsProcessor {
    /**
     * Create a MinLengthLogitsProcessor.
     * @param {number} min_length The minimum length below which the score of `eos_token_id` is set to negative infinity.
     * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
     */
    constructor(min_length, eos_token_id) {
      super();
      this.min_length = min_length;
      this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
    }
    /**
     * Apply logit processor.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The processed logits.
     */
    _call(input_ids, logits) {
      if (input_ids.length < this.min_length) {
        for (const eos_token of this.eos_token_id) {
          logits.data[eos_token] = -Infinity;
        }
      }
      return logits;
    }
  }
  class MinNewTokensLengthLogitsProcessor extends LogitsProcessor {
    /**
     * Create a MinNewTokensLengthLogitsProcessor.
     * @param {number} prompt_length_to_skip The input tokens length.
     * @param {number} min_new_tokens The minimum *new* tokens length below which the score of `eos_token_id` is set to negative infinity.
     * @param {number|number[]} eos_token_id The ID/IDs of the end-of-sequence token.
     */
    constructor(prompt_length_to_skip, min_new_tokens, eos_token_id) {
      super();
      this.prompt_length_to_skip = prompt_length_to_skip;
      this.min_new_tokens = min_new_tokens;
      this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
    }
    /**
     * Apply logit processor.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The processed logits.
     */
    _call(input_ids, logits) {
      const new_tokens_length = input_ids.length - this.prompt_length_to_skip;
      if (new_tokens_length < this.min_new_tokens) {
        for (const eos_token of this.eos_token_id) {
          logits.data[eos_token] = -Infinity;
        }
      }
      return logits;
    }
  }
  class NoBadWordsLogitsProcessor extends LogitsProcessor {
    /**
     * Create a `NoBadWordsLogitsProcessor`.
     * @param {number[][]} bad_words_ids List of list of token ids that are not allowed to be generated.
     * @param {number|number[]} eos_token_id The id of the *end-of-sequence* token. Optionally, use a list to set multiple *end-of-sequence* tokens.
     */
    constructor(bad_words_ids, eos_token_id) {
      super();
      this.bad_words_ids = bad_words_ids;
      this.eos_token_id = Array.isArray(eos_token_id) ? eos_token_id : [eos_token_id];
    }
    /**
     * Apply logit processor.
     * @param {Array} input_ids The input IDs.
     * @param {Object} logits The logits.
     * @returns {Object} The processed logits.
     */
    _call(input_ids, logits) {
      for (const bad_word_ids of this.bad_words_ids) {
        let mark = true;
        for (let i = 1; i <= bad_word_ids.length - 1 && bad_word_ids.length < input_ids.length; ++i) {
          if (bad_word_ids.at(-i - 1) !== input_ids.at(-i)) {
            mark = false;
            break;
          }
        }
        if (mark) {
          logits.data[bad_word_ids.at(-1)] = -Infinity;
        }
      }
      return logits;
    }
  }
  const GenerationConfig = (
    /** @type {any} */
    class {
      /**
       * Create a new GenerationConfig object.
       * @param {GenerationConfigType} kwargs 
       */
      constructor(kwargs = {}) {
        var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R;
        this.max_length = (_a2 = kwargs.max_length) != null ? _a2 : 20;
        this.max_new_tokens = (_b2 = kwargs.max_new_tokens) != null ? _b2 : null;
        this.min_length = (_c2 = kwargs.min_length) != null ? _c2 : 0;
        this.min_new_tokens = (_d = kwargs.min_new_tokens) != null ? _d : null;
        this.early_stopping = (_e = kwargs.early_stopping) != null ? _e : false;
        this.max_time = (_f = kwargs.max_time) != null ? _f : null;
        this.do_sample = (_g = kwargs.do_sample) != null ? _g : false;
        this.num_beams = (_h = kwargs.num_beams) != null ? _h : 1;
        this.num_beam_groups = (_i = kwargs.num_beam_groups) != null ? _i : 1;
        this.penalty_alpha = (_j = kwargs.penalty_alpha) != null ? _j : null;
        this.use_cache = (_k = kwargs.use_cache) != null ? _k : true;
        this.temperature = (_l = kwargs.temperature) != null ? _l : 1;
        this.top_k = (_m = kwargs.top_k) != null ? _m : 50;
        this.top_p = (_n = kwargs.top_p) != null ? _n : 1;
        this.typical_p = (_o = kwargs.typical_p) != null ? _o : 1;
        this.epsilon_cutoff = (_p = kwargs.epsilon_cutoff) != null ? _p : 0;
        this.eta_cutoff = (_q = kwargs.eta_cutoff) != null ? _q : 0;
        this.diversity_penalty = (_r = kwargs.diversity_penalty) != null ? _r : 0;
        this.repetition_penalty = (_s = kwargs.repetition_penalty) != null ? _s : 1;
        this.encoder_repetition_penalty = (_t = kwargs.encoder_repetition_penalty) != null ? _t : 1;
        this.length_penalty = (_u = kwargs.length_penalty) != null ? _u : 1;
        this.no_repeat_ngram_size = (_v = kwargs.no_repeat_ngram_size) != null ? _v : 0;
        this.bad_words_ids = (_w = kwargs.bad_words_ids) != null ? _w : null;
        this.force_words_ids = (_x = kwargs.force_words_ids) != null ? _x : null;
        this.renormalize_logits = (_y = kwargs.renormalize_logits) != null ? _y : false;
        this.constraints = (_z = kwargs.constraints) != null ? _z : null;
        this.forced_bos_token_id = (_A = kwargs.forced_bos_token_id) != null ? _A : null;
        this.forced_eos_token_id = (_B = kwargs.forced_eos_token_id) != null ? _B : null;
        this.remove_invalid_values = (_C = kwargs.remove_invalid_values) != null ? _C : false;
        this.exponential_decay_length_penalty = (_D = kwargs.exponential_decay_length_penalty) != null ? _D : null;
        this.suppress_tokens = (_E = kwargs.suppress_tokens) != null ? _E : null;
        this.begin_suppress_tokens = (_F = kwargs.begin_suppress_tokens) != null ? _F : null;
        this.forced_decoder_ids = (_G = kwargs.forced_decoder_ids) != null ? _G : null;
        this.num_return_sequences = (_H = kwargs.num_return_sequences) != null ? _H : 1;
        this.output_attentions = (_I = kwargs.output_attentions) != null ? _I : false;
        this.output_hidden_states = (_J = kwargs.output_hidden_states) != null ? _J : false;
        this.output_scores = (_K = kwargs.output_scores) != null ? _K : false;
        this.return_dict_in_generate = (_L = kwargs.return_dict_in_generate) != null ? _L : false;
        this.pad_token_id = (_M = kwargs.pad_token_id) != null ? _M : null;
        this.bos_token_id = (_N = kwargs.bos_token_id) != null ? _N : null;
        this.eos_token_id = (_O = kwargs.eos_token_id) != null ? _O : null;
        this.encoder_no_repeat_ngram_size = (_P = kwargs.encoder_no_repeat_ngram_size) != null ? _P : 0;
        this.decoder_start_token_id = (_Q = kwargs.decoder_start_token_id) != null ? _Q : null;
        this.generation_kwargs = (_R = kwargs.generation_kwargs) != null ? _R : {};
      }
    }
  );
  class Sampler extends Callable {
    /**
     * Creates a new Sampler object with the specified generation config.
     * @param {GenerationConfigType} generation_config The generation config.
     */
    constructor(generation_config) {
      super();
      this.generation_config = generation_config;
    }
    /**
     * Executes the sampler, using the specified logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {void}
     */
    _call(logits, index = -1) {
      return this.sample(logits, index);
    }
    /**
     * Abstract method for sampling the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @throws {Error}
     */
    sample(logits, index) {
      throw Error("sample should be implemented in subclasses.");
    }
    /**
     * Returns the specified logits as an array, with temperature applied.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Float32Array}
     */
    getLogits(logits, index) {
      let vocabSize = logits.dims.at(-1);
      let logs = (
        /** @type {Float32Array} */
        logits.data
      );
      if (index === -1) {
        logs = logs.slice(-vocabSize);
      } else {
        let startIndex = index * vocabSize;
        logs = logs.slice(startIndex, startIndex + vocabSize);
      }
      if (this.generation_config.temperature > 0) {
        logs = logs.map((x) => x / this.generation_config.temperature);
      }
      return logs;
    }
    /**
     * Selects an item randomly based on the specified probabilities.
     * @param {Array} probabilities An array of probabilities to use for selection.
     * @returns {number} The index of the selected item.
     */
    randomSelect(probabilities) {
      let sumProbabilities = probabilities.reduce((acc, curr) => acc + curr, 0);
      let r = Math.random() * sumProbabilities;
      for (let i = 0; i < probabilities.length; ++i) {
        r -= probabilities[i];
        if (r <= 0) {
          return i;
        }
      }
      return 0;
    }
    /**
     * Returns a Sampler object based on the specified options.
     * @param {GenerationConfigType} generation_config An object containing options for the sampler.
     * @returns {Sampler} A Sampler object.
     */
    static getSampler(generation_config) {
      if (generation_config.do_sample) {
        return new MultinomialSampler(generation_config);
      } else if (generation_config.num_beams > 1) {
        return new BeamSearchSampler(generation_config);
      } else {
        if (generation_config.num_return_sequences > 1) {
          throw Error(`num_return_sequences has to be 1 when doing greedy search, but is ${generation_config.num_return_sequences}.`);
        }
        return new GreedySampler(generation_config);
      }
    }
  }
  class GreedySampler extends Sampler {
    /**
     * Sample the maximum probability of a given logits tensor.
     * @param {Tensor} logits
     * @param {number} [index=-1]
     * @returns {Array} An array with a single tuple, containing the index of the maximum value and a meaningless score (since this is a greedy search).
     */
    sample(logits, index = -1) {
      let logs = this.getLogits(logits, index);
      let argmax = max(logs)[1];
      return [
        [argmax, 0]
      ];
    }
  }
  class MultinomialSampler extends Sampler {
    /**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */
    sample(logits, index = -1) {
      let k = logits.dims.at(-1);
      if (this.generation_config.top_k > 0) {
        k = Math.min(this.generation_config.top_k, k);
      }
      const logs = this.getLogits(logits, index);
      const topLogits = getTopItems(logs, k);
      const probabilities = softmax(topLogits.map((x) => x[1]));
      return Array.from({ length: this.generation_config.num_beams }, () => {
        const sampledIndex = this.randomSelect(probabilities);
        return [
          topLogits[sampledIndex][0],
          // token id
          Math.log(probabilities[sampledIndex])
          // score
        ];
      });
    }
  }
  class BeamSearchSampler extends Sampler {
    /**
     * Sample from the logits.
     * @param {Tensor} logits
     * @param {number} index
     * @returns {Array}
     */
    sample(logits, index = -1) {
      let k = logits.dims.at(-1);
      if (this.generation_config.top_k > 0) {
        k = Math.min(this.generation_config.top_k, k);
      }
      const logs = this.getLogits(logits, index);
      const topLogits = getTopItems(logs, k);
      const probabilities = softmax(topLogits.map((x) => x[1]));
      return Array.from({ length: this.generation_config.num_beams }, (_, i) => {
        return [
          topLogits[i][0],
          // token id
          Math.log(probabilities[i])
          // score
        ];
      });
    }
  }
  const { InferenceSession, Tensor: ONNXTensor, env } = ONNX;
  const MODEL_TYPES = {
    EncoderOnly: 0,
    EncoderDecoder: 1,
    Seq2Seq: 2,
    Vision2Seq: 3,
    DecoderOnly: 4,
    MaskGeneration: 5
  };
  const MODEL_TYPE_MAPPING = /* @__PURE__ */ new Map();
  const MODEL_NAME_TO_CLASS_MAPPING = /* @__PURE__ */ new Map();
  const MODEL_CLASS_TO_NAME_MAPPING = /* @__PURE__ */ new Map();
  function constructSession(pretrained_model_name_or_path, fileName, options) {
    return __async(this, null, function* () {
      let modelFileName = `onnx/${fileName}${options.quantized ? "_quantized" : ""}.onnx`;
      let buffer = yield getModelFile(pretrained_model_name_or_path, modelFileName, true, options);
      try {
        return yield InferenceSession.create(buffer, {
          executionProviders
        });
      } catch (err) {
        if (executionProviders.length === 1 && executionProviders[0] === "wasm") {
          throw err;
        }
        console.warn(err);
        console.warn(
          "Something went wrong during model construction (most likely a missing operation). Using `wasm` as a fallback. "
        );
        return yield InferenceSession.create(buffer, {
          executionProviders: ["wasm"]
        });
      }
    });
  }
  function validateInputs(session, inputs) {
    const checkedInputs = /* @__PURE__ */ Object.create(null);
    const missingInputs = [];
    for (const inputName of session.inputNames) {
      const tensor = inputs[inputName];
      if (!(tensor instanceof Tensor)) {
        missingInputs.push(inputName);
        continue;
      }
      checkedInputs[inputName] = env.wasm.proxy ? tensor.clone() : tensor;
    }
    if (missingInputs.length > 0) {
      throw new Error(
        `An error occurred during model execution: "Missing the following inputs: ${missingInputs.join(", ")}.`
      );
    }
    const numInputsProvided = Object.keys(inputs).length;
    const numInputsNeeded = session.inputNames.length;
    if (numInputsProvided > numInputsNeeded) {
      let ignored = Object.keys(inputs).filter((inputName) => !session.inputNames.includes(inputName));
      console.warn(`WARNING: Too many inputs were provided (${numInputsProvided} > ${numInputsNeeded}). The following inputs will be ignored: "${ignored.join(", ")}".`);
    }
    return checkedInputs;
  }
  function sessionRun(session, inputs) {
    return __async(this, null, function* () {
      const checkedInputs = validateInputs(session, inputs);
      try {
        let output = yield session.run(checkedInputs);
        output = replaceTensors(output);
        return output;
      } catch (e) {
        console.error(`An error occurred during model execution: "${e}".`);
        console.error("Inputs given to model:", checkedInputs);
        throw e;
      }
    });
  }
  function replaceTensors(obj) {
    for (let prop in obj) {
      if (obj[prop] instanceof ONNXTensor) {
        obj[prop] = new Tensor(obj[prop]);
      } else if (typeof obj[prop] === "object") {
        replaceTensors(obj[prop]);
      }
    }
    return obj;
  }
  function toI64Tensor(items) {
    if (items instanceof Tensor) {
      return items;
    }
    if (items.length === 0) {
      throw Error("items must be non-empty");
    }
    if (Array.isArray(items[0])) {
      if (items.some((x) => x.length !== items[0].length)) {
        throw Error("Unable to create tensor, you should probably activate truncation and/or padding with 'padding=True' and/or 'truncation=True' to have batched tensors with the same length.");
      }
      return new Tensor(
        "int64",
        BigInt64Array.from(items.flat().map((x) => BigInt(x))),
        [items.length, items[0].length]
      );
    } else {
      return new Tensor(
        "int64",
        BigInt64Array.from(items.map((x) => BigInt(x))),
        [1, items.length]
      );
    }
  }
  function prepareAttentionMask(self2, tokens) {
    var _a2, _b2;
    let pad_token_id = (_a2 = self2.config.pad_token_id) != null ? _a2 : null;
    let eos_token_id = (_b2 = self2.config.eos_token_id) != null ? _b2 : null;
    if (isIntegralNumber(eos_token_id)) {
      eos_token_id = [eos_token_id];
    }
    let is_pad_token_in_inputs = tokens.indexOf(pad_token_id) !== -1;
    let is_pad_token_not_equal_to_eos_token_id = eos_token_id === null || !eos_token_id.includes(pad_token_id);
    if (is_pad_token_in_inputs && is_pad_token_not_equal_to_eos_token_id) {
      let data = BigInt64Array.from(
        // Note: != so that int matches bigint
        // @ts-ignore
        tokens.data.map((x) => x != pad_token_id)
      );
      return new Tensor("int64", data, tokens.dims);
    } else {
      return ones_like(tokens);
    }
  }
  function preparePositionIds(session, feeds, use_cache_branch) {
    if (!session.inputNames.includes("position_ids")) return;
    const data = new BigInt64Array(feeds.attention_mask.data.length);
    for (let i = 0; i < feeds.attention_mask.dims[0]; ++i) {
      let start = i * feeds.attention_mask.dims[1];
      let sum = BigInt(0);
      for (let j = 0; j < feeds.attention_mask.dims[1]; ++j) {
        const index = start + j;
        if (feeds.attention_mask.data[index] === /* @__PURE__ */ BigInt("0")) {
          data[index] = BigInt(1);
        } else {
          data[index] = sum;
          sum += feeds.attention_mask.data[index];
        }
      }
    }
    feeds.position_ids = new Tensor("int64", data, feeds.attention_mask.dims);
    if (use_cache_branch) {
      feeds.position_ids = feeds.position_ids.slice(null, -1).unsqueeze_(-1);
    }
  }
  function boolTensor(value) {
    return new Tensor("bool", [value], [1]);
  }
  function seq2seqForward(self2, model_inputs) {
    return __async(this, null, function* () {
      let { encoder_outputs, past_key_values } = model_inputs;
      if (!encoder_outputs) {
        encoder_outputs = (yield encoderForward(self2, model_inputs)).last_hidden_state;
      }
      let decoderFeeds = {
        input_ids: model_inputs.decoder_input_ids,
        encoder_hidden_states: encoder_outputs
      };
      const use_cache_branch = !!past_key_values;
      if (self2.decoder_merged_session.inputNames.includes("use_cache_branch")) {
        decoderFeeds.use_cache_branch = boolTensor(use_cache_branch);
      }
      if (self2.decoder_merged_session.inputNames.includes("encoder_attention_mask")) {
        decoderFeeds.encoder_attention_mask = model_inputs.attention_mask;
      }
      preparePositionIds(self2.decoder_merged_session, decoderFeeds, use_cache_branch);
      self2.addPastKeyValues(decoderFeeds, past_key_values);
      const decoderResults = yield sessionRun(self2.decoder_merged_session, decoderFeeds);
      let logits = decoderResults.logits;
      past_key_values = self2.getPastKeyValues(decoderResults, past_key_values);
      const attns = self2.getAttentions(decoderResults);
      return new Seq2SeqLMOutput(__spreadValues({ logits, past_key_values, encoder_outputs }, attns));
    });
  }
  function seq2seqStartBeams(self2, inputTokenIds, generation_config, numOutputTokens) {
    var _a2, _b2, _c2, _d;
    let beams = [];
    let beamId = 0;
    const requires_attention_mask = (_a2 = self2.requires_attention_mask) != null ? _a2 : true;
    let decoder_input_ids = (_d = (_c2 = (_b2 = generation_config.decoder_input_ids) != null ? _b2 : generation_config.decoder_start_token_id) != null ? _c2 : generation_config.bos_token_id) != null ? _d : generation_config.eos_token_id;
    if (decoder_input_ids instanceof Tensor) {
      decoder_input_ids = decoder_input_ids.tolist().flat();
    } else if (!Array.isArray(decoder_input_ids)) {
      decoder_input_ids = [decoder_input_ids];
    }
    for (let tokens of inputTokenIds) {
      tokens.dims = [1, ...tokens.dims];
      let start = {
        inputs: tokens,
        encoder_outputs: null,
        prev_model_outputs: null,
        output_token_ids: decoder_input_ids,
        done: false,
        score: 0,
        id: beamId++
        // assign unique id to beams
      };
      if (requires_attention_mask) {
        start.attention_mask = prepareAttentionMask(self2, tokens);
      }
      beams.push(start);
    }
    return beams;
  }
  function seq2seqRunBeam(self2, beam) {
    return __async(this, null, function* () {
      var _a2;
      const input_name = self2.main_input_name;
      let decoder_input_ids = beam.output_token_ids;
      if (beam.prev_model_outputs) {
        decoder_input_ids = decoder_input_ids.slice(-1);
      }
      let model_inputs = {
        [input_name]: beam.inputs,
        decoder_input_ids: toI64Tensor(decoder_input_ids),
        encoder_outputs: beam.encoder_outputs,
        past_key_values: (_a2 = beam.prev_model_outputs) == null ? void 0 : _a2.past_key_values
      };
      if (beam.attention_mask) {
        model_inputs.attention_mask = beam.attention_mask;
      }
      let output = yield self2.forward(model_inputs);
      beam.prev_model_outputs = output;
      beam.encoder_outputs = output.encoder_outputs;
      return output;
    });
  }
  function seq2seqUpdatebeam(beam, newTokenId) {
    beam.output_token_ids = [...beam.output_token_ids, newTokenId];
  }
  function encoderForward(self2, model_inputs) {
    return __async(this, null, function* () {
      const encoderFeeds = /* @__PURE__ */ Object.create(null);
      for (const key of self2.session.inputNames) {
        encoderFeeds[key] = model_inputs[key];
      }
      if (self2.session.inputNames.includes("token_type_ids") && !encoderFeeds.token_type_ids) {
        encoderFeeds.token_type_ids = new Tensor(
          "int64",
          new BigInt64Array(encoderFeeds.input_ids.data.length),
          encoderFeeds.input_ids.dims
        );
      }
      return yield sessionRun(self2.session, encoderFeeds);
    });
  }
  function decoderForward(self2, model_inputs) {
    return __async(this, null, function* () {
      let { input_ids, past_key_values, attention_mask } = model_inputs;
      let decoderFeeds = {
        input_ids,
        attention_mask: attention_mask != null ? attention_mask : prepareAttentionMask(self2, input_ids)
      };
      const use_cache_branch = !!past_key_values;
      if (self2.session.inputNames.includes("use_cache_branch")) {
        decoderFeeds.use_cache_branch = boolTensor(use_cache_branch);
      }
      preparePositionIds(self2.session, decoderFeeds, use_cache_branch);
      self2.addPastKeyValues(decoderFeeds, past_key_values);
      let decoderResults = yield sessionRun(self2.session, decoderFeeds);
      let logits = decoderResults.logits;
      past_key_values = self2.getPastKeyValues(decoderResults, past_key_values);
      return { logits, past_key_values };
    });
  }
  function decoderStartBeams(self2, inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask) {
    let beams = [];
    let beamId = 0;
    for (let tokens of inputTokenIds) {
      let output_token_ids = tokens.tolist().map(Number);
      tokens.dims = [1, ...tokens.dims];
      let attn_mask;
      if (inputs_attention_mask) {
        attn_mask = inputs_attention_mask[beamId];
        attn_mask.dims = [1, ...attn_mask.dims];
      } else {
        attn_mask = prepareAttentionMask(self2, tokens);
      }
      let start = {
        input: tokens,
        model_input_ids: tokens,
        attention_mask: attn_mask,
        prev_model_outputs: null,
        output_token_ids,
        num_output_tokens: numOutputTokens,
        done: false,
        score: 0,
        id: beamId++
        // assign unique id to beams
      };
      beams.push(start);
    }
    return beams;
  }
  function decoderRunBeam(self2, beam) {
    return __async(this, null, function* () {
      var _a2;
      let attnMaskData = new BigInt64Array(beam.output_token_ids.length).fill(/* @__PURE__ */ BigInt("1"));
      let model_inputs = {
        input_ids: beam.model_input_ids,
        attention_mask: new Tensor(
          "int64",
          attnMaskData,
          [1, attnMaskData.length]
        ),
        past_key_values: (_a2 = beam.prev_model_outputs) == null ? void 0 : _a2.past_key_values
      };
      let output = yield self2.forward(model_inputs);
      beam.prev_model_outputs = output;
      return output;
    });
  }
  function decoderUpdatebeam(beam, newTokenId) {
    beam.output_token_ids = [...beam.output_token_ids, newTokenId];
    beam.model_input_ids = new Tensor("int64", [BigInt(newTokenId)], [1, 1]);
  }
  class PreTrainedModel extends Callable {
    /**
     * Creates a new instance of the `PreTrainedModel` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     */
    constructor(config, session) {
      super();
      __publicField2(this, "main_input_name", "input_ids");
      this.config = config;
      this.session = session;
      const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
      const modelType = MODEL_TYPE_MAPPING.get(modelName);
      this.can_generate = false;
      this._runBeam = null;
      this._getStartBeams = null;
      this._updateBeam = null;
      this._forward = null;
      if (modelType === MODEL_TYPES.DecoderOnly) {
        this.can_generate = true;
        this._runBeam = decoderRunBeam;
        this._getStartBeams = decoderStartBeams;
        this._updateBeam = decoderUpdatebeam;
        this._forward = decoderForward;
      } else if (modelType === MODEL_TYPES.Seq2Seq || modelType === MODEL_TYPES.Vision2Seq) {
        this.can_generate = true;
        this._runBeam = seq2seqRunBeam;
        this._getStartBeams = seq2seqStartBeams;
        this._updateBeam = seq2seqUpdatebeam;
        this._forward = seq2seqForward;
      } else if (modelType === MODEL_TYPES.EncoderDecoder) {
        this._forward = encoderForward;
      } else {
        this._forward = encoderForward;
      }
    }
    /**
    * Disposes of all the ONNX sessions that were created during inference.
    * @returns {Promise<unknown[]>} An array of promises, one for each ONNX session that is being disposed.
    * @todo Use https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/FinalizationRegistry
    */
    dispose() {
      return __async(this, null, function* () {
        const promises = [];
        for (let key of Object.keys(this)) {
          const item = this[key];
          if (item instanceof InferenceSession) {
            promises.push(item.handler.dispose());
          }
        }
        return yield Promise.all(promises);
      });
    }
    /**
     * Instantiate one of the model classes of the library from a pretrained model.
     * 
     * The model class to instantiate is selected based on the `model_type` property of the config object
     * (either passed as an argument or loaded from `pretrained_model_name_or_path` if possible)
     * 
     * @param {string} pretrained_model_name_or_path The name or path of the pretrained model. Can be either:
     * - A string, the *model id* of a pretrained model hosted inside a model repo on huggingface.co.
     *   Valid model ids can be located at the root-level, like `bert-base-uncased`, or namespaced under a
     *   user or organization name, like `dbmdz/bert-base-german-cased`.
     * - A path to a *directory* containing model weights, e.g., `./my_model_directory/`.
     * @param {import('./utils/hub.js').PretrainedOptions} options Additional options for loading the model.
     * 
     * @returns {Promise<PreTrainedModel>} A new instance of the `PreTrainedModel` class.
     */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        model_file_name = null
      } = {}) {
        var _a2, _b2;
        let options = {
          quantized,
          progress_callback,
          config,
          cache_dir,
          local_files_only,
          revision,
          model_file_name
        };
        const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this);
        const modelType = MODEL_TYPE_MAPPING.get(modelName);
        let info;
        if (modelType === MODEL_TYPES.DecoderOnly) {
          info = yield Promise.all([
            AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
            constructSession(pretrained_model_name_or_path, (_a2 = options.model_file_name) != null ? _a2 : "decoder_model_merged", options),
            getModelJSON(pretrained_model_name_or_path, "generation_config.json", false, options)
          ]);
        } else if (modelType === MODEL_TYPES.Seq2Seq || modelType === MODEL_TYPES.Vision2Seq) {
          info = yield Promise.all([
            AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
            constructSession(pretrained_model_name_or_path, "encoder_model", options),
            constructSession(pretrained_model_name_or_path, "decoder_model_merged", options),
            getModelJSON(pretrained_model_name_or_path, "generation_config.json", false, options)
          ]);
        } else if (modelType === MODEL_TYPES.MaskGeneration) {
          info = yield Promise.all([
            AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
            constructSession(pretrained_model_name_or_path, "vision_encoder", options),
            constructSession(pretrained_model_name_or_path, "prompt_encoder_mask_decoder", options)
          ]);
        } else if (modelType === MODEL_TYPES.EncoderDecoder) {
          info = yield Promise.all([
            AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
            constructSession(pretrained_model_name_or_path, "encoder_model", options),
            constructSession(pretrained_model_name_or_path, "decoder_model_merged", options)
          ]);
        } else {
          if (modelType !== MODEL_TYPES.EncoderOnly) {
            console.warn(`Model type for '${modelName != null ? modelName : config == null ? void 0 : config.model_type}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);
          }
          info = yield Promise.all([
            AutoConfig.from_pretrained(pretrained_model_name_or_path, options),
            constructSession(pretrained_model_name_or_path, (_b2 = options.model_file_name) != null ? _b2 : "model", options)
          ]);
        }
        return new this(...info);
      });
    }
    /**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Object containing input tensors
     * @returns {Promise<Object>} Object containing output tensors
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return yield this.forward(model_inputs);
      });
    }
    /**
     * Forward method for a pretrained model. If not overridden by a subclass, the correct forward method
     * will be chosen based on the model type.
     * @param {Object} model_inputs The input data to the model in the format specified in the ONNX model.
     * @returns {Promise<Object>} The output data from the model in the format specified in the ONNX model.
     * @throws {Error} This method must be implemented in subclasses.
     */
    forward(model_inputs) {
      return __async(this, null, function* () {
        return yield this._forward(this, model_inputs);
      });
    }
    /**
     * @param {import('./utils/generation.js').GenerationConfigType} generation_config 
     * @param {number} input_ids_seq_length The starting sequence length for the input ids.
     * @returns {LogitsProcessorList}
     * @private
     */
    _get_logits_processor(generation_config, input_ids_seq_length, logits_processor = null) {
      const processors = new LogitsProcessorList();
      if (generation_config.repetition_penalty !== null && generation_config.repetition_penalty !== 1) {
        processors.push(new RepetitionPenaltyLogitsProcessor(generation_config.repetition_penalty));
      }
      if (generation_config.no_repeat_ngram_size !== null && generation_config.no_repeat_ngram_size > 0) {
        processors.push(new NoRepeatNGramLogitsProcessor(generation_config.no_repeat_ngram_size));
      }
      if (generation_config.bad_words_ids !== null) {
        processors.push(new NoBadWordsLogitsProcessor(generation_config.bad_words_ids, generation_config.eos_token_id));
      }
      if (generation_config.min_length !== null && generation_config.eos_token_id !== null && generation_config.min_length > 0) {
        processors.push(new MinLengthLogitsProcessor(generation_config.min_length, generation_config.eos_token_id));
      }
      if (generation_config.min_new_tokens !== null && generation_config.eos_token_id !== null && generation_config.min_new_tokens > 0) {
        processors.push(new MinNewTokensLengthLogitsProcessor(
          input_ids_seq_length,
          generation_config.min_new_tokens,
          generation_config.eos_token_id
        ));
      }
      if (generation_config.forced_bos_token_id !== null) {
        processors.push(new ForcedBOSTokenLogitsProcessor(generation_config.forced_bos_token_id));
      }
      if (generation_config.forced_eos_token_id !== null) {
        processors.push(new ForcedEOSTokenLogitsProcessor(
          generation_config.max_length,
          generation_config.forced_eos_token_id
        ));
      }
      if (generation_config.begin_suppress_tokens !== null) {
        let begin_index = input_ids_seq_length > 1 || generation_config.forced_bos_token_id === null ? input_ids_seq_length : input_ids_seq_length + 1;
        if (generation_config.forced_decoder_ids !== null) {
          begin_index += generation_config.forced_decoder_ids[generation_config.forced_decoder_ids.length - 1][0];
        }
        processors.push(new SuppressTokensAtBeginLogitsProcessor(generation_config.begin_suppress_tokens, begin_index));
      }
      if (generation_config.forced_decoder_ids !== null) {
        processors.push(new ForceTokensLogitsProcessor(generation_config.forced_decoder_ids));
      }
      if (logits_processor !== null) {
        processors.extend(logits_processor);
      }
      return processors;
    }
    /**
     * This function merges multiple generation configs together to form a final generation config to be used by the model for text generation.
     * It first creates an empty `GenerationConfig` object, then it applies the model's own `generation_config` property to it. Finally, if a `generation_config` object was passed in the arguments, it overwrites the corresponding properties in the final config with those of the passed config object.
     * @param {import('./utils/generation.js').GenerationConfigType} generation_config A `GenerationConfig` object containing generation parameters.
     * @returns {import('./utils/generation.js').GenerationConfigType} The final generation config object to be used by the model for text generation.
     */
    _get_generation_config(generation_config) {
      let gen_config = new GenerationConfig(this.config);
      if ("generation_config" in this) {
        Object.assign(gen_config, this.generation_config);
      }
      if (generation_config !== null) {
        Object.assign(gen_config, generation_config);
      }
      return gen_config;
    }
    /**
     * @typedef {import('./utils/maths.js').TypedArray} TypedArray
     */
    /**
     * @typedef {{ sequences: Tensor, decoder_attentions: Tensor, cross_attentions: Tensor }} EncoderDecoderOutput
     * @typedef {Object} DecoderOutput
     * 
     * Generates text based on the given inputs and generation configuration using the model.
     * @param {Tensor|Array|TypedArray} inputs An array of input token IDs.
     * @param {Object|GenerationConfig|null} generation_config The generation configuration to use. If null, default configuration will be used.
     * @param {Object|null} logits_processor An optional logits processor to use. If null, a new LogitsProcessorList instance will be created.
     * @param {Object} options options
     * @param {Object} [options.inputs_attention_mask=null] An optional attention mask for the inputs.
     * @returns {Promise<number[][]|EncoderDecoderOutput|DecoderOutput>} An array of generated output sequences, where each sequence is an array of token IDs.
     * @throws {Error} Throws an error if the inputs array is empty.
     */
    generate(_0) {
      return __async(this, arguments, function* (inputs, generation_config = null, logits_processor = null, {
        inputs_attention_mask = null
      } = {}) {
        var _a2, _b2, _c2, _d, _e;
        if (!this.can_generate) {
          const modelName = MODEL_CLASS_TO_NAME_MAPPING.get(this.constructor);
          let errorMessage = `The current model class (${modelName}) is not compatible with \`.generate()\`, as it doesn't have a language model head.`;
          const modelType = this.config.model_type;
          const possibleInfo = (_c2 = (_b2 = (_a2 = MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(modelType)) != null ? _a2 : MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES.get(modelType)) != null ? _b2 : MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES.get(modelType)) != null ? _c2 : MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES.get(modelType);
          if (possibleInfo) {
            errorMessage += ` Please use the following class instead: '${possibleInfo[0]}'`;
          }
          throw Error(errorMessage);
        }
        if (!(inputs instanceof Tensor) && !isTypedArray(inputs) && !Array.isArray(inputs)) {
          throw Error(`\`inputs\` must be a Tensor, TypedArray, or Array, but is "${inputs.constructor.name}".`);
        }
        let input_ids_seq_length;
        if (this.config.is_encoder_decoder) {
          input_ids_seq_length = 0;
        } else {
          input_ids_seq_length = inputs instanceof Tensor ? inputs.dims.at(-1) : inputs.length;
          if (input_ids_seq_length === 0) {
            throw Error("Must supply a non-empty array of input token ids.");
          }
        }
        generation_config = this._get_generation_config(generation_config);
        logits_processor = logits_processor != null ? logits_processor : new LogitsProcessorList();
        logits_processor = this._get_logits_processor(
          generation_config,
          input_ids_seq_length,
          logits_processor
        );
        let eos_token_ids = generation_config.eos_token_id;
        if (eos_token_ids !== null && !Array.isArray(eos_token_ids)) {
          eos_token_ids = [eos_token_ids];
        }
        let numOutputTokens = 1;
        const maxOutputTokens = numOutputTokens + ((_d = generation_config.max_new_tokens) != null ? _d : Infinity);
        const useMaxLength = Number.isInteger(generation_config.max_length) && ((_e = generation_config.max_new_tokens) != null ? _e : null) === null;
        let sampler = Sampler.getSampler(generation_config);
        let beams = this.getStartBeams(inputs, generation_config, numOutputTokens, inputs_attention_mask);
        while (beams.some((x) => !x.done) && numOutputTokens < maxOutputTokens) {
          let newest_beams = [];
          for (let beam of beams) {
            if (beam.done) {
              newest_beams.push(beam);
              continue;
            }
            if (useMaxLength && beam.output_token_ids.length >= generation_config.max_length) {
              beam.done = true;
              newest_beams.push(beam);
              continue;
            }
            let output = yield this.runBeam(beam);
            if (generation_config.output_attentions) {
              this.addAttentionsToBeam(beam, output);
            }
            if (generation_config.output_scores) ;
            let logits = output.logits.slice(null, -1, null);
            logits_processor(beam.output_token_ids, logits);
            let sampledTokens = sampler(logits);
            for (let [newTokenId, logProb] of sampledTokens) {
              let newBeam = __spreadValues({}, beam);
              this.updateBeam(newBeam, newTokenId);
              newBeam.score += logProb;
              if (eos_token_ids && eos_token_ids.includes(newTokenId)) {
                newBeam.done = true;
              }
              newest_beams.push(newBeam);
            }
          }
          ++numOutputTokens;
          newest_beams = this.groupBeams(newest_beams).map(
            (group) => group.sort((a, b) => b.score - a.score).slice(0, generation_config.num_beams)
            // remove outside beam width
          );
          beams = newest_beams.flat();
          if (generation_config.callback_function) {
            generation_config.callback_function(beams);
          }
        }
        const groupedBeams = this.groupBeams(beams);
        const getFlattened = (key) => groupedBeams.map(
          (batch) => {
            if (generation_config.num_return_sequences > 1) {
              return batch.slice(0, generation_config.num_return_sequences).map((x) => x[key]);
            } else {
              return [batch[0][key]];
            }
          }
        ).flat();
        const sequences = getFlattened("output_token_ids");
        if (generation_config.return_dict_in_generate) {
          const decoder_attentions = getFlattened("decoder_attentions");
          const cross_attentions = getFlattened("cross_attentions");
          return {
            sequences,
            decoder_attentions,
            cross_attentions
          };
        } else {
          return sequences;
        }
      });
    }
    /**
     * Helper function to add attentions to beam
     * @param {Object} beam 
     * @param {Object} output
     * @private 
     */
    addAttentionsToBeam(beam, output) {
      if (this.config.is_encoder_decoder) {
        if (!output.cross_attentions || output.cross_attentions.length === 0) {
          throw Error(
            "`output_attentions` is true, but the model did not produce cross-attentions. This is most likely because the model was not exported with `output_attentions=True`."
          );
        }
        if (!beam.cross_attentions) {
          beam.cross_attentions = [];
        }
        beam.cross_attentions.push(output.cross_attentions);
      }
      if (!output.decoder_attentions || output.decoder_attentions.length === 0) {
        throw Error(
          "`output_attentions` is true, but the model did not produce decoder-attentions. This is most likely because the model was not exported with `output_attentions=True`."
        );
      }
      if (!beam.decoder_attentions) {
        beam.decoder_attentions = [];
      }
      beam.decoder_attentions.push(output.decoder_attentions);
    }
    /**
     * Groups an array of beam objects by their ids.
     *
     * @param {Array} beams The array of beam objects to group.
     * @returns {Array} An array of arrays, where each inner array contains beam objects with the same id.
     */
    groupBeams(beams) {
      const groups = /* @__PURE__ */ Object.create(null);
      for (const obj of beams) {
        if (groups[obj.id] === void 0) {
          groups[obj.id] = [obj];
        } else {
          groups[obj.id].push(obj);
        }
      }
      return Object.values(groups);
    }
    /**
     * Returns an object containing past key values from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @param {Object} pastKeyValues The previous past key values.
     * @returns {Object} An object containing past key values.
     */
    getPastKeyValues(decoderResults, pastKeyValues) {
      const pkvs = /* @__PURE__ */ Object.create(null);
      for (const name2 in decoderResults) {
        if (name2.startsWith("present")) {
          let newName = name2.replace("present", "past_key_values");
          if (pastKeyValues && name2.includes("encoder")) {
            pkvs[newName] = pastKeyValues[newName];
          } else {
            pkvs[newName] = decoderResults[name2];
          }
        }
      }
      return pkvs;
    }
    /**
     * Returns an object containing attentions from the given decoder results object.
     *
     * @param {Object} decoderResults The decoder results object.
     * @returns {Object} An object containing attentions.
     */
    getAttentions(decoderResults) {
      const attns = /* @__PURE__ */ Object.create(null);
      for (const attnName of ["cross_attentions", "decoder_attentions"]) {
        const result2 = [];
        for (const name2 in decoderResults) {
          if (name2.startsWith(attnName)) {
            const index = name2.split(".").pop();
            result2[index] = decoderResults[name2];
          }
        }
        attns[attnName] = result2;
      }
      return attns;
    }
    /**
     * Adds past key values to the decoder feeds object. If pastKeyValues is null, creates new tensors for past key values.
     *
     * @param {Object} decoderFeeds The decoder feeds object to add past key values to.
     * @param {Object} pastKeyValues An object containing past key values.
     */
    addPastKeyValues(decoderFeeds, pastKeyValues) {
      var _a2;
      if (pastKeyValues) {
        Object.assign(decoderFeeds, pastKeyValues);
      } else {
        const batch_size = 1;
        if (this.config.is_encoder_decoder && ((_a2 = this.add_encoder_pkv) != null ? _a2 : true)) {
          let encoder_dims = [batch_size, this.num_encoder_heads, 0, this.encoder_dim_kv];
          let decoder_dims = [batch_size, this.num_decoder_heads, 0, this.decoder_dim_kv];
          for (let i = 0; i < this.num_decoder_layers; ++i) {
            decoderFeeds[`past_key_values.${i}.encoder.key`] = new Tensor("float32", [], encoder_dims);
            decoderFeeds[`past_key_values.${i}.encoder.value`] = new Tensor("float32", [], encoder_dims);
            decoderFeeds[`past_key_values.${i}.decoder.key`] = new Tensor("float32", [], decoder_dims);
            decoderFeeds[`past_key_values.${i}.decoder.value`] = new Tensor("float32", [], decoder_dims);
          }
        } else if (this.config.model_type === "falcon") {
          let dims = [batch_size * this.num_heads, 0, this.dim_kv];
          for (let i = 0; i < this.num_layers; ++i) {
            decoderFeeds[`past_key_values.${i}.key`] = new Tensor("float32", [], dims);
            decoderFeeds[`past_key_values.${i}.value`] = new Tensor("float32", [], dims);
          }
        } else if (this.config.multi_query) {
          let dims = [batch_size * this.num_heads, 0, 2 * this.dim_kv];
          for (let i = 0; i < this.num_layers; ++i) {
            decoderFeeds[`past_key_values.${i}.key_value`] = new Tensor("float32", [], dims);
          }
        } else if (this.config.model_type === "bloom") {
          let keyDims = [batch_size * this.num_heads, this.dim_kv, 0];
          let valueDims = [batch_size * this.num_heads, 0, this.dim_kv];
          for (let i = 0; i < this.num_layers; ++i) {
            decoderFeeds[`past_key_values.${i}.key`] = new Tensor("float32", [], keyDims);
            decoderFeeds[`past_key_values.${i}.value`] = new Tensor("float32", [], valueDims);
          }
        } else {
          let dims = [batch_size, this.num_heads, 0, this.dim_kv];
          for (let i = 0; i < this.num_layers; ++i) {
            decoderFeeds[`past_key_values.${i}.key`] = new Tensor("float32", [], dims);
            decoderFeeds[`past_key_values.${i}.value`] = new Tensor("float32", [], dims);
          }
        }
      }
    }
    /**
     * Initializes and returns the beam for text generation task
     * @param {Tensor} inputTokenIds The input token ids.
     * @param {Object} generation_config The generation config.
     * @param {number} numOutputTokens The number of tokens to be generated.
     * @param {Tensor} inputs_attention_mask Optional input attention mask.
     * @returns {any} A Beam object representing the initialized beam.
     * @private
     */
    getStartBeams(inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask) {
      return this._getStartBeams(this, inputTokenIds, generation_config, numOutputTokens, inputs_attention_mask);
    }
    /**
     * Runs a single step of the beam search generation algorithm.
     * @param {any} beam The current beam being generated.
     * @returns {Promise<any>} The updated beam after a single generation step.
     * @private
     */
    runBeam(beam) {
      return __async(this, null, function* () {
        return yield this._runBeam(this, beam);
      });
    }
    /**
     * Update a beam with a new token ID.
     * @param {Object} beam The beam to update.
     * @param {number} newTokenId The new token ID to add to the beam's output.
     * @private
     */
    updateBeam(beam, newTokenId) {
      return this._updateBeam(beam, newTokenId);
    }
  }
  class ModelOutput {
  }
  class BertPreTrainedModel extends PreTrainedModel {
  }
  class BertModel extends BertPreTrainedModel {
  }
  class BertForMaskedLM extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(BertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class BertForSequenceClassification extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(BertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class BertForTokenClassification extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(BertForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class BertForQuestionAnswering extends BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(BertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class NomicBertPreTrainedModel extends PreTrainedModel {
  }
  class NomicBertModel extends NomicBertPreTrainedModel {
  }
  class RoFormerPreTrainedModel extends PreTrainedModel {
  }
  class RoFormerModel extends RoFormerPreTrainedModel {
  }
  class RoFormerForMaskedLM extends RoFormerPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(RoFormerForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RoFormerForSequenceClassification extends RoFormerPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(RoFormerForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RoFormerForTokenClassification extends RoFormerPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(RoFormerForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RoFormerForQuestionAnswering extends RoFormerPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(RoFormerForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ConvBertPreTrainedModel extends PreTrainedModel {
  }
  class ConvBertModel extends ConvBertPreTrainedModel {
  }
  class ConvBertForMaskedLM extends ConvBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(ConvBertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ConvBertForSequenceClassification extends ConvBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ConvBertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ConvBertForTokenClassification extends ConvBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(ConvBertForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ConvBertForQuestionAnswering extends ConvBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(ConvBertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ElectraPreTrainedModel extends PreTrainedModel {
  }
  class ElectraModel extends ElectraPreTrainedModel {
  }
  class ElectraForMaskedLM extends ElectraPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(ElectraForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ElectraForSequenceClassification extends ElectraPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ElectraForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ElectraForTokenClassification extends ElectraPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(ElectraForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ElectraForQuestionAnswering extends ElectraPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(ElectraForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class CamembertPreTrainedModel extends PreTrainedModel {
  }
  class CamembertModel extends CamembertPreTrainedModel {
  }
  class CamembertForMaskedLM extends CamembertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(CamembertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class CamembertForSequenceClassification extends CamembertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(CamembertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class CamembertForTokenClassification extends CamembertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(CamembertForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class CamembertForQuestionAnswering extends CamembertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(CamembertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaPreTrainedModel extends PreTrainedModel {
  }
  class DebertaModel extends DebertaPreTrainedModel {
  }
  class DebertaForMaskedLM extends DebertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(DebertaForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaForSequenceClassification extends DebertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(DebertaForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaForTokenClassification extends DebertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(DebertaForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaForQuestionAnswering extends DebertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(DebertaForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaV2PreTrainedModel extends PreTrainedModel {
  }
  class DebertaV2Model extends DebertaV2PreTrainedModel {
  }
  class DebertaV2ForMaskedLM extends DebertaV2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(DebertaV2ForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaV2ForSequenceClassification extends DebertaV2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(DebertaV2ForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaV2ForTokenClassification extends DebertaV2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(DebertaV2ForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DebertaV2ForQuestionAnswering extends DebertaV2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(DebertaV2ForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DistilBertPreTrainedModel extends PreTrainedModel {
  }
  class DistilBertModel extends DistilBertPreTrainedModel {
  }
  class DistilBertForSequenceClassification extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(DistilBertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DistilBertForTokenClassification extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(DistilBertForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DistilBertForQuestionAnswering extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(DistilBertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DistilBertForMaskedLM extends DistilBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(DistilBertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class EsmPreTrainedModel extends PreTrainedModel {
  }
  class EsmModel extends EsmPreTrainedModel {
  }
  class EsmForMaskedLM extends EsmPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(EsmForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class EsmForSequenceClassification extends EsmPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(EsmForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class EsmForTokenClassification extends EsmPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(EsmForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MobileBertPreTrainedModel extends PreTrainedModel {
  }
  class MobileBertModel extends MobileBertPreTrainedModel {
  }
  class MobileBertForMaskedLM extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(MobileBertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MobileBertForSequenceClassification extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(MobileBertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MobileBertForQuestionAnswering extends MobileBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(MobileBertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MPNetPreTrainedModel extends PreTrainedModel {
  }
  class MPNetModel extends MPNetPreTrainedModel {
  }
  class MPNetForMaskedLM extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} An object containing the model's output logits for masked language modeling.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(MPNetForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MPNetForSequenceClassification extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(MPNetForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MPNetForTokenClassification extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(MPNetForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MPNetForQuestionAnswering extends MPNetPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} An object containing the model's output logits for question answering.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(MPNetForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SqueezeBertPreTrainedModel extends PreTrainedModel {
  }
  class SqueezeBertModel extends SqueezeBertPreTrainedModel {
  }
  class SqueezeBertForMaskedLM extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(SqueezeBertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SqueezeBertForSequenceClassification extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(SqueezeBertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SqueezeBertForQuestionAnswering extends SqueezeBertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(SqueezeBertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class AlbertPreTrainedModel extends PreTrainedModel {
  }
  class AlbertModel extends AlbertPreTrainedModel {
  }
  class AlbertForSequenceClassification extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(AlbertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class AlbertForQuestionAnswering extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(AlbertForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class AlbertForMaskedLM extends AlbertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(AlbertForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class T5PreTrainedModel extends PreTrainedModel {
  }
  class T5Model extends T5PreTrainedModel {
  }
  class T5ForConditionalGeneration extends T5PreTrainedModel {
    /**
     * Creates a new instance of the `T5ForConditionalGeneration` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     * @param {any} decoder_merged_session session for the decoder.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.num_decoder_layers;
      this.num_decoder_heads = this.config.num_heads;
      this.decoder_dim_kv = this.config.d_kv;
      this.num_encoder_layers = this.config.num_layers;
      this.num_encoder_heads = this.config.num_heads;
      this.encoder_dim_kv = this.config.d_kv;
    }
  }
  class LongT5PreTrainedModel extends PreTrainedModel {
  }
  class LongT5Model extends LongT5PreTrainedModel {
  }
  class LongT5ForConditionalGeneration extends LongT5PreTrainedModel {
    /**
     * Creates a new instance of the `LongT5ForConditionalGeneration` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     * @param {any} decoder_merged_session session for the decoder.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.num_decoder_layers;
      this.num_decoder_heads = this.config.num_heads;
      this.decoder_dim_kv = this.config.d_kv;
      this.num_encoder_layers = this.config.num_layers;
      this.num_encoder_heads = this.config.num_heads;
      this.encoder_dim_kv = this.config.d_kv;
    }
  }
  class MT5PreTrainedModel extends PreTrainedModel {
  }
  class MT5Model extends MT5PreTrainedModel {
  }
  class MT5ForConditionalGeneration extends MT5PreTrainedModel {
    /**
     * Creates a new instance of the `MT5ForConditionalGeneration` class.
     * @param {any} config The model configuration.
     * @param {any} session The ONNX session containing the encoder weights.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.num_decoder_layers;
      this.num_decoder_heads = this.config.num_heads;
      this.decoder_dim_kv = this.config.d_kv;
      this.num_encoder_layers = this.config.num_layers;
      this.num_encoder_heads = this.config.num_heads;
      this.encoder_dim_kv = this.config.d_kv;
    }
  }
  class BartPretrainedModel extends PreTrainedModel {
  }
  class BartModel extends BartPretrainedModel {
  }
  class BartForConditionalGeneration extends BartPretrainedModel {
    /**
     * Creates a new instance of the `BartForConditionalGeneration` class.
     * @param {Object} config The configuration object for the Bart model.
     * @param {Object} session The ONNX session used to execute the model.
     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
     * @param {Object} generation_config The generation configuration object.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class BartForSequenceClassification extends BartPretrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(BartForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MBartPreTrainedModel extends PreTrainedModel {
  }
  class MBartModel extends MBartPreTrainedModel {
  }
  class MBartForConditionalGeneration extends MBartPreTrainedModel {
    /**
     * Creates a new instance of the `MBartForConditionalGeneration` class.
     * @param {Object} config The configuration object for the Bart model.
     * @param {Object} session The ONNX session used to execute the model.
     * @param {Object} decoder_merged_session The ONNX session used to execute the decoder.
     * @param {Object} generation_config The generation configuration object.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class MBartForSequenceClassification extends MBartPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(MBartForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MBartForCausalLM extends MBartPreTrainedModel {
    /**
     * Creates a new instance of the `MBartForCausalLM` class.
     * @param {Object} config Configuration object for the model.
     * @param {Object} decoder_merged_session ONNX Session object for the decoder.
     * @param {Object} generation_config Configuration object for the generation process.
     */
    constructor(config, decoder_merged_session, generation_config) {
      super(config, decoder_merged_session);
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class BlenderbotPreTrainedModel extends PreTrainedModel {
  }
  class BlenderbotModel extends BlenderbotPreTrainedModel {
  }
  class BlenderbotForConditionalGeneration extends BlenderbotPreTrainedModel {
    /**
     * Creates a new instance of the `BlenderbotForConditionalGeneration` class.
     * @param {any} config The model configuration.
     * @param {any} session The ONNX session containing the encoder weights.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class BlenderbotSmallPreTrainedModel extends PreTrainedModel {
  }
  class BlenderbotSmallModel extends BlenderbotSmallPreTrainedModel {
  }
  class BlenderbotSmallForConditionalGeneration extends BlenderbotSmallPreTrainedModel {
    /**
     * Creates a new instance of the `BlenderbotForConditionalGeneration` class.
     * @param {any} config The model configuration.
     * @param {any} session The ONNX session containing the encoder weights.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class RobertaPreTrainedModel extends PreTrainedModel {
  }
  class RobertaModel extends RobertaPreTrainedModel {
  }
  class RobertaForMaskedLM extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(RobertaForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RobertaForSequenceClassification extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(RobertaForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RobertaForTokenClassification extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(RobertaForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class RobertaForQuestionAnswering extends RobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(RobertaForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMPreTrainedModel extends PreTrainedModel {
  }
  class XLMModel extends XLMPreTrainedModel {
  }
  class XLMWithLMHeadModel extends XLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(XLMWithLMHeadModel.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMForSequenceClassification extends XLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(XLMForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMForTokenClassification extends XLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(XLMForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMForQuestionAnswering extends XLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(XLMForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMRobertaPreTrainedModel extends PreTrainedModel {
  }
  class XLMRobertaModel extends XLMRobertaPreTrainedModel {
  }
  class XLMRobertaForMaskedLM extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<MaskedLMOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new MaskedLMOutput(yield __superGet(XLMRobertaForMaskedLM.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMRobertaForSequenceClassification extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(XLMRobertaForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMRobertaForTokenClassification extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for token classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(XLMRobertaForTokenClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class XLMRobertaForQuestionAnswering extends XLMRobertaPreTrainedModel {
    /**
     * Calls the model on new inputs.
     *
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<QuestionAnsweringModelOutput>} returned object
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new QuestionAnsweringModelOutput(yield __superGet(XLMRobertaForQuestionAnswering.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ASTPreTrainedModel extends PreTrainedModel {
  }
  class ASTModel extends ASTPreTrainedModel {
  }
  class ASTForAudioClassification extends ASTPreTrainedModel {
  }
  class WhisperPreTrainedModel extends PreTrainedModel {
  }
  class WhisperModel extends WhisperPreTrainedModel {
  }
  class WhisperForConditionalGeneration extends WhisperPreTrainedModel {
    /**
     * Creates a new instance of the `WhisperForConditionalGeneration` class.
     * @param {Object} config Configuration object for the model.
     * @param {Object} session ONNX Session object for the model.
     * @param {Object} decoder_merged_session ONNX Session object for the decoder.
     * @param {Object} generation_config Configuration object for the generation process.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      __publicField2(this, "requires_attention_mask", false);
      __publicField2(this, "main_input_name", "input_features");
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
    /**
     * @typedef {Object} WhisperGenerationConfig
     * @extends GenerationConfig
     * @property {boolean} [return_timestamps=null] Whether to return the timestamps with the text. This enables the `WhisperTimestampsLogitsProcessor`.
     * @property {boolean} [return_token_timestamps=null] Whether to return token-level timestamps
     * with the text. This can be used with or without the `return_timestamps` option. To get word-level
     * timestamps, use the tokenizer to group the tokens into words.
     * @property {number} [num_frames=null]  The number of audio frames available in this chunk. This is only used generating word-level timestamps.
     */
    /**
     * Generates outputs based on input and generation configuration.
     * @param {Object} inputs Input data for the model.
     * @param {WhisperGenerationConfig} generation_config Configuration object for the generation process.
     * @param {Object} logits_processor Optional logits processor object.
     * @returns {Promise<Object>} Promise object represents the generated outputs.
     */
    generate(inputs, generation_config = null, logits_processor = null) {
      return __async(this, null, function* () {
        var _a2;
        generation_config = this._get_generation_config(generation_config);
        (_a2 = generation_config.return_timestamps) != null ? _a2 : generation_config.return_timestamps = false;
        if (generation_config.return_timestamps) {
          logits_processor = [new WhisperTimeStampLogitsProcessor(generation_config)];
        }
        if (generation_config.return_token_timestamps) {
          generation_config.output_attentions = true;
          generation_config.return_dict_in_generate = true;
          if (generation_config.task === "translate") {
            console.warn("Token-level timestamps may not be reliable for task 'translate'.");
          }
          if (!generation_config.alignment_heads) {
            throw new Error(
              "Model generation config has no `alignment_heads`, token-level timestamps not available. See https://gist.github.com/hollance/42e32852f24243b748ae6bc1f985b13a on how to add this property to the generation config."
            );
          }
        }
        const outputs = yield __superGet(WhisperForConditionalGeneration.prototype, this, "generate").call(this, inputs, generation_config, logits_processor);
        if (generation_config.return_token_timestamps && generation_config.alignment_heads) {
          outputs["token_timestamps"] = this._extract_token_timestamps(
            outputs,
            generation_config.alignment_heads,
            generation_config.num_frames
          );
        }
        return outputs;
      });
    }
    /**
     * Calculates token-level timestamps using the encoder-decoder cross-attentions and
     * dynamic time-warping (DTW) to map each output token to a position in the input audio.
     * @param {Object} generate_outputs Outputs generated by the model
     * @param {Tensor[][][]} generate_outputs.cross_attentions The cross attentions output by the model
     * @param {Tensor[][][]} generate_outputs.decoder_attentions The decoder attentions output by the model
     * @param {number[][]} generate_outputs.sequences The sequences output by the model
     * @param {number[][]} alignment_heads Alignment heads of the model
     * @param {number} [num_frames=null] Number of frames in the input audio.
     * @param {number} [time_precision=0.02] Precision of the timestamps in seconds
     * @returns {Tensor} tensor containing the timestamps in seconds for each predicted token
     */
    _extract_token_timestamps(generate_outputs, alignment_heads, num_frames = null, time_precision = 0.02) {
      if (!generate_outputs.cross_attentions) {
        throw new Error(
          "Model outputs must contain cross attentions to extract timestamps. This is most likely because the model was not exported with `output_attentions=True`."
        );
      }
      let median_filter_width = this.config.median_filter_width;
      if (median_filter_width === void 0) {
        console.warn("Model config has no `median_filter_width`, using default value of 7.");
        median_filter_width = 7;
      }
      const batchedMatrices = generate_outputs.cross_attentions.map((batch) => {
        let cross_attentions = Array.from(
          { length: this.config.decoder_layers },
          (_, i) => cat(batch.map((x) => x[i]), 2)
        );
        let weights = stack(alignment_heads.map(([l, h]) => {
          return num_frames ? cross_attentions[l].slice(null, h, null, [0, num_frames]) : cross_attentions[l].slice(null, h);
        }));
        weights = weights.transpose(1, 0, 2, 3);
        let [std, calculatedMean] = std_mean(weights, -2, 0, true);
        let smoothedWeights = weights.clone();
        for (let a = 0; a < smoothedWeights.dims[0]; ++a) {
          let aTensor = smoothedWeights[a];
          for (let b = 0; b < aTensor.dims[0]; ++b) {
            let bTensor = aTensor[b];
            const stdTensor = std[a][b][0];
            const meanTensor = calculatedMean[a][b][0];
            for (let c = 0; c < bTensor.dims[0]; ++c) {
              let cTensor = bTensor[c];
              for (let d = 0; d < cTensor.data.length; ++d) {
                cTensor.data[d] = (cTensor.data[d] - meanTensor.data[d]) / stdTensor.data[d];
              }
              cTensor.data.set(medianFilter(cTensor.data, median_filter_width));
            }
          }
        }
        const matrix = mean(smoothedWeights, 1);
        return matrix;
      });
      const timestampsShape = [generate_outputs.sequences.length, generate_outputs.sequences[0].length];
      const timestamps = new Tensor(
        "float32",
        new Float32Array(timestampsShape[0] * timestampsShape[1]),
        timestampsShape
      );
      for (let batch_idx = 0; batch_idx < timestampsShape[0]; ++batch_idx) {
        const matrix = batchedMatrices[batch_idx].neg().squeeze_(0);
        let [text_indices, time_indices] = dynamicTimeWarping(matrix);
        let diffs = Array.from({ length: text_indices.length - 1 }, (v, i) => text_indices[i + 1] - text_indices[i]);
        let jumps = mergeArrays([1], diffs).map((x) => !!x);
        let jump_times = [];
        for (let i = 0; i < jumps.length; ++i) {
          if (jumps[i]) {
            jump_times.push(time_indices[i] * time_precision);
          }
        }
        timestamps[batch_idx].data.set(jump_times, 1);
      }
      return timestamps;
    }
  }
  class VisionEncoderDecoderModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `VisionEncoderDecoderModel` class.
     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
     * @param {Object} session The ONNX session containing the encoder model.
     * @param {any} decoder_merged_session The ONNX session containing the merged decoder model.
     * @param {Object} generation_config Configuration object for the generation process.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      var _a2;
      super(config, session);
      __publicField2(this, "main_input_name", "pixel_values");
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      const encoderConfig = this.config.encoder;
      const decoderConfig = this.config.decoder;
      const encoderModelType = encoderConfig.model_type;
      const encoderModel = (_a2 = MODEL_MAPPING_NAMES_ENCODER_ONLY.get(encoderModelType)) != null ? _a2 : MODEL_MAPPING_NAMES_ENCODER_DECODER.get(encoderModelType);
      if (!encoderModel) {
        console.warn(`Model type for encoder '${encoderModelType}' not found, assuming encoder-only architecture. Please report this at https://github.com/xenova/transformers.js/issues/new/choose.`);
      }
      const decoderModel = MODEL_WITH_LM_HEAD_MAPPING_NAMES.get(decoderConfig.model_type);
      if (!decoderModel) {
        throw new Error(`Unable to construct \`VisionEncoderDecoder\` due to unsupported decoder: "${this.config.decoder.model_type}"`);
      }
      const decoderModelClass = decoderModel[1];
      const decoder = new decoderModelClass(decoderConfig, decoder_merged_session, generation_config);
      this.add_encoder_pkv = "num_decoder_layers" in decoder;
      if (this.add_encoder_pkv) {
        this.num_decoder_layers = decoder.num_decoder_layers;
        this.num_decoder_heads = decoder.num_decoder_heads;
        this.decoder_dim_kv = decoder.decoder_dim_kv;
        this.num_encoder_layers = decoder.num_encoder_layers;
        this.num_encoder_heads = decoder.num_encoder_heads;
        this.encoder_dim_kv = decoder.encoder_dim_kv;
      } else {
        this.num_layers = decoder.num_layers;
        this.num_heads = decoder.num_heads;
        this.dim_kv = decoder.dim_kv;
      }
    }
  }
  class CLIPPreTrainedModel extends PreTrainedModel {
  }
  class CLIPModel extends CLIPPreTrainedModel {
  }
  class CLIPTextModelWithProjection extends CLIPPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "text_model";
        return __superGet(CLIPTextModelWithProjection, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class CLIPVisionModelWithProjection extends CLIPPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "vision_model";
        return __superGet(CLIPVisionModelWithProjection, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class SiglipPreTrainedModel extends PreTrainedModel {
  }
  class SiglipModel extends SiglipPreTrainedModel {
  }
  class SiglipTextModel extends SiglipPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "text_model";
        return __superGet(SiglipTextModel, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class SiglipVisionModel extends CLIPPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "vision_model";
        return __superGet(SiglipVisionModel, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class ChineseCLIPPreTrainedModel extends PreTrainedModel {
  }
  class ChineseCLIPModel extends ChineseCLIPPreTrainedModel {
  }
  class CLIPSegPreTrainedModel extends PreTrainedModel {
  }
  class CLIPSegModel extends CLIPSegPreTrainedModel {
  }
  class CLIPSegForImageSegmentation extends CLIPSegPreTrainedModel {
  }
  class GPT2PreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPT2PreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_head;
      this.num_layers = this.config.n_layer;
      this.dim_kv = this.config.n_embd / this.num_heads;
    }
  }
  class GPT2Model extends GPT2PreTrainedModel {
  }
  class GPT2LMHeadModel extends GPT2PreTrainedModel {
  }
  class GPTNeoPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTNeoPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_heads;
      this.num_layers = this.config.num_layers;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class GPTNeoModel extends GPTNeoPreTrainedModel {
  }
  class GPTNeoForCausalLM extends GPTNeoPreTrainedModel {
  }
  class GPTNeoXPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTNeoXPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class GPTNeoXModel extends GPTNeoXPreTrainedModel {
  }
  class GPTNeoXForCausalLM extends GPTNeoXPreTrainedModel {
  }
  class GPTJPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTJPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_head;
      this.num_layers = this.config.n_layer;
      this.dim_kv = this.config.n_embd / this.num_heads;
    }
  }
  class GPTJModel extends GPTJPreTrainedModel {
  }
  class GPTJForCausalLM extends GPTJPreTrainedModel {
  }
  class GPTBigCodePreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `GPTBigCodePreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_head;
      this.num_layers = this.config.n_layer;
      this.dim_kv = this.config.n_embd / this.num_heads;
    }
  }
  class GPTBigCodeModel extends GPTBigCodePreTrainedModel {
  }
  class GPTBigCodeForCausalLM extends GPTBigCodePreTrainedModel {
  }
  class CodeGenPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `CodeGenPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_head;
      this.num_layers = this.config.n_layer;
      this.dim_kv = this.config.n_embd / this.num_heads;
    }
  }
  class CodeGenModel extends CodeGenPreTrainedModel {
  }
  class CodeGenForCausalLM extends CodeGenPreTrainedModel {
  }
  class LlamaPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `LlamaPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      var _a2;
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = (_a2 = this.config.num_key_value_heads) != null ? _a2 : this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
    }
  }
  class LlamaModel extends LlamaPreTrainedModel {
  }
  class LlamaForCausalLM extends LlamaPreTrainedModel {
  }
  class Qwen2PreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `Qwen2PreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      var _a2;
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = (_a2 = this.config.num_key_value_heads) != null ? _a2 : this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
    }
  }
  class Qwen2Model extends Qwen2PreTrainedModel {
  }
  class Qwen2ForCausalLM extends Qwen2PreTrainedModel {
  }
  class PhiPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `PhiPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class PhiModel extends PhiPreTrainedModel {
  }
  class PhiForCausalLM extends PhiPreTrainedModel {
  }
  class BloomPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `BloomPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_head;
      this.num_layers = this.config.n_layer;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class BloomModel extends BloomPreTrainedModel {
  }
  class BloomForCausalLM extends BloomPreTrainedModel {
  }
  class MptPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `MptPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.n_heads;
      this.num_layers = this.config.n_layers;
      this.dim_kv = this.config.d_model / this.num_heads;
    }
  }
  class MptModel extends MptPreTrainedModel {
  }
  class MptForCausalLM extends MptPreTrainedModel {
  }
  class OPTPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `OPTPreTrainedModel` class.
     * @param {Object} config The model configuration object.
     * @param {Object} session The ONNX session object.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class OPTModel extends OPTPreTrainedModel {
  }
  class OPTForCausalLM extends OPTPreTrainedModel {
  }
  class ViTPreTrainedModel extends PreTrainedModel {
  }
  class ViTModel extends ViTPreTrainedModel {
  }
  class ViTForImageClassification extends ViTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ViTForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class FastViTPreTrainedModel extends PreTrainedModel {
  }
  class FastViTModel extends FastViTPreTrainedModel {
  }
  class FastViTForImageClassification extends FastViTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(FastViTForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class VitMattePreTrainedModel extends PreTrainedModel {
  }
  class VitMatteForImageMatting extends VitMattePreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new ImageMattingOutput(yield __superGet(VitMatteForImageMatting.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MobileViTPreTrainedModel extends PreTrainedModel {
  }
  class MobileViTModel extends MobileViTPreTrainedModel {
  }
  class MobileViTForImageClassification extends MobileViTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(MobileViTForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class MobileViTV2PreTrainedModel extends PreTrainedModel {
  }
  class MobileViTV2Model extends MobileViTV2PreTrainedModel {
  }
  class MobileViTV2ForImageClassification extends MobileViTV2PreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(MobileViTV2ForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class OwlViTPreTrainedModel extends PreTrainedModel {
  }
  class OwlViTModel extends OwlViTPreTrainedModel {
  }
  class OwlViTForObjectDetection extends OwlViTPreTrainedModel {
  }
  class Owlv2PreTrainedModel extends PreTrainedModel {
  }
  class Owlv2Model extends Owlv2PreTrainedModel {
  }
  class Owlv2ForObjectDetection extends Owlv2PreTrainedModel {
  }
  class BeitPreTrainedModel extends PreTrainedModel {
  }
  class BeitModel extends BeitPreTrainedModel {
  }
  class BeitForImageClassification extends BeitPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(BeitForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DetrPreTrainedModel extends PreTrainedModel {
  }
  class DetrModel extends DetrPreTrainedModel {
  }
  class DetrForObjectDetection extends DetrPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new DetrObjectDetectionOutput(yield __superGet(DetrForObjectDetection.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DetrForSegmentation extends DetrPreTrainedModel {
    /**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Model inputs
     * @returns {Promise<DetrSegmentationOutput>} Object containing segmentation outputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new DetrSegmentationOutput(yield __superGet(DetrForSegmentation.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class DetrObjectDetectionOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
     */
    constructor({ logits, pred_boxes }) {
      super();
      this.logits = logits;
      this.pred_boxes = pred_boxes;
    }
  }
  class DetrSegmentationOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.pred_boxes Predicted boxes.
     * @param {Tensor} output.pred_masks Predicted masks.
     */
    constructor({ logits, pred_boxes, pred_masks }) {
      super();
      this.logits = logits;
      this.pred_boxes = pred_boxes;
      this.pred_masks = pred_masks;
    }
  }
  class TableTransformerPreTrainedModel extends PreTrainedModel {
  }
  class TableTransformerModel extends TableTransformerPreTrainedModel {
  }
  class TableTransformerForObjectDetection extends TableTransformerPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TableTransformerObjectDetectionOutput(yield __superGet(TableTransformerForObjectDetection.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class TableTransformerObjectDetectionOutput extends DetrObjectDetectionOutput {
  }
  class DeiTPreTrainedModel extends PreTrainedModel {
  }
  class DeiTModel extends DeiTPreTrainedModel {
  }
  class DeiTForImageClassification extends DeiTPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(DeiTForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ResNetPreTrainedModel extends PreTrainedModel {
  }
  class ResNetModel extends ResNetPreTrainedModel {
  }
  class ResNetForImageClassification extends ResNetPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ResNetForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SwinPreTrainedModel extends PreTrainedModel {
  }
  class SwinModel extends SwinPreTrainedModel {
  }
  class SwinForImageClassification extends SwinPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(SwinForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Swin2SRPreTrainedModel extends PreTrainedModel {
  }
  class Swin2SRModel extends Swin2SRPreTrainedModel {
  }
  class Swin2SRForImageSuperResolution extends Swin2SRPreTrainedModel {
  }
  class DPTPreTrainedModel extends PreTrainedModel {
  }
  class DPTModel extends DPTPreTrainedModel {
  }
  class DPTForDepthEstimation extends DPTPreTrainedModel {
  }
  class DepthAnythingPreTrainedModel extends PreTrainedModel {
  }
  class DepthAnythingForDepthEstimation extends DepthAnythingPreTrainedModel {
  }
  class GLPNPreTrainedModel extends PreTrainedModel {
  }
  class GLPNModel extends GLPNPreTrainedModel {
  }
  class GLPNForDepthEstimation extends GLPNPreTrainedModel {
  }
  class DonutSwinPreTrainedModel extends PreTrainedModel {
  }
  class DonutSwinModel extends DonutSwinPreTrainedModel {
  }
  class ConvNextPreTrainedModel extends PreTrainedModel {
  }
  class ConvNextModel extends ConvNextPreTrainedModel {
  }
  class ConvNextForImageClassification extends ConvNextPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ConvNextForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class ConvNextV2PreTrainedModel extends PreTrainedModel {
  }
  class ConvNextV2Model extends ConvNextV2PreTrainedModel {
  }
  class ConvNextV2ForImageClassification extends ConvNextV2PreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(ConvNextV2ForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Dinov2PreTrainedModel extends PreTrainedModel {
  }
  class Dinov2Model extends Dinov2PreTrainedModel {
  }
  class Dinov2ForImageClassification extends Dinov2PreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(Dinov2ForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class YolosPreTrainedModel extends PreTrainedModel {
  }
  class YolosModel extends YolosPreTrainedModel {
  }
  class YolosForObjectDetection extends YolosPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new YolosObjectDetectionOutput(yield __superGet(YolosForObjectDetection.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class YolosObjectDetectionOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification logits (including no-object) for all queries.
     * @param {Tensor} output.pred_boxes Normalized boxes coordinates for all queries, represented as (center_x, center_y, width, height).
     * These values are normalized in [0, 1], relative to the size of each individual image in the batch (disregarding possible padding).
     */
    constructor({ logits, pred_boxes }) {
      super();
      this.logits = logits;
      this.pred_boxes = pred_boxes;
    }
  }
  class SamPreTrainedModel extends PreTrainedModel {
  }
  class SamModel extends SamPreTrainedModel {
    /**
     * Creates a new instance of the `SamModel` class.
     * @param {Object} config The configuration object specifying the hyperparameters and other model settings.
     * @param {Object} vision_encoder The ONNX session containing the vision encoder model.
     * @param {any} prompt_encoder_mask_decoder The ONNX session containing the prompt encoder and mask decoder model.
     */
    constructor(config, vision_encoder, prompt_encoder_mask_decoder) {
      super(config, vision_encoder);
      this.prompt_encoder_mask_decoder = prompt_encoder_mask_decoder;
    }
    /**
     * Compute image embeddings and positional image embeddings, given the pixel values of an image.
     * @param {Object} model_inputs Object containing the model inputs.
     * @param {Tensor} model_inputs.pixel_values Pixel values obtained using a `SamProcessor`.
     * @returns {Promise<{ image_embeddings: Tensor, image_positional_embeddings: Tensor }>} The image embeddings and positional image embeddings.
     */
    get_image_embeddings(_0) {
      return __async(this, arguments, function* ({ pixel_values }) {
        return yield encoderForward(this, { pixel_values });
      });
    }
    /**
     * @typedef {Object} SamModelInputs Object containing the model inputs.
     * @property {Tensor} pixel_values Pixel values as a Tensor with shape `(batch_size, num_channels, height, width)`.
     * These can be obtained using a `SamProcessor`.
     * @property {Tensor} input_points Input 2D spatial points with shape `(batch_size, num_points, 2)`.
     * This is used by the prompt encoder to encode the prompt.
     * @property {Tensor} [input_labels] Input labels for the points, as a Tensor of shape `(batch_size, point_batch_size, num_points)`.
     * This is used by the prompt encoder to encode the prompt. There are 4 types of labels:
     *  - `1`: the point is a point that contains the object of interest
     *  - `0`: the point is a point that does not contain the object of interest
     *  - `-1`: the point corresponds to the background
     *  - `-10`: the point is a padding point, thus should be ignored by the prompt encoder
     * @property {Tensor} [image_embeddings] Image embeddings used by the mask decoder.
     * @property {Tensor} [image_positional_embeddings] Image positional embeddings used by the mask decoder.
     */
    /**
     * @param {SamModelInputs} model_inputs Object containing the model inputs.
     * @returns {Promise<Object>} The output of the model.
     */
    forward(model_inputs) {
      return __async(this, null, function* () {
        if (!model_inputs.image_embeddings || !model_inputs.image_positional_embeddings) {
          model_inputs = __spreadValues(__spreadValues({}, model_inputs), yield this.get_image_embeddings(model_inputs));
        }
        if (!model_inputs.input_labels) {
          const shape = model_inputs.input_points.dims.slice(0, -1);
          const numElements = shape.reduce((a, b) => a * b, 1);
          model_inputs.input_labels = new Tensor(
            "int64",
            new BigInt64Array(numElements).fill(/* @__PURE__ */ BigInt("1")),
            shape
          );
        }
        return yield sessionRun(this.prompt_encoder_mask_decoder, {
          input_points: model_inputs.input_points,
          input_labels: model_inputs.input_labels,
          image_embeddings: model_inputs.image_embeddings,
          image_positional_embeddings: model_inputs.image_positional_embeddings
        });
      });
    }
    /**
     * Runs the model with the provided inputs
     * @param {Object} model_inputs Model inputs
     * @returns {Promise<SamImageSegmentationOutput>} Object containing segmentation outputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SamImageSegmentationOutput(yield __superGet(SamModel.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SamImageSegmentationOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.iou_scores The output logits of the model.
     * @param {Tensor} output.pred_masks Predicted boxes.
     */
    constructor({ iou_scores, pred_masks }) {
      super();
      this.iou_scores = iou_scores;
      this.pred_masks = pred_masks;
    }
  }
  class MarianPreTrainedModel extends PreTrainedModel {
  }
  class MarianModel extends MarianPreTrainedModel {
  }
  class MarianMTModel extends MarianPreTrainedModel {
    /**
     * Creates a new instance of the `MarianMTModel` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class M2M100PreTrainedModel extends PreTrainedModel {
  }
  class M2M100Model extends M2M100PreTrainedModel {
  }
  class M2M100ForConditionalGeneration extends M2M100PreTrainedModel {
    /**
     * Creates a new instance of the `M2M100ForConditionalGeneration` class.
    * @param {Object} config The model configuration object.
    * @param {Object} session The ONNX session object.
    * @param {any} decoder_merged_session 
    * @param {any} generation_config 
    */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.d_model / this.num_encoder_heads;
    }
  }
  class Wav2Vec2PreTrainedModel extends PreTrainedModel {
  }
  class Wav2Vec2Model extends Wav2Vec2PreTrainedModel {
  }
  class Wav2Vec2ForCTC extends Wav2Vec2PreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(Wav2Vec2ForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Wav2Vec2ForSequenceClassification extends Wav2Vec2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(Wav2Vec2ForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Wav2Vec2ForAudioFrameClassification extends Wav2Vec2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(Wav2Vec2ForAudioFrameClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class UniSpeechPreTrainedModel extends PreTrainedModel {
  }
  class UniSpeechModel extends UniSpeechPreTrainedModel {
  }
  class UniSpeechForCTC extends UniSpeechPreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(UniSpeechForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class UniSpeechForSequenceClassification extends UniSpeechPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(UniSpeechForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class UniSpeechSatPreTrainedModel extends PreTrainedModel {
  }
  class UniSpeechSatModel extends UniSpeechSatPreTrainedModel {
  }
  class UniSpeechSatForCTC extends UniSpeechSatPreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(UniSpeechSatForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class UniSpeechSatForSequenceClassification extends UniSpeechSatPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(UniSpeechSatForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class UniSpeechSatForAudioFrameClassification extends UniSpeechSatPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(UniSpeechSatForAudioFrameClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Wav2Vec2BertPreTrainedModel extends PreTrainedModel {
  }
  class Wav2Vec2BertModel extends Wav2Vec2BertPreTrainedModel {
  }
  class Wav2Vec2BertForCTC extends Wav2Vec2BertPreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_features Float values of input mel-spectrogram.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(Wav2Vec2BertForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class Wav2Vec2BertForSequenceClassification extends Wav2Vec2BertPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(Wav2Vec2BertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class HubertModel extends Wav2Vec2PreTrainedModel {
  }
  class HubertForCTC extends Wav2Vec2PreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(HubertForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class HubertForSequenceClassification extends Wav2Vec2PreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(HubertForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class WavLMPreTrainedModel extends PreTrainedModel {
  }
  class WavLMModel extends WavLMPreTrainedModel {
  }
  class WavLMForCTC extends WavLMPreTrainedModel {
    /**
     * @param {Object} model_inputs
     * @param {Tensor} model_inputs.input_values Float values of input raw speech waveform.
     * @param {Tensor} model_inputs.attention_mask Mask to avoid performing convolution and attention on padding token indices. Mask values selected in [0, 1]
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new CausalLMOutput(yield __superGet(WavLMForCTC.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class WavLMForSequenceClassification extends WavLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<SequenceClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(WavLMForSequenceClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class WavLMForXVector extends WavLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<XVectorOutput>} An object containing the model's output logits and speaker embeddings.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new XVectorOutput(yield __superGet(WavLMForXVector.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class WavLMForAudioFrameClassification extends WavLMPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<TokenClassifierOutput>} An object containing the model's output logits for sequence classification.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new TokenClassifierOutput(yield __superGet(WavLMForAudioFrameClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SpeechT5PreTrainedModel extends PreTrainedModel {
  }
  class SpeechT5ForSpeechToText extends SpeechT5PreTrainedModel {
  }
  class SpeechT5ForTextToSpeech extends SpeechT5PreTrainedModel {
    /**
     * Creates a new instance of the `SpeechT5ForTextToSpeech` class.
     * @param {Object} config The model configuration.
     * @param {any} session session for the model.
     * @param {any} decoder_merged_session session for the decoder.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, decoder_merged_session, generation_config) {
      super(config, session);
      this.decoder_merged_session = decoder_merged_session;
      this.generation_config = generation_config;
      this.num_decoder_layers = this.config.decoder_layers;
      this.num_decoder_heads = this.config.decoder_attention_heads;
      this.decoder_dim_kv = this.config.hidden_size / this.num_decoder_heads;
      this.num_encoder_layers = this.config.encoder_layers;
      this.num_encoder_heads = this.config.encoder_attention_heads;
      this.encoder_dim_kv = this.config.hidden_size / this.num_encoder_heads;
    }
    /**
     * @typedef {Object} SpeechOutput
     * @property {Tensor} [spectrogram] The predicted log-mel spectrogram of shape
     * `(output_sequence_length, config.num_mel_bins)`. Returned when no `vocoder` is provided
     * @property {Tensor} [waveform] The predicted waveform of shape `(num_frames,)`. Returned when a `vocoder` is provided.
     * @property {Tensor} [cross_attentions] The outputs of the decoder's cross-attention layers of shape
     * `(config.decoder_layers, config.decoder_attention_heads, output_sequence_length, input_sequence_length)`. returned when `output_cross_attentions` is `true`.
     */
    /**
     * Converts a sequence of input tokens into a sequence of mel spectrograms, which are subsequently turned into a speech waveform using a vocoder.
     * @param {Tensor} input_values Indices of input sequence tokens in the vocabulary.
     * @param {Tensor} speaker_embeddings Tensor containing the speaker embeddings.
     * @param {Object} options Optional parameters for generating speech.
     * @param {number} [options.threshold=0.5] The generated sequence ends when the predicted stop token probability exceeds this value.
     * @param {number} [options.minlenratio=0.0] Used to calculate the minimum required length for the output sequence.
     * @param {number} [options.maxlenratio=20.0] Used to calculate the maximum allowed length for the output sequence.
     * @param {Object} [options.vocoder=null] The vocoder that converts the mel spectrogram into a speech waveform. If `null`, the output is the mel spectrogram.
     * @param {boolean} [options.output_cross_attentions=false] Whether or not to return the attentions tensors of the decoder's cross-attention layers.
     * @returns {Promise<SpeechOutput>} A promise which resolves to an object containing the spectrogram, waveform, and cross-attention tensors.
     */
    generate_speech(_0, _1) {
      return __async(this, arguments, function* (input_values, speaker_embeddings, {
        threshold = 0.5,
        minlenratio = 0,
        maxlenratio = 20,
        vocoder = null
        // output_cross_attentions = false, // TODO add
      } = {}) {
        const model_inputs = {
          input_ids: input_values
        };
        const { encoder_outputs, encoder_attention_mask } = yield encoderForward(this, model_inputs);
        const r = encoder_outputs.dims[1] / this.config.reduction_factor;
        const maxlen = Math.floor(r * maxlenratio);
        const minlen = Math.floor(r * minlenratio);
        const num_mel_bins = this.config.num_mel_bins;
        let spectrogramParts = [];
        let past_key_values = null;
        let decoder_outputs = null;
        let idx = 0;
        while (true) {
          ++idx;
          const use_cache_branch = boolTensor(!!decoder_outputs);
          let output_sequence;
          if (decoder_outputs) {
            output_sequence = decoder_outputs.output_sequence_out;
          } else {
            output_sequence = new Tensor(
              "float32",
              new Float32Array(num_mel_bins),
              [1, 1, num_mel_bins]
            );
          }
          let decoderFeeds = {
            use_cache_branch,
            output_sequence,
            encoder_attention_mask,
            speaker_embeddings,
            encoder_hidden_states: encoder_outputs
          };
          this.addPastKeyValues(decoderFeeds, past_key_values);
          decoder_outputs = yield sessionRun(this.decoder_merged_session, decoderFeeds);
          past_key_values = this.getPastKeyValues(decoder_outputs, past_key_values);
          const { prob, spectrum } = decoder_outputs;
          spectrogramParts.push(spectrum);
          if (idx >= minlen && // Finished when stop token or maximum length is reached.
          (Array.from(prob.data).filter((p) => p >= threshold).length > 0 || idx >= maxlen)) {
            break;
          }
        }
        const spectrogram = cat(spectrogramParts);
        const { waveform } = yield sessionRun(vocoder.session, { spectrogram });
        return {
          spectrogram,
          waveform
          // cross_attentions: null, // TODO add
        };
      });
    }
  }
  class SpeechT5HifiGan extends PreTrainedModel {
    constructor() {
      super(...arguments);
      __publicField2(this, "main_input_name", "spectrogram");
    }
  }
  class TrOCRPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `TrOCRPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_encoder_layers = this.num_decoder_layers = this.config.decoder_layers;
      this.num_encoder_heads = this.num_decoder_heads = this.config.decoder_attention_heads;
      this.encoder_dim_kv = this.decoder_dim_kv = this.config.d_model / this.num_decoder_heads;
    }
  }
  class TrOCRForCausalLM extends TrOCRPreTrainedModel {
  }
  class MistralPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `MistralPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_key_value_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
    }
  }
  class MistralModel extends MistralPreTrainedModel {
  }
  class MistralForCausalLM extends MistralPreTrainedModel {
  }
  class Starcoder2PreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `Starcoder2PreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_key_value_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
    }
  }
  class Starcoder2Model extends Starcoder2PreTrainedModel {
  }
  class Starcoder2ForCausalLM extends Starcoder2PreTrainedModel {
  }
  class FalconPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `FalconPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.config.num_attention_heads;
    }
  }
  class FalconModel extends FalconPreTrainedModel {
  }
  class FalconForCausalLM extends FalconPreTrainedModel {
  }
  class ClapPreTrainedModel extends PreTrainedModel {
  }
  class ClapModel extends ClapPreTrainedModel {
  }
  class ClapTextModelWithProjection extends ClapPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "text_model";
        return __superGet(ClapTextModelWithProjection, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class ClapAudioModelWithProjection extends ClapPreTrainedModel {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, options = {}) {
        var _a2;
        (_a2 = options.model_file_name) != null ? _a2 : options.model_file_name = "audio_model";
        return __superGet(ClapAudioModelWithProjection, this, "from_pretrained").call(this, pretrained_model_name_or_path, options);
      });
    }
  }
  class VitsPreTrainedModel extends PreTrainedModel {
  }
  class VitsModel extends VitsPreTrainedModel {
    /**
     * Calls the model on new inputs.
     * @param {Object} model_inputs The inputs to the model.
     * @returns {Promise<VitsModelOutput>} The outputs for the VITS model.
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new VitsModelOutput(yield __superGet(VitsModel.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class SegformerPreTrainedModel extends PreTrainedModel {
  }
  class SegformerForImageClassification extends SegformerPreTrainedModel {
  }
  class SegformerForSemanticSegmentation extends SegformerPreTrainedModel {
  }
  class StableLmPreTrainedModel extends PreTrainedModel {
    /**
     * Creates a new instance of the `StableLmPreTrainedModel` class.
     * @param {Object} config The configuration of the model.
     * @param {any} session The ONNX session containing the model weights.
     * @param {GenerationConfig} generation_config The generation configuration.
     */
    constructor(config, session, generation_config) {
      super(config, session);
      this.generation_config = generation_config;
      this.config.pad_token_id = this.config.eos_token_id;
      this.num_heads = this.config.num_attention_heads;
      this.num_layers = this.config.num_hidden_layers;
      this.dim_kv = this.config.hidden_size / this.num_heads;
    }
  }
  class StableLmForCausalLM extends StableLmPreTrainedModel {
  }
  class EfficientNetPreTrainedModel extends PreTrainedModel {
  }
  class EfficientNetModel extends EfficientNetPreTrainedModel {
  }
  class EfficientNetForImageClassification extends EfficientNetPreTrainedModel {
    /**
     * @param {any} model_inputs
     */
    _call(model_inputs) {
      return __async(this, null, function* () {
        return new SequenceClassifierOutput(yield __superGet(EfficientNetForImageClassification.prototype, this, "_call").call(this, model_inputs));
      });
    }
  }
  class PretrainedMixin {
    /** @type {PreTrainedModel.from_pretrained} */
    static from_pretrained(_0) {
      return __async(this, arguments, function* (pretrained_model_name_or_path, {
        quantized = true,
        progress_callback = null,
        config = null,
        cache_dir = null,
        local_files_only = false,
        revision = "main",
        model_file_name = null
      } = {}) {
        let options = {
          quantized,
          progress_callback,
          config,
          cache_dir,
          local_files_only,
          revision,
          model_file_name
        };
        config = yield AutoConfig.from_pretrained(pretrained_model_name_or_path, options);
        if (!options.config) {
          options.config = config;
        }
        if (!this.MODEL_CLASS_MAPPINGS) {
          throw new Error("`MODEL_CLASS_MAPPINGS` not implemented for this type of `AutoClass`: " + this.name);
        }
        for (let MODEL_CLASS_MAPPING of this.MODEL_CLASS_MAPPINGS) {
          const modelInfo = MODEL_CLASS_MAPPING.get(config.model_type);
          if (!modelInfo) {
            continue;
          }
          return yield modelInfo[1].from_pretrained(pretrained_model_name_or_path, options);
        }
        if (this.BASE_IF_FAIL) {
          console.warn(`Unknown model class "${config.model_type}", attempting to construct from base class.`);
          return yield PreTrainedModel.from_pretrained(pretrained_model_name_or_path, options);
        } else {
          throw Error(`Unsupported model type: ${config.model_type}`);
        }
      });
    }
  }
  /**
   * Mapping from model type to model class.
   * @type {Map<string, Object>[]}
   */
  __publicField2(PretrainedMixin, "MODEL_CLASS_MAPPINGS", null);
  /**
   * Whether to attempt to instantiate the base class (`PretrainedModel`) if 
   * the model type is not found in the mapping.
   */
  __publicField2(PretrainedMixin, "BASE_IF_FAIL", false);
  const MODEL_MAPPING_NAMES_ENCODER_ONLY = /* @__PURE__ */ new Map([
    ["bert", ["BertModel", BertModel]],
    ["nomic_bert", ["NomicBertModel", NomicBertModel]],
    ["roformer", ["RoFormerModel", RoFormerModel]],
    ["electra", ["ElectraModel", ElectraModel]],
    ["esm", ["EsmModel", EsmModel]],
    ["convbert", ["ConvBertModel", ConvBertModel]],
    ["camembert", ["CamembertModel", CamembertModel]],
    ["deberta", ["DebertaModel", DebertaModel]],
    ["deberta-v2", ["DebertaV2Model", DebertaV2Model]],
    ["mpnet", ["MPNetModel", MPNetModel]],
    ["albert", ["AlbertModel", AlbertModel]],
    ["distilbert", ["DistilBertModel", DistilBertModel]],
    ["roberta", ["RobertaModel", RobertaModel]],
    ["xlm", ["XLMModel", XLMModel]],
    ["xlm-roberta", ["XLMRobertaModel", XLMRobertaModel]],
    ["clap", ["ClapModel", ClapModel]],
    ["clip", ["CLIPModel", CLIPModel]],
    ["clipseg", ["CLIPSegModel", CLIPSegModel]],
    ["chinese_clip", ["ChineseCLIPModel", ChineseCLIPModel]],
    ["siglip", ["SiglipModel", SiglipModel]],
    ["mobilebert", ["MobileBertModel", MobileBertModel]],
    ["squeezebert", ["SqueezeBertModel", SqueezeBertModel]],
    ["wav2vec2", ["Wav2Vec2Model", Wav2Vec2Model]],
    ["wav2vec2-bert", ["Wav2Vec2BertModel", Wav2Vec2BertModel]],
    ["unispeech", ["UniSpeechModel", UniSpeechModel]],
    ["unispeech-sat", ["UniSpeechSatModel", UniSpeechSatModel]],
    ["hubert", ["HubertModel", HubertModel]],
    ["wavlm", ["WavLMModel", WavLMModel]],
    ["audio-spectrogram-transformer", ["ASTModel", ASTModel]],
    ["vits", ["VitsModel", VitsModel]],
    ["detr", ["DetrModel", DetrModel]],
    ["table-transformer", ["TableTransformerModel", TableTransformerModel]],
    ["vit", ["ViTModel", ViTModel]],
    ["fastvit", ["FastViTModel", FastViTModel]],
    ["mobilevit", ["MobileViTModel", MobileViTModel]],
    ["mobilevitv2", ["MobileViTV2Model", MobileViTV2Model]],
    ["owlvit", ["OwlViTModel", OwlViTModel]],
    ["owlv2", ["Owlv2Model", Owlv2Model]],
    ["beit", ["BeitModel", BeitModel]],
    ["deit", ["DeiTModel", DeiTModel]],
    ["convnext", ["ConvNextModel", ConvNextModel]],
    ["convnextv2", ["ConvNextV2Model", ConvNextV2Model]],
    ["dinov2", ["Dinov2Model", Dinov2Model]],
    ["resnet", ["ResNetModel", ResNetModel]],
    ["swin", ["SwinModel", SwinModel]],
    ["swin2sr", ["Swin2SRModel", Swin2SRModel]],
    ["donut-swin", ["DonutSwinModel", DonutSwinModel]],
    ["yolos", ["YolosModel", YolosModel]],
    ["dpt", ["DPTModel", DPTModel]],
    ["glpn", ["GLPNModel", GLPNModel]],
    ["hifigan", ["SpeechT5HifiGan", SpeechT5HifiGan]],
    ["efficientnet", ["EfficientNetModel", EfficientNetModel]]
  ]);
  const MODEL_MAPPING_NAMES_ENCODER_DECODER = /* @__PURE__ */ new Map([
    ["t5", ["T5Model", T5Model]],
    ["longt5", ["LongT5Model", LongT5Model]],
    ["mt5", ["MT5Model", MT5Model]],
    ["bart", ["BartModel", BartModel]],
    ["mbart", ["MBartModel", MBartModel]],
    ["marian", ["MarianModel", MarianModel]],
    ["whisper", ["WhisperModel", WhisperModel]],
    ["m2m_100", ["M2M100Model", M2M100Model]],
    ["blenderbot", ["BlenderbotModel", BlenderbotModel]],
    ["blenderbot-small", ["BlenderbotSmallModel", BlenderbotSmallModel]]
  ]);
  const MODEL_MAPPING_NAMES_DECODER_ONLY = /* @__PURE__ */ new Map([
    ["bloom", ["BloomModel", BloomModel]],
    ["gpt2", ["GPT2Model", GPT2Model]],
    ["gptj", ["GPTJModel", GPTJModel]],
    ["gpt_bigcode", ["GPTBigCodeModel", GPTBigCodeModel]],
    ["gpt_neo", ["GPTNeoModel", GPTNeoModel]],
    ["gpt_neox", ["GPTNeoXModel", GPTNeoXModel]],
    ["codegen", ["CodeGenModel", CodeGenModel]],
    ["llama", ["LlamaModel", LlamaModel]],
    ["qwen2", ["Qwen2Model", Qwen2Model]],
    ["phi", ["PhiModel", PhiModel]],
    ["mpt", ["MptModel", MptModel]],
    ["opt", ["OPTModel", OPTModel]],
    ["mistral", ["MistralModel", MistralModel]],
    ["starcoder2", ["Starcoder2Model", Starcoder2Model]],
    ["falcon", ["FalconModel", FalconModel]]
  ]);
  const MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["speecht5", ["SpeechT5ForSpeechToText", SpeechT5ForSpeechToText]],
    ["whisper", ["WhisperForConditionalGeneration", WhisperForConditionalGeneration]]
  ]);
  const MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["speecht5", ["SpeechT5ForTextToSpeech", SpeechT5ForTextToSpeech]]
  ]);
  const MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["vits", ["VitsModel", VitsModel]]
  ]);
  const MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["bert", ["BertForSequenceClassification", BertForSequenceClassification]],
    ["roformer", ["RoFormerForSequenceClassification", RoFormerForSequenceClassification]],
    ["electra", ["ElectraForSequenceClassification", ElectraForSequenceClassification]],
    ["esm", ["EsmForSequenceClassification", EsmForSequenceClassification]],
    ["convbert", ["ConvBertForSequenceClassification", ConvBertForSequenceClassification]],
    ["camembert", ["CamembertForSequenceClassification", CamembertForSequenceClassification]],
    ["deberta", ["DebertaForSequenceClassification", DebertaForSequenceClassification]],
    ["deberta-v2", ["DebertaV2ForSequenceClassification", DebertaV2ForSequenceClassification]],
    ["mpnet", ["MPNetForSequenceClassification", MPNetForSequenceClassification]],
    ["albert", ["AlbertForSequenceClassification", AlbertForSequenceClassification]],
    ["distilbert", ["DistilBertForSequenceClassification", DistilBertForSequenceClassification]],
    ["roberta", ["RobertaForSequenceClassification", RobertaForSequenceClassification]],
    ["xlm", ["XLMForSequenceClassification", XLMForSequenceClassification]],
    ["xlm-roberta", ["XLMRobertaForSequenceClassification", XLMRobertaForSequenceClassification]],
    ["bart", ["BartForSequenceClassification", BartForSequenceClassification]],
    ["mbart", ["MBartForSequenceClassification", MBartForSequenceClassification]],
    ["mobilebert", ["MobileBertForSequenceClassification", MobileBertForSequenceClassification]],
    ["squeezebert", ["SqueezeBertForSequenceClassification", SqueezeBertForSequenceClassification]]
  ]);
  const MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["bert", ["BertForTokenClassification", BertForTokenClassification]],
    ["roformer", ["RoFormerForTokenClassification", RoFormerForTokenClassification]],
    ["electra", ["ElectraForTokenClassification", ElectraForTokenClassification]],
    ["esm", ["EsmForTokenClassification", EsmForTokenClassification]],
    ["convbert", ["ConvBertForTokenClassification", ConvBertForTokenClassification]],
    ["camembert", ["CamembertForTokenClassification", CamembertForTokenClassification]],
    ["deberta", ["DebertaForTokenClassification", DebertaForTokenClassification]],
    ["deberta-v2", ["DebertaV2ForTokenClassification", DebertaV2ForTokenClassification]],
    ["mpnet", ["MPNetForTokenClassification", MPNetForTokenClassification]],
    ["distilbert", ["DistilBertForTokenClassification", DistilBertForTokenClassification]],
    ["roberta", ["RobertaForTokenClassification", RobertaForTokenClassification]],
    ["xlm", ["XLMForTokenClassification", XLMForTokenClassification]],
    ["xlm-roberta", ["XLMRobertaForTokenClassification", XLMRobertaForTokenClassification]]
  ]);
  const MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["t5", ["T5ForConditionalGeneration", T5ForConditionalGeneration]],
    ["longt5", ["LongT5ForConditionalGeneration", LongT5ForConditionalGeneration]],
    ["mt5", ["MT5ForConditionalGeneration", MT5ForConditionalGeneration]],
    ["bart", ["BartForConditionalGeneration", BartForConditionalGeneration]],
    ["mbart", ["MBartForConditionalGeneration", MBartForConditionalGeneration]],
    ["marian", ["MarianMTModel", MarianMTModel]],
    ["m2m_100", ["M2M100ForConditionalGeneration", M2M100ForConditionalGeneration]],
    ["blenderbot", ["BlenderbotForConditionalGeneration", BlenderbotForConditionalGeneration]],
    ["blenderbot-small", ["BlenderbotSmallForConditionalGeneration", BlenderbotSmallForConditionalGeneration]]
  ]);
  const MODEL_WITH_LM_HEAD_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["bloom", ["BloomForCausalLM", BloomForCausalLM]],
    ["gpt2", ["GPT2LMHeadModel", GPT2LMHeadModel]],
    ["gptj", ["GPTJForCausalLM", GPTJForCausalLM]],
    ["gpt_bigcode", ["GPTBigCodeForCausalLM", GPTBigCodeForCausalLM]],
    ["gpt_neo", ["GPTNeoForCausalLM", GPTNeoForCausalLM]],
    ["gpt_neox", ["GPTNeoXForCausalLM", GPTNeoXForCausalLM]],
    ["codegen", ["CodeGenForCausalLM", CodeGenForCausalLM]],
    ["llama", ["LlamaForCausalLM", LlamaForCausalLM]],
    ["qwen2", ["Qwen2ForCausalLM", Qwen2ForCausalLM]],
    ["phi", ["PhiForCausalLM", PhiForCausalLM]],
    ["mpt", ["MptForCausalLM", MptForCausalLM]],
    ["opt", ["OPTForCausalLM", OPTForCausalLM]],
    ["mbart", ["MBartForCausalLM", MBartForCausalLM]],
    ["mistral", ["MistralForCausalLM", MistralForCausalLM]],
    ["starcoder2", ["Starcoder2ForCausalLM", Starcoder2ForCausalLM]],
    ["falcon", ["FalconForCausalLM", FalconForCausalLM]],
    ["trocr", ["TrOCRForCausalLM", TrOCRForCausalLM]],
    ["stablelm", ["StableLmForCausalLM", StableLmForCausalLM]]
  ]);
  const MODEL_FOR_MASKED_LM_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["bert", ["BertForMaskedLM", BertForMaskedLM]],
    ["roformer", ["RoFormerForMaskedLM", RoFormerForMaskedLM]],
    ["electra", ["ElectraForMaskedLM", ElectraForMaskedLM]],
    ["esm", ["EsmForMaskedLM", EsmForMaskedLM]],
    ["convbert", ["ConvBertForMaskedLM", ConvBertForMaskedLM]],
    ["camembert", ["CamembertForMaskedLM", CamembertForMaskedLM]],
    ["deberta", ["DebertaForMaskedLM", DebertaForMaskedLM]],
    ["deberta-v2", ["DebertaV2ForMaskedLM", DebertaV2ForMaskedLM]],
    ["mpnet", ["MPNetForMaskedLM", MPNetForMaskedLM]],
    ["albert", ["AlbertForMaskedLM", AlbertForMaskedLM]],
    ["distilbert", ["DistilBertForMaskedLM", DistilBertForMaskedLM]],
    ["roberta", ["RobertaForMaskedLM", RobertaForMaskedLM]],
    ["xlm", ["XLMWithLMHeadModel", XLMWithLMHeadModel]],
    ["xlm-roberta", ["XLMRobertaForMaskedLM", XLMRobertaForMaskedLM]],
    ["mobilebert", ["MobileBertForMaskedLM", MobileBertForMaskedLM]],
    ["squeezebert", ["SqueezeBertForMaskedLM", SqueezeBertForMaskedLM]]
  ]);
  const MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["bert", ["BertForQuestionAnswering", BertForQuestionAnswering]],
    ["roformer", ["RoFormerForQuestionAnswering", RoFormerForQuestionAnswering]],
    ["electra", ["ElectraForQuestionAnswering", ElectraForQuestionAnswering]],
    ["convbert", ["ConvBertForQuestionAnswering", ConvBertForQuestionAnswering]],
    ["camembert", ["CamembertForQuestionAnswering", CamembertForQuestionAnswering]],
    ["deberta", ["DebertaForQuestionAnswering", DebertaForQuestionAnswering]],
    ["deberta-v2", ["DebertaV2ForQuestionAnswering", DebertaV2ForQuestionAnswering]],
    ["mpnet", ["MPNetForQuestionAnswering", MPNetForQuestionAnswering]],
    ["albert", ["AlbertForQuestionAnswering", AlbertForQuestionAnswering]],
    ["distilbert", ["DistilBertForQuestionAnswering", DistilBertForQuestionAnswering]],
    ["roberta", ["RobertaForQuestionAnswering", RobertaForQuestionAnswering]],
    ["xlm", ["XLMForQuestionAnswering", XLMForQuestionAnswering]],
    ["xlm-roberta", ["XLMRobertaForQuestionAnswering", XLMRobertaForQuestionAnswering]],
    ["mobilebert", ["MobileBertForQuestionAnswering", MobileBertForQuestionAnswering]],
    ["squeezebert", ["SqueezeBertForQuestionAnswering", SqueezeBertForQuestionAnswering]]
  ]);
  const MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["vision-encoder-decoder", ["VisionEncoderDecoderModel", VisionEncoderDecoderModel]]
  ]);
  const MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["vit", ["ViTForImageClassification", ViTForImageClassification]],
    ["fastvit", ["FastViTForImageClassification", FastViTForImageClassification]],
    ["mobilevit", ["MobileViTForImageClassification", MobileViTForImageClassification]],
    ["mobilevitv2", ["MobileViTV2ForImageClassification", MobileViTV2ForImageClassification]],
    ["beit", ["BeitForImageClassification", BeitForImageClassification]],
    ["deit", ["DeiTForImageClassification", DeiTForImageClassification]],
    ["convnext", ["ConvNextForImageClassification", ConvNextForImageClassification]],
    ["convnextv2", ["ConvNextV2ForImageClassification", ConvNextV2ForImageClassification]],
    ["dinov2", ["Dinov2ForImageClassification", Dinov2ForImageClassification]],
    ["resnet", ["ResNetForImageClassification", ResNetForImageClassification]],
    ["swin", ["SwinForImageClassification", SwinForImageClassification]],
    ["segformer", ["SegformerForImageClassification", SegformerForImageClassification]],
    ["efficientnet", ["EfficientNetForImageClassification", EfficientNetForImageClassification]]
  ]);
  const MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["detr", ["DetrForObjectDetection", DetrForObjectDetection]],
    ["table-transformer", ["TableTransformerForObjectDetection", TableTransformerForObjectDetection]],
    ["yolos", ["YolosForObjectDetection", YolosForObjectDetection]]
  ]);
  const MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["owlvit", ["OwlViTForObjectDetection", OwlViTForObjectDetection]],
    ["owlv2", ["Owlv2ForObjectDetection", Owlv2ForObjectDetection]]
  ]);
  const MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["detr", ["DetrForSegmentation", DetrForSegmentation]],
    ["clipseg", ["CLIPSegForImageSegmentation", CLIPSegForImageSegmentation]]
  ]);
  const MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["segformer", ["SegformerForSemanticSegmentation", SegformerForSemanticSegmentation]]
  ]);
  const MODEL_FOR_MASK_GENERATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["sam", ["SamModel", SamModel]]
  ]);
  const MODEL_FOR_CTC_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["wav2vec2", ["Wav2Vec2ForCTC", Wav2Vec2ForCTC]],
    ["wav2vec2-bert", ["Wav2Vec2BertForCTC", Wav2Vec2BertForCTC]],
    ["unispeech", ["UniSpeechForCTC", UniSpeechForCTC]],
    ["unispeech-sat", ["UniSpeechSatForCTC", UniSpeechSatForCTC]],
    ["wavlm", ["WavLMForCTC", WavLMForCTC]],
    ["hubert", ["HubertForCTC", HubertForCTC]]
  ]);
  const MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["wav2vec2", ["Wav2Vec2ForSequenceClassification", Wav2Vec2ForSequenceClassification]],
    ["wav2vec2-bert", ["Wav2Vec2BertForSequenceClassification", Wav2Vec2BertForSequenceClassification]],
    ["unispeech", ["UniSpeechForSequenceClassification", UniSpeechForSequenceClassification]],
    ["unispeech-sat", ["UniSpeechSatForSequenceClassification", UniSpeechSatForSequenceClassification]],
    ["wavlm", ["WavLMForSequenceClassification", WavLMForSequenceClassification]],
    ["hubert", ["HubertForSequenceClassification", HubertForSequenceClassification]],
    ["audio-spectrogram-transformer", ["ASTForAudioClassification", ASTForAudioClassification]]
  ]);
  const MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["wavlm", ["WavLMForXVector", WavLMForXVector]]
  ]);
  const MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["unispeech-sat", ["UniSpeechSatForAudioFrameClassification", UniSpeechSatForAudioFrameClassification]],
    ["wavlm", ["WavLMForAudioFrameClassification", WavLMForAudioFrameClassification]],
    ["wav2vec2", ["Wav2Vec2ForAudioFrameClassification", Wav2Vec2ForAudioFrameClassification]]
  ]);
  const MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["vitmatte", ["VitMatteForImageMatting", VitMatteForImageMatting]]
  ]);
  const MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["swin2sr", ["Swin2SRForImageSuperResolution", Swin2SRForImageSuperResolution]]
  ]);
  const MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["dpt", ["DPTForDepthEstimation", DPTForDepthEstimation]],
    ["depth_anything", ["DepthAnythingForDepthEstimation", DepthAnythingForDepthEstimation]],
    ["glpn", ["GLPNForDepthEstimation", GLPNForDepthEstimation]]
  ]);
  const MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES = /* @__PURE__ */ new Map([
    ["clip", ["CLIPVisionModelWithProjection", CLIPVisionModelWithProjection]],
    ["siglip", ["SiglipVisionModel", SiglipVisionModel]]
  ]);
  const MODEL_CLASS_TYPE_MAPPING = [
    [MODEL_MAPPING_NAMES_ENCODER_ONLY, MODEL_TYPES.EncoderOnly],
    [MODEL_MAPPING_NAMES_ENCODER_DECODER, MODEL_TYPES.EncoderDecoder],
    [MODEL_MAPPING_NAMES_DECODER_ONLY, MODEL_TYPES.DecoderOnly],
    [MODEL_FOR_SEQUENCE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_TOKEN_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_SEQ_TO_SEQ_CAUSAL_LM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
    [MODEL_FOR_SPEECH_SEQ_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
    [MODEL_WITH_LM_HEAD_MAPPING_NAMES, MODEL_TYPES.DecoderOnly],
    [MODEL_FOR_MASKED_LM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_QUESTION_ANSWERING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_VISION_2_SEQ_MAPPING_NAMES, MODEL_TYPES.Vision2Seq],
    [MODEL_FOR_IMAGE_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_IMAGE_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_SEMANTIC_SEGMENTATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_IMAGE_MATTING_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_IMAGE_TO_IMAGE_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_DEPTH_ESTIMATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_ZERO_SHOT_OBJECT_DETECTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_MASK_GENERATION_MAPPING_NAMES, MODEL_TYPES.MaskGeneration],
    [MODEL_FOR_CTC_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_AUDIO_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_TEXT_TO_SPECTROGRAM_MAPPING_NAMES, MODEL_TYPES.Seq2Seq],
    [MODEL_FOR_TEXT_TO_WAVEFORM_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_AUDIO_XVECTOR_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    [MODEL_FOR_AUDIO_FRAME_CLASSIFICATION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly],
    // Custom:
    [MODEL_FOR_IMAGE_FEATURE_EXTRACTION_MAPPING_NAMES, MODEL_TYPES.EncoderOnly]
  ];
  for (const [mappings, type] of MODEL_CLASS_TYPE_MAPPING) {
    for (const [name2, model] of mappings.values()) {
      MODEL_TYPE_MAPPING.set(name2, type);
      MODEL_CLASS_TO_NAME_MAPPING.set(model, name2);
      MODEL_NAME_TO_CLASS_MAPPING.set(name2, model);
    }
  }
  const CUSTOM_MAPPING = [
    ["CLIPTextModelWithProjection", CLIPTextModelWithProjection, MODEL_TYPES.EncoderOnly],
    ["SiglipTextModel", SiglipTextModel, MODEL_TYPES.EncoderOnly],
    ["ClapTextModelWithProjection", ClapTextModelWithProjection, MODEL_TYPES.EncoderOnly],
    ["ClapAudioModelWithProjection", ClapAudioModelWithProjection, MODEL_TYPES.EncoderOnly]
  ];
  for (const [name2, model, type] of CUSTOM_MAPPING) {
    MODEL_TYPE_MAPPING.set(name2, type);
    MODEL_CLASS_TO_NAME_MAPPING.set(model, name2);
    MODEL_NAME_TO_CLASS_MAPPING.set(name2, model);
  }
  class AutoModel extends PretrainedMixin {
  }
  /** @type {Map<string, Object>[]} */
  // @ts-ignore
  __publicField2(AutoModel, "MODEL_CLASS_MAPPINGS", MODEL_CLASS_TYPE_MAPPING.map((x) => x[0]));
  __publicField2(AutoModel, "BASE_IF_FAIL", true);
  class Seq2SeqLMOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits The output logits of the model.
     * @param {Tensor} output.past_key_values An tensor of key/value pairs that represent the previous state of the model.
     * @param {Tensor} output.encoder_outputs The output of the encoder in a sequence-to-sequence model.
     * @param {Tensor} [output.decoder_attentions] Attentions weights of the decoder, after the attention softmax, used to compute the weighted average in the self-attention heads.
     * @param {Tensor} [output.cross_attentions] Attentions weights of the decoder's cross-attention layer, after the attention softmax, used to compute the weighted average in the cross-attention heads.
     */
    constructor({ logits, past_key_values, encoder_outputs, decoder_attentions = null, cross_attentions = null }) {
      super();
      this.logits = logits;
      this.past_key_values = past_key_values;
      this.encoder_outputs = encoder_outputs;
      this.decoder_attentions = decoder_attentions;
      this.cross_attentions = cross_attentions;
    }
  }
  class SequenceClassifierOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits classification (or regression if config.num_labels==1) scores (before SoftMax).
     */
    constructor({ logits }) {
      super();
      this.logits = logits;
    }
  }
  class XVectorOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification hidden states before AMSoftmax, of shape `(batch_size, config.xvector_output_dim)`.
     * @param {Tensor} output.embeddings Utterance embeddings used for vector similarity-based retrieval, of shape `(batch_size, config.xvector_output_dim)`.
     */
    constructor({ logits, embeddings }) {
      super();
      this.logits = logits;
      this.embeddings = embeddings;
    }
  }
  class TokenClassifierOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Classification scores (before SoftMax).
     */
    constructor({ logits }) {
      super();
      this.logits = logits;
    }
  }
  class MaskedLMOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before SoftMax).
     */
    constructor({ logits }) {
      super();
      this.logits = logits;
    }
  }
  class QuestionAnsweringModelOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.start_logits Span-start scores (before SoftMax).
     * @param {Tensor} output.end_logits Span-end scores (before SoftMax).
     */
    constructor({ start_logits, end_logits }) {
      super();
      this.start_logits = start_logits;
      this.end_logits = end_logits;
    }
  }
  class CausalLMOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.logits Prediction scores of the language modeling head (scores for each vocabulary token before softmax).
     */
    constructor({ logits }) {
      super();
      this.logits = logits;
    }
  }
  class ImageMattingOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.alphas Estimated alpha values, of shape `(batch_size, num_channels, height, width)`.
     */
    constructor({ alphas }) {
      super();
      this.alphas = alphas;
    }
  }
  class VitsModelOutput extends ModelOutput {
    /**
     * @param {Object} output The output of the model.
     * @param {Tensor} output.waveform The final audio waveform predicted by the model, of shape `(batch_size, sequence_length)`.
     * @param {Tensor} output.spectrogram The log-mel spectrogram predicted at the output of the flow model.
     * This spectrogram is passed to the Hi-Fi GAN decoder model to obtain the final audio waveform.
     */
    constructor({ waveform, spectrogram }) {
      super();
      this.waveform = waveform;
      this.spectrogram = spectrogram;
    }
  }
  const BROWSER_ENV = typeof self !== "undefined";
  if (BROWSER_ENV) ;
  else if (sharp) ;
  else {
    throw new Error("Unable to load image processing library.");
  }
  background;
  background;
  const CACHE_NAME = "onnx-model-cache-v1";
  const CACHE_EXPIRY_DAYS = 30;
  const MAX_CACHE_SIZE_MB = 500;
  const _ModelCacheManager = class _ModelCacheManager {
    static getInstance() {
      if (!_ModelCacheManager.instance) {
        _ModelCacheManager.instance = new _ModelCacheManager();
      }
      return _ModelCacheManager.instance;
    }
    constructor() {
    }
    getCacheMetadataKey(modelUrl) {
      const encodedUrl = encodeURIComponent(modelUrl);
      return `https://cache-metadata.local/${encodedUrl}`;
    }
    isCacheExpired(metadata) {
      const now = Date.now();
      const expiryTime = metadata.timestamp + CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1e3;
      return now > expiryTime;
    }
    isMetadataUrl(url) {
      return url.startsWith("https://cache-metadata.local/");
    }
    collectCacheEntries() {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        const keys = yield cache.keys();
        const entries = [];
        let totalSize = 0;
        let entryCount = 0;
        for (const request of keys) {
          if (this.isMetadataUrl(request.url)) continue;
          const response = yield cache.match(request);
          if (response) {
            const blob = yield response.blob();
            const size = blob.size;
            totalSize += size;
            entryCount++;
            const metadataResponse = yield cache.match(this.getCacheMetadataKey(request.url));
            let timestamp = 0;
            if (metadataResponse) {
              try {
                const metadata = yield metadataResponse.json();
                timestamp = metadata.timestamp;
              } catch (error) {
                console.warn("Failed to parse cache metadata:", error);
              }
            }
            entries.push({
              url: request.url,
              timestamp,
              size
            });
          }
        }
        return { entries, totalSize, entryCount };
      });
    }
    cleanupCacheOnDemand(newDataSize = 0) {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        const { entries, totalSize } = yield this.collectCacheEntries();
        const maxSizeBytes = MAX_CACHE_SIZE_MB * 1024 * 1024;
        const projectedSize = totalSize + newDataSize;
        if (projectedSize <= maxSizeBytes) {
          return;
        }
        console.log(
          `Cache size (${(totalSize / 1024 / 1024).toFixed(2)}MB) + new data (${(newDataSize / 1024 / 1024).toFixed(2)}MB) exceeds limit (${MAX_CACHE_SIZE_MB}MB), cleaning up...`
        );
        const expiredEntries = [];
        const validEntries = [];
        for (const entry of entries) {
          const metadataResponse = yield cache.match(this.getCacheMetadataKey(entry.url));
          let isExpired = false;
          if (metadataResponse) {
            try {
              const metadata = yield metadataResponse.json();
              isExpired = this.isCacheExpired(metadata);
            } catch (error) {
              isExpired = true;
            }
          } else {
            isExpired = true;
          }
          if (isExpired) {
            expiredEntries.push(entry);
          } else {
            validEntries.push(entry);
          }
        }
        let currentSize = totalSize;
        for (const entry of expiredEntries) {
          yield cache.delete(entry.url);
          yield cache.delete(this.getCacheMetadataKey(entry.url));
          currentSize -= entry.size;
          console.log(
            `Cleaned up expired cache entry: ${entry.url} (${(entry.size / 1024 / 1024).toFixed(2)}MB)`
          );
        }
        if (currentSize + newDataSize > maxSizeBytes) {
          validEntries.sort((a, b) => a.timestamp - b.timestamp);
          for (const entry of validEntries) {
            if (currentSize + newDataSize <= maxSizeBytes) break;
            yield cache.delete(entry.url);
            yield cache.delete(this.getCacheMetadataKey(entry.url));
            currentSize -= entry.size;
            console.log(
              `Cleaned up old cache entry: ${entry.url} (${(entry.size / 1024 / 1024).toFixed(2)}MB)`
            );
          }
        }
        console.log(`Cache cleanup complete. New size: ${(currentSize / 1024 / 1024).toFixed(2)}MB`);
      });
    }
    storeCacheMetadata(modelUrl, size) {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        const metadata = {
          timestamp: Date.now(),
          modelUrl,
          size,
          version: CACHE_NAME
        };
        const metadataResponse = new Response(JSON.stringify(metadata), {
          headers: { "Content-Type": "application/json" }
        });
        yield cache.put(this.getCacheMetadataKey(modelUrl), metadataResponse);
      });
    }
    getCachedModelData(modelUrl) {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        const cachedResponse = yield cache.match(modelUrl);
        if (!cachedResponse) {
          return null;
        }
        const metadataResponse = yield cache.match(this.getCacheMetadataKey(modelUrl));
        if (metadataResponse) {
          try {
            const metadata = yield metadataResponse.json();
            if (!this.isCacheExpired(metadata)) {
              console.log("Model found in cache and not expired. Loading from cache.");
              return cachedResponse.arrayBuffer();
            } else {
              console.log("Cached model is expired, removing...");
              yield this.deleteCacheEntry(modelUrl);
              return null;
            }
          } catch (error) {
            console.warn("Failed to parse cache metadata, treating as expired:", error);
            yield this.deleteCacheEntry(modelUrl);
            return null;
          }
        } else {
          console.log("Cached model has no metadata, treating as expired...");
          yield this.deleteCacheEntry(modelUrl);
          return null;
        }
      });
    }
    storeModelData(modelUrl, data) {
      return __async(this, null, function* () {
        yield this.cleanupCacheOnDemand(data.byteLength);
        const cache = yield caches.open(CACHE_NAME);
        const response = new Response(data);
        yield cache.put(modelUrl, response);
        yield this.storeCacheMetadata(modelUrl, data.byteLength);
        console.log(
          `Model cached successfully (${(data.byteLength / 1024 / 1024).toFixed(2)}MB): ${modelUrl}`
        );
      });
    }
    deleteCacheEntry(modelUrl) {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        yield cache.delete(modelUrl);
        yield cache.delete(this.getCacheMetadataKey(modelUrl));
      });
    }
    clearAllCache() {
      return __async(this, null, function* () {
        const cache = yield caches.open(CACHE_NAME);
        const keys = yield cache.keys();
        for (const request of keys) {
          yield cache.delete(request);
        }
        console.log("All model cache entries cleared");
      });
    }
    getCacheStats() {
      return __async(this, null, function* () {
        const { entries, totalSize, entryCount } = yield this.collectCacheEntries();
        const cache = yield caches.open(CACHE_NAME);
        const cacheEntries = [];
        for (const entry of entries) {
          const metadataResponse = yield cache.match(this.getCacheMetadataKey(entry.url));
          let expired = false;
          if (metadataResponse) {
            try {
              const metadata = yield metadataResponse.json();
              expired = this.isCacheExpired(metadata);
            } catch (error) {
              expired = true;
            }
          } else {
            expired = true;
          }
          const age = entry.timestamp > 0 ? `${Math.round((Date.now() - entry.timestamp) / (1e3 * 60 * 60 * 24))} days` : "unknown";
          cacheEntries.push({
            url: entry.url,
            size: entry.size,
            sizeMB: Number((entry.size / 1024 / 1024).toFixed(2)),
            timestamp: entry.timestamp,
            age,
            expired
          });
        }
        return {
          totalSize,
          totalSizeMB: Number((totalSize / 1024 / 1024).toFixed(2)),
          entryCount,
          entries: cacheEntries.sort((a, b) => b.timestamp - a.timestamp)
        };
      });
    }
    manualCleanup() {
      return __async(this, null, function* () {
        yield this.cleanupCacheOnDemand(0);
        console.log("Manual cache cleanup completed");
      });
    }
    /**
     * Check if a specific model is cached and not expired
     * @param modelUrl The model URL to check
     * @returns Promise<boolean> True if model is cached and valid
     */
    isModelCached(modelUrl) {
      return __async(this, null, function* () {
        try {
          const cache = yield caches.open(CACHE_NAME);
          const cachedResponse = yield cache.match(modelUrl);
          if (!cachedResponse) {
            return false;
          }
          const metadataResponse = yield cache.match(this.getCacheMetadataKey(modelUrl));
          if (metadataResponse) {
            try {
              const metadata = yield metadataResponse.json();
              return !this.isCacheExpired(metadata);
            } catch (error) {
              console.warn("Failed to parse cache metadata for cache check:", error);
              return false;
            }
          } else {
            return false;
          }
        } catch (error) {
          console.error("Error checking model cache:", error);
          return false;
        }
      });
    }
    /**
     * Check if any valid (non-expired) model cache exists
     * @returns Promise<boolean> True if at least one valid model cache exists
     */
    hasAnyValidCache() {
      return __async(this, null, function* () {
        try {
          const cache = yield caches.open(CACHE_NAME);
          const keys = yield cache.keys();
          for (const request of keys) {
            if (this.isMetadataUrl(request.url)) continue;
            const metadataResponse = yield cache.match(this.getCacheMetadataKey(request.url));
            if (metadataResponse) {
              try {
                const metadata = yield metadataResponse.json();
                if (!this.isCacheExpired(metadata)) {
                  return true;
                }
              } catch (error) {
                continue;
              }
            }
          }
          return false;
        } catch (error) {
          console.error("Error checking for valid cache:", error);
          return false;
        }
      });
    }
  };
  __publicField2(_ModelCacheManager, "instance", null);
  let ModelCacheManager = _ModelCacheManager;
  background;
  function cleanupModelCache() {
    return __async(this, null, function* () {
      try {
        const cacheManager = ModelCacheManager.getInstance();
        yield cacheManager.manualCleanup();
      } catch (error) {
        console.error("Failed to cleanup cache:", error);
        throw error;
      }
    });
  }
  function hasAnyModelCache() {
    return __async(this, null, function* () {
      try {
        const cacheManager = ModelCacheManager.getInstance();
        return yield cacheManager.hasAnyValidCache();
      } catch (error) {
        console.error("Error checking for any model cache:", error);
        return false;
      }
    });
  }
  const PREDEFINED_MODELS = {
    // Multilingual model - default recommendation
    "multilingual-e5-small": {
      modelIdentifier: "Xenova/multilingual-e5-small",
      dimension: 384,
      description: "Multilingual E5 Small - Lightweight multilingual model supporting 100+ languages",
      language: "multilingual",
      performance: "excellent",
      size: "116MB",
      // Quantized version
      latency: "20ms",
      multilingualFeatures: {
        languageSupport: "100+",
        crossLanguageRetrieval: "good",
        chineseEnglishMixed: "good"
      },
      modelSpecificConfig: {
        requiresTokenTypeIds: false
        // E5 model doesn't require token_type_ids
      }
    },
    "multilingual-e5-base": {
      modelIdentifier: "Xenova/multilingual-e5-base",
      dimension: 768,
      description: "Multilingual E5 base - Medium-scale multilingual model supporting 100+ languages",
      language: "multilingual",
      performance: "excellent",
      size: "279MB",
      // Quantized version
      latency: "30ms",
      multilingualFeatures: {
        languageSupport: "100+",
        crossLanguageRetrieval: "excellent",
        chineseEnglishMixed: "excellent"
      },
      modelSpecificConfig: {
        requiresTokenTypeIds: false
        // E5 model doesn't require token_type_ids
      }
    }
  };
  class SemanticSimilarityEngineProxy {
    // Flag to prevent concurrent ensureOffscreenEngineInitialized calls
    constructor(config = {}) {
      __publicField2(this, "_isInitialized", false);
      __publicField2(this, "config");
      __publicField2(this, "offscreenManager");
      __publicField2(this, "_isEnsuring", false);
      this.config = config;
      this.offscreenManager = OffscreenManager.getInstance();
      console.log("SemanticSimilarityEngineProxy: Proxy created with config:", {
        modelPreset: config.modelPreset,
        modelVersion: config.modelVersion,
        dimension: config.dimension
      });
    }
    initialize() {
      return __async(this, null, function* () {
        try {
          console.log("SemanticSimilarityEngineProxy: Starting proxy initialization...");
          console.log("SemanticSimilarityEngineProxy: Ensuring offscreen document exists...");
          yield this.offscreenManager.ensureOffscreenDocument();
          console.log("SemanticSimilarityEngineProxy: Offscreen document ready");
          console.log("SemanticSimilarityEngineProxy: Ensuring offscreen engine is initialized...");
          yield this.ensureOffscreenEngineInitialized();
          this._isInitialized = true;
          console.log(
            "SemanticSimilarityEngineProxy: Proxy initialized, delegating to offscreen engine"
          );
        } catch (error) {
          console.error("SemanticSimilarityEngineProxy: Initialization failed:", error);
          throw new Error(
            `Failed to initialize proxy: ${error instanceof Error ? error.message : "Unknown error"}`
          );
        }
      });
    }
    /**
     * Check engine status in offscreen
     */
    checkOffscreenEngineStatus() {
      return __async(this, null, function* () {
        try {
          const response = yield chrome.runtime.sendMessage({
            target: "offscreen",
            type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_STATUS
          });
          if (response && response.success) {
            return {
              isInitialized: response.isInitialized || false,
              currentConfig: response.currentConfig || null
            };
          }
        } catch (error) {
          console.warn("SemanticSimilarityEngineProxy: Failed to check engine status:", error);
        }
        return { isInitialized: false, currentConfig: null };
      });
    }
    /**
     * Ensure engine in offscreen is initialized (with concurrency protection)
     */
    ensureOffscreenEngineInitialized() {
      return __async(this, null, function* () {
        if (this._isEnsuring) {
          console.log("SemanticSimilarityEngineProxy: Already ensuring initialization, waiting...");
          yield new Promise((resolve) => setTimeout(resolve, 100));
          return;
        }
        try {
          this._isEnsuring = true;
          const status = yield this.checkOffscreenEngineStatus();
          if (!status.isInitialized) {
            console.log(
              "SemanticSimilarityEngineProxy: Engine not initialized in offscreen, initializing..."
            );
            const response = yield chrome.runtime.sendMessage({
              target: "offscreen",
              type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_INIT,
              config: this.config
            });
            if (!response || !response.success) {
              throw new Error((response == null ? void 0 : response.error) || "Failed to initialize engine in offscreen document");
            }
            console.log("SemanticSimilarityEngineProxy: Engine reinitialized successfully");
          }
        } finally {
          this._isEnsuring = false;
        }
      });
    }
    /**
     * Send message to offscreen document with retry mechanism and auto-reinitialization
     */
    sendMessageToOffscreen(message2, maxRetries = 3) {
      return __async(this, null, function* () {
        yield this.offscreenManager.ensureOffscreenDocument();
        let lastError = null;
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(
              `SemanticSimilarityEngineProxy: Sending message (attempt ${attempt}/${maxRetries}):`,
              message2.type
            );
            const response = yield chrome.runtime.sendMessage(message2);
            if (!response) {
              throw new Error("No response received from offscreen document");
            }
            if (!response.success && response.error && response.error.includes("not initialized")) {
              console.log(
                "SemanticSimilarityEngineProxy: Engine not initialized, attempting to reinitialize..."
              );
              yield this.ensureOffscreenEngineInitialized();
              const retryResponse = yield chrome.runtime.sendMessage(message2);
              if (retryResponse && retryResponse.success) {
                return retryResponse;
              }
            }
            return response;
          } catch (error) {
            lastError = error;
            console.warn(
              `SemanticSimilarityEngineProxy: Message failed (attempt ${attempt}/${maxRetries}):`,
              error
            );
            if (error instanceof Error && error.message.includes("not initialized")) {
              try {
                console.log(
                  "SemanticSimilarityEngineProxy: Attempting to reinitialize engine due to error..."
                );
                yield this.ensureOffscreenEngineInitialized();
                const retryResponse = yield chrome.runtime.sendMessage(message2);
                if (retryResponse && retryResponse.success) {
                  return retryResponse;
                }
              } catch (reinitError) {
                console.warn(
                  "SemanticSimilarityEngineProxy: Failed to reinitialize engine:",
                  reinitError
                );
              }
            }
            if (attempt < maxRetries) {
              yield new Promise((resolve) => setTimeout(resolve, 100 * attempt));
              try {
                yield this.offscreenManager.ensureOffscreenDocument();
              } catch (offscreenError) {
                console.warn(
                  "SemanticSimilarityEngineProxy: Failed to ensure offscreen document:",
                  offscreenError
                );
              }
            }
          }
        }
        throw new Error(
          `Failed to communicate with offscreen document after ${maxRetries} attempts. Last error: ${lastError == null ? void 0 : lastError.message}`
        );
      });
    }
    getEmbedding(_0) {
      return __async(this, arguments, function* (text, options = {}) {
        if (!this._isInitialized) {
          yield this.initialize();
        }
        yield this.ensureOffscreenEngineInitialized();
        const response = yield this.sendMessageToOffscreen({
          target: "offscreen",
          type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_COMPUTE,
          text,
          options
        });
        if (!response || !response.success) {
          throw new Error((response == null ? void 0 : response.error) || "Failed to get embedding from offscreen document");
        }
        if (!response.embedding || !Array.isArray(response.embedding)) {
          throw new Error("Invalid embedding data received from offscreen document");
        }
        return new Float32Array(response.embedding);
      });
    }
    getEmbeddingsBatch(_0) {
      return __async(this, arguments, function* (texts, options = {}) {
        if (!this._isInitialized) {
          yield this.initialize();
        }
        if (!texts || texts.length === 0) return [];
        yield this.ensureOffscreenEngineInitialized();
        const response = yield this.sendMessageToOffscreen({
          target: "offscreen",
          type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_BATCH_COMPUTE,
          texts,
          options
        });
        if (!response || !response.success) {
          throw new Error((response == null ? void 0 : response.error) || "Failed to get embeddings batch from offscreen document");
        }
        return response.embeddings.map((emb) => new Float32Array(emb));
      });
    }
    computeSimilarity(_0, _1) {
      return __async(this, arguments, function* (text1, text2, options = {}) {
        const [embedding1, embedding2] = yield this.getEmbeddingsBatch([text1, text2], options);
        return this.cosineSimilarity(embedding1, embedding2);
      });
    }
    computeSimilarityBatch(_0) {
      return __async(this, arguments, function* (pairs, options = {}) {
        if (!this._isInitialized) {
          yield this.initialize();
        }
        yield this.ensureOffscreenEngineInitialized();
        const response = yield this.sendMessageToOffscreen({
          target: "offscreen",
          type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_BATCH_COMPUTE,
          pairs,
          options
        });
        if (!response || !response.success) {
          throw new Error(
            (response == null ? void 0 : response.error) || "Failed to compute similarity batch from offscreen document"
          );
        }
        return response.similarities;
      });
    }
    cosineSimilarity(a, b) {
      if (a.length !== b.length) {
        throw new Error(`Vector dimensions don't match: ${a.length} vs ${b.length}`);
      }
      let dotProduct = 0;
      let normA = 0;
      let normB = 0;
      for (let i = 0; i < a.length; i++) {
        dotProduct += a[i] * b[i];
        normA += a[i] * a[i];
        normB += b[i] * b[i];
      }
      const magnitude = Math.sqrt(normA) * Math.sqrt(normB);
      return magnitude === 0 ? 0 : dotProduct / magnitude;
    }
    get isInitialized() {
      return this._isInitialized;
    }
    dispose() {
      return __async(this, null, function* () {
        this._isInitialized = false;
        console.log("SemanticSimilarityEngineProxy: Proxy disposed");
      });
    }
  }
  background;
  const semanticSimilarityEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    PREDEFINED_MODELS,
    SemanticSimilarityEngineProxy,
    cleanupModelCache,
    hasAnyModelCache
  }, Symbol.toStringTag, { value: "Module" }));
  class ContentIndexer {
    constructor(options) {
      __publicField2(this, "textChunker");
      __publicField2(this, "vectorDatabase");
      __publicField2(this, "semanticEngine");
      __publicField2(this, "isInitialized", false);
      __publicField2(this, "isInitializing", false);
      __publicField2(this, "initPromise", null);
      __publicField2(this, "indexedPages", /* @__PURE__ */ new Set());
      __publicField2(this, "options");
      this.options = __spreadValues({
        autoIndex: true,
        maxChunksPerPage: 50,
        skipDuplicates: true
      }, options);
      this.textChunker = new TextChunker();
    }
    /**
     * Get current selected model configuration
     */
    getCurrentModelConfig() {
      return __async(this, null, function* () {
        try {
          const result2 = yield chrome.storage.local.get(["selectedModel", "selectedVersion"]);
          const selectedModel = result2.selectedModel || "multilingual-e5-small";
          const selectedVersion = result2.selectedVersion || "quantized";
          const modelInfo = PREDEFINED_MODELS[selectedModel];
          return {
            modelPreset: selectedModel,
            modelIdentifier: modelInfo.modelIdentifier,
            dimension: modelInfo.dimension,
            modelVersion: selectedVersion,
            useLocalFiles: false,
            maxLength: 256,
            cacheSize: 1e3,
            forceOffscreen: true
          };
        } catch (error) {
          console.error("ContentIndexer: Failed to get current model config, using default:", error);
          return {
            modelPreset: "multilingual-e5-small",
            modelIdentifier: "Xenova/multilingual-e5-small",
            dimension: 384,
            modelVersion: "quantized",
            useLocalFiles: false,
            maxLength: 256,
            cacheSize: 1e3,
            forceOffscreen: true
          };
        }
      });
    }
    /**
     * Initialize content indexer
     */
    initialize() {
      return __async(this, null, function* () {
        if (this.isInitialized) return;
        if (this.isInitializing && this.initPromise) return this.initPromise;
        this.isInitializing = true;
        this.initPromise = this._doInitialize().finally(() => {
          this.isInitializing = false;
        });
        return this.initPromise;
      });
    }
    _doInitialize() {
      return __async(this, null, function* () {
        try {
          const engineConfig = yield this.getCurrentModelConfig();
          this.semanticEngine = new SemanticSimilarityEngineProxy(engineConfig);
          yield this.semanticEngine.initialize();
          this.vectorDatabase = yield getGlobalVectorDatabase({
            dimension: engineConfig.dimension,
            efSearch: 50
          });
          yield this.vectorDatabase.initialize();
          this.setupTabEventListeners();
          this.isInitialized = true;
        } catch (error) {
          console.error("ContentIndexer: Initialization failed:", error);
          this.isInitialized = false;
          throw error;
        }
      });
    }
    /**
     * Index content of specified tab
     */
    indexTabContent(tabId) {
      return __async(this, null, function* () {
        if (!this.isSemanticEngineReady() && !this.isSemanticEngineInitializing()) {
          console.log(
            `ContentIndexer: Skipping tab ${tabId} - semantic engine not ready and not initializing`
          );
          return;
        }
        if (!this.isInitialized) {
          if (!this.isSemanticEngineReady()) {
            console.log(
              `ContentIndexer: Skipping tab ${tabId} - ContentIndexer not initialized and semantic engine not ready`
            );
            return;
          }
          yield this.initialize();
        }
        try {
          const tab = yield chrome.tabs.get(tabId);
          if (!tab.url || !this.shouldIndexUrl(tab.url)) {
            console.log(`ContentIndexer: Skipping tab ${tabId} - URL not indexable`);
            return;
          }
          const pageKey = `${tab.url}_${tab.title}`;
          if (this.options.skipDuplicates && this.indexedPages.has(pageKey)) {
            console.log(`ContentIndexer: Skipping tab ${tabId} - already indexed`);
            return;
          }
          console.log(`ContentIndexer: Starting to index tab ${tabId}: ${tab.title}`);
          const content = yield this.extractTabContent(tabId);
          if (!content) {
            console.log(`ContentIndexer: No content extracted from tab ${tabId}`);
            return;
          }
          const chunks = this.textChunker.chunkText(content.textContent, content.title);
          console.log(`ContentIndexer: Generated ${chunks.length} chunks for tab ${tabId}`);
          const chunksToIndex = chunks.slice(0, this.options.maxChunksPerPage);
          if (chunks.length > this.options.maxChunksPerPage) {
            console.log(
              `ContentIndexer: Limited chunks from ${chunks.length} to ${this.options.maxChunksPerPage}`
            );
          }
          for (const chunk of chunksToIndex) {
            try {
              const embedding = yield this.semanticEngine.getEmbedding(chunk.text);
              const label = yield this.vectorDatabase.addDocument(
                tabId,
                tab.url,
                tab.title || "",
                chunk,
                embedding
              );
              console.log(`ContentIndexer: Indexed chunk ${chunk.index} with label ${label}`);
            } catch (error) {
              console.error(`ContentIndexer: Failed to index chunk ${chunk.index}:`, error);
            }
          }
          this.indexedPages.add(pageKey);
          console.log(
            `ContentIndexer: Successfully indexed ${chunksToIndex.length} chunks for tab ${tabId}`
          );
        } catch (error) {
          console.error(`ContentIndexer: Failed to index tab ${tabId}:`, error);
        }
      });
    }
    /**
     * Search content
     */
    searchContent(query, topK = 10) {
      return __async(this, null, function* () {
        if (!this.isSemanticEngineReady() && !this.isSemanticEngineInitializing()) {
          throw new Error(
            "Semantic engine is not ready yet. Please initialize the semantic engine first."
          );
        }
        if (!this.isInitialized) {
          if (!this.isSemanticEngineReady()) {
            throw new Error(
              "ContentIndexer not initialized and semantic engine not ready. Please initialize the semantic engine first."
            );
          }
          yield this.initialize();
        }
        try {
          const queryEmbedding = yield this.semanticEngine.getEmbedding(query);
          const results = yield this.vectorDatabase.search(queryEmbedding, topK);
          console.log(`ContentIndexer: Found ${results.length} results for query: "${query}"`);
          return results;
        } catch (error) {
          console.error("ContentIndexer: Search failed:", error);
          if (error instanceof Error && error.message.includes("not initialized")) {
            console.log(
              "ContentIndexer: Attempting to reinitialize semantic engine and retry search..."
            );
            try {
              yield this.semanticEngine.initialize();
              const queryEmbedding = yield this.semanticEngine.getEmbedding(query);
              const results = yield this.vectorDatabase.search(queryEmbedding, topK);
              console.log(
                `ContentIndexer: Retry successful, found ${results.length} results for query: "${query}"`
              );
              return results;
            } catch (retryError) {
              console.error("ContentIndexer: Retry after reinitialization also failed:", retryError);
              throw retryError;
            }
          }
          throw error;
        }
      });
    }
    /**
     * Remove tab index
     */
    removeTabIndex(tabId) {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          return;
        }
        try {
          yield this.vectorDatabase.removeTabDocuments(tabId);
          for (const pageKey of this.indexedPages) {
            if (pageKey.includes(`tab_${tabId}_`)) {
              this.indexedPages.delete(pageKey);
            }
          }
          console.log(`ContentIndexer: Removed index for tab ${tabId}`);
        } catch (error) {
          console.error(`ContentIndexer: Failed to remove index for tab ${tabId}:`, error);
        }
      });
    }
    /**
     * Check if semantic engine is ready (checks both local and global state)
     */
    isSemanticEngineReady() {
      return this.semanticEngine && this.semanticEngine.isInitialized;
    }
    /**
     * Check if global semantic engine is ready (in background/offscreen)
     */
    isGlobalSemanticEngineReady() {
      return __async(this, null, function* () {
        try {
          const { handleGetModelStatus: handleGetModelStatus2 } = yield Promise.resolve().then(() => semanticSimilarity);
          const response = yield handleGetModelStatus2();
          return response && response.success && response.status && response.status.initializationStatus === "ready";
        } catch (error) {
          console.error("ContentIndexer: Failed to check global semantic engine status:", error);
          return false;
        }
      });
    }
    /**
     * Check if semantic engine is initializing
     */
    isSemanticEngineInitializing() {
      return this.isInitializing || this.semanticEngine && this.semanticEngine.isInitializing;
    }
    /**
     * Reinitialize content indexer (for model switching)
     */
    reinitialize() {
      return __async(this, null, function* () {
        console.log("ContentIndexer: Reinitializing for model switch...");
        this.isInitialized = false;
        this.isInitializing = false;
        this.initPromise = null;
        yield this.performCompleteDataCleanupForModelSwitch();
        this.indexedPages.clear();
        console.log("ContentIndexer: Cleared indexed pages cache");
        try {
          console.log("ContentIndexer: Creating new semantic engine proxy...");
          const newEngineConfig = yield this.getCurrentModelConfig();
          console.log("ContentIndexer: New engine config:", newEngineConfig);
          this.semanticEngine = new SemanticSimilarityEngineProxy(newEngineConfig);
          console.log("ContentIndexer: New semantic engine proxy created");
          yield this.semanticEngine.initialize();
          console.log("ContentIndexer: Semantic engine proxy initialization completed");
        } catch (error) {
          console.error("ContentIndexer: Failed to create new semantic engine proxy:", error);
          throw error;
        }
        console.log(
          "ContentIndexer: New semantic engine proxy is ready, proceeding with initialization"
        );
        yield this.initialize();
        console.log("ContentIndexer: Reinitialization completed successfully");
      });
    }
    /**
     * Perform complete data cleanup for model switching
     */
    performCompleteDataCleanupForModelSwitch() {
      return __async(this, null, function* () {
        console.log("ContentIndexer: Starting complete data cleanup for model switch...");
        try {
          if (this.vectorDatabase) {
            try {
              console.log("ContentIndexer: Clearing existing vector database instance...");
              yield this.vectorDatabase.clear();
              console.log("ContentIndexer: Vector database instance cleared successfully");
            } catch (error) {
              console.warn("ContentIndexer: Failed to clear vector database instance:", error);
            }
          }
          try {
            const { clearAllVectorData: clearAllVectorData2 } = yield Promise.resolve().then(() => vectorDatabase);
            yield clearAllVectorData2();
            console.log("ContentIndexer: Cleared all vector data for model switch");
          } catch (error) {
            console.warn("ContentIndexer: Failed to clear vector data:", error);
          }
          try {
            const keysToRemove = [
              "hnswlib_document_mappings_tab_content_index.dat",
              "hnswlib_document_mappings_content_index.dat",
              "hnswlib_document_mappings_vector_index.dat",
              "vectorDatabaseStats",
              "lastCleanupTime"
            ];
            yield chrome.storage.local.remove(keysToRemove);
            console.log("ContentIndexer: Cleared chrome.storage model-related data");
          } catch (error) {
            console.warn("ContentIndexer: Failed to clear chrome.storage data:", error);
          }
          try {
            const deleteVectorDB = indexedDB.deleteDatabase("VectorDatabaseStorage");
            yield new Promise((resolve) => {
              deleteVectorDB.onsuccess = () => {
                console.log("ContentIndexer: VectorDatabaseStorage database deleted");
                resolve();
              };
              deleteVectorDB.onerror = () => {
                console.warn("ContentIndexer: Failed to delete VectorDatabaseStorage database");
                resolve();
              };
              deleteVectorDB.onblocked = () => {
                console.warn("ContentIndexer: VectorDatabaseStorage database deletion blocked");
                resolve();
              };
            });
            const deleteHnswDB = indexedDB.deleteDatabase("/hnswlib-index");
            yield new Promise((resolve) => {
              deleteHnswDB.onsuccess = () => {
                console.log("ContentIndexer: /hnswlib-index database deleted");
                resolve();
              };
              deleteHnswDB.onerror = () => {
                console.warn("ContentIndexer: Failed to delete /hnswlib-index database");
                resolve();
              };
              deleteHnswDB.onblocked = () => {
                console.warn("ContentIndexer: /hnswlib-index database deletion blocked");
                resolve();
              };
            });
            console.log("ContentIndexer: All IndexedDB databases cleared for model switch");
          } catch (error) {
            console.warn("ContentIndexer: Failed to clear IndexedDB databases:", error);
          }
          console.log("ContentIndexer: Complete data cleanup for model switch finished successfully");
        } catch (error) {
          console.error("ContentIndexer: Complete data cleanup for model switch failed:", error);
          throw error;
        }
      });
    }
    /**
     * Manually trigger semantic engine initialization (async, don't wait for completion)
     * Note: This should only be called after the semantic engine is already initialized
     */
    startSemanticEngineInitialization() {
      if (!this.isInitialized && !this.isInitializing) {
        console.log("ContentIndexer: Checking if semantic engine is ready...");
        this.isGlobalSemanticEngineReady().then((isReady) => {
          if (isReady) {
            console.log("ContentIndexer: Starting initialization (semantic engine ready)...");
            this.initialize().catch((error) => {
              console.error("ContentIndexer: Background initialization failed:", error);
            });
          } else {
            console.log("ContentIndexer: Semantic engine not ready, skipping initialization");
          }
        }).catch((error) => {
          console.error("ContentIndexer: Failed to check semantic engine status:", error);
        });
      }
    }
    /**
     * Get indexing statistics
     */
    getStats() {
      const vectorStats = this.vectorDatabase ? this.vectorDatabase.getStats() : {
        totalDocuments: 0,
        totalTabs: 0,
        indexSize: 0
      };
      return __spreadProps(__spreadValues({}, vectorStats), {
        indexedPages: this.indexedPages.size,
        isInitialized: this.isInitialized,
        semanticEngineReady: this.isSemanticEngineReady(),
        semanticEngineInitializing: this.isSemanticEngineInitializing()
      });
    }
    /**
     * Clear all indexes
     */
    clearAllIndexes() {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          return;
        }
        try {
          yield this.vectorDatabase.clear();
          this.indexedPages.clear();
          console.log("ContentIndexer: All indexes cleared");
        } catch (error) {
          console.error("ContentIndexer: Failed to clear indexes:", error);
        }
      });
    }
    setupTabEventListeners() {
      chrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => __async(this, null, function* () {
        if (this.options.autoIndex && changeInfo.status === "complete" && tab.url) {
          setTimeout(() => {
            if (!this.isSemanticEngineReady() && !this.isSemanticEngineInitializing()) {
              console.log(
                `ContentIndexer: Skipping auto-index for tab ${tabId} - semantic engine not ready`
              );
              return;
            }
            this.indexTabContent(tabId).catch((error) => {
              console.error(`ContentIndexer: Auto-indexing failed for tab ${tabId}:`, error);
            });
          }, 2e3);
        }
      }));
      chrome.tabs.onRemoved.addListener((tabId) => __async(this, null, function* () {
        yield this.removeTabIndex(tabId);
      }));
      if (chrome.webNavigation) {
        chrome.webNavigation.onCommitted.addListener((details) => __async(this, null, function* () {
          if (details.frameId === 0) {
            yield this.removeTabIndex(details.tabId);
          }
        }));
      }
    }
    shouldIndexUrl(url) {
      const excludePatterns = [
        /^chrome:\/\//,
        /^chrome-extension:\/\//,
        /^edge:\/\//,
        /^about:/,
        /^moz-extension:\/\//,
        /^file:\/\//
      ];
      return !excludePatterns.some((pattern) => pattern.test(url));
    }
    extractTabContent(tabId) {
      return __async(this, null, function* () {
        try {
          yield chrome.scripting.executeScript({
            target: { tabId },
            files: ["inject-scripts/web-fetcher-helper.js"]
          });
          const response = yield chrome.tabs.sendMessage(tabId, {
            action: TOOL_MESSAGE_TYPES.WEB_FETCHER_GET_TEXT_CONTENT
          });
          if (response.success && response.textContent) {
            return {
              textContent: response.textContent,
              title: response.title || ""
            };
          } else {
            console.error(
              `ContentIndexer: Failed to extract content from tab ${tabId}:`,
              response.error
            );
            return null;
          }
        } catch (error) {
          console.error(`ContentIndexer: Error extracting content from tab ${tabId}:`, error);
          return null;
        }
      });
    }
  }
  let globalContentIndexer = null;
  function getGlobalContentIndexer() {
    if (!globalContentIndexer) {
      globalContentIndexer = new ContentIndexer();
    }
    return globalContentIndexer;
  }
  background;
  const contentIndexer = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    ContentIndexer,
    getGlobalContentIndexer
  }, Symbol.toStringTag, { value: "Module" }));
  class VectorSearchTabsContentTool extends BaseBrowserToolExecutor {
    constructor() {
      super();
      __publicField2(this, "name", TOOL_NAMES.BROWSER.SEARCH_TABS_CONTENT);
      __publicField2(this, "contentIndexer");
      __publicField2(this, "isInitialized", false);
      this.contentIndexer = new ContentIndexer({
        autoIndex: true,
        maxChunksPerPage: LIMITS.MAX_SEARCH_RESULTS,
        skipDuplicates: true
      });
    }
    initializeIndexer() {
      return __async(this, null, function* () {
        try {
          yield this.contentIndexer.initialize();
          this.isInitialized = true;
          console.log("VectorSearchTabsContentTool: Content indexer initialized successfully");
        } catch (error) {
          console.error("VectorSearchTabsContentTool: Failed to initialize content indexer:", error);
          this.isInitialized = false;
        }
      });
    }
    execute(args) {
      return __async(this, null, function* () {
        try {
          const { query } = args;
          if (!query || query.trim().length === 0) {
            return createErrorResponse(
              ERROR_MESSAGES.INVALID_PARAMETERS + ": Query parameter is required and cannot be empty"
            );
          }
          console.log(`VectorSearchTabsContentTool: Starting vector search with query: "${query}"`);
          if (!this.contentIndexer.isSemanticEngineReady()) {
            if (this.contentIndexer.isSemanticEngineInitializing()) {
              return createErrorResponse(
                "Vector search engine is still initializing (model downloading). Please wait a moment and try again."
              );
            } else {
              console.log("VectorSearchTabsContentTool: Initializing content indexer...");
              yield this.initializeIndexer();
              if (!this.contentIndexer.isSemanticEngineReady()) {
                return createErrorResponse("Failed to initialize vector search engine");
              }
            }
          }
          const windows = yield chrome.windows.getAll({ populate: true });
          const allTabs = [];
          for (const window2 of windows) {
            if (window2.tabs) {
              allTabs.push(...window2.tabs);
            }
          }
          console.log(`VectorSearchTabsContentTool: Found ${allTabs.length} tabs to search`);
          const validTabs = allTabs.filter(
            (tab) => tab.id && tab.url && !tab.url.startsWith("chrome://") && !tab.url.startsWith("chrome-extension://") && !tab.url.startsWith("edge://") && !tab.url.startsWith("about:")
          );
          console.log(`VectorSearchTabsContentTool: ${validTabs.length} valid tabs to process`);
          const searchResults = yield this.contentIndexer.searchContent(query, 50);
          const vectorSearchResults = this.convertSearchResults(searchResults);
          const deduplicatedResults = this.deduplicateByTab(vectorSearchResults);
          const topResults = deduplicatedResults.sort((a, b) => b.semanticScore - a.semanticScore).slice(0, 10);
          const stats = this.contentIndexer.getStats();
          const result2 = {
            success: true,
            totalTabsSearched: validTabs.length,
            matchedTabsCount: topResults.length,
            vectorSearchEnabled: true,
            indexStats: {
              totalDocuments: stats.totalDocuments,
              totalTabs: stats.totalTabs,
              indexedPages: stats.indexedPages,
              semanticEngineReady: stats.semanticEngineReady,
              semanticEngineInitializing: stats.semanticEngineInitializing
            },
            matchedTabs: topResults.map((result22) => ({
              tabId: result22.tabId,
              url: result22.url,
              title: result22.title,
              semanticScore: result22.semanticScore,
              matchedSnippets: [result22.matchedSnippet],
              chunkSource: result22.chunkSource,
              timestamp: result22.timestamp
            }))
          };
          console.log(
            `VectorSearchTabsContentTool: Found ${topResults.length} results with vector search`
          );
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2, null, 2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("VectorSearchTabsContentTool: Search failed:", error);
          return createErrorResponse(
            `Vector search failed: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
    /**
     * Ensure all tabs are indexed
     */
    ensureTabsIndexed(tabs) {
      return __async(this, null, function* () {
        const indexPromises = tabs.filter((tab) => tab.id).map((tab) => __async(this, null, function* () {
          try {
            yield this.contentIndexer.indexTabContent(tab.id);
          } catch (error) {
            console.warn(`VectorSearchTabsContentTool: Failed to index tab ${tab.id}:`, error);
          }
        }));
        yield Promise.allSettled(indexPromises);
      });
    }
    /**
     * Convert search results format
     */
    convertSearchResults(searchResults) {
      return searchResults.map((result2) => ({
        tabId: result2.document.tabId,
        url: result2.document.url,
        title: result2.document.title,
        semanticScore: result2.similarity,
        matchedSnippet: this.extractSnippet(result2.document.chunk.text),
        chunkSource: result2.document.chunk.source,
        timestamp: result2.document.timestamp
      }));
    }
    /**
     * Deduplicate by tab, keep only the highest similarity fragment per tab
     */
    deduplicateByTab(results) {
      const tabMap = /* @__PURE__ */ new Map();
      for (const result2 of results) {
        const existingResult = tabMap.get(result2.tabId);
        if (!existingResult || result2.semanticScore > existingResult.semanticScore) {
          tabMap.set(result2.tabId, result2);
        }
      }
      return Array.from(tabMap.values());
    }
    /**
     * Extract text snippet for display
     */
    extractSnippet(text, maxLength = 200) {
      if (text.length <= maxLength) {
        return text;
      }
      const truncated = text.substring(0, maxLength);
      const lastSentenceEnd = Math.max(
        truncated.lastIndexOf("."),
        truncated.lastIndexOf("!"),
        truncated.lastIndexOf("?"),
        truncated.lastIndexOf("。"),
        truncated.lastIndexOf("！"),
        truncated.lastIndexOf("？")
      );
      if (lastSentenceEnd > maxLength * 0.7) {
        return truncated.substring(0, lastSentenceEnd + 1);
      }
      const lastSpaceIndex = truncated.lastIndexOf(" ");
      if (lastSpaceIndex > maxLength * 0.8) {
        return truncated.substring(0, lastSpaceIndex) + "...";
      }
      return truncated + "...";
    }
    /**
     * Get index statistics
     */
    getIndexStats() {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          return {
            totalDocuments: 0,
            totalTabs: 0,
            indexSize: 0,
            indexedPages: 0,
            isInitialized: false,
            semanticEngineReady: false,
            semanticEngineInitializing: false
          };
        }
        return this.contentIndexer.getStats();
      });
    }
    /**
     * Manually rebuild index
     */
    rebuildIndex() {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          yield this.initializeIndexer();
        }
        try {
          yield this.contentIndexer.clearAllIndexes();
          const windows = yield chrome.windows.getAll({ populate: true });
          const allTabs = [];
          for (const window2 of windows) {
            if (window2.tabs) {
              allTabs.push(...window2.tabs);
            }
          }
          const validTabs = allTabs.filter(
            (tab) => tab.id && tab.url && !tab.url.startsWith("chrome://") && !tab.url.startsWith("chrome-extension://") && !tab.url.startsWith("edge://") && !tab.url.startsWith("about:")
          );
          yield this.ensureTabsIndexed(validTabs);
          console.log(`VectorSearchTabsContentTool: Rebuilt index for ${validTabs.length} tabs`);
        } catch (error) {
          console.error("VectorSearchTabsContentTool: Failed to rebuild index:", error);
          throw error;
        }
      });
    }
    /**
     * Manually index specified tab
     */
    indexTab(tabId) {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          yield this.initializeIndexer();
        }
        yield this.contentIndexer.indexTabContent(tabId);
      });
    }
    /**
     * Remove index for specified tab
     */
    removeTabIndex(tabId) {
      return __async(this, null, function* () {
        if (!this.isInitialized) {
          return;
        }
        yield this.contentIndexer.removeTabIndex(tabId);
      });
    }
  }
  const vectorSearchTabsContentTool = new VectorSearchTabsContentTool();
  background;
  function createImageBitmapFromUrl(dataUrl) {
    return __async(this, null, function* () {
      const response = yield fetch(dataUrl);
      const blob = yield response.blob();
      return yield createImageBitmap(blob);
    });
  }
  function stitchImages(parts, totalWidthPx, totalHeightPx) {
    return __async(this, null, function* () {
      const canvas = new OffscreenCanvas(totalWidthPx, totalHeightPx);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Unable to get canvas context");
      }
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      for (const part of parts) {
        try {
          const img = yield createImageBitmapFromUrl(part.dataUrl);
          const sx = 0;
          const sy = 0;
          const sWidth = img.width;
          let sHeight = img.height;
          const dy = part.y;
          if (dy + sHeight > totalHeightPx) {
            sHeight = totalHeightPx - dy;
          }
          if (sHeight <= 0) continue;
          ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, dy, sWidth, sHeight);
        } catch (error) {
          console.error("Error stitching image part:", error, part);
        }
      }
      return canvas;
    });
  }
  function cropAndResizeImage(originalDataUrl, cropRectPx, dpr = 1, targetWidthOpt, targetHeightOpt) {
    return __async(this, null, function* () {
      const img = yield createImageBitmapFromUrl(originalDataUrl);
      let sx = cropRectPx.x;
      let sy = cropRectPx.y;
      let sWidth = cropRectPx.width;
      let sHeight = cropRectPx.height;
      if (sx < 0) {
        sWidth += sx;
        sx = 0;
      }
      if (sy < 0) {
        sHeight += sy;
        sy = 0;
      }
      if (sx + sWidth > img.width) {
        sWidth = img.width - sx;
      }
      if (sy + sHeight > img.height) {
        sHeight = img.height - sy;
      }
      if (sWidth <= 0 || sHeight <= 0) {
        throw new Error(
          "Invalid calculated crop size (<=0). Element may not be visible or fully captured."
        );
      }
      const finalCanvasWidthPx = targetWidthOpt ? targetWidthOpt * dpr : sWidth;
      const finalCanvasHeightPx = targetHeightOpt ? targetHeightOpt * dpr : sHeight;
      const canvas = new OffscreenCanvas(finalCanvasWidthPx, finalCanvasHeightPx);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Unable to get canvas context");
      }
      ctx.drawImage(img, sx, sy, sWidth, sHeight, 0, 0, finalCanvasWidthPx, finalCanvasHeightPx);
      return canvas;
    });
  }
  function canvasToDataURL(canvas, format2 = "image/png", quality) {
    return __async(this, null, function* () {
      const blob = yield canvas.convertToBlob({
        type: format2,
        quality: format2 === "image/jpeg" ? quality : void 0
      });
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
      });
    });
  }
  function compressImage(imageDataUrl, options) {
    return __async(this, null, function* () {
      const { scale = 1, quality = 0.8, format: format2 = "image/jpeg" } = options;
      const imageBitmap = yield createImageBitmapFromUrl(imageDataUrl);
      const newWidth = Math.round(imageBitmap.width * scale);
      const newHeight = Math.round(imageBitmap.height * scale);
      const canvas = new OffscreenCanvas(newWidth, newHeight);
      const ctx = canvas.getContext("2d");
      if (!ctx) {
        throw new Error("Failed to get 2D context from OffscreenCanvas");
      }
      ctx.drawImage(imageBitmap, 0, 0, newWidth, newHeight);
      const compressedDataUrl = yield canvas.convertToBlob({ type: format2, quality });
      const dataUrl = yield new Promise((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.readAsDataURL(compressedDataUrl);
      });
      return { dataUrl, mimeType: format2 };
    });
  }
  background;
  const SCREENSHOT_CONSTANTS = {
    SCROLL_DELAY_MS: 350,
    // Time to wait after scroll for rendering and lazy loading
    CAPTURE_STITCH_DELAY_MS: 50,
    // Small delay between captures in a scroll sequence
    MAX_CAPTURE_PARTS: 50,
    // Maximum number of parts to capture (for infinite scroll pages)
    MAX_CAPTURE_HEIGHT_PX: 5e4,
    // Maximum height in pixels to capture
    PIXEL_TOLERANCE: 1,
    SCRIPT_INIT_DELAY: 100
    // Delay for script initialization
  };
  class ScreenshotTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.SCREENSHOT);
    }
    /**
     * Execute screenshot operation
     */
    execute(args) {
      return __async(this, null, function* () {
        var _a2, _b2, _c2, _d;
        const {
          name: name2 = "screenshot",
          selector,
          storeBase64 = false,
          fullPage = false,
          savePng = true
        } = args;
        console.log(`Starting screenshot with options:`, args);
        const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
        if (!tabs[0]) {
          return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND);
        }
        const tab = tabs[0];
        if (((_a2 = tab.url) == null ? void 0 : _a2.startsWith("chrome://")) || ((_b2 = tab.url) == null ? void 0 : _b2.startsWith("edge://")) || ((_c2 = tab.url) == null ? void 0 : _c2.startsWith("https://chrome.google.com/webstore")) || ((_d = tab.url) == null ? void 0 : _d.startsWith("https://microsoftedge.microsoft.com/"))) {
          return createErrorResponse(
            "Cannot capture special browser pages or web store pages due to security restrictions."
          );
        }
        let finalImageDataUrl;
        const results = { base64: null, fileSaved: false };
        let originalScroll = { x: 0, y: 0 };
        try {
          yield this.injectContentScript(tab.id, ["inject-scripts/screenshot-helper.js"]);
          yield new Promise((resolve) => setTimeout(resolve, SCREENSHOT_CONSTANTS.SCRIPT_INIT_DELAY));
          yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.SCREENSHOT_PREPARE_PAGE_FOR_CAPTURE,
            options: { fullPage }
          });
          const pageDetails = yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.SCREENSHOT_GET_PAGE_DETAILS
          });
          originalScroll = { x: pageDetails.currentScrollX, y: pageDetails.currentScrollY };
          if (fullPage) {
            this.logInfo("Capturing full page...");
            finalImageDataUrl = yield this._captureFullPage(tab.id, args, pageDetails);
          } else if (selector) {
            this.logInfo(`Capturing element: ${selector}`);
            finalImageDataUrl = yield this._captureElement(tab.id, args, pageDetails.devicePixelRatio);
          } else {
            this.logInfo("Capturing visible area...");
            finalImageDataUrl = yield chrome.tabs.captureVisibleTab(tab.windowId, { format: "png" });
          }
          if (!finalImageDataUrl) {
            throw new Error("Failed to capture image data");
          }
          if (storeBase64 === true) {
            const compressed = yield compressImage(finalImageDataUrl, {
              scale: 0.7,
              // Reduce dimensions by 30%
              quality: 0.8,
              // 80% quality for good balance
              format: "image/jpeg"
              // JPEG for better compression
            });
            const base64Data = compressed.dataUrl.replace(/^data:image\/[^;]+;base64,/, "");
            results.base64 = base64Data;
            return {
              content: [
                {
                  type: "text",
                  text: JSON.stringify({ base64Data, mimeType: compressed.mimeType })
                }
              ],
              isError: false
            };
          }
          if (savePng === true) {
            this.logInfo("Saving PNG...");
            try {
              const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
              const filename = `${name2.replace(/[^a-z0-9_-]/gi, "_") || "screenshot"}_${timestamp}.png`;
              const downloadId = yield chrome.downloads.download({
                url: finalImageDataUrl,
                filename,
                saveAs: false
              });
              results.downloadId = downloadId;
              results.filename = filename;
              results.fileSaved = true;
              try {
                yield new Promise((resolve) => setTimeout(resolve, 100));
                const [downloadItem] = yield chrome.downloads.search({ id: downloadId });
                if (downloadItem && downloadItem.filename) {
                  results.fullPath = downloadItem.filename;
                }
              } catch (pathError) {
                console.warn("Could not get full file path:", pathError);
              }
            } catch (error) {
              console.error("Error saving PNG file:", error);
              results.saveError = String(error instanceof Error ? error.message : error);
            }
          }
        } catch (error) {
          console.error("Error during screenshot execution:", error);
          return createErrorResponse(
            `Screenshot error: ${error instanceof Error ? error.message : JSON.stringify(error)}`
          );
        } finally {
          try {
            yield this.sendMessageToTab(tab.id, {
              action: TOOL_MESSAGE_TYPES.SCREENSHOT_RESET_PAGE_AFTER_CAPTURE,
              scrollX: originalScroll.x,
              scrollY: originalScroll.y
            });
          } catch (err) {
            console.warn("Failed to reset page, tab might have closed:", err);
          }
        }
        this.logInfo("Screenshot completed!");
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify(__spreadValues({
                success: true,
                message: `Screenshot [${name2}] captured successfully`,
                tabId: tab.id,
                url: tab.url,
                name: name2
              }, results))
            }
          ],
          isError: false
        };
      });
    }
    /**
     * Log information
     */
    logInfo(message2) {
      console.log(`[Screenshot Tool] ${message2}`);
    }
    /**
     * Capture specific element
     */
    _captureElement(tabId, options, pageDpr) {
      return __async(this, null, function* () {
        const elementDetails = yield this.sendMessageToTab(tabId, {
          action: TOOL_MESSAGE_TYPES.SCREENSHOT_GET_ELEMENT_DETAILS,
          selector: options.selector
        });
        const dpr = elementDetails.devicePixelRatio || pageDpr || 1;
        const cropRectPx = {
          x: elementDetails.rect.x * dpr,
          y: elementDetails.rect.y * dpr,
          width: elementDetails.rect.width * dpr,
          height: elementDetails.rect.height * dpr
        };
        yield new Promise((resolve) => setTimeout(resolve, SCREENSHOT_CONSTANTS.SCRIPT_INIT_DELAY));
        const visibleCaptureDataUrl = yield chrome.tabs.captureVisibleTab({ format: "png" });
        if (!visibleCaptureDataUrl) {
          throw new Error("Failed to capture visible tab for element cropping");
        }
        const croppedCanvas = yield cropAndResizeImage(
          visibleCaptureDataUrl,
          cropRectPx,
          dpr,
          options.width,
          // Target output width in CSS pixels
          options.height
          // Target output height in CSS pixels
        );
        return canvasToDataURL(croppedCanvas);
      });
    }
    /**
     * Capture full page
     */
    _captureFullPage(tabId, options, initialPageDetails) {
      return __async(this, null, function* () {
        const dpr = initialPageDetails.devicePixelRatio;
        const totalWidthCss = options.width || initialPageDetails.totalWidth;
        const totalHeightCss = initialPageDetails.totalHeight;
        const maxHeightPx = options.maxHeight || SCREENSHOT_CONSTANTS.MAX_CAPTURE_HEIGHT_PX;
        const limitedHeightCss = Math.min(totalHeightCss, maxHeightPx / dpr);
        const totalWidthPx = totalWidthCss * dpr;
        const totalHeightPx = limitedHeightCss * dpr;
        this.logInfo(
          `Viewport size: ${initialPageDetails.viewportWidth}x${initialPageDetails.viewportHeight} CSS pixels`
        );
        this.logInfo(
          `Page dimensions: ${totalWidthCss}x${totalHeightCss} CSS pixels (limited to ${limitedHeightCss} height)`
        );
        const viewportHeightCss = initialPageDetails.viewportHeight;
        const capturedParts = [];
        let currentScrollYCss = 0;
        let capturedHeightPx = 0;
        let partIndex = 0;
        while (capturedHeightPx < totalHeightPx && partIndex < SCREENSHOT_CONSTANTS.MAX_CAPTURE_PARTS) {
          this.logInfo(
            `Capturing part ${partIndex + 1}... (${Math.round(capturedHeightPx / totalHeightPx * 100)}%)`
          );
          if (currentScrollYCss > 0) {
            const scrollResp = yield this.sendMessageToTab(tabId, {
              action: TOOL_MESSAGE_TYPES.SCREENSHOT_SCROLL_PAGE,
              x: 0,
              y: currentScrollYCss,
              scrollDelay: SCREENSHOT_CONSTANTS.SCROLL_DELAY_MS
            });
            currentScrollYCss = scrollResp.newScrollY;
          }
          yield new Promise(
            (resolve) => setTimeout(resolve, SCREENSHOT_CONSTANTS.CAPTURE_STITCH_DELAY_MS)
          );
          const dataUrl = yield chrome.tabs.captureVisibleTab({ format: "png" });
          if (!dataUrl) throw new Error("captureVisibleTab returned empty during full page capture");
          const yOffsetPx = currentScrollYCss * dpr;
          capturedParts.push({ dataUrl, y: yOffsetPx });
          const imgForHeight = yield createImageBitmapFromUrl(dataUrl);
          const lastPartEffectiveHeightPx = Math.min(imgForHeight.height, totalHeightPx - yOffsetPx);
          capturedHeightPx = yOffsetPx + lastPartEffectiveHeightPx;
          if (capturedHeightPx >= totalHeightPx - SCREENSHOT_CONSTANTS.PIXEL_TOLERANCE) break;
          currentScrollYCss += viewportHeightCss;
          if (currentScrollYCss > totalHeightCss - viewportHeightCss && currentScrollYCss < totalHeightCss) {
            currentScrollYCss = totalHeightCss - viewportHeightCss;
          }
          partIndex++;
        }
        if (partIndex >= SCREENSHOT_CONSTANTS.MAX_CAPTURE_PARTS) {
          this.logInfo(
            `Reached maximum number of capture parts (${SCREENSHOT_CONSTANTS.MAX_CAPTURE_PARTS}). This may be an infinite scroll page.`
          );
        }
        if (totalHeightCss > limitedHeightCss) {
          this.logInfo(
            `Page height (${totalHeightCss}px) exceeds maximum capture height (${maxHeightPx / dpr}px). Capturing limited portion.`
          );
        }
        this.logInfo("Stitching image...");
        const finalCanvas = yield stitchImages(capturedParts, totalWidthPx, totalHeightPx);
        let outputCanvas = finalCanvas;
        if (options.width && !options.height) {
          const targetWidthPx = options.width * dpr;
          const aspectRatio = finalCanvas.height / finalCanvas.width;
          const targetHeightPx = targetWidthPx * aspectRatio;
          outputCanvas = new OffscreenCanvas(targetWidthPx, targetHeightPx);
          const ctx = outputCanvas.getContext("2d");
          if (ctx) {
            ctx.drawImage(finalCanvas, 0, 0, targetWidthPx, targetHeightPx);
          }
        } else if (options.height && !options.width) {
          const targetHeightPx = options.height * dpr;
          const aspectRatio = finalCanvas.width / finalCanvas.height;
          const targetWidthPx = targetHeightPx * aspectRatio;
          outputCanvas = new OffscreenCanvas(targetWidthPx, targetHeightPx);
          const ctx = outputCanvas.getContext("2d");
          if (ctx) {
            ctx.drawImage(finalCanvas, 0, 0, targetWidthPx, targetHeightPx);
          }
        } else if (options.width && options.height) {
          const targetWidthPx = options.width * dpr;
          const targetHeightPx = options.height * dpr;
          outputCanvas = new OffscreenCanvas(targetWidthPx, targetHeightPx);
          const ctx = outputCanvas.getContext("2d");
          if (ctx) {
            ctx.drawImage(finalCanvas, 0, 0, targetWidthPx, targetHeightPx);
          }
        }
        return canvasToDataURL(outputCanvas);
      });
    }
  }
  const screenshotTool = new ScreenshotTool();
  background;
  class WebFetcherTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.WEB_FETCHER);
    }
    /**
     * Execute web fetcher operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const htmlContent = args.htmlContent === true;
        const textContent = htmlContent ? false : args.textContent !== false;
        const url = args.url;
        const selector = args.selector;
        console.log(`Starting web fetcher with options:`, {
          htmlContent,
          textContent,
          url,
          selector
        });
        try {
          let tab;
          if (url) {
            console.log(`Checking if URL is already open: ${url}`);
            const allTabs = yield chrome.tabs.query({});
            const matchingTabs = allTabs.filter((t) => {
              var _a2;
              const tabUrl = ((_a2 = t.url) == null ? void 0 : _a2.endsWith("/")) ? t.url.slice(0, -1) : t.url;
              const targetUrl = url.endsWith("/") ? url.slice(0, -1) : url;
              return tabUrl === targetUrl;
            });
            if (matchingTabs.length > 0) {
              tab = matchingTabs[0];
              console.log(`Found existing tab with URL: ${url}, tab ID: ${tab.id}`);
            } else {
              console.log(`No existing tab found with URL: ${url}, creating new tab`);
              tab = yield chrome.tabs.create({ url, active: true });
              console.log("Waiting for page to load...");
              yield new Promise((resolve) => setTimeout(resolve, 3e3));
            }
          } else {
            const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (!tabs[0]) {
              return createErrorResponse("No active tab found");
            }
            tab = tabs[0];
          }
          if (!tab.id) {
            return createErrorResponse("Tab has no ID");
          }
          yield chrome.tabs.update(tab.id, { active: true });
          const result2 = {
            success: true,
            url: tab.url,
            title: tab.title
          };
          yield this.injectContentScript(tab.id, ["inject-scripts/web-fetcher-helper.js"]);
          if (htmlContent) {
            const htmlResponse = yield this.sendMessageToTab(tab.id, {
              action: TOOL_MESSAGE_TYPES.WEB_FETCHER_GET_HTML_CONTENT,
              selector
            });
            if (htmlResponse.success) {
              result2.htmlContent = htmlResponse.htmlContent;
            } else {
              console.error("Failed to get HTML content:", htmlResponse.error);
              result2.htmlContentError = htmlResponse.error;
            }
          }
          if (textContent) {
            const textResponse = yield this.sendMessageToTab(tab.id, {
              action: TOOL_MESSAGE_TYPES.WEB_FETCHER_GET_TEXT_CONTENT,
              selector
            });
            if (textResponse.success) {
              result2.textContent = textResponse.textContent;
              if (textResponse.article) {
                result2.article = {
                  title: textResponse.article.title,
                  byline: textResponse.article.byline,
                  siteName: textResponse.article.siteName,
                  excerpt: textResponse.article.excerpt,
                  lang: textResponse.article.lang
                };
              }
              if (textResponse.metadata) {
                result2.metadata = textResponse.metadata;
              }
            } else {
              console.error("Failed to get text content:", textResponse.error);
              result2.textContentError = textResponse.error;
            }
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in web fetcher:", error);
          return createErrorResponse(
            `Error fetching web content: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const webFetcherTool = new WebFetcherTool();
  class GetInteractiveElementsTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.GET_INTERACTIVE_ELEMENTS);
    }
    /**
     * Execute get interactive elements operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const { textQuery, selector, includeCoordinates = true, types } = args;
        console.log(`Starting get interactive elements with options:`, args);
        try {
          const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!tabs[0]) {
            return createErrorResponse("No active tab found");
          }
          const tab = tabs[0];
          if (!tab.id) {
            return createErrorResponse("Active tab has no ID");
          }
          yield this.injectContentScript(tab.id, ["inject-scripts/interactive-elements-helper.js"]);
          const result2 = yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.GET_INTERACTIVE_ELEMENTS,
            textQuery,
            selector,
            includeCoordinates,
            types
          });
          if (!result2.success) {
            return createErrorResponse(result2.error || "Failed to get interactive elements");
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  elements: result2.elements,
                  count: result2.elements.length,
                  query: {
                    textQuery,
                    selector,
                    types: types || "all"
                  }
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in get interactive elements operation:", error);
          return createErrorResponse(
            `Error getting interactive elements: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const getInteractiveElementsTool = new GetInteractiveElementsTool();
  background;
  class ClickTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.CLICK);
    }
    /**
     * Execute click operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const {
          selector,
          coordinates,
          waitForNavigation = false,
          timeout = TIMEOUTS.DEFAULT_WAIT * 5
        } = args;
        console.log(`Starting click operation with options:`, args);
        if (!selector && !coordinates) {
          return createErrorResponse(
            ERROR_MESSAGES.INVALID_PARAMETERS + ": Either selector or coordinates must be provided"
          );
        }
        try {
          const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!tabs[0]) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND);
          }
          const tab = tabs[0];
          if (!tab.id) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND + ": Active tab has no ID");
          }
          yield this.injectContentScript(tab.id, ["inject-scripts/click-helper.js"]);
          const result2 = yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.CLICK_ELEMENT,
            selector,
            coordinates,
            waitForNavigation,
            timeout
          });
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: result2.message || "Click operation successful",
                  elementInfo: result2.elementInfo,
                  navigationOccurred: result2.navigationOccurred,
                  clickMethod: coordinates ? "coordinates" : "selector"
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in click operation:", error);
          return createErrorResponse(
            `Error performing click: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const clickTool = new ClickTool();
  class FillTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.FILL);
    }
    /**
     * Execute fill operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const { selector, value } = args;
        console.log(`Starting fill operation with options:`, args);
        if (!selector) {
          return createErrorResponse(ERROR_MESSAGES.INVALID_PARAMETERS + ": Selector must be provided");
        }
        if (value === void 0 || value === null) {
          return createErrorResponse(ERROR_MESSAGES.INVALID_PARAMETERS + ": Value must be provided");
        }
        try {
          const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!tabs[0]) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND);
          }
          const tab = tabs[0];
          if (!tab.id) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND + ": Active tab has no ID");
          }
          yield this.injectContentScript(tab.id, ["inject-scripts/fill-helper.js"]);
          const result2 = yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.FILL_ELEMENT,
            selector,
            value
          });
          if (result2.error) {
            return createErrorResponse(result2.error);
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: result2.message || "Fill operation successful",
                  elementInfo: result2.elementInfo
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in fill operation:", error);
          return createErrorResponse(
            `Error filling element: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const fillTool = new FillTool();
  background;
  const DEFAULT_NETWORK_REQUEST_TIMEOUT = 3e4;
  class NetworkRequestTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NETWORK_REQUEST);
    }
    execute(args) {
      return __async(this, null, function* () {
        var _a2;
        const {
          url,
          method = "GET",
          headers = {},
          body,
          timeout = DEFAULT_NETWORK_REQUEST_TIMEOUT
        } = args;
        console.log(`NetworkRequestTool: Executing with options:`, args);
        if (!url) {
          return createErrorResponse("URL parameter is required.");
        }
        try {
          const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!((_a2 = tabs[0]) == null ? void 0 : _a2.id)) {
            return createErrorResponse("No active tab found or tab has no ID.");
          }
          const activeTabId = tabs[0].id;
          yield this.injectContentScript(activeTabId, ["inject-scripts/network-helper.js"]);
          console.log(
            `NetworkRequestTool: Sending to content script: URL=${url}, Method=${method}, Headers=${Object.keys(headers).join(",")}, BodyType=${typeof body}`
          );
          const resultFromContentScript = yield this.sendMessageToTab(activeTabId, {
            action: TOOL_MESSAGE_TYPES.NETWORK_SEND_REQUEST,
            url,
            method,
            headers,
            body,
            timeout
          });
          console.log(`NetworkRequestTool: Response from content script:`, resultFromContentScript);
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(resultFromContentScript)
              }
            ],
            isError: !(resultFromContentScript == null ? void 0 : resultFromContentScript.success)
          };
        } catch (error) {
          console.error("NetworkRequestTool: Error sending network request:", error);
          return createErrorResponse(
            `Error sending network request: ${error.message || String(error)}`
          );
        }
      });
    }
  }
  const networkRequestTool = new NetworkRequestTool();
  background;
  const STATIC_RESOURCE_EXTENSIONS$1 = [
    ".png",
    ".jpg",
    ".jpeg",
    ".gif",
    ".bmp",
    ".webp",
    ".svg",
    ".ico",
    ".cur",
    ".css",
    ".woff",
    ".woff2",
    ".ttf",
    ".eot",
    ".otf",
    ".mp3",
    ".mp4",
    ".avi",
    ".mov",
    ".webm",
    ".ogg",
    ".wav",
    ".pdf",
    ".zip",
    ".rar",
    ".7z",
    ".iso",
    ".dmg",
    ".js",
    ".jsx",
    ".ts",
    ".tsx",
    ".map"
    // Source maps
  ];
  const AD_ANALYTICS_DOMAINS$1 = [
    "google-analytics.com",
    "googletagmanager.com",
    "analytics.google.com",
    "doubleclick.net",
    "googlesyndication.com",
    "googleads.g.doubleclick.net",
    "facebook.com/tr",
    "connect.facebook.net",
    "bat.bing.com",
    "linkedin.com",
    // Often for tracking pixels/insights
    "analytics.twitter.com",
    "static.hotjar.com",
    "script.hotjar.com",
    "stats.g.doubleclick.net",
    "amazon-adsystem.com",
    "adservice.google.com",
    "pagead2.googlesyndication.com",
    "ads-twitter.com",
    "ads.yahoo.com",
    "adroll.com",
    "adnxs.com",
    "criteo.com",
    "quantserve.com",
    "scorecardresearch.com",
    "segment.io",
    "amplitude.com",
    "mixpanel.com",
    "optimizely.com",
    "crazyegg.com",
    "clicktale.net",
    "mouseflow.com",
    "fullstory.com",
    "clarity.ms"
  ];
  const DEBUGGER_PROTOCOL_VERSION$1 = "1.3";
  const MAX_RESPONSE_BODY_SIZE_BYTES = 1 * 1024 * 1024;
  const DEFAULT_MAX_CAPTURE_TIME_MS = 3 * 60 * 1e3;
  const DEFAULT_INACTIVITY_TIMEOUT_MS = 60 * 1e3;
  const _NetworkDebuggerStartTool = class _NetworkDebuggerStartTool extends BaseBrowserToolExecutor {
    constructor() {
      super();
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NETWORK_DEBUGGER_START);
      __publicField2(this, "captureData", /* @__PURE__ */ new Map());
      // tabId -> capture data
      __publicField2(this, "captureTimers", /* @__PURE__ */ new Map());
      // tabId -> max capture timer
      __publicField2(this, "inactivityTimers", /* @__PURE__ */ new Map());
      // tabId -> inactivity timer
      __publicField2(this, "lastActivityTime", /* @__PURE__ */ new Map());
      // tabId -> timestamp of last network activity
      __publicField2(this, "pendingResponseBodies", /* @__PURE__ */ new Map());
      // requestId -> promise for getResponseBody
      __publicField2(this, "requestCounters", /* @__PURE__ */ new Map());
      if (_NetworkDebuggerStartTool.instance) {
        return _NetworkDebuggerStartTool.instance;
      }
      _NetworkDebuggerStartTool.instance = this;
      chrome.debugger.onEvent.addListener(this.handleDebuggerEvent.bind(this));
      chrome.debugger.onDetach.addListener(this.handleDebuggerDetach.bind(this));
      chrome.tabs.onRemoved.addListener(this.handleTabRemoved.bind(this));
      chrome.tabs.onCreated.addListener(this.handleTabCreated.bind(this));
    }
    handleTabRemoved(tabId) {
      if (this.captureData.has(tabId)) {
        console.log(`NetworkDebuggerStartTool: Tab ${tabId} was closed, cleaning up resources.`);
        this.cleanupCapture(tabId);
      }
    }
    /**
     * Handle tab creation events
     * If a new tab is opened from a tab that is currently capturing, automatically start capturing the new tab's requests
     */
    handleTabCreated(tab) {
      return __async(this, null, function* () {
        try {
          if (this.captureData.size === 0) return;
          const openerTabId = tab.openerTabId;
          if (!openerTabId) return;
          if (!this.captureData.has(openerTabId)) return;
          const newTabId = tab.id;
          if (!newTabId) return;
          console.log(
            `NetworkDebuggerStartTool: New tab ${newTabId} created from capturing tab ${openerTabId}, will extend capture to it.`
          );
          const openerCaptureInfo = this.captureData.get(openerTabId);
          if (!openerCaptureInfo) return;
          yield new Promise((resolve) => setTimeout(resolve, 500));
          yield this.startCaptureForTab(newTabId, {
            maxCaptureTime: openerCaptureInfo.maxCaptureTime,
            inactivityTimeout: openerCaptureInfo.inactivityTimeout,
            includeStatic: openerCaptureInfo.includeStatic
          });
          console.log(`NetworkDebuggerStartTool: Successfully extended capture to new tab ${newTabId}`);
        } catch (error) {
          console.error(`NetworkDebuggerStartTool: Error extending capture to new tab:`, error);
        }
      });
    }
    /**
     * Start network request capture for specified tab
     * @param tabId Tab ID
     * @param options Capture options
     */
    startCaptureForTab(tabId, options) {
      return __async(this, null, function* () {
        var _a2;
        const { maxCaptureTime, inactivityTimeout, includeStatic } = options;
        if (this.captureData.has(tabId)) {
          console.log(
            `NetworkDebuggerStartTool: Already capturing on tab ${tabId}. Stopping previous session.`
          );
          yield this.stopCapture(tabId);
        }
        try {
          const tab = yield chrome.tabs.get(tabId);
          const targets = yield chrome.debugger.getTargets();
          const existingTarget = targets.find(
            (t) => t.tabId === tabId && t.attached && t.type === "page"
          );
          if (existingTarget && !existingTarget.extensionId) {
            throw new Error(
              `Debugger is already attached to tab ${tabId} by another tool (e.g., DevTools).`
            );
          }
          try {
            yield chrome.debugger.attach({ tabId }, DEBUGGER_PROTOCOL_VERSION$1);
          } catch (error) {
            if ((_a2 = error.message) == null ? void 0 : _a2.includes("Cannot attach to the target with an attached client")) {
              throw new Error(
                `Debugger is already attached to tab ${tabId}. This might be DevTools or another extension.`
              );
            }
            throw error;
          }
          try {
            yield chrome.debugger.sendCommand({ tabId }, "Network.enable");
          } catch (error) {
            yield chrome.debugger.detach({ tabId }).catch((e) => console.warn("Error detaching after failed enable:", e));
            throw error;
          }
          this.captureData.set(tabId, {
            startTime: Date.now(),
            tabUrl: tab.url,
            tabTitle: tab.title,
            maxCaptureTime,
            inactivityTimeout,
            includeStatic,
            requests: {},
            limitReached: false
          });
          this.requestCounters.set(tabId, 0);
          this.updateLastActivityTime(tabId);
          console.log(
            `NetworkDebuggerStartTool: Started capture for tab ${tabId} (${tab.url}). Max requests: ${_NetworkDebuggerStartTool.MAX_REQUESTS_PER_CAPTURE}, Max time: ${maxCaptureTime}ms, Inactivity: ${inactivityTimeout}ms.`
          );
          if (maxCaptureTime > 0) {
            this.captureTimers.set(
              tabId,
              setTimeout(() => __async(this, null, function* () {
                console.log(
                  `NetworkDebuggerStartTool: Max capture time (${maxCaptureTime}ms) reached for tab ${tabId}.`
                );
                yield this.stopCapture(tabId, true);
              }), maxCaptureTime)
            );
          }
        } catch (error) {
          console.error(`NetworkDebuggerStartTool: Error starting capture for tab ${tabId}:`, error);
          if (this.captureData.has(tabId)) {
            yield chrome.debugger.detach({ tabId }).catch((e) => console.warn("Cleanup detach error:", e));
            this.cleanupCapture(tabId);
          }
          throw error;
        }
      });
    }
    handleDebuggerEvent(source, method, params) {
      if (!source.tabId) return;
      const tabId = source.tabId;
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      this.updateLastActivityTime(tabId);
      switch (method) {
        case "Network.requestWillBeSent":
          this.handleRequestWillBeSent(tabId, params);
          break;
        case "Network.responseReceived":
          this.handleResponseReceived(tabId, params);
          break;
        case "Network.loadingFinished":
          this.handleLoadingFinished(tabId, params);
          break;
        case "Network.loadingFailed":
          this.handleLoadingFailed(tabId, params);
          break;
      }
    }
    handleDebuggerDetach(source, reason) {
      if (source.tabId && this.captureData.has(source.tabId)) {
        console.log(
          `NetworkDebuggerStartTool: Debugger detached from tab ${source.tabId}, reason: ${reason}. Cleaning up.`
        );
        this.cleanupCapture(source.tabId);
      }
    }
    updateLastActivityTime(tabId) {
      this.lastActivityTime.set(tabId, Date.now());
      const captureInfo = this.captureData.get(tabId);
      if (captureInfo && captureInfo.inactivityTimeout > 0) {
        if (this.inactivityTimers.has(tabId)) {
          clearTimeout(this.inactivityTimers.get(tabId));
        }
        this.inactivityTimers.set(
          tabId,
          setTimeout(() => this.checkInactivity(tabId), captureInfo.inactivityTimeout)
        );
      }
    }
    checkInactivity(tabId) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      const lastActivity = this.lastActivityTime.get(tabId) || captureInfo.startTime;
      const now = Date.now();
      const inactiveTime = now - lastActivity;
      if (inactiveTime >= captureInfo.inactivityTimeout) {
        console.log(
          `NetworkDebuggerStartTool: No activity for ${inactiveTime}ms (threshold: ${captureInfo.inactivityTimeout}ms), stopping capture for tab ${tabId}`
        );
        this.stopCaptureByInactivity(tabId);
      } else {
        const remainingTime = Math.max(0, captureInfo.inactivityTimeout - inactiveTime);
        this.inactivityTimers.set(
          tabId,
          setTimeout(() => this.checkInactivity(tabId), remainingTime)
        );
      }
    }
    stopCaptureByInactivity(tabId) {
      return __async(this, null, function* () {
        const captureInfo = this.captureData.get(tabId);
        if (!captureInfo) return;
        console.log(`NetworkDebuggerStartTool: Stopping capture due to inactivity for tab ${tabId}.`);
        yield this.stopCapture(tabId, true);
      });
    }
    shouldFilterRequestByUrl(url) {
      try {
        const urlObj = new URL(url);
        if (AD_ANALYTICS_DOMAINS$1.some((domain) => urlObj.hostname.includes(domain))) {
          return true;
        }
        return false;
      } catch (e) {
        console.error(`NetworkDebuggerStartTool: Error parsing URL for filtering: ${url}`, e);
        return false;
      }
    }
    shouldFilterRequestByExtension(url, includeStatic) {
      if (includeStatic) return false;
      try {
        const urlObj = new URL(url);
        const path = urlObj.pathname.toLowerCase();
        if (STATIC_RESOURCE_EXTENSIONS$1.some((ext) => path.endsWith(ext))) {
          return true;
        }
        return false;
      } catch (e) {
        console.error(
          `NetworkDebuggerStartTool: Error parsing URL for extension filtering: ${url}`,
          e
        );
        return false;
      }
    }
    // MIME type-based filtering, called after response is received
    shouldFilterByMimeType(mimeType, includeStatic) {
      if (!mimeType) return false;
      if (_NetworkDebuggerStartTool.API_MIME_TYPES.some((apiMime) => mimeType.startsWith(apiMime))) {
        return false;
      }
      if (!includeStatic) {
        if (_NetworkDebuggerStartTool.STATIC_MIME_TYPES_TO_FILTER.some(
          (staticMime) => mimeType.startsWith(staticMime)
        )) {
          return true;
        }
      }
      return false;
    }
    handleRequestWillBeSent(tabId, params) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      const { requestId, request, timestamp, type, loaderId, frameId } = params;
      if (this.shouldFilterRequestByUrl(request.url) || this.shouldFilterRequestByExtension(request.url, captureInfo.includeStatic)) {
        return;
      }
      const currentCount = this.requestCounters.get(tabId) || 0;
      if (currentCount >= _NetworkDebuggerStartTool.MAX_REQUESTS_PER_CAPTURE) {
        captureInfo.limitReached = true;
        return;
      }
      if (!captureInfo.requests[requestId]) {
        captureInfo.requests[requestId] = {
          requestId,
          url: request.url,
          method: request.method,
          requestHeaders: request.headers,
          // Temporary, will be processed
          requestTime: timestamp * 1e3,
          // Convert seconds to milliseconds
          type: type || "Other",
          status: "pending",
          // Initial status
          loaderId,
          // Useful for tracking redirects
          frameId
          // Useful for context
        };
        if (request.postData) {
          captureInfo.requests[requestId].requestBody = request.postData;
        }
      } else {
        const existingRequest = captureInfo.requests[requestId];
        existingRequest.url = request.url;
        existingRequest.requestTime = timestamp * 1e3;
        if (request.headers) existingRequest.requestHeaders = request.headers;
        if (request.postData) existingRequest.requestBody = request.postData;
        else delete existingRequest.requestBody;
      }
    }
    handleResponseReceived(tabId, params) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      const { requestId, response, timestamp, type } = params;
      const requestInfo = captureInfo.requests[requestId];
      if (!requestInfo) {
        return;
      }
      if (this.shouldFilterByMimeType(response.mimeType, captureInfo.includeStatic)) {
        delete captureInfo.requests[requestId];
        return;
      }
      const currentStoredCount = Object.keys(captureInfo.requests).length;
      this.requestCounters.set(tabId, currentStoredCount);
      requestInfo.status = response.status === 0 ? "pending" : "complete";
      requestInfo.statusCode = response.status;
      requestInfo.statusText = response.statusText;
      requestInfo.responseHeaders = response.headers;
      requestInfo.mimeType = response.mimeType;
      requestInfo.responseTime = timestamp * 1e3;
      if (type) requestInfo.type = type;
    }
    handleLoadingFinished(tabId, params) {
      return __async(this, null, function* () {
        const captureInfo = this.captureData.get(tabId);
        if (!captureInfo) return;
        const { requestId, encodedDataLength } = params;
        const requestInfo = captureInfo.requests[requestId];
        if (!requestInfo) {
          return;
        }
        requestInfo.encodedDataLength = encodedDataLength;
        if (requestInfo.status === "pending") requestInfo.status = "complete";
        if (this.shouldCaptureResponseBody(requestInfo)) {
          try {
            const responseBodyData = yield this.getResponseBody(tabId, requestId);
            if (responseBodyData) {
              if (responseBodyData.body && responseBodyData.body.length > MAX_RESPONSE_BODY_SIZE_BYTES) {
                requestInfo.responseBody = responseBodyData.body.substring(0, MAX_RESPONSE_BODY_SIZE_BYTES) + `

... [Response truncated, total size: ${responseBodyData.body.length} bytes] ...`;
              } else {
                requestInfo.responseBody = responseBodyData.body;
              }
              requestInfo.base64Encoded = responseBodyData.base64Encoded;
            }
          } catch (error) {
            requestInfo.errorText = (requestInfo.errorText || "") + ` Failed to get body: ${error instanceof Error ? error.message : String(error)}`;
          }
        }
      });
    }
    shouldCaptureResponseBody(requestInfo) {
      const mimeType = requestInfo.mimeType || "";
      if (_NetworkDebuggerStartTool.API_MIME_TYPES.some((type) => mimeType.startsWith(type))) {
        return true;
      }
      const url = requestInfo.url.toLowerCase();
      if (/\/(api|service|rest|graphql|query|data|rpc|v[0-9]+)\//i.test(url) || url.includes(".json") || url.includes("json=") || url.includes("format=json")) {
        if (mimeType && _NetworkDebuggerStartTool.STATIC_MIME_TYPES_TO_FILTER.some(
          (staticMime) => mimeType.startsWith(staticMime)
        )) {
          return false;
        }
        return true;
      }
      return false;
    }
    handleLoadingFailed(tabId, params) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      const { requestId, errorText, canceled, type } = params;
      const requestInfo = captureInfo.requests[requestId];
      if (!requestInfo) {
        return;
      }
      requestInfo.status = "error";
      requestInfo.errorText = errorText;
      requestInfo.canceled = canceled;
      if (type) requestInfo.type = type;
    }
    getResponseBody(tabId, requestId) {
      return __async(this, null, function* () {
        const pendingKey = `${tabId}_${requestId}`;
        if (this.pendingResponseBodies.has(pendingKey)) {
          return this.pendingResponseBodies.get(pendingKey);
        }
        const responseBodyPromise = (() => __async(this, null, function* () {
          try {
            const attachedTabs = yield chrome.debugger.getTargets();
            if (!attachedTabs.some((target) => target.tabId === tabId && target.attached)) {
              throw new Error(`Debugger not attached to tab ${tabId}`);
            }
            const result2 = yield chrome.debugger.sendCommand({ tabId }, "Network.getResponseBody", {
              requestId
            });
            return result2;
          } finally {
            this.pendingResponseBodies.delete(pendingKey);
          }
        }))();
        this.pendingResponseBodies.set(pendingKey, responseBodyPromise);
        return responseBodyPromise;
      });
    }
    cleanupCapture(tabId) {
      if (this.captureTimers.has(tabId)) {
        clearTimeout(this.captureTimers.get(tabId));
        this.captureTimers.delete(tabId);
      }
      if (this.inactivityTimers.has(tabId)) {
        clearTimeout(this.inactivityTimers.get(tabId));
        this.inactivityTimers.delete(tabId);
      }
      this.lastActivityTime.delete(tabId);
      this.captureData.delete(tabId);
      this.requestCounters.delete(tabId);
      const keysToDelete = [];
      this.pendingResponseBodies.forEach((_, key) => {
        if (key.startsWith(`${tabId}_`)) {
          keysToDelete.push(key);
        }
      });
      keysToDelete.forEach((key) => this.pendingResponseBodies.delete(key));
      console.log(`NetworkDebuggerStartTool: Cleaned up resources for tab ${tabId}.`);
    }
    // isAutoStop is true if stop was triggered by timeout, false if by user/explicit call
    stopCapture(tabId, isAutoStop = false) {
      return __async(this, null, function* () {
        const captureInfo = this.captureData.get(tabId);
        if (!captureInfo) {
          return { success: false, message: "No capture in progress for this tab." };
        }
        console.log(
          `NetworkDebuggerStartTool: Stopping capture for tab ${tabId}. Auto-stop: ${isAutoStop}`
        );
        try {
          const attachedTargets = yield chrome.debugger.getTargets();
          const isAttached = attachedTargets.some(
            (target) => target.tabId === tabId && target.attached
          );
          if (isAttached) {
            try {
              yield chrome.debugger.sendCommand({ tabId }, "Network.disable");
            } catch (e) {
              console.warn(
                `NetworkDebuggerStartTool: Error disabling network for tab ${tabId} (possibly already detached):`,
                e
              );
            }
            try {
              yield chrome.debugger.detach({ tabId });
            } catch (e) {
              console.warn(
                `NetworkDebuggerStartTool: Error detaching debugger for tab ${tabId} (possibly already detached):`,
                e
              );
            }
          } else {
            console.log(
              `NetworkDebuggerStartTool: Debugger was not attached to tab ${tabId} at stopCapture.`
            );
          }
        } catch (error) {
          console.error(
            "NetworkDebuggerStartTool: Error during debugger interaction in stopCapture:",
            error
          );
        }
        const allRequests = Object.values(captureInfo.requests);
        const commonRequestHeaders = this.analyzeCommonHeaders(allRequests, "requestHeaders");
        const commonResponseHeaders = this.analyzeCommonHeaders(allRequests, "responseHeaders");
        const processedRequests = allRequests.map((req) => {
          const finalReq = __spreadValues({}, req);
          if (finalReq.requestHeaders) {
            finalReq.specificRequestHeaders = this.filterOutCommonHeaders(
              finalReq.requestHeaders,
              commonRequestHeaders
            );
            delete finalReq.requestHeaders;
          } else {
            finalReq.specificRequestHeaders = {};
          }
          if (finalReq.responseHeaders) {
            finalReq.specificResponseHeaders = this.filterOutCommonHeaders(
              finalReq.responseHeaders,
              commonResponseHeaders
            );
            delete finalReq.responseHeaders;
          } else {
            finalReq.specificResponseHeaders = {};
          }
          return finalReq;
        });
        processedRequests.sort((a, b) => (a.requestTime || 0) - (b.requestTime || 0));
        const resultData = {
          captureStartTime: captureInfo.startTime,
          captureEndTime: Date.now(),
          totalDurationMs: Date.now() - captureInfo.startTime,
          commonRequestHeaders,
          commonResponseHeaders,
          requests: processedRequests,
          requestCount: processedRequests.length,
          // Actual stored requests
          totalRequestsReceivedBeforeLimit: captureInfo.limitReached ? _NetworkDebuggerStartTool.MAX_REQUESTS_PER_CAPTURE : processedRequests.length,
          requestLimitReached: !!captureInfo.limitReached,
          stoppedBy: isAutoStop ? this.lastActivityTime.get(tabId) ? "inactivity_timeout" : "max_capture_time" : "user_request",
          tabUrl: captureInfo.tabUrl,
          tabTitle: captureInfo.tabTitle
        };
        console.log(
          `NetworkDebuggerStartTool: Capture stopped for tab ${tabId}. ${resultData.requestCount} requests processed. Limit reached: ${resultData.requestLimitReached}. Stopped by: ${resultData.stoppedBy}`
        );
        this.cleanupCapture(tabId);
        return {
          success: true,
          message: `Capture stopped. ${resultData.requestCount} requests.`,
          data: resultData
        };
      });
    }
    analyzeCommonHeaders(requests, headerTypeKey) {
      if (!requests || requests.length === 0) return {};
      const headerValueCounts = /* @__PURE__ */ new Map();
      let requestsWithHeadersCount = 0;
      for (const req of requests) {
        const headers = req[headerTypeKey];
        if (headers && Object.keys(headers).length > 0) {
          requestsWithHeadersCount++;
          for (const name2 in headers) {
            const lowerName = name2.toLowerCase();
            const value = headers[name2];
            if (!headerValueCounts.has(lowerName)) {
              headerValueCounts.set(lowerName, /* @__PURE__ */ new Map());
            }
            const values = headerValueCounts.get(lowerName);
            values.set(value, (values.get(value) || 0) + 1);
          }
        }
      }
      if (requestsWithHeadersCount === 0) return {};
      const commonHeaders = {};
      headerValueCounts.forEach((values, name2) => {
        values.forEach((count, value) => {
          if (count === requestsWithHeadersCount) {
            let originalName = name2;
            for (const req of requests) {
              const hdrs = req[headerTypeKey];
              if (hdrs) {
                const foundName = Object.keys(hdrs).find((k) => k.toLowerCase() === name2);
                if (foundName) {
                  originalName = foundName;
                  break;
                }
              }
            }
            commonHeaders[originalName] = value;
          }
        });
      });
      return commonHeaders;
    }
    filterOutCommonHeaders(headers, commonHeaders) {
      if (!headers || typeof headers !== "object") return {};
      const specificHeaders = {};
      const commonHeadersLower = {};
      Object.keys(commonHeaders).forEach((commonName) => {
        commonHeadersLower[commonName.toLowerCase()] = commonHeaders[commonName];
      });
      Object.keys(headers).forEach((name2) => {
        const lowerName = name2.toLowerCase();
        if (!(lowerName in commonHeadersLower) || headers[name2] !== commonHeadersLower[lowerName]) {
          specificHeaders[name2] = headers[name2];
        }
      });
      return specificHeaders;
    }
    execute(args) {
      return __async(this, null, function* () {
        var _a2, _b2;
        const {
          url: targetUrl,
          maxCaptureTime = DEFAULT_MAX_CAPTURE_TIME_MS,
          inactivityTimeout = DEFAULT_INACTIVITY_TIMEOUT_MS,
          includeStatic = false
        } = args;
        console.log(
          `NetworkDebuggerStartTool: Executing with args: url=${targetUrl}, maxTime=${maxCaptureTime}, inactivityTime=${inactivityTimeout}, includeStatic=${includeStatic}`
        );
        let tabToOperateOn;
        try {
          if (targetUrl) {
            const existingTabs = yield chrome.tabs.query({
              url: targetUrl.startsWith("http") ? targetUrl : `*://*/*${targetUrl}*`
            });
            if (existingTabs.length > 0 && ((_a2 = existingTabs[0]) == null ? void 0 : _a2.id)) {
              tabToOperateOn = existingTabs[0];
              yield chrome.windows.update(tabToOperateOn.windowId, { focused: true });
              yield chrome.tabs.update(tabToOperateOn.id, { active: true });
            } else {
              tabToOperateOn = yield chrome.tabs.create({ url: targetUrl, active: true });
              yield new Promise((resolve) => setTimeout(resolve, 500));
            }
          } else {
            const activeTabs = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (activeTabs.length > 0 && ((_b2 = activeTabs[0]) == null ? void 0 : _b2.id)) {
              tabToOperateOn = activeTabs[0];
            } else {
              return createErrorResponse("No active tab found and no URL provided.");
            }
          }
          if (!(tabToOperateOn == null ? void 0 : tabToOperateOn.id)) {
            return createErrorResponse("Failed to identify or create a target tab.");
          }
          const tabId = tabToOperateOn.id;
          try {
            yield this.startCaptureForTab(tabId, {
              maxCaptureTime,
              inactivityTimeout,
              includeStatic
            });
          } catch (error) {
            return createErrorResponse(
              `Failed to start capture for tab ${tabId}: ${error.message || String(error)}`
            );
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: `Network capture started on tab ${tabId}. Waiting for stop command or timeout.`,
                  tabId,
                  url: tabToOperateOn.url,
                  maxCaptureTime,
                  inactivityTimeout,
                  includeStatic,
                  maxRequests: _NetworkDebuggerStartTool.MAX_REQUESTS_PER_CAPTURE
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("NetworkDebuggerStartTool: Critical error during execute:", error);
          const tabIdToClean = tabToOperateOn == null ? void 0 : tabToOperateOn.id;
          if (tabIdToClean && this.captureData.has(tabIdToClean)) {
            yield chrome.debugger.detach({ tabId: tabIdToClean }).catch((e) => console.warn("Cleanup detach error:", e));
            this.cleanupCapture(tabIdToClean);
          }
          return createErrorResponse(
            `Error in NetworkDebuggerStartTool: ${error.message || String(error)}`
          );
        }
      });
    }
  };
  // tabId -> count of captured requests (after filtering)
  __publicField2(_NetworkDebuggerStartTool, "MAX_REQUESTS_PER_CAPTURE", 100);
  // Max requests to store to prevent memory issues
  __publicField2(_NetworkDebuggerStartTool, "instance", null);
  // Static resource MIME types list (used when includeStatic is false)
  __publicField2(_NetworkDebuggerStartTool, "STATIC_MIME_TYPES_TO_FILTER", [
    "image/",
    // all image types (image/png, image/jpeg, etc.)
    "font/",
    // all font types (font/woff, font/ttf, etc.)
    "audio/",
    // all audio types
    "video/",
    // all video types
    "text/css",
    // Note: text/javascript, application/javascript etc. are often filtered by extension.
    // If script files need to be filtered by MIME type as well, add them here.
    // 'application/javascript',
    // 'application/x-javascript',
    "application/pdf",
    "application/zip",
    "application/octet-stream"
    // Often used for downloads or generic binary data
  ]);
  // API-like response MIME types (these are generally NOT filtered, and we might want their bodies)
  __publicField2(_NetworkDebuggerStartTool, "API_MIME_TYPES", [
    "application/json",
    "application/xml",
    "text/xml",
    // 'text/json' is not standard, but sometimes seen. 'application/json' is preferred.
    "text/plain",
    // Can be API response, handle with care. Often captured.
    "application/x-www-form-urlencoded",
    // Form submissions, can be API calls
    "application/graphql"
    // Add other common API types if needed
  ]);
  let NetworkDebuggerStartTool = _NetworkDebuggerStartTool;
  const _NetworkDebuggerStopTool = class _NetworkDebuggerStopTool extends BaseBrowserToolExecutor {
    constructor() {
      super();
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NETWORK_DEBUGGER_STOP);
      if (_NetworkDebuggerStopTool.instance) {
        return _NetworkDebuggerStopTool.instance;
      }
      _NetworkDebuggerStopTool.instance = this;
    }
    execute() {
      return __async(this, null, function* () {
        var _a2;
        console.log(`NetworkDebuggerStopTool: Executing command.`);
        const startTool = NetworkDebuggerStartTool.instance;
        if (!startTool) {
          return createErrorResponse(
            "NetworkDebuggerStartTool instance not available. Cannot stop capture."
          );
        }
        const ongoingCaptures = Array.from(startTool["captureData"].keys());
        console.log(
          `NetworkDebuggerStopTool: Found ${ongoingCaptures.length} ongoing captures: ${ongoingCaptures.join(", ")}`
        );
        if (ongoingCaptures.length === 0) {
          return createErrorResponse("No active network captures found in any tab.");
        }
        const activeTabs = yield chrome.tabs.query({ active: true, currentWindow: true });
        const activeTabId = (_a2 = activeTabs[0]) == null ? void 0 : _a2.id;
        let primaryTabId;
        if (activeTabId && startTool["captureData"].has(activeTabId)) {
          primaryTabId = activeTabId;
          console.log(
            `NetworkDebuggerStopTool: Active tab ${activeTabId} is capturing, will stop it first.`
          );
        } else if (ongoingCaptures.length === 1) {
          primaryTabId = ongoingCaptures[0];
          console.log(
            `NetworkDebuggerStopTool: Only one tab ${primaryTabId} is capturing, stopping it.`
          );
        } else {
          primaryTabId = ongoingCaptures[0];
          console.log(
            `NetworkDebuggerStopTool: Multiple tabs capturing, active tab not among them. Stopping tab ${primaryTabId} first.`
          );
        }
        const result2 = yield this.performStop(startTool, primaryTabId);
        if (ongoingCaptures.length > 1) {
          const otherTabIds = ongoingCaptures.filter((id) => id !== primaryTabId);
          console.log(
            `NetworkDebuggerStopTool: Stopping ${otherTabIds.length} additional captures: ${otherTabIds.join(", ")}`
          );
          for (const tabId of otherTabIds) {
            try {
              yield startTool.stopCapture(tabId);
            } catch (error) {
              console.error(`NetworkDebuggerStopTool: Error stopping capture on tab ${tabId}:`, error);
            }
          }
        }
        return result2;
      });
    }
    performStop(startTool, tabId) {
      return __async(this, null, function* () {
        console.log(`NetworkDebuggerStopTool: Attempting to stop capture for tab ${tabId}.`);
        const stopResult = yield startTool.stopCapture(tabId);
        if (!(stopResult == null ? void 0 : stopResult.success)) {
          return createErrorResponse(
            (stopResult == null ? void 0 : stopResult.message) || `Failed to stop network capture for tab ${tabId}. It might not have been capturing.`
          );
        }
        const resultData = stopResult.data || {};
        const remainingCaptures = Array.from(startTool["captureData"].keys());
        if (resultData.requests && Array.isArray(resultData.requests)) {
          resultData.requests.sort(
            (a, b) => (a.requestTime || 0) - (b.requestTime || 0)
          );
        }
        return {
          content: [
            {
              type: "text",
              text: JSON.stringify({
                success: true,
                message: `Capture for tab ${tabId} (${resultData.tabUrl || "N/A"}) stopped. ${resultData.requestCount || 0} requests captured.`,
                tabId,
                tabUrl: resultData.tabUrl || "N/A",
                tabTitle: resultData.tabTitle || "Unknown Tab",
                requestCount: resultData.requestCount || 0,
                commonRequestHeaders: resultData.commonRequestHeaders || {},
                commonResponseHeaders: resultData.commonResponseHeaders || {},
                requests: resultData.requests || [],
                captureStartTime: resultData.captureStartTime,
                captureEndTime: resultData.captureEndTime,
                totalDurationMs: resultData.totalDurationMs,
                settingsUsed: resultData.settingsUsed || {},
                remainingCaptures,
                totalRequestsReceived: resultData.totalRequestsReceived || resultData.requestCount || 0,
                requestLimitReached: resultData.requestLimitReached || false
              })
            }
          ],
          isError: false
        };
      });
    }
  };
  __publicField2(_NetworkDebuggerStopTool, "instance", null);
  let NetworkDebuggerStopTool = _NetworkDebuggerStopTool;
  const networkDebuggerStartTool = new NetworkDebuggerStartTool();
  const networkDebuggerStopTool = new NetworkDebuggerStopTool();
  background;
  const STATIC_RESOURCE_EXTENSIONS = [
    ".jpg",
    ".jpeg",
    ".png",
    ".gif",
    ".svg",
    ".webp",
    ".ico",
    ".bmp",
    // Images
    ".css",
    ".scss",
    ".less",
    // Styles
    ".js",
    ".jsx",
    ".ts",
    ".tsx",
    // Scripts
    ".woff",
    ".woff2",
    ".ttf",
    ".eot",
    ".otf",
    // Fonts
    ".mp3",
    ".mp4",
    ".avi",
    ".mov",
    ".wmv",
    ".flv",
    ".ogg",
    ".wav",
    // Media
    ".pdf",
    ".doc",
    ".docx",
    ".xls",
    ".xlsx",
    ".ppt",
    ".pptx"
    // Documents
  ];
  const AD_ANALYTICS_DOMAINS = NETWORK_FILTERS.EXCLUDED_DOMAINS;
  const _NetworkCaptureStartTool = class _NetworkCaptureStartTool extends BaseBrowserToolExecutor {
    constructor() {
      super();
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NETWORK_CAPTURE_START);
      __publicField2(this, "captureData", /* @__PURE__ */ new Map());
      // tabId -> capture data
      __publicField2(this, "captureTimers", /* @__PURE__ */ new Map());
      // tabId -> max capture timer
      __publicField2(this, "inactivityTimers", /* @__PURE__ */ new Map());
      // tabId -> inactivity timer
      __publicField2(this, "lastActivityTime", /* @__PURE__ */ new Map());
      // tabId -> timestamp of last activity
      __publicField2(this, "requestCounters", /* @__PURE__ */ new Map());
      // Maximum capture request count
      __publicField2(this, "listeners", {});
      if (_NetworkCaptureStartTool.instance) {
        return _NetworkCaptureStartTool.instance;
      }
      _NetworkCaptureStartTool.instance = this;
      chrome.tabs.onRemoved.addListener(this.handleTabRemoved.bind(this));
      chrome.tabs.onCreated.addListener(this.handleTabCreated.bind(this));
    }
    /**
     * Handle tab close events
     */
    handleTabRemoved(tabId) {
      if (this.captureData.has(tabId)) {
        console.log(`NetworkCaptureV2: Tab ${tabId} was closed, cleaning up resources.`);
        this.cleanupCapture(tabId);
      }
    }
    /**
     * Handle tab creation events
     * If a new tab is opened from a tab being captured, automatically start capturing the new tab's requests
     */
    handleTabCreated(tab) {
      return __async(this, null, function* () {
        try {
          if (this.captureData.size === 0) return;
          const openerTabId = tab.openerTabId;
          if (!openerTabId) return;
          if (!this.captureData.has(openerTabId)) return;
          const newTabId = tab.id;
          if (!newTabId) return;
          console.log(
            `NetworkCaptureV2: New tab ${newTabId} created from capturing tab ${openerTabId}, will extend capture to it.`
          );
          const openerCaptureInfo = this.captureData.get(openerTabId);
          if (!openerCaptureInfo) return;
          yield new Promise((resolve) => setTimeout(resolve, 500));
          yield this.startCaptureForTab(newTabId, {
            maxCaptureTime: openerCaptureInfo.maxCaptureTime,
            inactivityTimeout: openerCaptureInfo.inactivityTimeout,
            includeStatic: openerCaptureInfo.includeStatic
          });
          console.log(`NetworkCaptureV2: Successfully extended capture to new tab ${newTabId}`);
        } catch (error) {
          console.error(`NetworkCaptureV2: Error extending capture to new tab:`, error);
        }
      });
    }
    /**
     * Determine whether a request should be filtered (based on URL)
     */
    shouldFilterRequest(url, includeStatic) {
      try {
        const urlObj = new URL(url);
        if (AD_ANALYTICS_DOMAINS.some((domain) => urlObj.hostname.includes(domain))) {
          console.log(`NetworkCaptureV2: Filtering ad/analytics domain: ${urlObj.hostname}`);
          return true;
        }
        if (!includeStatic) {
          const path = urlObj.pathname.toLowerCase();
          if (STATIC_RESOURCE_EXTENSIONS.some((ext) => path.endsWith(ext))) {
            console.log(`NetworkCaptureV2: Filtering static resource by extension: ${path}`);
            return true;
          }
        }
        return false;
      } catch (e) {
        console.error("NetworkCaptureV2: Error filtering URL:", e);
        return false;
      }
    }
    /**
     * Filter based on MIME type
     */
    shouldFilterByMimeType(mimeType, includeStatic) {
      if (!mimeType) return false;
      if (_NetworkCaptureStartTool.API_MIME_TYPES.some((type) => mimeType.startsWith(type))) {
        return false;
      }
      if (!includeStatic) {
        if (_NetworkCaptureStartTool.STATIC_MIME_TYPES_TO_FILTER.some(
          (type) => mimeType.startsWith(type)
        )) {
          console.log(`NetworkCaptureV2: Filtering static resource by MIME type: ${mimeType}`);
          return true;
        }
        if (mimeType.startsWith("text/")) {
          console.log(`NetworkCaptureV2: Filtering text response: ${mimeType}`);
          return true;
        }
      }
      return false;
    }
    /**
     * Update last activity time and reset inactivity timer
     */
    updateLastActivityTime(tabId) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      this.lastActivityTime.set(tabId, Date.now());
      if (this.inactivityTimers.has(tabId)) {
        clearTimeout(this.inactivityTimers.get(tabId));
      }
      if (captureInfo.inactivityTimeout > 0) {
        this.inactivityTimers.set(
          tabId,
          setTimeout(() => this.checkInactivity(tabId), captureInfo.inactivityTimeout)
        );
      }
    }
    /**
     * Check for inactivity
     */
    checkInactivity(tabId) {
      const captureInfo = this.captureData.get(tabId);
      if (!captureInfo) return;
      const lastActivity = this.lastActivityTime.get(tabId) || captureInfo.startTime;
      const now = Date.now();
      const inactiveTime = now - lastActivity;
      if (inactiveTime >= captureInfo.inactivityTimeout) {
        console.log(
          `NetworkCaptureV2: No activity for ${inactiveTime}ms, stopping capture for tab ${tabId}`
        );
        this.stopCaptureByInactivity(tabId);
      } else {
        const remainingTime = captureInfo.inactivityTimeout - inactiveTime;
        this.inactivityTimers.set(
          tabId,
          setTimeout(() => this.checkInactivity(tabId), remainingTime)
        );
      }
    }
    /**
     * Stop capture due to inactivity
     */
    stopCaptureByInactivity(tabId) {
      return __async(this, null, function* () {
        const captureInfo = this.captureData.get(tabId);
        if (!captureInfo) return;
        console.log(`NetworkCaptureV2: Stopping capture due to inactivity for tab ${tabId}`);
        yield this.stopCapture(tabId);
      });
    }
    /**
     * Clean up capture resources
     */
    cleanupCapture(tabId) {
      if (this.captureTimers.has(tabId)) {
        clearTimeout(this.captureTimers.get(tabId));
        this.captureTimers.delete(tabId);
      }
      if (this.inactivityTimers.has(tabId)) {
        clearTimeout(this.inactivityTimers.get(tabId));
        this.inactivityTimers.delete(tabId);
      }
      this.lastActivityTime.delete(tabId);
      this.captureData.delete(tabId);
      this.requestCounters.delete(tabId);
      console.log(`NetworkCaptureV2: Cleaned up all resources for tab ${tabId}`);
    }
    /**
     * Set up request listeners
     */
    setupListeners() {
      this.listeners.onBeforeRequest = (details) => {
        const captureInfo = this.captureData.get(details.tabId);
        if (!captureInfo) return;
        if (this.shouldFilterRequest(details.url, captureInfo.includeStatic)) {
          return;
        }
        const currentCount = this.requestCounters.get(details.tabId) || 0;
        if (currentCount >= _NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE) {
          console.log(
            `NetworkCaptureV2: Request limit (${_NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE}) reached for tab ${details.tabId}, ignoring new request: ${details.url}`
          );
          captureInfo.limitReached = true;
          return;
        }
        this.requestCounters.set(details.tabId, currentCount + 1);
        this.updateLastActivityTime(details.tabId);
        if (!captureInfo.requests[details.requestId]) {
          captureInfo.requests[details.requestId] = {
            requestId: details.requestId,
            url: details.url,
            method: details.method,
            type: details.type,
            requestTime: details.timeStamp
          };
          if (details.requestBody) {
            const requestBody = this.processRequestBody(details.requestBody);
            if (requestBody) {
              captureInfo.requests[details.requestId].requestBody = requestBody;
            }
          }
          console.log(
            `NetworkCaptureV2: Captured request ${currentCount + 1}/${_NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE} for tab ${details.tabId}: ${details.method} ${details.url}`
          );
        }
      };
      this.listeners.onSendHeaders = (details) => {
        const captureInfo = this.captureData.get(details.tabId);
        if (!captureInfo || !captureInfo.requests[details.requestId]) return;
        if (details.requestHeaders) {
          const headers = {};
          details.requestHeaders.forEach((header) => {
            headers[header.name] = header.value || "";
          });
          captureInfo.requests[details.requestId].requestHeaders = headers;
        }
      };
      this.listeners.onHeadersReceived = (details) => {
        var _a2, _b2;
        const captureInfo = this.captureData.get(details.tabId);
        if (!captureInfo || !captureInfo.requests[details.requestId]) return;
        const requestInfo = captureInfo.requests[details.requestId];
        requestInfo.status = details.statusCode;
        requestInfo.statusText = details.statusLine;
        requestInfo.responseTime = details.timeStamp;
        requestInfo.mimeType = (_b2 = (_a2 = details.responseHeaders) == null ? void 0 : _a2.find(
          (h) => h.name.toLowerCase() === "content-type"
        )) == null ? void 0 : _b2.value;
        if (requestInfo.mimeType && this.shouldFilterByMimeType(requestInfo.mimeType, captureInfo.includeStatic)) {
          delete captureInfo.requests[details.requestId];
          const currentCount = this.requestCounters.get(details.tabId) || 0;
          if (currentCount > 0) {
            this.requestCounters.set(details.tabId, currentCount - 1);
          }
          console.log(
            `NetworkCaptureV2: Filtered request by MIME type (${requestInfo.mimeType}): ${requestInfo.url}`
          );
          return;
        }
        if (details.responseHeaders) {
          const headers = {};
          details.responseHeaders.forEach((header) => {
            headers[header.name] = header.value || "";
          });
          requestInfo.responseHeaders = headers;
        }
        this.updateLastActivityTime(details.tabId);
      };
      this.listeners.onCompleted = (details) => {
        const captureInfo = this.captureData.get(details.tabId);
        if (!captureInfo || !captureInfo.requests[details.requestId]) return;
        const requestInfo = captureInfo.requests[details.requestId];
        if ("responseSize" in details) {
          requestInfo.responseSize = details.fromCache ? 0 : details.responseSize;
        }
        this.updateLastActivityTime(details.tabId);
      };
      this.listeners.onErrorOccurred = (details) => {
        const captureInfo = this.captureData.get(details.tabId);
        if (!captureInfo || !captureInfo.requests[details.requestId]) return;
        const requestInfo = captureInfo.requests[details.requestId];
        requestInfo.errorText = details.error;
        this.updateLastActivityTime(details.tabId);
      };
      chrome.webRequest.onBeforeRequest.addListener(
        this.listeners.onBeforeRequest,
        { urls: ["<all_urls>"] },
        ["requestBody"]
      );
      chrome.webRequest.onSendHeaders.addListener(
        this.listeners.onSendHeaders,
        { urls: ["<all_urls>"] },
        ["requestHeaders"]
      );
      chrome.webRequest.onHeadersReceived.addListener(
        this.listeners.onHeadersReceived,
        { urls: ["<all_urls>"] },
        ["responseHeaders"]
      );
      chrome.webRequest.onCompleted.addListener(this.listeners.onCompleted, { urls: ["<all_urls>"] });
      chrome.webRequest.onErrorOccurred.addListener(this.listeners.onErrorOccurred, {
        urls: ["<all_urls>"]
      });
    }
    /**
     * Remove all request listeners
     * Only remove listeners when all tab captures have stopped
     */
    removeListeners() {
      if (this.captureData.size > 0) {
        console.log(
          `NetworkCaptureV2: Still capturing on ${this.captureData.size} tabs, not removing listeners.`
        );
        return;
      }
      console.log(`NetworkCaptureV2: No more active captures, removing all listeners.`);
      if (this.listeners.onBeforeRequest) {
        chrome.webRequest.onBeforeRequest.removeListener(this.listeners.onBeforeRequest);
      }
      if (this.listeners.onSendHeaders) {
        chrome.webRequest.onSendHeaders.removeListener(this.listeners.onSendHeaders);
      }
      if (this.listeners.onHeadersReceived) {
        chrome.webRequest.onHeadersReceived.removeListener(this.listeners.onHeadersReceived);
      }
      if (this.listeners.onCompleted) {
        chrome.webRequest.onCompleted.removeListener(this.listeners.onCompleted);
      }
      if (this.listeners.onErrorOccurred) {
        chrome.webRequest.onErrorOccurred.removeListener(this.listeners.onErrorOccurred);
      }
      this.listeners = {};
    }
    /**
     * Process request body data
     */
    processRequestBody(requestBody) {
      if (requestBody.raw && requestBody.raw.length > 0) {
        return "[Binary data]";
      } else if (requestBody.formData) {
        return JSON.stringify(requestBody.formData);
      }
      return void 0;
    }
    /**
     * Start network request capture for specified tab
     * @param tabId Tab ID
     * @param options Capture options
     */
    startCaptureForTab(tabId, options) {
      return __async(this, null, function* () {
        const { maxCaptureTime, inactivityTimeout, includeStatic } = options;
        if (this.captureData.has(tabId)) {
          console.log(
            `NetworkCaptureV2: Already capturing on tab ${tabId}. Stopping previous session.`
          );
          yield this.stopCapture(tabId);
        }
        try {
          const tab = yield chrome.tabs.get(tabId);
          this.captureData.set(tabId, {
            tabId,
            tabUrl: tab.url || "",
            tabTitle: tab.title || "",
            startTime: Date.now(),
            requests: {},
            maxCaptureTime,
            inactivityTimeout,
            includeStatic,
            limitReached: false
          });
          this.requestCounters.set(tabId, 0);
          this.setupListeners();
          this.updateLastActivityTime(tabId);
          console.log(
            `NetworkCaptureV2: Started capture for tab ${tabId} (${tab.url}). Max requests: ${_NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE}, Max time: ${maxCaptureTime}ms, Inactivity: ${inactivityTimeout}ms.`
          );
          if (maxCaptureTime > 0) {
            this.captureTimers.set(
              tabId,
              setTimeout(() => __async(this, null, function* () {
                console.log(
                  `NetworkCaptureV2: Max capture time (${maxCaptureTime}ms) reached for tab ${tabId}.`
                );
                yield this.stopCapture(tabId);
              }), maxCaptureTime)
            );
          }
        } catch (error) {
          console.error(`NetworkCaptureV2: Error starting capture for tab ${tabId}:`, error);
          if (this.captureData.has(tabId)) {
            this.cleanupCapture(tabId);
          }
          throw error;
        }
      });
    }
    /**
     * Stop capture
     * @param tabId Tab ID
     */
    stopCapture(tabId) {
      return __async(this, null, function* () {
        const captureInfo = this.captureData.get(tabId);
        if (!captureInfo) {
          console.log(`NetworkCaptureV2: No capture in progress for tab ${tabId}`);
          return { success: false, message: `No capture in progress for tab ${tabId}` };
        }
        try {
          captureInfo.endTime = Date.now();
          const requestsArray = Object.values(captureInfo.requests);
          const commonRequestHeaders = this.analyzeCommonHeaders(requestsArray, "requestHeaders");
          const commonResponseHeaders = this.analyzeCommonHeaders(requestsArray, "responseHeaders");
          const processedRequests = requestsArray.map((req) => {
            const finalReq = __spreadValues({}, req);
            if (finalReq.requestHeaders) {
              finalReq.specificRequestHeaders = this.filterOutCommonHeaders(
                finalReq.requestHeaders,
                commonRequestHeaders
              );
              delete finalReq.requestHeaders;
            } else {
              finalReq.specificRequestHeaders = {};
            }
            if (finalReq.responseHeaders) {
              finalReq.specificResponseHeaders = this.filterOutCommonHeaders(
                finalReq.responseHeaders,
                commonResponseHeaders
              );
              delete finalReq.responseHeaders;
            } else {
              finalReq.specificResponseHeaders = {};
            }
            return finalReq;
          });
          processedRequests.sort((a, b) => (a.requestTime || 0) - (b.requestTime || 0));
          this.removeListeners();
          const resultData = {
            captureStartTime: captureInfo.startTime,
            captureEndTime: captureInfo.endTime,
            totalDurationMs: captureInfo.endTime - captureInfo.startTime,
            settingsUsed: {
              maxCaptureTime: captureInfo.maxCaptureTime,
              inactivityTimeout: captureInfo.inactivityTimeout,
              includeStatic: captureInfo.includeStatic,
              maxRequests: _NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE
            },
            commonRequestHeaders,
            commonResponseHeaders,
            requests: processedRequests,
            requestCount: processedRequests.length,
            totalRequestsReceived: this.requestCounters.get(tabId) || 0,
            requestLimitReached: captureInfo.limitReached || false,
            tabUrl: captureInfo.tabUrl,
            tabTitle: captureInfo.tabTitle
          };
          this.cleanupCapture(tabId);
          return {
            success: true,
            data: resultData
          };
        } catch (error) {
          console.error(`NetworkCaptureV2: Error stopping capture for tab ${tabId}:`, error);
          this.cleanupCapture(tabId);
          return {
            success: false,
            message: `Error stopping capture: ${error.message || String(error)}`
          };
        }
      });
    }
    /**
     * Analyze common request or response headers
     */
    analyzeCommonHeaders(requests, headerType) {
      if (!requests || requests.length === 0) return {};
      const commonHeaders = {};
      const firstRequestWithHeaders = requests.find(
        (req) => req[headerType] && Object.keys(req[headerType] || {}).length > 0
      );
      if (!firstRequestWithHeaders || !firstRequestWithHeaders[headerType]) {
        return {};
      }
      const headers = firstRequestWithHeaders[headerType];
      const headerNames = Object.keys(headers);
      for (const name2 of headerNames) {
        const value = headers[name2];
        const isCommon = requests.every((req) => {
          const reqHeaders = req[headerType];
          return reqHeaders && reqHeaders[name2] === value;
        });
        if (isCommon) {
          commonHeaders[name2] = value;
        }
      }
      return commonHeaders;
    }
    /**
     * Filter out common headers
     */
    filterOutCommonHeaders(headers, commonHeaders) {
      if (!headers || typeof headers !== "object") return {};
      const specificHeaders = {};
      Object.keys(headers).forEach((name2) => {
        if (!(name2 in commonHeaders) || headers[name2] !== commonHeaders[name2]) {
          specificHeaders[name2] = headers[name2];
        }
      });
      return specificHeaders;
    }
    execute(args) {
      return __async(this, null, function* () {
        const {
          url: targetUrl,
          maxCaptureTime = 3 * 60 * 1e3,
          // Default 3 minutes
          inactivityTimeout = 60 * 1e3,
          // Default 1 minute of inactivity before auto-stop
          includeStatic = false
          // Default: don't include static resources
        } = args;
        console.log(`NetworkCaptureStartTool: Executing with args:`, args);
        try {
          let tabToOperateOn;
          if (targetUrl) {
            const matchingTabs = yield chrome.tabs.query({ url: targetUrl });
            if (matchingTabs.length > 0) {
              tabToOperateOn = matchingTabs[0];
              console.log(`NetworkCaptureV2: Found existing tab with URL: ${targetUrl}`);
            } else {
              console.log(`NetworkCaptureV2: Creating new tab with URL: ${targetUrl}`);
              tabToOperateOn = yield chrome.tabs.create({ url: targetUrl, active: true });
              yield new Promise((resolve) => setTimeout(resolve, 1e3));
            }
          } else {
            const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (!tabs[0]) {
              return createErrorResponse("No active tab found");
            }
            tabToOperateOn = tabs[0];
          }
          if (!(tabToOperateOn == null ? void 0 : tabToOperateOn.id)) {
            return createErrorResponse("Failed to identify or create a tab");
          }
          try {
            yield this.startCaptureForTab(tabToOperateOn.id, {
              maxCaptureTime,
              inactivityTimeout,
              includeStatic
            });
          } catch (error) {
            return createErrorResponse(
              `Failed to start capture for tab ${tabToOperateOn.id}: ${error.message || String(error)}`
            );
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: "Network capture V2 started successfully, waiting for stop command.",
                  tabId: tabToOperateOn.id,
                  url: tabToOperateOn.url,
                  maxCaptureTime,
                  inactivityTimeout,
                  includeStatic,
                  maxRequests: _NetworkCaptureStartTool.MAX_REQUESTS_PER_CAPTURE
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("NetworkCaptureStartTool: Critical error:", error);
          return createErrorResponse(
            `Error in NetworkCaptureStartTool: ${error.message || String(error)}`
          );
        }
      });
    }
  };
  __publicField2(_NetworkCaptureStartTool, "instance", null);
  // tabId -> count of captured requests
  __publicField2(_NetworkCaptureStartTool, "MAX_REQUESTS_PER_CAPTURE", LIMITS.MAX_NETWORK_REQUESTS);
  // Static resource MIME types list (for filtering)
  __publicField2(_NetworkCaptureStartTool, "STATIC_MIME_TYPES_TO_FILTER", [
    "image/",
    // All image types
    "font/",
    // All font types
    "audio/",
    // All audio types
    "video/",
    // All video types
    "text/css",
    "text/javascript",
    "application/javascript",
    "application/x-javascript",
    "application/pdf",
    "application/zip",
    "application/octet-stream"
    // Usually for downloads or generic binary data
  ]);
  // API response MIME types list (these types are usually not filtered)
  __publicField2(_NetworkCaptureStartTool, "API_MIME_TYPES", [
    "application/json",
    "application/xml",
    "text/xml",
    "application/x-www-form-urlencoded",
    "application/graphql",
    "application/grpc",
    "application/protobuf",
    "application/x-protobuf",
    "application/x-json",
    "application/ld+json",
    "application/problem+json",
    "application/problem+xml",
    "application/soap+xml",
    "application/vnd.api+json"
  ]);
  let NetworkCaptureStartTool = _NetworkCaptureStartTool;
  const _NetworkCaptureStopTool = class _NetworkCaptureStopTool extends BaseBrowserToolExecutor {
    constructor() {
      super();
      __publicField2(this, "name", TOOL_NAMES.BROWSER.NETWORK_CAPTURE_STOP);
      if (_NetworkCaptureStopTool.instance) {
        return _NetworkCaptureStopTool.instance;
      }
      _NetworkCaptureStopTool.instance = this;
    }
    execute() {
      return __async(this, null, function* () {
        var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
        console.log(`NetworkCaptureStopTool: Executing`);
        try {
          const startTool = NetworkCaptureStartTool.instance;
          if (!startTool) {
            return createErrorResponse("Network capture V2 start tool instance not found");
          }
          const ongoingCaptures = Array.from(startTool.captureData.keys());
          console.log(
            `NetworkCaptureStopTool: Found ${ongoingCaptures.length} ongoing captures: ${ongoingCaptures.join(", ")}`
          );
          if (ongoingCaptures.length === 0) {
            return createErrorResponse("No active network captures found in any tab.");
          }
          const activeTabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          const activeTabId = (_a2 = activeTabs[0]) == null ? void 0 : _a2.id;
          let primaryTabId;
          if (activeTabId && startTool.captureData.has(activeTabId)) {
            primaryTabId = activeTabId;
            console.log(
              `NetworkCaptureStopTool: Active tab ${activeTabId} is capturing, will stop it first.`
            );
          } else if (ongoingCaptures.length === 1) {
            primaryTabId = ongoingCaptures[0];
            console.log(
              `NetworkCaptureStopTool: Only one tab ${primaryTabId} is capturing, stopping it.`
            );
          } else {
            primaryTabId = ongoingCaptures[0];
            console.log(
              `NetworkCaptureStopTool: Multiple tabs capturing, active tab not among them. Stopping tab ${primaryTabId} first.`
            );
          }
          const stopResult = yield startTool.stopCapture(primaryTabId);
          if (!stopResult.success) {
            return createErrorResponse(
              stopResult.message || `Failed to stop network capture for tab ${primaryTabId}`
            );
          }
          if (ongoingCaptures.length > 1) {
            const otherTabIds = ongoingCaptures.filter((id) => id !== primaryTabId);
            console.log(
              `NetworkCaptureStopTool: Stopping ${otherTabIds.length} additional captures: ${otherTabIds.join(", ")}`
            );
            for (const tabId of otherTabIds) {
              try {
                yield startTool.stopCapture(tabId);
              } catch (error) {
                console.error(`NetworkCaptureStopTool: Error stopping capture on tab ${tabId}:`, error);
              }
            }
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: `Capture complete. ${((_b2 = stopResult.data) == null ? void 0 : _b2.requestCount) || 0} requests captured.`,
                  tabId: primaryTabId,
                  tabUrl: ((_c2 = stopResult.data) == null ? void 0 : _c2.tabUrl) || "N/A",
                  tabTitle: ((_d = stopResult.data) == null ? void 0 : _d.tabTitle) || "Unknown Tab",
                  requestCount: ((_e = stopResult.data) == null ? void 0 : _e.requestCount) || 0,
                  commonRequestHeaders: ((_f = stopResult.data) == null ? void 0 : _f.commonRequestHeaders) || {},
                  commonResponseHeaders: ((_g = stopResult.data) == null ? void 0 : _g.commonResponseHeaders) || {},
                  requests: ((_h = stopResult.data) == null ? void 0 : _h.requests) || [],
                  captureStartTime: (_i = stopResult.data) == null ? void 0 : _i.captureStartTime,
                  captureEndTime: (_j = stopResult.data) == null ? void 0 : _j.captureEndTime,
                  totalDurationMs: (_k = stopResult.data) == null ? void 0 : _k.totalDurationMs,
                  settingsUsed: ((_l = stopResult.data) == null ? void 0 : _l.settingsUsed) || {},
                  totalRequestsReceived: ((_m = stopResult.data) == null ? void 0 : _m.totalRequestsReceived) || 0,
                  requestLimitReached: ((_n = stopResult.data) == null ? void 0 : _n.requestLimitReached) || false,
                  remainingCaptures: Array.from(startTool.captureData.keys())
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("NetworkCaptureStopTool: Critical error:", error);
          return createErrorResponse(
            `Error in NetworkCaptureStopTool: ${error.message || String(error)}`
          );
        }
      });
    }
  };
  __publicField2(_NetworkCaptureStopTool, "instance", null);
  let NetworkCaptureStopTool = _NetworkCaptureStopTool;
  const networkCaptureStartTool = new NetworkCaptureStartTool();
  const networkCaptureStopTool = new NetworkCaptureStopTool();
  background;
  class KeyboardTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.KEYBOARD);
    }
    /**
     * Execute keyboard operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const { keys, selector, delay = TIMEOUTS.KEYBOARD_DELAY } = args;
        console.log(`Starting keyboard operation with options:`, args);
        if (!keys) {
          return createErrorResponse(
            ERROR_MESSAGES.INVALID_PARAMETERS + ": Keys parameter must be provided"
          );
        }
        try {
          const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
          if (!tabs[0]) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND);
          }
          const tab = tabs[0];
          if (!tab.id) {
            return createErrorResponse(ERROR_MESSAGES.TAB_NOT_FOUND + ": Active tab has no ID");
          }
          yield this.injectContentScript(tab.id, ["inject-scripts/keyboard-helper.js"]);
          const result2 = yield this.sendMessageToTab(tab.id, {
            action: TOOL_MESSAGE_TYPES.SIMULATE_KEYBOARD,
            keys,
            selector,
            delay
          });
          if (result2.error) {
            return createErrorResponse(result2.error);
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify({
                  success: true,
                  message: result2.message || "Keyboard operation successful",
                  targetElement: result2.targetElement,
                  results: result2.results
                })
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in keyboard operation:", error);
          return createErrorResponse(
            `Error simulating keyboard events: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const keyboardTool = new KeyboardTool();
  background;
  const millisecondsInWeek = 6048e5;
  const millisecondsInDay = 864e5;
  const millisecondsInMinute = 6e4;
  const millisecondsInHour = 36e5;
  const constructFromSymbol = Symbol.for("constructDateFrom");
  function constructFrom(date, value) {
    if (typeof date === "function") return date(value);
    if (date && typeof date === "object" && constructFromSymbol in date)
      return date[constructFromSymbol](value);
    if (date instanceof Date) return new date.constructor(value);
    return new Date(value);
  }
  function toDate(argument, context) {
    return constructFrom(context || argument, argument);
  }
  function addDays(date, amount, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    if (isNaN(amount)) return constructFrom(date, NaN);
    if (!amount) return _date;
    _date.setDate(_date.getDate() + amount);
    return _date;
  }
  function addMonths(date, amount, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    if (isNaN(amount)) return constructFrom(date, NaN);
    if (!amount) {
      return _date;
    }
    const dayOfMonth = _date.getDate();
    const endOfDesiredMonth = constructFrom(date, _date.getTime());
    endOfDesiredMonth.setMonth(_date.getMonth() + amount + 1, 0);
    const daysInMonth = endOfDesiredMonth.getDate();
    if (dayOfMonth >= daysInMonth) {
      return endOfDesiredMonth;
    } else {
      _date.setFullYear(
        endOfDesiredMonth.getFullYear(),
        endOfDesiredMonth.getMonth(),
        dayOfMonth
      );
      return _date;
    }
  }
  let defaultOptions = {};
  function getDefaultOptions() {
    return defaultOptions;
  }
  function startOfWeek(date, options) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const weekStartsOn = (_h = (_g = (_d = (_c2 = options == null ? void 0 : options.weekStartsOn) != null ? _c2 : (_b2 = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.weekStartsOn) != null ? _d : defaultOptions2.weekStartsOn) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.weekStartsOn) != null ? _h : 0;
    const _date = toDate(date, options == null ? void 0 : options.in);
    const day = _date.getDay();
    const diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
    _date.setDate(_date.getDate() - diff);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function startOfISOWeek(date, options) {
    return startOfWeek(date, __spreadProps(__spreadValues({}, options), { weekStartsOn: 1 }));
  }
  function getISOWeekYear(date, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const fourthOfJanuaryOfNextYear = constructFrom(_date, 0);
    fourthOfJanuaryOfNextYear.setFullYear(year + 1, 0, 4);
    fourthOfJanuaryOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfISOWeek(fourthOfJanuaryOfNextYear);
    const fourthOfJanuaryOfThisYear = constructFrom(_date, 0);
    fourthOfJanuaryOfThisYear.setFullYear(year, 0, 4);
    fourthOfJanuaryOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfISOWeek(fourthOfJanuaryOfThisYear);
    if (_date.getTime() >= startOfNextYear.getTime()) {
      return year + 1;
    } else if (_date.getTime() >= startOfThisYear.getTime()) {
      return year;
    } else {
      return year - 1;
    }
  }
  function getTimezoneOffsetInMilliseconds(date) {
    const _date = toDate(date);
    const utcDate = new Date(
      Date.UTC(
        _date.getFullYear(),
        _date.getMonth(),
        _date.getDate(),
        _date.getHours(),
        _date.getMinutes(),
        _date.getSeconds(),
        _date.getMilliseconds()
      )
    );
    utcDate.setUTCFullYear(_date.getFullYear());
    return +date - +utcDate;
  }
  function normalizeDates(context, ...dates) {
    const normalize = constructFrom.bind(
      null,
      dates.find((date) => typeof date === "object")
    );
    return dates.map(normalize);
  }
  function startOfDay(date, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    _date.setHours(0, 0, 0, 0);
    return _date;
  }
  function differenceInCalendarDays(laterDate, earlierDate, options) {
    const [laterDate_, earlierDate_] = normalizeDates(
      options == null ? void 0 : options.in,
      laterDate,
      earlierDate
    );
    const laterStartOfDay = startOfDay(laterDate_);
    const earlierStartOfDay = startOfDay(earlierDate_);
    const laterTimestamp = +laterStartOfDay - getTimezoneOffsetInMilliseconds(laterStartOfDay);
    const earlierTimestamp = +earlierStartOfDay - getTimezoneOffsetInMilliseconds(earlierStartOfDay);
    return Math.round((laterTimestamp - earlierTimestamp) / millisecondsInDay);
  }
  function startOfISOWeekYear(date, options) {
    const year = getISOWeekYear(date, options);
    const fourthOfJanuary = constructFrom(date, 0);
    fourthOfJanuary.setFullYear(year, 0, 4);
    fourthOfJanuary.setHours(0, 0, 0, 0);
    return startOfISOWeek(fourthOfJanuary);
  }
  function addWeeks(date, amount, options) {
    return addDays(date, amount * 7, options);
  }
  function addYears(date, amount, options) {
    return addMonths(date, amount * 12, options);
  }
  function constructNow(date) {
    return constructFrom(date, Date.now());
  }
  function isDate(value) {
    return value instanceof Date || typeof value === "object" && Object.prototype.toString.call(value) === "[object Date]";
  }
  function isValid(date) {
    return !(!isDate(date) && typeof date !== "number" || isNaN(+toDate(date)));
  }
  function startOfYear(date, options) {
    const date_ = toDate(date, options == null ? void 0 : options.in);
    date_.setFullYear(date_.getFullYear(), 0, 1);
    date_.setHours(0, 0, 0, 0);
    return date_;
  }
  const formatDistanceLocale = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  };
  const formatDistance = (token, count, options) => {
    let result2;
    const tokenValue = formatDistanceLocale[token];
    if (typeof tokenValue === "string") {
      result2 = tokenValue;
    } else if (count === 1) {
      result2 = tokenValue.one;
    } else {
      result2 = tokenValue.other.replace("{{count}}", count.toString());
    }
    if (options == null ? void 0 : options.addSuffix) {
      if (options.comparison && options.comparison > 0) {
        return "in " + result2;
      } else {
        return result2 + " ago";
      }
    }
    return result2;
  };
  function buildFormatLongFn(args) {
    return (options = {}) => {
      const width = options.width ? String(options.width) : args.defaultWidth;
      const format2 = args.formats[width] || args.formats[args.defaultWidth];
      return format2;
    };
  }
  const dateFormats = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  };
  const timeFormats = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  };
  const dateTimeFormats = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  };
  const formatLong = {
    date: buildFormatLongFn({
      formats: dateFormats,
      defaultWidth: "full"
    }),
    time: buildFormatLongFn({
      formats: timeFormats,
      defaultWidth: "full"
    }),
    dateTime: buildFormatLongFn({
      formats: dateTimeFormats,
      defaultWidth: "full"
    })
  };
  const formatRelativeLocale = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  };
  const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
  function buildLocalizeFn(args) {
    return (value, options) => {
      const context = (options == null ? void 0 : options.context) ? String(options.context) : "standalone";
      let valuesArray;
      if (context === "formatting" && args.formattingValues) {
        const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : defaultWidth;
        valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
      } else {
        const defaultWidth = args.defaultWidth;
        const width = (options == null ? void 0 : options.width) ? String(options.width) : args.defaultWidth;
        valuesArray = args.values[width] || args.values[defaultWidth];
      }
      const index = args.argumentCallback ? args.argumentCallback(value) : value;
      return valuesArray[index];
    };
  }
  const eraValues = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  };
  const quarterValues = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  };
  const monthValues = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ],
    wide: [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ]
  };
  const dayValues = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ]
  };
  const dayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  };
  const formattingDayPeriodValues = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  };
  const ordinalNumber = (dirtyNumber, _options) => {
    const number = Number(dirtyNumber);
    const rem100 = number % 100;
    if (rem100 > 20 || rem100 < 10) {
      switch (rem100 % 10) {
        case 1:
          return number + "st";
        case 2:
          return number + "nd";
        case 3:
          return number + "rd";
      }
    }
    return number + "th";
  };
  const localize = {
    ordinalNumber,
    era: buildLocalizeFn({
      values: eraValues,
      defaultWidth: "wide"
    }),
    quarter: buildLocalizeFn({
      values: quarterValues,
      defaultWidth: "wide",
      argumentCallback: (quarter) => quarter - 1
    }),
    month: buildLocalizeFn({
      values: monthValues,
      defaultWidth: "wide"
    }),
    day: buildLocalizeFn({
      values: dayValues,
      defaultWidth: "wide"
    }),
    dayPeriod: buildLocalizeFn({
      values: dayPeriodValues,
      defaultWidth: "wide",
      formattingValues: formattingDayPeriodValues,
      defaultFormattingWidth: "wide"
    })
  };
  function buildMatchFn(args) {
    return (string, options = {}) => {
      const width = options.width;
      const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
      const matchResult = string.match(matchPattern);
      if (!matchResult) {
        return null;
      }
      const matchedString = matchResult[0];
      const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
      const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
        // [TODO] -- I challenge you to fix the type
        findKey(parsePatterns, (pattern) => pattern.test(matchedString))
      );
      let value;
      value = args.valueCallback ? args.valueCallback(key) : key;
      value = options.valueCallback ? (
        // [TODO] -- I challenge you to fix the type
        options.valueCallback(value)
      ) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }
  function findKey(object, predicate) {
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
        return key;
      }
    }
    return void 0;
  }
  function findIndex(array, predicate) {
    for (let key = 0; key < array.length; key++) {
      if (predicate(array[key])) {
        return key;
      }
    }
    return void 0;
  }
  function buildMatchPatternFn(args) {
    return (string, options = {}) => {
      const matchResult = string.match(args.matchPattern);
      if (!matchResult) return null;
      const matchedString = matchResult[0];
      const parseResult = string.match(args.parsePattern);
      if (!parseResult) return null;
      let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
      value = options.valueCallback ? options.valueCallback(value) : value;
      const rest = string.slice(matchedString.length);
      return { value, rest };
    };
  }
  const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
  const parseOrdinalNumberPattern = /\d+/i;
  const matchEraPatterns = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  };
  const parseEraPatterns = {
    any: [/^b/i, /^(a|c)/i]
  };
  const matchQuarterPatterns = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  };
  const parseQuarterPatterns = {
    any: [/1/i, /2/i, /3/i, /4/i]
  };
  const matchMonthPatterns = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  };
  const parseMonthPatterns = {
    narrow: [
      /^j/i,
      /^f/i,
      /^m/i,
      /^a/i,
      /^m/i,
      /^j/i,
      /^j/i,
      /^a/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ],
    any: [
      /^ja/i,
      /^f/i,
      /^mar/i,
      /^ap/i,
      /^may/i,
      /^jun/i,
      /^jul/i,
      /^au/i,
      /^s/i,
      /^o/i,
      /^n/i,
      /^d/i
    ]
  };
  const matchDayPatterns = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  };
  const parseDayPatterns = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  };
  const matchDayPeriodPatterns = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  };
  const parseDayPeriodPatterns = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  };
  const match = {
    ordinalNumber: buildMatchPatternFn({
      matchPattern: matchOrdinalNumberPattern,
      parsePattern: parseOrdinalNumberPattern,
      valueCallback: (value) => parseInt(value, 10)
    }),
    era: buildMatchFn({
      matchPatterns: matchEraPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseEraPatterns,
      defaultParseWidth: "any"
    }),
    quarter: buildMatchFn({
      matchPatterns: matchQuarterPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseQuarterPatterns,
      defaultParseWidth: "any",
      valueCallback: (index) => index + 1
    }),
    month: buildMatchFn({
      matchPatterns: matchMonthPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseMonthPatterns,
      defaultParseWidth: "any"
    }),
    day: buildMatchFn({
      matchPatterns: matchDayPatterns,
      defaultMatchWidth: "wide",
      parsePatterns: parseDayPatterns,
      defaultParseWidth: "any"
    }),
    dayPeriod: buildMatchFn({
      matchPatterns: matchDayPeriodPatterns,
      defaultMatchWidth: "any",
      parsePatterns: parseDayPeriodPatterns,
      defaultParseWidth: "any"
    })
  };
  const enUS = {
    code: "en-US",
    formatDistance,
    formatLong,
    formatRelative,
    localize,
    match,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  };
  function getDayOfYear(date, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    const diff = differenceInCalendarDays(_date, startOfYear(_date));
    const dayOfYear = diff + 1;
    return dayOfYear;
  }
  function getISOWeek(date, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    const diff = +startOfISOWeek(_date) - +startOfISOWeekYear(_date);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function getWeekYear(date, options) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h;
    const _date = toDate(date, options == null ? void 0 : options.in);
    const year = _date.getFullYear();
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = (_h = (_g = (_d = (_c2 = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c2 : (_b2 = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
    const firstWeekOfNextYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
    firstWeekOfNextYear.setFullYear(year + 1, 0, firstWeekContainsDate);
    firstWeekOfNextYear.setHours(0, 0, 0, 0);
    const startOfNextYear = startOfWeek(firstWeekOfNextYear, options);
    const firstWeekOfThisYear = constructFrom((options == null ? void 0 : options.in) || date, 0);
    firstWeekOfThisYear.setFullYear(year, 0, firstWeekContainsDate);
    firstWeekOfThisYear.setHours(0, 0, 0, 0);
    const startOfThisYear = startOfWeek(firstWeekOfThisYear, options);
    if (+_date >= +startOfNextYear) {
      return year + 1;
    } else if (+_date >= +startOfThisYear) {
      return year;
    } else {
      return year - 1;
    }
  }
  function startOfWeekYear(date, options) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h;
    const defaultOptions2 = getDefaultOptions();
    const firstWeekContainsDate = (_h = (_g = (_d = (_c2 = options == null ? void 0 : options.firstWeekContainsDate) != null ? _c2 : (_b2 = (_a2 = options == null ? void 0 : options.locale) == null ? void 0 : _a2.options) == null ? void 0 : _b2.firstWeekContainsDate) != null ? _d : defaultOptions2.firstWeekContainsDate) != null ? _g : (_f = (_e = defaultOptions2.locale) == null ? void 0 : _e.options) == null ? void 0 : _f.firstWeekContainsDate) != null ? _h : 1;
    const year = getWeekYear(date, options);
    const firstWeek = constructFrom((options == null ? void 0 : options.in) || date, 0);
    firstWeek.setFullYear(year, 0, firstWeekContainsDate);
    firstWeek.setHours(0, 0, 0, 0);
    const _date = startOfWeek(firstWeek, options);
    return _date;
  }
  function getWeek(date, options) {
    const _date = toDate(date, options == null ? void 0 : options.in);
    const diff = +startOfWeek(_date, options) - +startOfWeekYear(_date, options);
    return Math.round(diff / millisecondsInWeek) + 1;
  }
  function addLeadingZeros(number, targetLength) {
    const sign = number < 0 ? "-" : "";
    const output = Math.abs(number).toString().padStart(targetLength, "0");
    return sign + output;
  }
  const lightFormatters = {
    // Year
    y(date, token) {
      const signedYear = date.getFullYear();
      const year = signedYear > 0 ? signedYear : 1 - signedYear;
      return addLeadingZeros(token === "yy" ? year % 100 : year, token.length);
    },
    // Month
    M(date, token) {
      const month = date.getMonth();
      return token === "M" ? String(month + 1) : addLeadingZeros(month + 1, 2);
    },
    // Day of the month
    d(date, token) {
      return addLeadingZeros(date.getDate(), token.length);
    },
    // AM or PM
    a(date, token) {
      const dayPeriodEnumValue = date.getHours() / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return dayPeriodEnumValue.toUpperCase();
        case "aaa":
          return dayPeriodEnumValue;
        case "aaaaa":
          return dayPeriodEnumValue[0];
        case "aaaa":
        default:
          return dayPeriodEnumValue === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h(date, token) {
      return addLeadingZeros(date.getHours() % 12 || 12, token.length);
    },
    // Hour [0-23]
    H(date, token) {
      return addLeadingZeros(date.getHours(), token.length);
    },
    // Minute
    m(date, token) {
      return addLeadingZeros(date.getMinutes(), token.length);
    },
    // Second
    s(date, token) {
      return addLeadingZeros(date.getSeconds(), token.length);
    },
    // Fraction of second
    S(date, token) {
      const numberOfDigits = token.length;
      const milliseconds = date.getMilliseconds();
      const fractionalSeconds = Math.trunc(
        milliseconds * Math.pow(10, numberOfDigits - 3)
      );
      return addLeadingZeros(fractionalSeconds, token.length);
    }
  };
  const dayPeriodEnum = {
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  };
  const formatters = {
    // Era
    G: function(date, token, localize2) {
      const era = date.getFullYear() > 0 ? 1 : 0;
      switch (token) {
        // AD, BC
        case "G":
        case "GG":
        case "GGG":
          return localize2.era(era, { width: "abbreviated" });
        // A, B
        case "GGGGG":
          return localize2.era(era, { width: "narrow" });
        // Anno Domini, Before Christ
        case "GGGG":
        default:
          return localize2.era(era, { width: "wide" });
      }
    },
    // Year
    y: function(date, token, localize2) {
      if (token === "yo") {
        const signedYear = date.getFullYear();
        const year = signedYear > 0 ? signedYear : 1 - signedYear;
        return localize2.ordinalNumber(year, { unit: "year" });
      }
      return lightFormatters.y(date, token);
    },
    // Local week-numbering year
    Y: function(date, token, localize2, options) {
      const signedWeekYear = getWeekYear(date, options);
      const weekYear = signedWeekYear > 0 ? signedWeekYear : 1 - signedWeekYear;
      if (token === "YY") {
        const twoDigitYear = weekYear % 100;
        return addLeadingZeros(twoDigitYear, 2);
      }
      if (token === "Yo") {
        return localize2.ordinalNumber(weekYear, { unit: "year" });
      }
      return addLeadingZeros(weekYear, token.length);
    },
    // ISO week-numbering year
    R: function(date, token) {
      const isoWeekYear = getISOWeekYear(date);
      return addLeadingZeros(isoWeekYear, token.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(date, token) {
      const year = date.getFullYear();
      return addLeadingZeros(year, token.length);
    },
    // Quarter
    Q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "Q":
          return String(quarter);
        // 01, 02, 03, 04
        case "QQ":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "Qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "QQQ":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "formatting"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "QQQQQ":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "formatting"
          });
        // 1st quarter, 2nd quarter, ...
        case "QQQQ":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(date, token, localize2) {
      const quarter = Math.ceil((date.getMonth() + 1) / 3);
      switch (token) {
        // 1, 2, 3, 4
        case "q":
          return String(quarter);
        // 01, 02, 03, 04
        case "qq":
          return addLeadingZeros(quarter, 2);
        // 1st, 2nd, 3rd, 4th
        case "qo":
          return localize2.ordinalNumber(quarter, { unit: "quarter" });
        // Q1, Q2, Q3, Q4
        case "qqq":
          return localize2.quarter(quarter, {
            width: "abbreviated",
            context: "standalone"
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)
        case "qqqqq":
          return localize2.quarter(quarter, {
            width: "narrow",
            context: "standalone"
          });
        // 1st quarter, 2nd quarter, ...
        case "qqqq":
        default:
          return localize2.quarter(quarter, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        case "M":
        case "MM":
          return lightFormatters.M(date, token);
        // 1st, 2nd, ..., 12th
        case "Mo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "MMM":
          return localize2.month(month, {
            width: "abbreviated",
            context: "formatting"
          });
        // J, F, ..., D
        case "MMMMM":
          return localize2.month(month, {
            width: "narrow",
            context: "formatting"
          });
        // January, February, ..., December
        case "MMMM":
        default:
          return localize2.month(month, { width: "wide", context: "formatting" });
      }
    },
    // Stand-alone month
    L: function(date, token, localize2) {
      const month = date.getMonth();
      switch (token) {
        // 1, 2, ..., 12
        case "L":
          return String(month + 1);
        // 01, 02, ..., 12
        case "LL":
          return addLeadingZeros(month + 1, 2);
        // 1st, 2nd, ..., 12th
        case "Lo":
          return localize2.ordinalNumber(month + 1, { unit: "month" });
        // Jan, Feb, ..., Dec
        case "LLL":
          return localize2.month(month, {
            width: "abbreviated",
            context: "standalone"
          });
        // J, F, ..., D
        case "LLLLL":
          return localize2.month(month, {
            width: "narrow",
            context: "standalone"
          });
        // January, February, ..., December
        case "LLLL":
        default:
          return localize2.month(month, { width: "wide", context: "standalone" });
      }
    },
    // Local week of year
    w: function(date, token, localize2, options) {
      const week = getWeek(date, options);
      if (token === "wo") {
        return localize2.ordinalNumber(week, { unit: "week" });
      }
      return addLeadingZeros(week, token.length);
    },
    // ISO week of year
    I: function(date, token, localize2) {
      const isoWeek = getISOWeek(date);
      if (token === "Io") {
        return localize2.ordinalNumber(isoWeek, { unit: "week" });
      }
      return addLeadingZeros(isoWeek, token.length);
    },
    // Day of the month
    d: function(date, token, localize2) {
      if (token === "do") {
        return localize2.ordinalNumber(date.getDate(), { unit: "date" });
      }
      return lightFormatters.d(date, token);
    },
    // Day of year
    D: function(date, token, localize2) {
      const dayOfYear = getDayOfYear(date);
      if (token === "Do") {
        return localize2.ordinalNumber(dayOfYear, { unit: "dayOfYear" });
      }
      return addLeadingZeros(dayOfYear, token.length);
    },
    // Day of week
    E: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      switch (token) {
        // Tue
        case "E":
        case "EE":
        case "EEE":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "EEEEE":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "EEEEEE":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "EEEE":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (Nth day of week with current locale or weekStartsOn)
        case "e":
          return String(localDayOfWeek);
        // Padded numerical value
        case "ee":
          return addLeadingZeros(localDayOfWeek, 2);
        // 1st, 2nd, ..., 7th
        case "eo":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "eee":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "eeeee":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "eeeeee":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "eeee":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(date, token, localize2, options) {
      const dayOfWeek = date.getDay();
      const localDayOfWeek = (dayOfWeek - options.weekStartsOn + 8) % 7 || 7;
      switch (token) {
        // Numerical value (same as in `e`)
        case "c":
          return String(localDayOfWeek);
        // Padded numerical value
        case "cc":
          return addLeadingZeros(localDayOfWeek, token.length);
        // 1st, 2nd, ..., 7th
        case "co":
          return localize2.ordinalNumber(localDayOfWeek, { unit: "day" });
        case "ccc":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "standalone"
          });
        // T
        case "ccccc":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "standalone"
          });
        // Tu
        case "cccccc":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "standalone"
          });
        // Tuesday
        case "cccc":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(date, token, localize2) {
      const dayOfWeek = date.getDay();
      const isoDayOfWeek = dayOfWeek === 0 ? 7 : dayOfWeek;
      switch (token) {
        // 2
        case "i":
          return String(isoDayOfWeek);
        // 02
        case "ii":
          return addLeadingZeros(isoDayOfWeek, token.length);
        // 2nd
        case "io":
          return localize2.ordinalNumber(isoDayOfWeek, { unit: "day" });
        // Tue
        case "iii":
          return localize2.day(dayOfWeek, {
            width: "abbreviated",
            context: "formatting"
          });
        // T
        case "iiiii":
          return localize2.day(dayOfWeek, {
            width: "narrow",
            context: "formatting"
          });
        // Tu
        case "iiiiii":
          return localize2.day(dayOfWeek, {
            width: "short",
            context: "formatting"
          });
        // Tuesday
        case "iiii":
        default:
          return localize2.day(dayOfWeek, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(date, token, localize2) {
      const hours = date.getHours();
      const dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      switch (token) {
        case "a":
        case "aa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours === 12) {
        dayPeriodEnumValue = dayPeriodEnum.noon;
      } else if (hours === 0) {
        dayPeriodEnumValue = dayPeriodEnum.midnight;
      } else {
        dayPeriodEnumValue = hours / 12 >= 1 ? "pm" : "am";
      }
      switch (token) {
        case "b":
        case "bb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(date, token, localize2) {
      const hours = date.getHours();
      let dayPeriodEnumValue;
      if (hours >= 17) {
        dayPeriodEnumValue = dayPeriodEnum.evening;
      } else if (hours >= 12) {
        dayPeriodEnumValue = dayPeriodEnum.afternoon;
      } else if (hours >= 4) {
        dayPeriodEnumValue = dayPeriodEnum.morning;
      } else {
        dayPeriodEnumValue = dayPeriodEnum.night;
      }
      switch (token) {
        case "B":
        case "BB":
        case "BBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return localize2.dayPeriod(dayPeriodEnumValue, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(date, token, localize2) {
      if (token === "ho") {
        let hours = date.getHours() % 12;
        if (hours === 0) hours = 12;
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return lightFormatters.h(date, token);
    },
    // Hour [0-23]
    H: function(date, token, localize2) {
      if (token === "Ho") {
        return localize2.ordinalNumber(date.getHours(), { unit: "hour" });
      }
      return lightFormatters.H(date, token);
    },
    // Hour [0-11]
    K: function(date, token, localize2) {
      const hours = date.getHours() % 12;
      if (token === "Ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Hour [1-24]
    k: function(date, token, localize2) {
      let hours = date.getHours();
      if (hours === 0) hours = 24;
      if (token === "ko") {
        return localize2.ordinalNumber(hours, { unit: "hour" });
      }
      return addLeadingZeros(hours, token.length);
    },
    // Minute
    m: function(date, token, localize2) {
      if (token === "mo") {
        return localize2.ordinalNumber(date.getMinutes(), { unit: "minute" });
      }
      return lightFormatters.m(date, token);
    },
    // Second
    s: function(date, token, localize2) {
      if (token === "so") {
        return localize2.ordinalNumber(date.getSeconds(), { unit: "second" });
      }
      return lightFormatters.s(date, token);
    },
    // Fraction of second
    S: function(date, token) {
      return lightFormatters.S(date, token);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      if (timezoneOffset === 0) {
        return "Z";
      }
      switch (token) {
        // Hours and optional minutes
        case "X":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XX`
        case "XXXX":
        case "XX":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `XXX`
        case "XXXXX":
        case "XXX":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Hours and optional minutes
        case "x":
          return formatTimezoneWithOptionalMinutes(timezoneOffset);
        // Hours, minutes and optional seconds without `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xx`
        case "xxxx":
        case "xx":
          return formatTimezone(timezoneOffset);
        // Hours, minutes and optional seconds with `:` delimiter
        // Note: neither ISO-8601 nor JavaScript supports seconds in timezone offsets
        // so this token always has the same output as `xxx`
        case "xxxxx":
        case "xxx":
        // Hours and minutes with `:` delimiter
        default:
          return formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (GMT)
    O: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "OOOO":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(date, token, _localize) {
      const timezoneOffset = date.getTimezoneOffset();
      switch (token) {
        // Short
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + formatTimezoneShort(timezoneOffset, ":");
        // Long
        case "zzzz":
        default:
          return "GMT" + formatTimezone(timezoneOffset, ":");
      }
    },
    // Seconds timestamp
    t: function(date, token, _localize) {
      const timestamp = Math.trunc(+date / 1e3);
      return addLeadingZeros(timestamp, token.length);
    },
    // Milliseconds timestamp
    T: function(date, token, _localize) {
      return addLeadingZeros(+date, token.length);
    }
  };
  function formatTimezoneShort(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = Math.trunc(absOffset / 60);
    const minutes = absOffset % 60;
    if (minutes === 0) {
      return sign + String(hours);
    }
    return sign + String(hours) + delimiter + addLeadingZeros(minutes, 2);
  }
  function formatTimezoneWithOptionalMinutes(offset, delimiter) {
    if (offset % 60 === 0) {
      const sign = offset > 0 ? "-" : "+";
      return sign + addLeadingZeros(Math.abs(offset) / 60, 2);
    }
    return formatTimezone(offset, delimiter);
  }
  function formatTimezone(offset, delimiter = "") {
    const sign = offset > 0 ? "-" : "+";
    const absOffset = Math.abs(offset);
    const hours = addLeadingZeros(Math.trunc(absOffset / 60), 2);
    const minutes = addLeadingZeros(absOffset % 60, 2);
    return sign + hours + delimiter + minutes;
  }
  const dateLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "P":
        return formatLong2.date({ width: "short" });
      case "PP":
        return formatLong2.date({ width: "medium" });
      case "PPP":
        return formatLong2.date({ width: "long" });
      case "PPPP":
      default:
        return formatLong2.date({ width: "full" });
    }
  };
  const timeLongFormatter = (pattern, formatLong2) => {
    switch (pattern) {
      case "p":
        return formatLong2.time({ width: "short" });
      case "pp":
        return formatLong2.time({ width: "medium" });
      case "ppp":
        return formatLong2.time({ width: "long" });
      case "pppp":
      default:
        return formatLong2.time({ width: "full" });
    }
  };
  const dateTimeLongFormatter = (pattern, formatLong2) => {
    const matchResult = pattern.match(/(P+)(p+)?/) || [];
    const datePattern = matchResult[1];
    const timePattern = matchResult[2];
    if (!timePattern) {
      return dateLongFormatter(pattern, formatLong2);
    }
    let dateTimeFormat;
    switch (datePattern) {
      case "P":
        dateTimeFormat = formatLong2.dateTime({ width: "short" });
        break;
      case "PP":
        dateTimeFormat = formatLong2.dateTime({ width: "medium" });
        break;
      case "PPP":
        dateTimeFormat = formatLong2.dateTime({ width: "long" });
        break;
      case "PPPP":
      default:
        dateTimeFormat = formatLong2.dateTime({ width: "full" });
        break;
    }
    return dateTimeFormat.replace("{{date}}", dateLongFormatter(datePattern, formatLong2)).replace("{{time}}", timeLongFormatter(timePattern, formatLong2));
  };
  const longFormatters = {
    p: timeLongFormatter,
    P: dateTimeLongFormatter
  };
  const dayOfYearTokenRE = /^D+$/;
  const weekYearTokenRE = /^Y+$/;
  const throwTokens = ["D", "DD", "YY", "YYYY"];
  function isProtectedDayOfYearToken(token) {
    return dayOfYearTokenRE.test(token);
  }
  function isProtectedWeekYearToken(token) {
    return weekYearTokenRE.test(token);
  }
  function warnOrThrowProtectedError(token, format2, input) {
    const _message = message(token, format2, input);
    console.warn(_message);
    if (throwTokens.includes(token)) throw new RangeError(_message);
  }
  function message(token, format2, input) {
    const subject = token[0] === "Y" ? "years" : "days of the month";
    return `Use \`${token.toLowerCase()}\` instead of \`${token}\` (in \`${format2}\`) for formatting ${subject} to the input \`${input}\`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md`;
  }
  const formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g;
  const longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
  const escapedStringRegExp = /^'([^]*?)'?$/;
  const doubleQuoteRegExp = /''/g;
  const unescapedLatinCharacterRegExp = /[a-zA-Z]/;
  function format(date, formatStr, options) {
    var _a2, _b2, _c2, _d, _e, _f, _g, _h, _i;
    const defaultOptions2 = getDefaultOptions();
    const locale = (_a2 = defaultOptions2.locale) != null ? _a2 : enUS;
    const firstWeekContainsDate = (_e = (_d = defaultOptions2.firstWeekContainsDate) != null ? _d : (_c2 = (_b2 = defaultOptions2.locale) == null ? void 0 : _b2.options) == null ? void 0 : _c2.firstWeekContainsDate) != null ? _e : 1;
    const weekStartsOn = (_i = (_h = defaultOptions2.weekStartsOn) != null ? _h : (_g = (_f = defaultOptions2.locale) == null ? void 0 : _f.options) == null ? void 0 : _g.weekStartsOn) != null ? _i : 0;
    const originalDate = toDate(date, options == null ? void 0 : options.in);
    if (!isValid(originalDate)) {
      throw new RangeError("Invalid time value");
    }
    let parts = formatStr.match(longFormattingTokensRegExp).map((substring) => {
      const firstCharacter = substring[0];
      if (firstCharacter === "p" || firstCharacter === "P") {
        const longFormatter = longFormatters[firstCharacter];
        return longFormatter(substring, locale.formatLong);
      }
      return substring;
    }).join("").match(formattingTokensRegExp).map((substring) => {
      if (substring === "''") {
        return { isToken: false, value: "'" };
      }
      const firstCharacter = substring[0];
      if (firstCharacter === "'") {
        return { isToken: false, value: cleanEscapedString(substring) };
      }
      if (formatters[firstCharacter]) {
        return { isToken: true, value: substring };
      }
      if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
        throw new RangeError(
          "Format string contains an unescaped latin alphabet character `" + firstCharacter + "`"
        );
      }
      return { isToken: false, value: substring };
    });
    if (locale.localize.preprocessor) {
      parts = locale.localize.preprocessor(originalDate, parts);
    }
    const formatterOptions = {
      firstWeekContainsDate,
      weekStartsOn,
      locale
    };
    return parts.map((part) => {
      if (!part.isToken) return part.value;
      const token = part.value;
      if (isProtectedWeekYearToken(token) || isProtectedDayOfYearToken(token)) {
        warnOrThrowProtectedError(token, formatStr, String(date));
      }
      const formatter = formatters[token[0]];
      return formatter(originalDate, token, locale.localize, formatterOptions);
    }).join("");
  }
  function cleanEscapedString(input) {
    const matched = input.match(escapedStringRegExp);
    if (!matched) {
      return input;
    }
    return matched[1].replace(doubleQuoteRegExp, "'");
  }
  function subDays(date, amount, options) {
    return addDays(date, -amount, options);
  }
  function parseISO(argument, options) {
    const invalidDate = () => constructFrom(options == null ? void 0 : options.in, NaN);
    const additionalDigits = 2;
    const dateStrings = splitDateString(argument);
    let date;
    if (dateStrings.date) {
      const parseYearResult = parseYear(dateStrings.date, additionalDigits);
      date = parseDate(parseYearResult.restDateString, parseYearResult.year);
    }
    if (!date || isNaN(+date)) return invalidDate();
    const timestamp = +date;
    let time = 0;
    let offset;
    if (dateStrings.time) {
      time = parseTime(dateStrings.time);
      if (isNaN(time)) return invalidDate();
    }
    if (dateStrings.timezone) {
      offset = parseTimezone(dateStrings.timezone);
      if (isNaN(offset)) return invalidDate();
    } else {
      const tmpDate = new Date(timestamp + time);
      const result2 = toDate(0, options == null ? void 0 : options.in);
      result2.setFullYear(
        tmpDate.getUTCFullYear(),
        tmpDate.getUTCMonth(),
        tmpDate.getUTCDate()
      );
      result2.setHours(
        tmpDate.getUTCHours(),
        tmpDate.getUTCMinutes(),
        tmpDate.getUTCSeconds(),
        tmpDate.getUTCMilliseconds()
      );
      return result2;
    }
    return toDate(timestamp + time + offset, options == null ? void 0 : options.in);
  }
  const patterns = {
    dateTimeDelimiter: /[T ]/,
    timeZoneDelimiter: /[Z ]/i,
    timezone: /([Z+-].*)$/
  };
  const dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
  const timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
  const timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
  function splitDateString(dateString) {
    const dateStrings = {};
    const array = dateString.split(patterns.dateTimeDelimiter);
    let timeString;
    if (array.length > 2) {
      return dateStrings;
    }
    if (/:/.test(array[0])) {
      timeString = array[0];
    } else {
      dateStrings.date = array[0];
      timeString = array[1];
      if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
        dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
        timeString = dateString.substr(
          dateStrings.date.length,
          dateString.length
        );
      }
    }
    if (timeString) {
      const token = patterns.timezone.exec(timeString);
      if (token) {
        dateStrings.time = timeString.replace(token[1], "");
        dateStrings.timezone = token[1];
      } else {
        dateStrings.time = timeString;
      }
    }
    return dateStrings;
  }
  function parseYear(dateString, additionalDigits) {
    const regex = new RegExp(
      "^(?:(\\d{4}|[+-]\\d{" + (4 + additionalDigits) + "})|(\\d{2}|[+-]\\d{" + (2 + additionalDigits) + "})$)"
    );
    const captures = dateString.match(regex);
    if (!captures) return { year: NaN, restDateString: "" };
    const year = captures[1] ? parseInt(captures[1]) : null;
    const century = captures[2] ? parseInt(captures[2]) : null;
    return {
      year: century === null ? year : century * 100,
      restDateString: dateString.slice((captures[1] || captures[2]).length)
    };
  }
  function parseDate(dateString, year) {
    if (year === null) return /* @__PURE__ */ new Date(NaN);
    const captures = dateString.match(dateRegex);
    if (!captures) return /* @__PURE__ */ new Date(NaN);
    const isWeekDate = !!captures[4];
    const dayOfYear = parseDateUnit(captures[1]);
    const month = parseDateUnit(captures[2]) - 1;
    const day = parseDateUnit(captures[3]);
    const week = parseDateUnit(captures[4]);
    const dayOfWeek = parseDateUnit(captures[5]) - 1;
    if (isWeekDate) {
      if (!validateWeekDate(year, week, dayOfWeek)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      return dayOfISOWeekYear(year, week, dayOfWeek);
    } else {
      const date = /* @__PURE__ */ new Date(0);
      if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
        return /* @__PURE__ */ new Date(NaN);
      }
      date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
      return date;
    }
  }
  function parseDateUnit(value) {
    return value ? parseInt(value) : 1;
  }
  function parseTime(timeString) {
    const captures = timeString.match(timeRegex);
    if (!captures) return NaN;
    const hours = parseTimeUnit(captures[1]);
    const minutes = parseTimeUnit(captures[2]);
    const seconds = parseTimeUnit(captures[3]);
    if (!validateTime(hours, minutes, seconds)) {
      return NaN;
    }
    return hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * 1e3;
  }
  function parseTimeUnit(value) {
    return value && parseFloat(value.replace(",", ".")) || 0;
  }
  function parseTimezone(timezoneString) {
    if (timezoneString === "Z") return 0;
    const captures = timezoneString.match(timezoneRegex);
    if (!captures) return 0;
    const sign = captures[1] === "+" ? -1 : 1;
    const hours = parseInt(captures[2]);
    const minutes = captures[3] && parseInt(captures[3]) || 0;
    if (!validateTimezone(hours, minutes)) {
      return NaN;
    }
    return sign * (hours * millisecondsInHour + minutes * millisecondsInMinute);
  }
  function dayOfISOWeekYear(isoWeekYear, week, day) {
    const date = /* @__PURE__ */ new Date(0);
    date.setUTCFullYear(isoWeekYear, 0, 4);
    const fourthOfJanuaryDay = date.getUTCDay() || 7;
    const diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
    date.setUTCDate(date.getUTCDate() + diff);
    return date;
  }
  const daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function isLeapYearIndex(year) {
    return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
  }
  function validateDate(year, month, date) {
    return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
  }
  function validateDayOfYearDate(year, dayOfYear) {
    return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
  }
  function validateWeekDate(_year, week, day) {
    return week >= 1 && week <= 53 && day >= 0 && day <= 6;
  }
  function validateTime(hours, minutes, seconds) {
    if (hours === 24) {
      return minutes === 0 && seconds === 0;
    }
    return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
  }
  function validateTimezone(_hours, minutes) {
    return minutes >= 0 && minutes <= 59;
  }
  function startOfToday(options) {
    return startOfDay(Date.now(), options);
  }
  function startOfYesterday(options) {
    const now = constructNow(options == null ? void 0 : options.in);
    const year = now.getFullYear();
    const month = now.getMonth();
    const day = now.getDate();
    const date = constructNow(options == null ? void 0 : options.in);
    date.setFullYear(year, month, day - 1);
    date.setHours(0, 0, 0, 0);
    return date;
  }
  function subMonths(date, amount, options) {
    return addMonths(date, -amount, options);
  }
  function subWeeks(date, amount, options) {
    return addWeeks(date, -amount, options);
  }
  function subYears(date, amount, options) {
    return addYears(date, -amount, options);
  }
  const _HistoryTool = class _HistoryTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.HISTORY);
    }
    /**
     * Parse a date string into milliseconds since epoch.
     * Returns null if the date string is invalid.
     * Supports:
     *  - ISO date strings (e.g., "2023-10-31", "2023-10-31T14:30:00.000Z")
     *  - Relative times: "1 day ago", "2 weeks ago", "3 months ago", "1 year ago"
     *  - Special keywords: "now", "today", "yesterday"
     */
    parseDateString(dateStr) {
      if (!dateStr) {
        return null;
      }
      const now = /* @__PURE__ */ new Date();
      const lowerDateStr = dateStr.toLowerCase().trim();
      if (lowerDateStr === "now") return now.getTime();
      if (lowerDateStr === "today") return startOfToday().getTime();
      if (lowerDateStr === "yesterday") return startOfYesterday().getTime();
      const relativeMatch = lowerDateStr.match(
        /^(\d+)\s+(day|days|week|weeks|month|months|year|years)\s+ago$/
      );
      if (relativeMatch) {
        const amount = parseInt(relativeMatch[1], 10);
        const unit = relativeMatch[2];
        let resultDate;
        if (unit.startsWith("day")) resultDate = subDays(now, amount);
        else if (unit.startsWith("week")) resultDate = subWeeks(now, amount);
        else if (unit.startsWith("month")) resultDate = subMonths(now, amount);
        else if (unit.startsWith("year")) resultDate = subYears(now, amount);
        else return null;
        return resultDate.getTime();
      }
      let parsedDate = parseISO(dateStr);
      if (isValid(parsedDate)) {
        return parsedDate.getTime();
      }
      parsedDate = new Date(dateStr);
      if (isValid(parsedDate) && dateStr.includes(parsedDate.getFullYear().toString())) {
        return parsedDate.getTime();
      }
      console.warn(`Could not parse date string: ${dateStr}`);
      return null;
    }
    /**
     * Format a timestamp as a human-readable date string
     */
    formatDate(timestamp) {
      return format(timestamp, "yyyy-MM-dd HH:mm:ss");
    }
    execute(args) {
      return __async(this, null, function* () {
        try {
          console.log("Executing HistoryTool with args:", args);
          const {
            text = "",
            maxResults = 100,
            // Default to 100 results
            excludeCurrentTabs = false
          } = args;
          const now = Date.now();
          let startTimeMs;
          let endTimeMs;
          if (args.startTime) {
            const parsedStart = this.parseDateString(args.startTime);
            if (parsedStart === null) {
              return createErrorResponse(
                `Invalid format for start time: "${args.startTime}". Supported formats: ISO (YYYY-MM-DD), "today", "yesterday", "X days/weeks/months/years ago".`
              );
            }
            startTimeMs = parsedStart;
          } else {
            startTimeMs = now - _HistoryTool.ONE_DAY_MS;
          }
          if (args.endTime) {
            const parsedEnd = this.parseDateString(args.endTime);
            if (parsedEnd === null) {
              return createErrorResponse(
                `Invalid format for end time: "${args.endTime}". Supported formats: ISO (YYYY-MM-DD), "today", "yesterday", "X days/weeks/months/years ago".`
              );
            }
            endTimeMs = parsedEnd;
          } else {
            endTimeMs = now;
          }
          if (startTimeMs > endTimeMs) {
            return createErrorResponse("Start time cannot be after end time.");
          }
          console.log(
            `Searching history from ${this.formatDate(startTimeMs)} to ${this.formatDate(endTimeMs)} for query "${text}"`
          );
          const historyItems = yield chrome.history.search({
            text,
            startTime: startTimeMs,
            endTime: endTimeMs,
            maxResults
          });
          console.log(`Found ${historyItems.length} history items before filtering current tabs.`);
          let filteredItems = historyItems;
          if (excludeCurrentTabs && historyItems.length > 0) {
            const currentTabs = yield chrome.tabs.query({});
            const openUrls = /* @__PURE__ */ new Set();
            currentTabs.forEach((tab) => {
              if (tab.url) {
                openUrls.add(tab.url);
              }
            });
            if (openUrls.size > 0) {
              filteredItems = historyItems.filter((item) => !(item.url && openUrls.has(item.url)));
              console.log(
                `Filtered out ${historyItems.length - filteredItems.length} items that are currently open. ${filteredItems.length} items remaining.`
              );
            }
          }
          const result2 = {
            items: filteredItems.map((item) => ({
              id: item.id,
              url: item.url,
              title: item.title,
              lastVisitTime: item.lastVisitTime,
              visitCount: item.visitCount,
              typedCount: item.typedCount
            })),
            totalCount: filteredItems.length,
            timeRange: {
              startTime: startTimeMs,
              endTime: endTimeMs,
              startTimeFormatted: this.formatDate(startTimeMs),
              endTimeFormatted: this.formatDate(endTimeMs)
            }
          };
          if (text) {
            result2.query = text;
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2, null, 2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in HistoryTool.execute:", error);
          return createErrorResponse(
            `Error retrieving browsing history: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  };
  __publicField2(_HistoryTool, "ONE_DAY_MS", 24 * 60 * 60 * 1e3);
  let HistoryTool = _HistoryTool;
  const historyTool = new HistoryTool();
  background;
  const fallbackMessages = {
    // Extension metadata
    extensionName: "chrome-mcp-server",
    extensionDescription: "Exposes browser capabilities with your own chrome",
    // Section headers
    nativeServerConfigLabel: "Native Server Configuration",
    semanticEngineLabel: "Semantic Engine",
    embeddingModelLabel: "Embedding Model",
    indexDataManagementLabel: "Index Data Management",
    modelCacheManagementLabel: "Model Cache Management",
    // Status labels
    statusLabel: "Status",
    runningStatusLabel: "Running Status",
    connectionStatusLabel: "Connection Status",
    lastUpdatedLabel: "Last Updated:",
    // Connection states
    connectButton: "Connect",
    disconnectButton: "Disconnect",
    connectingStatus: "Connecting...",
    connectedStatus: "Connected",
    disconnectedStatus: "Disconnected",
    detectingStatus: "Detecting...",
    // Server states
    serviceRunningStatus: "Service Running (Port: {0})",
    serviceNotConnectedStatus: "Service Not Connected",
    connectedServiceNotStartedStatus: "Connected, Service Not Started",
    // Configuration labels
    mcpServerConfigLabel: "MCP Server Configuration",
    connectionPortLabel: "Connection Port",
    refreshStatusButton: "Refresh Status",
    copyConfigButton: "Copy Configuration",
    // Action buttons
    retryButton: "Retry",
    cancelButton: "Cancel",
    confirmButton: "Confirm",
    saveButton: "Save",
    closeButton: "Close",
    resetButton: "Reset",
    // Progress states
    initializingStatus: "Initializing...",
    processingStatus: "Processing...",
    loadingStatus: "Loading...",
    clearingStatus: "Clearing...",
    cleaningStatus: "Cleaning...",
    downloadingStatus: "Downloading...",
    // Semantic engine states
    semanticEngineReadyStatus: "Semantic Engine Ready",
    semanticEngineInitializingStatus: "Semantic Engine Initializing...",
    semanticEngineInitFailedStatus: "Semantic Engine Initialization Failed",
    semanticEngineNotInitStatus: "Semantic Engine Not Initialized",
    initSemanticEngineButton: "Initialize Semantic Engine",
    reinitializeButton: "Reinitialize",
    // Model states
    downloadingModelStatus: "Downloading Model... {0}%",
    switchingModelStatus: "Switching Model...",
    modelLoadedStatus: "Model Loaded",
    modelFailedStatus: "Model Failed to Load",
    // Model descriptions
    lightweightModelDescription: "Lightweight Multilingual Model",
    betterThanSmallDescription: "Slightly larger than e5-small, but better performance",
    multilingualModelDescription: "Multilingual Semantic Model",
    // Performance levels
    fastPerformance: "Fast",
    balancedPerformance: "Balanced",
    accuratePerformance: "Accurate",
    // Error messages
    networkErrorMessage: "Network connection error, please check network and retry",
    modelCorruptedErrorMessage: "Model file corrupted or incomplete, please retry download",
    unknownErrorMessage: "Unknown error, please check if your network can access HuggingFace",
    permissionDeniedErrorMessage: "Permission denied",
    timeoutErrorMessage: "Operation timed out",
    // Data statistics
    indexedPagesLabel: "Indexed Pages",
    indexSizeLabel: "Index Size",
    activeTabsLabel: "Active Tabs",
    vectorDocumentsLabel: "Vector Documents",
    cacheSizeLabel: "Cache Size",
    cacheEntriesLabel: "Cache Entries",
    // Data management
    clearAllDataButton: "Clear All Data",
    clearAllCacheButton: "Clear All Cache",
    cleanExpiredCacheButton: "Clean Expired Cache",
    exportDataButton: "Export Data",
    importDataButton: "Import Data",
    // Dialog titles
    confirmClearDataTitle: "Confirm Clear Data",
    settingsTitle: "Settings",
    aboutTitle: "About",
    helpTitle: "Help",
    // Dialog messages
    clearDataWarningMessage: "This operation will clear all indexed webpage content and vector data, including:",
    clearDataList1: "All webpage text content index",
    clearDataList2: "Vector embedding data",
    clearDataList3: "Search history and cache",
    clearDataIrreversibleWarning: "This operation is irreversible! After clearing, you need to browse webpages again to rebuild the index.",
    confirmClearButton: "Confirm Clear",
    // Cache states
    cacheDetailsLabel: "Cache Details",
    noCacheDataMessage: "No cache data",
    loadingCacheInfoStatus: "Loading cache information...",
    processingCacheStatus: "Processing cache...",
    expiredLabel: "Expired",
    // Browser integration
    bookmarksBarLabel: "Bookmarks Bar",
    newTabLabel: "New Tab",
    currentPageLabel: "Current Page",
    // Accessibility
    menuLabel: "Menu",
    navigationLabel: "Navigation",
    mainContentLabel: "Main Content",
    // Future features
    languageSelectorLabel: "Language",
    themeLabel: "Theme",
    lightTheme: "Light",
    darkTheme: "Dark",
    autoTheme: "Auto",
    advancedSettingsLabel: "Advanced Settings",
    debugModeLabel: "Debug Mode",
    verboseLoggingLabel: "Verbose Logging",
    // Notifications
    successNotification: "Operation completed successfully",
    warningNotification: "Warning: Please review before proceeding",
    infoNotification: "Information",
    configCopiedNotification: "Configuration copied to clipboard",
    dataClearedNotification: "Data cleared successfully",
    // Units
    bytesUnit: "bytes",
    kilobytesUnit: "KB",
    megabytesUnit: "MB",
    gigabytesUnit: "GB",
    itemsUnit: "items",
    pagesUnit: "pages",
    // Legacy keys for backwards compatibility
    nativeServerConfig: "Native Server Configuration",
    runningStatus: "Running Status",
    refreshStatus: "Refresh Status",
    lastUpdated: "Last Updated:",
    mcpServerConfig: "MCP Server Configuration",
    connectionPort: "Connection Port",
    connecting: "Connecting...",
    disconnect: "Disconnect",
    connect: "Connect",
    semanticEngine: "Semantic Engine",
    embeddingModel: "Embedding Model",
    retry: "Retry",
    indexDataManagement: "Index Data Management",
    clearing: "Clearing...",
    clearAllData: "Clear All Data",
    copyConfig: "Copy Configuration",
    serviceRunning: "Service Running (Port: {0})",
    connectedServiceNotStarted: "Connected, Service Not Started",
    serviceNotConnected: "Service Not Connected",
    detecting: "Detecting...",
    lightweightModel: "Lightweight Multilingual Model",
    betterThanSmall: "Slightly larger than e5-small, but better performance",
    multilingualModel: "Multilingual Semantic Model",
    fast: "Fast",
    balanced: "Balanced",
    accurate: "Accurate",
    semanticEngineReady: "Semantic Engine Ready",
    semanticEngineInitializing: "Semantic Engine Initializing...",
    semanticEngineInitFailed: "Semantic Engine Initialization Failed",
    semanticEngineNotInit: "Semantic Engine Not Initialized",
    downloadingModel: "Downloading Model... {0}%",
    switchingModel: "Switching Model...",
    networkError: "Network connection error, please check network and retry",
    modelCorrupted: "Model file corrupted or incomplete, please retry download",
    unknownError: "Unknown error, please check if your network can access HuggingFace",
    reinitialize: "Reinitialize",
    initializing: "Initializing...",
    initSemanticEngine: "Initialize Semantic Engine",
    indexedPages: "Indexed Pages",
    indexSize: "Index Size",
    activeTabs: "Active Tabs",
    vectorDocuments: "Vector Documents",
    confirmClearData: "Confirm Clear Data",
    clearDataWarning: "This operation will clear all indexed webpage content and vector data, including:",
    clearDataIrreversible: "This operation is irreversible! After clearing, you need to browse webpages again to rebuild the index.",
    confirmClear: "Confirm Clear",
    cancel: "Cancel",
    confirm: "Confirm",
    processing: "Processing...",
    modelCacheManagement: "Model Cache Management",
    cacheSize: "Cache Size",
    cacheEntries: "Cache Entries",
    cacheDetails: "Cache Details",
    noCacheData: "No cache data",
    loadingCacheInfo: "Loading cache information...",
    processingCache: "Processing cache...",
    cleaning: "Cleaning...",
    cleanExpiredCache: "Clean Expired Cache",
    clearAllCache: "Clear All Cache",
    expired: "Expired",
    bookmarksBar: "Bookmarks Bar"
  };
  function getMessage(key, substitutions) {
    try {
      if (typeof chrome !== "undefined" && chrome.i18n && chrome.i18n.getMessage) {
        const message2 = chrome.i18n.getMessage(key, substitutions);
        if (message2) {
          return message2;
        }
      }
    } catch (error) {
      console.warn(`Failed to get i18n message for key "${key}":`, error);
    }
    let fallback = fallbackMessages[key];
    return fallback;
  }
  background;
  function getBookmarkFolderPath(bookmarkNodeId) {
    return __async(this, null, function* () {
      const pathParts = [];
      try {
        const initialNodes = yield chrome.bookmarks.get(bookmarkNodeId);
        if (initialNodes.length > 0 && initialNodes[0]) {
          const initialNode = initialNodes[0];
          let pathNodeId = initialNode.parentId;
          while (pathNodeId) {
            const parentNodes = yield chrome.bookmarks.get(pathNodeId);
            if (parentNodes.length === 0) break;
            const parentNode = parentNodes[0];
            if (parentNode.title) {
              pathParts.unshift(parentNode.title);
            }
            if (!parentNode.parentId) break;
            pathNodeId = parentNode.parentId;
          }
        }
      } catch (error) {
        console.error(`Error getting bookmark path for node ID ${bookmarkNodeId}:`, error);
        return pathParts.join(" > ") || "Error getting path";
      }
      return pathParts.join(" > ");
    });
  }
  function findFolderByPathOrId(pathOrId) {
    return __async(this, null, function* () {
      try {
        const nodes = yield chrome.bookmarks.get(pathOrId);
        if (nodes && nodes.length > 0 && !nodes[0].url) {
          return nodes[0];
        }
      } catch (e) {
      }
      const pathParts = pathOrId.split("/").map((p) => p.trim()).filter((p) => p.length > 0);
      if (pathParts.length === 0) return null;
      const rootChildren = yield chrome.bookmarks.getChildren("0");
      let currentNodes = rootChildren;
      let foundFolder = null;
      for (let i = 0; i < pathParts.length; i++) {
        const part = pathParts[i];
        foundFolder = null;
        let matchedNodeThisLevel = null;
        for (const node of currentNodes) {
          if (!node.url && node.title.toLowerCase() === part.toLowerCase()) {
            matchedNodeThisLevel = node;
            break;
          }
        }
        if (matchedNodeThisLevel) {
          if (i === pathParts.length - 1) {
            foundFolder = matchedNodeThisLevel;
          } else {
            currentNodes = yield chrome.bookmarks.getChildren(matchedNodeThisLevel.id);
          }
        } else {
          return null;
        }
      }
      return foundFolder;
    });
  }
  function createFolderPath(folderPath, parentId) {
    return __async(this, null, function* () {
      const pathParts = folderPath.split("/").map((p) => p.trim()).filter((p) => p.length > 0);
      if (pathParts.length === 0) {
        throw new Error("Folder path cannot be empty");
      }
      let currentParentId = "";
      if (!currentParentId) {
        const rootChildren = yield chrome.bookmarks.getChildren("0");
        const bookmarkBarFolder = rootChildren.find(
          (node) => !node.url && (node.title === getMessage("bookmarksBarLabel") || node.title === "Bookmarks bar" || node.title === "Bookmarks Bar")
        );
        currentParentId = (bookmarkBarFolder == null ? void 0 : bookmarkBarFolder.id) || "1";
      }
      let currentFolder = null;
      for (const folderName of pathParts) {
        const children = yield chrome.bookmarks.getChildren(currentParentId);
        const existingFolder = children.find(
          (child) => !child.url && child.title.toLowerCase() === folderName.toLowerCase()
        );
        if (existingFolder) {
          currentFolder = existingFolder;
          currentParentId = existingFolder.id;
        } else {
          currentFolder = yield chrome.bookmarks.create({
            parentId: currentParentId,
            title: folderName
          });
          currentParentId = currentFolder.id;
        }
      }
      if (!currentFolder) {
        throw new Error("Failed to create folder path");
      }
      return currentFolder;
    });
  }
  function flattenBookmarkNodesToBookmarks(nodes) {
    const result2 = [];
    const stack2 = [...nodes];
    while (stack2.length > 0) {
      const node = stack2.pop();
      if (!node) continue;
      if (node.url) {
        result2.push(node);
      }
      if (node.children) {
        for (let i = node.children.length - 1; i >= 0; i--) {
          stack2.push(node.children[i]);
        }
      }
    }
    return result2;
  }
  function findBookmarksByUrl(url, title) {
    return __async(this, null, function* () {
      const searchResults = yield chrome.bookmarks.search({ url });
      if (!title) {
        return searchResults;
      }
      const titleLower = title.toLowerCase();
      return searchResults.filter(
        (bookmark) => bookmark.title && bookmark.title.toLowerCase().includes(titleLower)
      );
    });
  }
  class BookmarkSearchTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.BOOKMARK_SEARCH);
    }
    /**
     * Execute bookmark search
     */
    execute(args) {
      return __async(this, null, function* () {
        const { query = "", maxResults = 50, folderPath } = args;
        console.log(
          `BookmarkSearchTool: Searching bookmarks, keywords: "${query}", folder path: "${folderPath}"`
        );
        try {
          let bookmarksToSearch = [];
          let targetFolderNode = null;
          if (folderPath) {
            targetFolderNode = yield findFolderByPathOrId(folderPath);
            if (!targetFolderNode) {
              return createErrorResponse(`Specified folder not found: "${folderPath}"`);
            }
            const subTree = yield chrome.bookmarks.getSubTree(targetFolderNode.id);
            bookmarksToSearch = subTree.length > 0 ? flattenBookmarkNodesToBookmarks(subTree[0].children || []) : [];
          }
          let filteredBookmarks;
          if (query) {
            if (targetFolderNode) {
              const lowerCaseQuery = query.toLowerCase();
              filteredBookmarks = bookmarksToSearch.filter(
                (bookmark) => bookmark.title && bookmark.title.toLowerCase().includes(lowerCaseQuery) || bookmark.url && bookmark.url.toLowerCase().includes(lowerCaseQuery)
              );
            } else {
              filteredBookmarks = yield chrome.bookmarks.search({ query });
              filteredBookmarks = filteredBookmarks.filter((item) => !!item.url);
            }
          } else {
            if (!targetFolderNode) {
              const tree = yield chrome.bookmarks.getTree();
              bookmarksToSearch = flattenBookmarkNodesToBookmarks(tree);
            }
            filteredBookmarks = bookmarksToSearch;
          }
          const limitedResults = filteredBookmarks.slice(0, maxResults);
          const resultsWithPath = yield Promise.all(
            limitedResults.map((bookmark) => __async(null, null, function* () {
              const path = yield getBookmarkFolderPath(bookmark.id);
              return {
                id: bookmark.id,
                title: bookmark.title,
                url: bookmark.url,
                dateAdded: bookmark.dateAdded,
                folderPath: path
              };
            }))
          );
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(
                  {
                    success: true,
                    totalResults: resultsWithPath.length,
                    query: query || null,
                    folderSearched: targetFolderNode ? targetFolderNode.title || targetFolderNode.id : "All bookmarks",
                    bookmarks: resultsWithPath
                  },
                  null,
                  2
                )
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error searching bookmarks:", error);
          return createErrorResponse(
            `Error searching bookmarks: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  class BookmarkAddTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.BOOKMARK_ADD);
    }
    /**
     * Execute add bookmark operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const { url, title, parentId, createFolder = false } = args;
        console.log(`BookmarkAddTool: Adding bookmark, options:`, args);
        try {
          let bookmarkUrl = url;
          let bookmarkTitle = title;
          if (!bookmarkUrl) {
            const tabs = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (!tabs[0] || !tabs[0].url) {
              return createErrorResponse("No active tab with valid URL found, and no URL provided");
            }
            bookmarkUrl = tabs[0].url;
            if (!bookmarkTitle) {
              bookmarkTitle = tabs[0].title || bookmarkUrl;
            }
          }
          if (!bookmarkUrl) {
            return createErrorResponse("URL is required to create bookmark");
          }
          let actualParentId = void 0;
          if (parentId) {
            let folderNode = yield findFolderByPathOrId(parentId);
            if (!folderNode && createFolder) {
              try {
                folderNode = yield createFolderPath(parentId);
              } catch (createError) {
                return createErrorResponse(
                  `Failed to create folder path: ${createError instanceof Error ? createError.message : String(createError)}`
                );
              }
            }
            if (folderNode) {
              actualParentId = folderNode.id;
            } else {
              try {
                const nodes = yield chrome.bookmarks.get(parentId);
                if (nodes && nodes.length > 0 && !nodes[0].url) {
                  actualParentId = nodes[0].id;
                } else {
                  return createErrorResponse(
                    `Specified parent folder (ID/path: "${parentId}") not found or is not a folder${createFolder ? ", and creation failed" : ". You can set createFolder=true to auto-create folders"}`
                  );
                }
              } catch (e) {
                return createErrorResponse(
                  `Specified parent folder (ID/path: "${parentId}") not found or invalid${createFolder ? ", and creation failed" : ". You can set createFolder=true to auto-create folders"}`
                );
              }
            }
          } else {
            const rootChildren = yield chrome.bookmarks.getChildren("0");
            const bookmarkBarFolder = rootChildren.find(
              (node) => !node.url && (node.title === getMessage("bookmarksBarLabel") || node.title === "Bookmarks bar" || node.title === "Bookmarks Bar")
            );
            actualParentId = (bookmarkBarFolder == null ? void 0 : bookmarkBarFolder.id) || "1";
          }
          const newBookmark = yield chrome.bookmarks.create({
            parentId: actualParentId,
            // If undefined, API uses default value
            title: bookmarkTitle || bookmarkUrl,
            // Ensure title is never empty
            url: bookmarkUrl
          });
          const path = yield getBookmarkFolderPath(newBookmark.id);
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(
                  {
                    success: true,
                    message: "Bookmark added successfully",
                    bookmark: {
                      id: newBookmark.id,
                      title: newBookmark.title,
                      url: newBookmark.url,
                      dateAdded: newBookmark.dateAdded,
                      folderPath: path
                    },
                    folderCreated: createFolder && parentId ? "Folder created if necessary" : false
                  },
                  null,
                  2
                )
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error adding bookmark:", error);
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (errorMessage.includes("Can't bookmark URLs of type")) {
            return createErrorResponse(
              `Error adding bookmark: Cannot bookmark this type of URL (e.g., chrome:// system pages). ${errorMessage}`
            );
          }
          return createErrorResponse(`Error adding bookmark: ${errorMessage}`);
        }
      });
    }
  }
  class BookmarkDeleteTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.BOOKMARK_DELETE);
    }
    /**
     * Execute delete bookmark operation
     */
    execute(args) {
      return __async(this, null, function* () {
        const { bookmarkId, url, title } = args;
        console.log(`BookmarkDeleteTool: Deleting bookmark, options:`, args);
        if (!bookmarkId && !url) {
          return createErrorResponse("Must provide bookmark ID or URL to delete bookmark");
        }
        try {
          let bookmarksToDelete = [];
          if (bookmarkId) {
            try {
              const nodes = yield chrome.bookmarks.get(bookmarkId);
              if (nodes && nodes.length > 0 && nodes[0].url) {
                bookmarksToDelete = nodes;
              } else {
                return createErrorResponse(
                  `Bookmark with ID "${bookmarkId}" not found, or the ID does not correspond to a bookmark`
                );
              }
            } catch (error) {
              return createErrorResponse(`Invalid bookmark ID: "${bookmarkId}"`);
            }
          } else if (url) {
            bookmarksToDelete = yield findBookmarksByUrl(url, title);
            if (bookmarksToDelete.length === 0) {
              return createErrorResponse(
                `No bookmark found with URL "${url}"${title ? ` (title contains: "${title}")` : ""}`
              );
            }
          }
          const deletedBookmarks = [];
          const errors = [];
          for (const bookmark of bookmarksToDelete) {
            try {
              const path = yield getBookmarkFolderPath(bookmark.id);
              yield chrome.bookmarks.remove(bookmark.id);
              deletedBookmarks.push({
                id: bookmark.id,
                title: bookmark.title,
                url: bookmark.url,
                folderPath: path
              });
            } catch (error) {
              const errorMsg = error instanceof Error ? error.message : String(error);
              errors.push(
                `Failed to delete bookmark "${bookmark.title}" (ID: ${bookmark.id}): ${errorMsg}`
              );
            }
          }
          if (deletedBookmarks.length === 0) {
            return createErrorResponse(`Failed to delete bookmarks: ${errors.join("; ")}`);
          }
          const result2 = {
            success: true,
            message: `Successfully deleted ${deletedBookmarks.length} bookmark(s)`,
            deletedBookmarks
          };
          if (errors.length > 0) {
            result2.partialSuccess = true;
            result2.errors = errors;
          }
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2, null, 2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error deleting bookmark:", error);
          return createErrorResponse(
            `Error deleting bookmark: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  const bookmarkSearchTool = new BookmarkSearchTool();
  const bookmarkAddTool = new BookmarkAddTool();
  const bookmarkDeleteTool = new BookmarkDeleteTool();
  background;
  const injectedTabs = /* @__PURE__ */ new Map();
  class InjectScriptTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.INJECT_SCRIPT);
    }
    execute(args) {
      return __async(this, null, function* () {
        try {
          const { url, type, jsScript } = args;
          let tab;
          if (!type || !jsScript) {
            return createErrorResponse("Param [type] and [jsScript] is required");
          }
          if (url) {
            console.log(`Checking if URL is already open: ${url}`);
            const allTabs = yield chrome.tabs.query({});
            const matchingTabs = allTabs.filter((t) => {
              var _a2;
              const tabUrl = ((_a2 = t.url) == null ? void 0 : _a2.endsWith("/")) ? t.url.slice(0, -1) : t.url;
              const targetUrl = url.endsWith("/") ? url.slice(0, -1) : url;
              return tabUrl === targetUrl;
            });
            if (matchingTabs.length > 0) {
              tab = matchingTabs[0];
              console.log(`Found existing tab with URL: ${url}, tab ID: ${tab.id}`);
            } else {
              console.log(`No existing tab found with URL: ${url}, creating new tab`);
              tab = yield chrome.tabs.create({ url, active: true });
              console.log("Waiting for page to load...");
              yield new Promise((resolve) => setTimeout(resolve, 3e3));
            }
          } else {
            const tabs = yield chrome.tabs.query({ active: true });
            if (!tabs[0]) {
              return createErrorResponse("No active tab found");
            }
            tab = tabs[0];
          }
          if (!tab.id) {
            return createErrorResponse("Tab has no ID");
          }
          yield chrome.tabs.update(tab.id, { active: true });
          const res = yield handleInject(tab.id, __spreadValues({}, args));
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(res)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in InjectScriptTool.execute:", error);
          return createErrorResponse(
            `Inject script error: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  class SendCommandToInjectScriptTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.SEND_COMMAND_TO_INJECT_SCRIPT);
    }
    execute(args) {
      return __async(this, null, function* () {
        try {
          const { tabId, eventName, payload } = args;
          if (!eventName) {
            return createErrorResponse("Param [eventName] is required");
          }
          if (tabId) {
            const tabExists = yield isTabExists(tabId);
            if (!tabExists) {
              return createErrorResponse("The tab:[tabId] is not exists");
            }
          }
          let finalTabId = tabId;
          if (finalTabId === void 0) {
            const tabs = yield chrome.tabs.query({ active: true });
            if (!tabs[0]) {
              return createErrorResponse("No active tab found");
            }
            finalTabId = tabs[0].id;
          }
          if (!finalTabId) {
            return createErrorResponse("No active tab found");
          }
          if (!injectedTabs.has(finalTabId)) {
            throw new Error("No script injected in this tab.");
          }
          const result2 = yield chrome.tabs.sendMessage(finalTabId, {
            action: eventName,
            payload,
            targetWorld: injectedTabs.get(finalTabId).type
            // The bridge uses this to decide whether to forward to MAIN world.
          });
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("Error in InjectScriptTool.execute:", error);
          return createErrorResponse(
            `Inject script error: ${error instanceof Error ? error.message : String(error)}`
          );
        }
      });
    }
  }
  function isTabExists(tabId) {
    return __async(this, null, function* () {
      try {
        yield chrome.tabs.get(tabId);
        return true;
      } catch (error) {
        return false;
      }
    });
  }
  function handleInject(tabId, scriptConfig) {
    return __async(this, null, function* () {
      if (injectedTabs.has(tabId)) {
        console.log(`Tab ${tabId} already has injections. Cleaning up first.`);
        yield handleCleanup(tabId);
      }
      const { type, jsScript } = scriptConfig;
      const hasMain = type === ExecutionWorld.MAIN;
      if (hasMain) {
        yield chrome.scripting.executeScript({
          target: { tabId },
          files: ["inject-scripts/inject-bridge.js"],
          world: ExecutionWorld.ISOLATED
        });
        yield chrome.scripting.executeScript({
          target: { tabId },
          func: (code) => new Function(code)(),
          args: [jsScript],
          world: ExecutionWorld.MAIN
        });
      } else {
        yield chrome.scripting.executeScript({
          target: { tabId },
          func: (code) => new Function(code)(),
          args: [jsScript],
          world: ExecutionWorld.ISOLATED
        });
      }
      injectedTabs.set(tabId, scriptConfig);
      console.log(`Scripts successfully injected into tab ${tabId}.`);
      return { injected: true };
    });
  }
  function handleCleanup(tabId) {
    return __async(this, null, function* () {
      if (!injectedTabs.has(tabId)) return;
      chrome.tabs.sendMessage(tabId, { type: "chrome-mcp:cleanup" }).catch(
        (err) => console.warn(`Could not send cleanup message to tab ${tabId}. It might have been closed.`)
      );
      injectedTabs.delete(tabId);
      console.log(`Cleanup signal sent to tab ${tabId}. State cleared.`);
    });
  }
  const injectScriptTool = new InjectScriptTool();
  const sendCommandToInjectScriptTool = new SendCommandToInjectScriptTool();
  chrome.tabs.onRemoved.addListener((tabId) => {
    if (injectedTabs.has(tabId)) {
      console.log(`Tab ${tabId} closed. Cleaning up state.`);
      injectedTabs.delete(tabId);
    }
  });
  background;
  const DEBUGGER_PROTOCOL_VERSION = "1.3";
  const DEFAULT_MAX_MESSAGES = 100;
  class ConsoleTool extends BaseBrowserToolExecutor {
    constructor() {
      super(...arguments);
      __publicField2(this, "name", TOOL_NAMES.BROWSER.CONSOLE);
    }
    execute(args) {
      return __async(this, null, function* () {
        const { url, includeExceptions = true, maxMessages = DEFAULT_MAX_MESSAGES } = args;
        let targetTab;
        try {
          if (url) {
            targetTab = yield this.navigateToUrl(url);
          } else {
            const [activeTab] = yield chrome.tabs.query({ active: true, currentWindow: true });
            if (!(activeTab == null ? void 0 : activeTab.id)) {
              return createErrorResponse("No active tab found and no URL provided.");
            }
            targetTab = activeTab;
          }
          if (!(targetTab == null ? void 0 : targetTab.id)) {
            return createErrorResponse("Failed to identify target tab.");
          }
          const tabId = targetTab.id;
          const result2 = yield this.captureConsoleMessages(tabId, {
            includeExceptions,
            maxMessages
          });
          return {
            content: [
              {
                type: "text",
                text: JSON.stringify(result2)
              }
            ],
            isError: false
          };
        } catch (error) {
          console.error("ConsoleTool: Critical error during execute:", error);
          return createErrorResponse(`Error in ConsoleTool: ${error.message || String(error)}`);
        }
      });
    }
    navigateToUrl(url) {
      return __async(this, null, function* () {
        var _a2;
        const existingTabs = yield chrome.tabs.query({ url });
        if (existingTabs.length > 0 && ((_a2 = existingTabs[0]) == null ? void 0 : _a2.id)) {
          const tab = existingTabs[0];
          yield chrome.tabs.update(tab.id, { active: true });
          yield chrome.windows.update(tab.windowId, { focused: true });
          return tab;
        } else {
          const newTab = yield chrome.tabs.create({ url, active: true });
          yield this.waitForTabReady(newTab.id);
          return newTab;
        }
      });
    }
    waitForTabReady(tabId) {
      return __async(this, null, function* () {
        return new Promise((resolve) => {
          const checkTab = () => __async(null, null, function* () {
            try {
              const tab = yield chrome.tabs.get(tabId);
              if (tab.status === "complete") {
                resolve();
              } else {
                setTimeout(checkTab, 100);
              }
            } catch (error) {
              resolve();
            }
          });
          checkTab();
        });
      });
    }
    formatConsoleArgs(args) {
      if (!args || args.length === 0) return "";
      return args.map((arg) => {
        if (arg.type === "string") {
          return arg.value || "";
        } else if (arg.type === "number") {
          return String(arg.value || "");
        } else if (arg.type === "boolean") {
          return String(arg.value || "");
        } else if (arg.type === "object") {
          return arg.description || "[Object]";
        } else if (arg.type === "undefined") {
          return "undefined";
        } else if (arg.type === "function") {
          return arg.description || "[Function]";
        } else {
          return arg.description || arg.value || String(arg);
        }
      }).join(" ");
    }
    captureConsoleMessages(tabId, options) {
      return __async(this, null, function* () {
        var _a2, _b2;
        const { includeExceptions, maxMessages } = options;
        const startTime = Date.now();
        const messages = [];
        const exceptions = [];
        let limitReached = false;
        try {
          const tab = yield chrome.tabs.get(tabId);
          const targets = yield chrome.debugger.getTargets();
          const existingTarget = targets.find(
            (t) => t.tabId === tabId && t.attached && t.type === "page"
          );
          if (existingTarget && !existingTarget.extensionId) {
            throw new Error(
              `Debugger is already attached to tab ${tabId} by another tool (e.g., DevTools).`
            );
          }
          try {
            yield chrome.debugger.attach({ tabId }, DEBUGGER_PROTOCOL_VERSION);
          } catch (error) {
            if ((_a2 = error.message) == null ? void 0 : _a2.includes("Cannot attach to the target with an attached client")) {
              throw new Error(
                `Debugger is already attached to tab ${tabId}. This might be DevTools or another extension.`
              );
            }
            throw error;
          }
          const collectedMessages = [];
          const collectedExceptions = [];
          const eventListener = (source, method, params) => {
            var _a3, _b3, _c2, _d, _e, _f;
            if (source.tabId !== tabId) return;
            if (method === "Log.entryAdded" && (params == null ? void 0 : params.entry)) {
              collectedMessages.push(params.entry);
            } else if (method === "Runtime.consoleAPICalled" && params) {
              const logEntry = {
                timestamp: params.timestamp,
                level: params.type || "log",
                text: this.formatConsoleArgs(params.args || []),
                source: "console-api",
                url: (_c2 = (_b3 = (_a3 = params.stackTrace) == null ? void 0 : _a3.callFrames) == null ? void 0 : _b3[0]) == null ? void 0 : _c2.url,
                lineNumber: (_f = (_e = (_d = params.stackTrace) == null ? void 0 : _d.callFrames) == null ? void 0 : _e[0]) == null ? void 0 : _f.lineNumber,
                stackTrace: params.stackTrace,
                args: params.args
              };
              collectedMessages.push(logEntry);
            } else if (method === "Runtime.exceptionThrown" && includeExceptions && (params == null ? void 0 : params.exceptionDetails)) {
              collectedExceptions.push(params.exceptionDetails);
            }
          };
          chrome.debugger.onEvent.addListener(eventListener);
          try {
            yield chrome.debugger.sendCommand({ tabId }, "Runtime.enable");
            yield chrome.debugger.sendCommand({ tabId }, "Log.enable");
            yield new Promise((resolve) => setTimeout(resolve, 2e3));
            for (const entry of collectedMessages) {
              if (messages.length >= maxMessages) {
                limitReached = true;
                break;
              }
              const message2 = {
                timestamp: entry.timestamp,
                level: entry.level || "log",
                text: entry.text || "",
                source: entry.source,
                url: entry.url,
                lineNumber: entry.lineNumber
              };
              if (entry.stackTrace) {
                message2.stackTrace = entry.stackTrace;
              }
              if (entry.args && Array.isArray(entry.args)) {
                message2.args = entry.args;
              }
              messages.push(message2);
            }
            for (const exceptionDetails of collectedExceptions) {
              const exception = {
                timestamp: Date.now(),
                text: exceptionDetails.text || ((_b2 = exceptionDetails.exception) == null ? void 0 : _b2.description) || "Unknown exception",
                url: exceptionDetails.url,
                lineNumber: exceptionDetails.lineNumber,
                columnNumber: exceptionDetails.columnNumber
              };
              if (exceptionDetails.stackTrace) {
                exception.stackTrace = exceptionDetails.stackTrace;
              }
              exceptions.push(exception);
            }
          } finally {
            chrome.debugger.onEvent.removeListener(eventListener);
            try {
              yield chrome.debugger.sendCommand({ tabId }, "Runtime.disable");
            } catch (e) {
              console.warn(`ConsoleTool: Error disabling Runtime for tab ${tabId}:`, e);
            }
            try {
              yield chrome.debugger.sendCommand({ tabId }, "Log.disable");
            } catch (e) {
              console.warn(`ConsoleTool: Error disabling Log for tab ${tabId}:`, e);
            }
            try {
              yield chrome.debugger.detach({ tabId });
            } catch (e) {
              console.warn(`ConsoleTool: Error detaching debugger for tab ${tabId}:`, e);
            }
          }
          const endTime = Date.now();
          messages.sort((a, b) => a.timestamp - b.timestamp);
          exceptions.sort((a, b) => a.timestamp - b.timestamp);
          return {
            success: true,
            message: `Console capture completed for tab ${tabId}. ${messages.length} messages, ${exceptions.length} exceptions captured.`,
            tabId,
            tabUrl: tab.url || "",
            tabTitle: tab.title || "",
            captureStartTime: startTime,
            captureEndTime: endTime,
            totalDurationMs: endTime - startTime,
            messages,
            exceptions,
            messageCount: messages.length,
            exceptionCount: exceptions.length,
            messageLimitReached: limitReached
          };
        } catch (error) {
          console.error(`ConsoleTool: Error capturing console messages for tab ${tabId}:`, error);
          throw error;
        }
      });
    }
  }
  const consoleTool = new ConsoleTool();
  background;
  background;
  const browserTools = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    bookmarkAddTool,
    bookmarkDeleteTool,
    bookmarkSearchTool,
    clickTool,
    closeTabsTool,
    consoleTool,
    fillTool,
    getInteractiveElementsTool,
    goBackOrForwardTool,
    historyTool,
    injectScriptTool,
    keyboardTool,
    navigateTool,
    networkCaptureStartTool,
    networkCaptureStopTool,
    networkDebuggerStartTool,
    networkDebuggerStopTool,
    networkRequestTool,
    screenshotTool,
    searchTabsContentTool: vectorSearchTabsContentTool,
    sendCommandToInjectScriptTool,
    webFetcherTool,
    windowTool
  }, Symbol.toStringTag, { value: "Module" }));
  const tools = __spreadValues({}, browserTools);
  const toolsMap = new Map(Object.values(tools).map((tool) => [tool.name, tool]));
  const handleCallTool = (param) => __async(null, null, function* () {
    const tool = toolsMap.get(param.name);
    if (!tool) {
      return createErrorResponse(`Tool ${param.name} not found`);
    }
    try {
      return yield tool.execute(param.args);
    } catch (error) {
      console.error(`Tool execution failed for ${param.name}:`, error);
      return createErrorResponse(
        error instanceof Error ? error.message : ERROR_MESSAGES.TOOL_EXECUTION_FAILED
      );
    }
  });
  background;
  let nativePort = null;
  const HOST_NAME = NATIVE_HOST.NAME;
  let currentServerStatus = {
    isRunning: false,
    lastUpdated: Date.now()
  };
  function saveServerStatus(status) {
    return __async(this, null, function* () {
      try {
        yield chrome.storage.local.set({ [STORAGE_KEYS.SERVER_STATUS]: status });
      } catch (error) {
        console.error(ERROR_MESSAGES.SERVER_STATUS_SAVE_FAILED, error);
      }
    });
  }
  function loadServerStatus() {
    return __async(this, null, function* () {
      try {
        const result2 = yield chrome.storage.local.get([STORAGE_KEYS.SERVER_STATUS]);
        if (result2[STORAGE_KEYS.SERVER_STATUS]) {
          return result2[STORAGE_KEYS.SERVER_STATUS];
        }
      } catch (error) {
        console.error(ERROR_MESSAGES.SERVER_STATUS_LOAD_FAILED, error);
      }
      return {
        isRunning: false,
        lastUpdated: Date.now()
      };
    });
  }
  function broadcastServerStatusChange(status) {
    chrome.runtime.sendMessage({
      type: BACKGROUND_MESSAGE_TYPES.SERVER_STATUS_CHANGED,
      payload: status
    }).catch(() => {
    });
  }
  function connectNativeHost(port = NATIVE_HOST.DEFAULT_PORT) {
    if (nativePort) {
      return;
    }
    try {
      nativePort = chrome.runtime.connectNative(HOST_NAME);
      nativePort.onMessage.addListener((message2) => __async(null, null, function* () {
        var _a2, _b2;
        if (message2.type === NativeMessageType.PROCESS_DATA && message2.requestId) {
          const requestId = message2.requestId;
          const requestPayload = message2.payload;
          nativePort == null ? void 0 : nativePort.postMessage({
            responseToRequestId: requestId,
            payload: {
              status: "success",
              message: SUCCESS_MESSAGES.TOOL_EXECUTED,
              data: requestPayload
            }
          });
        } else if (message2.type === NativeMessageType.CALL_TOOL && message2.requestId) {
          const requestId = message2.requestId;
          try {
            const result2 = yield handleCallTool(message2.payload);
            nativePort == null ? void 0 : nativePort.postMessage({
              responseToRequestId: requestId,
              payload: {
                status: "success",
                message: SUCCESS_MESSAGES.TOOL_EXECUTED,
                data: result2
              }
            });
          } catch (error) {
            nativePort == null ? void 0 : nativePort.postMessage({
              responseToRequestId: requestId,
              payload: {
                status: "error",
                message: ERROR_MESSAGES.TOOL_EXECUTION_FAILED,
                error: error instanceof Error ? error.message : String(error)
              }
            });
          }
        } else if (message2.type === NativeMessageType.SERVER_STARTED) {
          const port2 = (_a2 = message2.payload) == null ? void 0 : _a2.port;
          currentServerStatus = {
            isRunning: true,
            port: port2,
            lastUpdated: Date.now()
          };
          yield saveServerStatus(currentServerStatus);
          broadcastServerStatusChange(currentServerStatus);
          console.log(`${SUCCESS_MESSAGES.SERVER_STARTED} on port ${port2}`);
        } else if (message2.type === NativeMessageType.SERVER_STOPPED) {
          currentServerStatus = {
            isRunning: false,
            port: currentServerStatus.port,
            // Keep last known port for reconnection
            lastUpdated: Date.now()
          };
          yield saveServerStatus(currentServerStatus);
          broadcastServerStatusChange(currentServerStatus);
          console.log(SUCCESS_MESSAGES.SERVER_STOPPED);
        } else if (message2.type === NativeMessageType.ERROR_FROM_NATIVE_HOST) {
          console.error("Error from native host:", ((_b2 = message2.payload) == null ? void 0 : _b2.message) || "Unknown error");
        }
      }));
      nativePort.onDisconnect.addListener(() => {
        console.error(ERROR_MESSAGES.NATIVE_DISCONNECTED, chrome.runtime.lastError);
        nativePort = null;
      });
      nativePort.postMessage({ type: NativeMessageType.START, payload: { port } });
    } catch (error) {
      console.error(ERROR_MESSAGES.NATIVE_CONNECTION_FAILED, error);
    }
  }
  const initNativeHostListener = () => {
    loadServerStatus().then((status) => {
      currentServerStatus = status;
    }).catch((error) => {
      console.error(ERROR_MESSAGES.SERVER_STATUS_LOAD_FAILED, error);
    });
    chrome.runtime.onStartup.addListener(connectNativeHost);
    chrome.runtime.onMessage.addListener((message2, _sender, sendResponse) => {
      if (message2 === NativeMessageType.CONNECT_NATIVE || message2.type === NativeMessageType.CONNECT_NATIVE) {
        const port = typeof message2 === "object" && message2.port ? message2.port : NATIVE_HOST.DEFAULT_PORT;
        connectNativeHost(port);
        sendResponse({ success: true, port });
        return true;
      }
      if (message2.type === NativeMessageType.PING_NATIVE) {
        const connected = nativePort !== null;
        sendResponse({ connected });
        return true;
      }
      if (message2.type === NativeMessageType.DISCONNECT_NATIVE) {
        if (nativePort) {
          nativePort.disconnect();
          nativePort = null;
          sendResponse({ success: true });
        } else {
          sendResponse({ success: false, error: "No active connection" });
        }
        return true;
      }
      if (message2.type === BACKGROUND_MESSAGE_TYPES.GET_SERVER_STATUS) {
        sendResponse({
          success: true,
          serverStatus: currentServerStatus,
          connected: nativePort !== null
        });
        return true;
      }
      if (message2.type === BACKGROUND_MESSAGE_TYPES.REFRESH_SERVER_STATUS) {
        loadServerStatus().then((storedStatus) => {
          currentServerStatus = storedStatus;
          sendResponse({
            success: true,
            serverStatus: currentServerStatus,
            connected: nativePort !== null
          });
        }).catch((error) => {
          console.error(ERROR_MESSAGES.SERVER_STATUS_LOAD_FAILED, error);
          sendResponse({
            success: false,
            error: ERROR_MESSAGES.SERVER_STATUS_LOAD_FAILED,
            serverStatus: currentServerStatus,
            connected: nativePort !== null
          });
        });
        return true;
      }
    });
  };
  background;
  let currentBackgroundModelConfig = null;
  function initializeSemanticEngineIfCached() {
    return __async(this, null, function* () {
      try {
        console.log("Background: Checking if semantic engine should be initialized from cache...");
        const hasCachedModel = yield hasAnyModelCache();
        if (!hasCachedModel) {
          console.log("Background: No cached models found, skipping semantic engine initialization");
          return false;
        }
        console.log("Background: Found cached models, initializing semantic engine...");
        yield initializeDefaultSemanticEngine();
        return true;
      } catch (error) {
        console.error("Background: Error during conditional semantic engine initialization:", error);
        return false;
      }
    });
  }
  function initializeDefaultSemanticEngine() {
    return __async(this, null, function* () {
      try {
        console.log("Background: Initializing default semantic engine...");
        yield updateModelStatus("initializing", 0);
        const result2 = yield chrome.storage.local.get([STORAGE_KEYS.SEMANTIC_MODEL, "selectedVersion"]);
        const defaultModel = result2[STORAGE_KEYS.SEMANTIC_MODEL] || "multilingual-e5-small";
        const defaultVersion = result2.selectedVersion || "quantized";
        const { PREDEFINED_MODELS: PREDEFINED_MODELS2 } = yield Promise.resolve().then(() => semanticSimilarityEngine);
        const modelInfo = PREDEFINED_MODELS2[defaultModel];
        yield OffscreenManager.getInstance().ensureOffscreenDocument();
        const response = yield chrome.runtime.sendMessage({
          target: "offscreen",
          type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_INIT,
          config: {
            useLocalFiles: false,
            modelPreset: defaultModel,
            modelVersion: defaultVersion,
            modelDimension: modelInfo.dimension,
            forceOffscreen: true
          }
        });
        if (response && response.success) {
          currentBackgroundModelConfig = {
            modelPreset: defaultModel,
            modelVersion: defaultVersion,
            modelDimension: modelInfo.dimension
          };
          console.log("Semantic engine initialized successfully:", currentBackgroundModelConfig);
          yield updateModelStatus("ready", 100);
          try {
            const { getGlobalContentIndexer: getGlobalContentIndexer2 } = yield Promise.resolve().then(() => contentIndexer);
            const contentIndexer$1 = getGlobalContentIndexer2();
            contentIndexer$1.startSemanticEngineInitialization();
            console.log("ContentIndexer initialization triggered after semantic engine initialization");
          } catch (indexerError) {
            console.warn(
              "Failed to initialize ContentIndexer after semantic engine initialization:",
              indexerError
            );
          }
        } else {
          const errorMessage = (response == null ? void 0 : response.error) || ERROR_MESSAGES.TOOL_EXECUTION_FAILED;
          yield updateModelStatus("error", 0, errorMessage, "unknown");
          throw new Error(errorMessage);
        }
      } catch (error) {
        console.error("Background: Failed to initialize default semantic engine:", error);
        const errorMessage = (error == null ? void 0 : error.message) || "Unknown error during semantic engine initialization";
        yield updateModelStatus("error", 0, errorMessage, "unknown");
      }
    });
  }
  function needsModelSwitch(modelPreset, modelVersion, modelDimension) {
    if (!currentBackgroundModelConfig) {
      return true;
    }
    const keyFields = ["modelPreset", "modelVersion", "modelDimension"];
    for (const field of keyFields) {
      const newValue = field === "modelPreset" ? modelPreset : field === "modelVersion" ? modelVersion : modelDimension;
      if (newValue !== currentBackgroundModelConfig[field]) {
        return true;
      }
    }
    return false;
  }
  function handleModelSwitch(modelPreset, modelVersion = "quantized", modelDimension, previousDimension) {
    return __async(this, null, function* () {
      try {
        const needsSwitch = needsModelSwitch(modelPreset, modelVersion, modelDimension);
        if (!needsSwitch) {
          yield updateModelStatus("ready", 100);
          return { success: true };
        }
        yield updateModelStatus("downloading", 0);
        try {
          yield OffscreenManager.getInstance().ensureOffscreenDocument();
        } catch (offscreenError) {
          console.error("Background: Failed to create offscreen document:", offscreenError);
          const errorMessage = `Failed to create offscreen document: ${offscreenError}`;
          yield updateModelStatus("error", 0, errorMessage, "unknown");
          return { success: false, error: errorMessage };
        }
        const response = yield chrome.runtime.sendMessage({
          target: "offscreen",
          type: OFFSCREEN_MESSAGE_TYPES.SIMILARITY_ENGINE_INIT,
          config: {
            useLocalFiles: false,
            modelPreset,
            modelVersion,
            modelDimension,
            forceOffscreen: true
          }
        });
        if (response && response.success) {
          currentBackgroundModelConfig = {
            modelPreset,
            modelVersion,
            modelDimension
          };
          try {
            if (modelDimension && previousDimension && modelDimension !== previousDimension) {
              const { getGlobalContentIndexer: getGlobalContentIndexer2 } = yield Promise.resolve().then(() => contentIndexer);
              const contentIndexer$1 = getGlobalContentIndexer2();
              yield contentIndexer$1.reinitialize();
            }
          } catch (indexerError) {
            console.warn("Background: Failed to reinitialize ContentIndexer:", indexerError);
          }
          yield updateModelStatus("ready", 100);
          return { success: true };
        } else {
          const errorMessage = (response == null ? void 0 : response.error) || "Failed to switch model";
          const errorType = analyzeErrorType(errorMessage);
          yield updateModelStatus("error", 0, errorMessage, errorType);
          throw new Error(errorMessage);
        }
      } catch (error) {
        console.error("Model switch failed:", error);
        const errorMessage = error.message || "Unknown error";
        const errorType = analyzeErrorType(errorMessage);
        yield updateModelStatus("error", 0, errorMessage, errorType);
        return { success: false, error: errorMessage };
      }
    });
  }
  function handleGetModelStatus() {
    return __async(this, null, function* () {
      try {
        if (typeof chrome === "undefined" || !chrome.storage || !chrome.storage.local) {
          console.error("Background: chrome.storage.local is not available for status query");
          return {
            success: true,
            status: {
              initializationStatus: "idle",
              downloadProgress: 0,
              isDownloading: false,
              lastUpdated: Date.now()
            }
          };
        }
        const result2 = yield chrome.storage.local.get(["modelState"]);
        const modelState = result2.modelState || {
          status: "idle",
          downloadProgress: 0,
          isDownloading: false,
          lastUpdated: Date.now()
        };
        return {
          success: true,
          status: {
            initializationStatus: modelState.status,
            downloadProgress: modelState.downloadProgress,
            isDownloading: modelState.isDownloading,
            lastUpdated: modelState.lastUpdated,
            errorMessage: modelState.errorMessage,
            errorType: modelState.errorType
          }
        };
      } catch (error) {
        console.error("Failed to get model status:", error);
        return { success: false, error: error.message };
      }
    });
  }
  function updateModelStatus(status, progress, errorMessage, errorType) {
    return __async(this, null, function* () {
      try {
        if (typeof chrome === "undefined" || !chrome.storage || !chrome.storage.local) {
          console.error("Background: chrome.storage.local is not available for status update");
          return;
        }
        const modelState = {
          status,
          downloadProgress: progress,
          isDownloading: status === "downloading" || status === "initializing",
          lastUpdated: Date.now(),
          errorMessage: errorMessage || "",
          errorType: errorType || ""
        };
        yield chrome.storage.local.set({ modelState });
      } catch (error) {
        console.error("Failed to update model status:", error);
      }
    });
  }
  function handleUpdateModelStatus(modelState) {
    return __async(this, null, function* () {
      try {
        if (typeof chrome === "undefined" || !chrome.storage || !chrome.storage.local) {
          console.error("Background: chrome.storage.local is not available");
          return { success: false, error: "chrome.storage.local is not available" };
        }
        yield chrome.storage.local.set({ modelState });
        return { success: true };
      } catch (error) {
        console.error("Background: Failed to update model status:", error);
        return { success: false, error: error.message };
      }
    });
  }
  function analyzeErrorType(errorMessage) {
    const message2 = errorMessage.toLowerCase();
    if (message2.includes("network") || message2.includes("fetch") || message2.includes("timeout") || message2.includes("connection") || message2.includes("cors") || message2.includes("failed to fetch")) {
      return "network";
    }
    if (message2.includes("corrupt") || message2.includes("invalid") || message2.includes("format") || message2.includes("parse") || message2.includes("decode") || message2.includes("onnx")) {
      return "file";
    }
    return "unknown";
  }
  const initSemanticSimilarityListener = () => {
    chrome.runtime.onMessage.addListener((message2, _sender, sendResponse) => {
      if (message2.type === BACKGROUND_MESSAGE_TYPES.SWITCH_SEMANTIC_MODEL) {
        handleModelSwitch(
          message2.modelPreset,
          message2.modelVersion,
          message2.modelDimension,
          message2.previousDimension
        ).then((result2) => sendResponse(result2)).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      } else if (message2.type === BACKGROUND_MESSAGE_TYPES.GET_MODEL_STATUS) {
        handleGetModelStatus().then((result2) => sendResponse(result2)).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      } else if (message2.type === BACKGROUND_MESSAGE_TYPES.UPDATE_MODEL_STATUS) {
        handleUpdateModelStatus(message2.modelState).then((result2) => sendResponse(result2)).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      } else if (message2.type === BACKGROUND_MESSAGE_TYPES.INITIALIZE_SEMANTIC_ENGINE) {
        initializeDefaultSemanticEngine().then(() => sendResponse({ success: true })).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      }
    });
  };
  background;
  const semanticSimilarity = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    handleGetModelStatus,
    handleModelSwitch,
    handleUpdateModelStatus,
    initSemanticSimilarityListener,
    initializeDefaultSemanticEngine,
    initializeSemanticEngineIfCached,
    updateModelStatus
  }, Symbol.toStringTag, { value: "Module" }));
  function handleGetStorageStats() {
    return __async(this, null, function* () {
      try {
        const { getGlobalContentIndexer: getGlobalContentIndexer2 } = yield Promise.resolve().then(() => contentIndexer);
        const contentIndexer$1 = getGlobalContentIndexer2();
        const stats = contentIndexer$1.getStats();
        return {
          success: true,
          stats: {
            indexedPages: stats.indexedPages || 0,
            totalDocuments: stats.totalDocuments || 0,
            totalTabs: stats.totalTabs || 0,
            indexSize: stats.indexSize || 0,
            isInitialized: stats.isInitialized || false,
            semanticEngineReady: stats.semanticEngineReady || false,
            semanticEngineInitializing: stats.semanticEngineInitializing || false
          }
        };
      } catch (error) {
        console.error("Background: Failed to get storage stats:", error);
        return {
          success: false,
          error: error.message,
          stats: {
            indexedPages: 0,
            totalDocuments: 0,
            totalTabs: 0,
            indexSize: 0,
            isInitialized: false,
            semanticEngineReady: false,
            semanticEngineInitializing: false
          }
        };
      }
    });
  }
  function handleClearAllData() {
    return __async(this, null, function* () {
      try {
        try {
          const { getGlobalContentIndexer: getGlobalContentIndexer2 } = yield Promise.resolve().then(() => contentIndexer);
          const contentIndexer$1 = getGlobalContentIndexer2();
          yield contentIndexer$1.clearAllIndexes();
          console.log("Storage: ContentIndexer indexes cleared successfully");
        } catch (indexerError) {
          console.warn("Background: Failed to clear ContentIndexer indexes:", indexerError);
        }
        try {
          const { clearAllVectorData: clearAllVectorData2 } = yield Promise.resolve().then(() => vectorDatabase);
          yield clearAllVectorData2();
          console.log("Storage: Vector database data cleared successfully");
        } catch (vectorError) {
          console.warn("Background: Failed to clear vector data:", vectorError);
        }
        try {
          const keysToRemove = ["vectorDatabaseStats", "lastCleanupTime", "contentIndexerStats"];
          yield chrome.storage.local.remove(keysToRemove);
          console.log("Storage: Chrome storage data cleared successfully");
        } catch (storageError) {
          console.warn("Background: Failed to clear chrome storage data:", storageError);
        }
        return { success: true };
      } catch (error) {
        console.error("Background: Failed to clear all data:", error);
        return { success: false, error: error.message };
      }
    });
  }
  const initStorageManagerListener = () => {
    chrome.runtime.onMessage.addListener((message2, _sender, sendResponse) => {
      if (message2.type === BACKGROUND_MESSAGE_TYPES.GET_STORAGE_STATS) {
        handleGetStorageStats().then((result2) => sendResponse(result2)).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      } else if (message2.type === BACKGROUND_MESSAGE_TYPES.CLEAR_ALL_DATA) {
        handleClearAllData().then((result2) => sendResponse(result2)).catch((error) => sendResponse({ success: false, error: error.message }));
        return true;
      }
    });
  };
  background;
  const definition = defineBackground(() => {
    initNativeHostListener();
    initSemanticSimilarityListener();
    initStorageManagerListener();
    initializeSemanticEngineIfCached().then((initialized) => {
      if (initialized) {
        console.log("Background: Semantic similarity engine initialized from cache");
      } else {
        console.log(
          "Background: Semantic similarity engine initialization skipped (no cache found)"
        );
      }
    }).catch((error) => {
      console.warn("Background: Failed to conditionally initialize semantic engine:", error);
    });
    cleanupModelCache().catch((error) => {
      console.warn("Background: Initial cache cleanup failed:", error);
    });
  });
  background;
  function initPlugins() {
  }
  ((_c = (_b = globalThis.browser) == null ? void 0 : _b.runtime) == null ? void 0 : _c.id) ? globalThis.browser : globalThis.chrome;
  function print(method, ...args) {
    return;
  }
  const logger = {
    debug: (...args) => print(console.debug, ...args),
    log: (...args) => print(console.log, ...args),
    warn: (...args) => print(console.warn, ...args),
    error: (...args) => print(console.error, ...args)
  };
  let result;
  try {
    initPlugins();
    result = definition.main();
    if (result instanceof Promise) {
      console.warn(
        "The background's main() function return a promise, but it must be synchronous"
      );
    }
  } catch (err) {
    logger.error("The background crashed on startup!");
    throw err;
  }
  const result$1 = result;
  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var hnswlib$1 = /* @__PURE__ */ (() => {
    return function() {
      return __async(this, arguments, function* (moduleArg = {}) {
        var moduleRtn;
        var Module = moduleArg;
        var readyPromiseResolve, readyPromiseReject;
        var readyPromise = new Promise((resolve, reject) => {
          readyPromiseResolve = resolve;
          readyPromiseReject = reject;
        });
        var thisProgram = "./this.program";
        var _scriptName = self.location.href;
        var scriptDirectory = "";
        function locateFile(path) {
          if (Module["locateFile"]) {
            return Module["locateFile"](path, scriptDirectory);
          }
          return scriptDirectory + path;
        }
        var readAsync, readBinary;
        {
          try {
            scriptDirectory = new URL(".", _scriptName).href;
          } catch (e) {
          }
          if (!(typeof window == "object" || typeof WorkerGlobalScope != "undefined"))
            throw new Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");
          {
            readAsync = (url) => __async(null, null, function* () {
              assert(!isFileURI(url), "readAsync does not work with file:// URLs");
              var response = yield fetch(url, { credentials: "same-origin" });
              if (response.ok) {
                return response.arrayBuffer();
              }
              throw new Error(response.status + " : " + response.url);
            });
          }
        }
        var out = console.log.bind(console);
        var err = console.error.bind(console);
        var IDBFS = "IDBFS is no longer included by default; build with -lidbfs.js";
        assert(true, "worker environment detected but not enabled at build time.  Add `worker` to `-sENVIRONMENT` to enable.");
        assert(true, "node environment detected but not enabled at build time.  Add `node` to `-sENVIRONMENT` to enable.");
        assert(true, "shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.");
        var wasmBinary;
        if (typeof WebAssembly != "object") {
          err("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        function assert(condition, text) {
          if (!condition) {
            abort("Assertion failed" + (text ? ": " + text : ""));
          }
        }
        var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAP64, HEAPU64, HEAPF64;
        var runtimeInitialized = false;
        var isFileURI = (filename) => filename.startsWith("file://");
        function writeStackCookie() {
          var max2 = _emscripten_stack_get_end();
          assert((max2 & 3) == 0);
          if (max2 == 0) {
            max2 += 4;
          }
          HEAPU32[max2 >> 2] = 34821223;
          HEAPU32[max2 + 4 >> 2] = 2310721022;
          HEAPU32[0 >> 2] = 1668509029;
        }
        function checkStackCookie() {
          if (ABORT)
            return;
          var max2 = _emscripten_stack_get_end();
          if (max2 == 0) {
            max2 += 4;
          }
          var cookie1 = HEAPU32[max2 >> 2];
          var cookie2 = HEAPU32[max2 + 4 >> 2];
          if (cookie1 != 34821223 || cookie2 != 2310721022) {
            abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max2)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);
          }
          if (HEAPU32[0 >> 2] != 1668509029) {
            abort("Runtime error: The application has corrupted its heap memory area (address zero)!");
          }
        }
        (() => {
          var h16 = new Int16Array(1);
          var h8 = new Int8Array(h16.buffer);
          h16[0] = 25459;
          if (h8[0] !== 115 || h8[1] !== 99)
            throw "Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";
        })();
        function consumedModuleProp(prop) {
          if (!Object.getOwnPropertyDescriptor(Module, prop)) {
            Object.defineProperty(Module, prop, {
              configurable: true,
              set() {
                abort(`Attempt to set \`Module.${prop}\` after it has already been processed.  This can happen, for example, when code is injected via '--post-js' rather than '--pre-js'`);
              }
            });
          }
        }
        function ignoredModuleProp(prop) {
          if (Object.getOwnPropertyDescriptor(Module, prop)) {
            abort(`\`Module.${prop}\` was supplied but \`${prop}\` not included in INCOMING_MODULE_JS_API`);
          }
        }
        function isExportedByForceFilesystem(name2) {
          return name2 === "FS_createPath" || name2 === "FS_createDataFile" || name2 === "FS_createPreloadedFile" || name2 === "FS_unlink" || name2 === "addRunDependency" || // The old FS has some functionality that WasmFS lacks.
          name2 === "FS_createLazyFile" || name2 === "FS_createDevice" || name2 === "removeRunDependency";
        }
        function hookGlobalSymbolAccess(sym, func) {
          if (typeof globalThis != "undefined" && !Object.getOwnPropertyDescriptor(globalThis, sym)) {
            Object.defineProperty(globalThis, sym, {
              configurable: true,
              get() {
                func();
                return void 0;
              }
            });
          }
        }
        function missingGlobal(sym, msg) {
          hookGlobalSymbolAccess(sym, () => {
            warnOnce(`\`${sym}\` is not longer defined by emscripten. ${msg}`);
          });
        }
        missingGlobal("buffer", "Please use HEAP8.buffer or wasmMemory.buffer");
        missingGlobal("asm", "Please use wasmExports instead");
        function missingLibrarySymbol(sym) {
          hookGlobalSymbolAccess(sym, () => {
            var msg = `\`${sym}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;
            var librarySymbol = sym;
            if (!librarySymbol.startsWith("_")) {
              librarySymbol = "$" + sym;
            }
            msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;
            if (isExportedByForceFilesystem(sym)) {
              msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
            }
            warnOnce(msg);
          });
          unexportedRuntimeSymbol(sym);
        }
        function unexportedRuntimeSymbol(sym) {
          if (!Object.getOwnPropertyDescriptor(Module, sym)) {
            Object.defineProperty(Module, sym, {
              configurable: true,
              get() {
                var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;
                if (isExportedByForceFilesystem(sym)) {
                  msg += ". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you";
                }
                abort(msg);
              }
            });
          }
        }
        function updateMemoryViews() {
          var b = wasmMemory.buffer;
          HEAP8 = new Int8Array(b);
          HEAP16 = new Int16Array(b);
          HEAPU8 = new Uint8Array(b);
          HEAPU16 = new Uint16Array(b);
          HEAP32 = new Int32Array(b);
          HEAPU32 = new Uint32Array(b);
          HEAPF32 = new Float32Array(b);
          HEAPF64 = new Float64Array(b);
          HEAP64 = new BigInt64Array(b);
          HEAPU64 = new BigUint64Array(b);
        }
        assert(
          typeof Int32Array != "undefined" && typeof Float64Array !== "undefined" && Int32Array.prototype.subarray != void 0 && Int32Array.prototype.set != void 0,
          "JS engine does not provide full typed array support"
        );
        function preRun() {
          if (Module["preRun"]) {
            if (typeof Module["preRun"] == "function")
              Module["preRun"] = [Module["preRun"]];
            while (Module["preRun"].length) {
              addOnPreRun(Module["preRun"].shift());
            }
          }
          consumedModuleProp("preRun");
          callRuntimeCallbacks(onPreRuns);
        }
        function initRuntime() {
          assert(!runtimeInitialized);
          runtimeInitialized = true;
          checkStackCookie();
          if (!Module["noFSInit"] && !FS.initialized)
            FS.init();
          wasmExports["__wasm_call_ctors"]();
          FS.ignorePermissions = false;
        }
        function postRun() {
          checkStackCookie();
          if (Module["postRun"]) {
            if (typeof Module["postRun"] == "function")
              Module["postRun"] = [Module["postRun"]];
            while (Module["postRun"].length) {
              addOnPostRun(Module["postRun"].shift());
            }
          }
          consumedModuleProp("postRun");
          callRuntimeCallbacks(onPostRuns);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        var runDependencyTracking = {};
        var runDependencyWatcher = null;
        function getUniqueRunDependency(id) {
          var orig = id;
          while (1) {
            if (!runDependencyTracking[id])
              return id;
            id = orig + Math.random();
          }
        }
        function addRunDependency(id) {
          var _a2;
          runDependencies++;
          (_a2 = Module["monitorRunDependencies"]) == null ? void 0 : _a2.call(Module, runDependencies);
          if (id) {
            assert(!runDependencyTracking[id]);
            runDependencyTracking[id] = 1;
            if (runDependencyWatcher === null && typeof setInterval != "undefined") {
              runDependencyWatcher = setInterval(() => {
                if (ABORT) {
                  clearInterval(runDependencyWatcher);
                  runDependencyWatcher = null;
                  return;
                }
                var shown = false;
                for (var dep in runDependencyTracking) {
                  if (!shown) {
                    shown = true;
                    err("still waiting on run dependencies:");
                  }
                  err(`dependency: ${dep}`);
                }
                if (shown) {
                  err("(end of list)");
                }
              }, 1e4);
            }
          } else {
            err("warning: run dependency added without ID");
          }
        }
        function removeRunDependency(id) {
          var _a2;
          runDependencies--;
          (_a2 = Module["monitorRunDependencies"]) == null ? void 0 : _a2.call(Module, runDependencies);
          if (id) {
            assert(runDependencyTracking[id]);
            delete runDependencyTracking[id];
          } else {
            err("warning: run dependency removed without ID");
          }
          if (runDependencies == 0) {
            if (runDependencyWatcher !== null) {
              clearInterval(runDependencyWatcher);
              runDependencyWatcher = null;
            }
            if (dependenciesFulfilled) {
              var callback = dependenciesFulfilled;
              dependenciesFulfilled = null;
              callback();
            }
          }
        }
        function abort(what) {
          var _a2;
          (_a2 = Module["onAbort"]) == null ? void 0 : _a2.call(Module, what);
          what = "Aborted(" + what + ")";
          err(what);
          ABORT = true;
          if (runtimeInitialized) {
            ___trap();
          }
          var e = new WebAssembly.RuntimeError(what);
          readyPromiseReject(e);
          throw e;
        }
        function createExportWrapper(name2, nargs) {
          return (...args) => {
            assert(runtimeInitialized, `native function \`${name2}\` called before runtime initialization`);
            var f = wasmExports[name2];
            assert(f, `exported native function \`${name2}\` not found`);
            assert(args.length <= nargs, `native function \`${name2}\` called with ${args.length} args but expects ${nargs}`);
            return f(...args);
          };
        }
        var wasmBinaryFile;
        function findWasmBinary() {
          if (Module["locateFile"]) {
            return locateFile("hnswlib.wasm");
          }
          return new URL("data:application/wasm;base64,AGFzbQEAAAAB/AM+YAJ/fwBgAX8Bf2ACf38Bf2ABfwBgA39/fwF/YAN/f38AYAR/f39/AX9gBH9/f38AYAZ/f39/f38Bf2AFf39/f38Bf2AFf39/f38AYAN/f38BfWAAAGAGf39/f39/AGAIf39/f39/f38Bf2AAAX9gB39/f39/f38Bf2AFf35+fn4AYAN/fn8BfmAFf39+f38AYAd/f39/f39/AGAFf39/f34Bf2AIf39/f39/f38AYAp/f39/f39/f39/AGAEf35+fwBgBn98f39/fwF/YAN/fn8Bf2AKf39/f39/f39/fwF/YAR/f39/AX5gDH9/f39/f39/f39/fwF/YAV/f39/fAF/YAZ/f39/fn4Bf2ALf39/f39/f39/f38Bf2AHf39/f39+fgF/YA9/f39/f39/f39/f39/f38AYAV/f39/fwF8YA1/f39/f39/f39/f39/AGAJf39/f39/f39/AGAFf39/fn4AYAR/fn9/AX9gBH9/f38BfWADf399AGAEf39/fQBgBH9/f30Bf2ABfAF8YAJ8fwF8YAJ+fwF/YAJ+fgF8YAF/AX5gA39+fwBgAn9+AGACf3wAYAR+fn5+AX9gA35+fgF/YAF/AXxgBH9+fn4AYAJ/fwF+YAJ+fgF9YAN/f34AYAR/f39+AX5gA39/fwF8YAV+f39/fwF/AsMJKgNlbnYNX2VtdmFsX2RlY3JlZgADA2VudhhfZW12YWxfZ2V0X21ldGhvZF9jYWxsZXIABANlbnYSX2VtdmFsX2NhbGxfbWV0aG9kACMDZW52Fl9lbXZhbF9ydW5fZGVzdHJ1Y3RvcnMAAwNlbnYZX2VtYmluZF9yZWdpc3Rlcl9mdW5jdGlvbgAWA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzACQDZW52Il9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IADQNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbgAXA2VudiVfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2NsYXNzX2Z1bmN0aW9uACUDZW52GV9lbWJpbmRfcmVnaXN0ZXJfb3B0aW9uYWwAAANlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAgNlbnYNX2VtdmFsX2luY3JlZgADA2VudhBfZW12YWxfbmV3X2FycmF5AA8DZW52EV9lbXZhbF9uZXdfb2JqZWN0AA8DZW52El9lbXZhbF9uZXdfY3N0cmluZwABA2VudhNfZW12YWxfc2V0X3Byb3BlcnR5AAUDZW52GGVtc2NyaXB0ZW5fYXNtX2NvbnN0X2ludAAEA2VudgpzeW5jSWRiX2pzAAMDZW52DV9fYXNzZXJ0X2ZhaWwABwNlbnYVX2VtYmluZF9yZWdpc3Rlcl92b2lkAAADZW52FV9lbWJpbmRfcmVnaXN0ZXJfYm9vbAAHA2VudhhfZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIACgNlbnYXX2VtYmluZF9yZWdpc3Rlcl9iaWdpbnQAJgNlbnYWX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAAFA2VudhtfZW1iaW5kX3JlZ2lzdGVyX3N0ZF9zdHJpbmcAAANlbnYcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZwAFA2VudhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsAAMDZW52HF9lbWJpbmRfcmVnaXN0ZXJfbWVtb3J5X3ZpZXcABRZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX3dyaXRlAAYDZW52CV9hYm9ydF9qcwAMFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAARZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxB2ZkX3NlZWsAJwNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAABA2VudhBfX3N5c2NhbGxfb3BlbmF0AAYDZW52EV9fc3lzY2FsbF9mY250bDY0AAQDZW52D19fc3lzY2FsbF9pb2N0bAAEFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfcmVhZAAGFndhc2lfc25hcHNob3RfcHJldmlldzERZW52aXJvbl9zaXplc19nZXQAAhZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxC2Vudmlyb25fZ2V0AAIDZW52CV90enNldF9qcwAHA2VudhBfX3N5c2NhbGxfc3RhdDY0AAIDZW52Il9fdGhyb3dfZXhjZXB0aW9uX3dpdGhfc3RhY2tfdHJhY2UAAwPSB9AHDAEMAwMDAwIMAwMBAAwMAgEDAgELKAECAQELAQMCAQQBAwQCAAUAAgAFAAUHAAoJAQEBAwYECg0FBwAABQQHCgcHBgACAAEAAAABAQAKAAEDAQ8AAw8FAAMPAgEBAw8AKQUqBQQEKwEDAAUBBQQEBgEABQUHBQQEBgQFAwIHAAIFBQMIAwAFAAAMAwMBAgsBAQEDCwECBwoACgACAQEDAAIBBQYDAgMDAQcFAAUKAAEBAwAKBQkNBwUBBwAsBAQAAQIBAQQEBgMDBBIBLQUJEAUBBy4KGQACAgwBEgEDAgABDA8PDxgYLwEEDAICAgQBARoaAQQwAwEDAAQTBwQBAQIEAgEBAwMAAwIBAQAFADEBAQMDAAMABQIBAQABAAUABAEBAQQDAwEMAgIEEwcBAAMBAwMBAwMAAAIBAQUEBAEFAQMAAQMMAAMyAQARETM0NTY3ABEYERERBzg5BjoEBAECAgYEBgI7AQkBAgMABgcJBwUECQcFBAgDEAIACAEFGwYHCBwIBggGCBwICh0LCDwIBwgPBAQCCBAIAgUbCAgICAgKHQgICAQJAQEJBwkEFAgVCRUeBAYUHwkECQEJFAgVCRUeFB8JBAAADgEICAgNCA0ICgkODggICA0IDQgKCQ4QDRABAAAAAQACECAABQUQBQoAAgAQIAAQBQoEAAIhFyIECCEXIgQIBA0NAQMAAwMBBQMDAQMAAgMCAgMDAAQGBgYCBAIEBgQJAQMCBAIEBgQJDgkJAw4EDgkJAQEJAQ4OCQEODgkBAwEDAQEAAAAAAAAAAAEDAQMBAwEDAQMBAwEDAQMBAwEDAQMBAwEDAQMDAQMAAQAFBQQBBQcBBQAAAwEDAwEMAgwBAwAFAQMFDAAFAgUDBQMBAwMDBQIAAgICAwEWAQUFBAIAAhYBAAAAAAICAgIAAQUBBQQFBAEDAAMFAQwMAwAMDAwDDAMEBAQCBQcHBwcEAgcKDQoKCg0NDQEBAQEDAwEDAQIBAT0AAwMCAgECBQQBAAMBAQECAgIBAQAFAQMCAAIBAQIBAgQEBAEAAAECAgIAAQECBQECBAgAAgAAAgIAAAABAQMGAgQCAgICAgICAAABAAQGAQECAgICAAYBAQQBAgAABwAAAAAAAAAAAAAAAAYAAgMAAgABAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAADAgAAAAQAAAAAAAAAAAAAAAACAAAAAAAEAAAAAAAGAAAAAAICAgIAAAAAAAACAAAABAAAAAAAAAICAgAAAAAABAAABAAAAAAAAAIAAQAABQABBQMBDwQFAXAAjwYFBwEBggKAgAINAwEAAwYSA38BQfCiBwt/AUEAC38BQQALB+UDFQZtZW1vcnkCABFfX3dhc21fY2FsbF9jdG9ycwAqDV9fZ2V0VHlwZU5hbWUAKw9fX2NwcF9leGNlcHRpb24EABlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQAGbWFsbG9jAIYCBGZyZWUAhwIGZmZsdXNoAJkCGGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZACOAhllbXNjcmlwdGVuX3N0YWNrX2dldF9iYXNlAI0CCHN0cmVycm9yAM4FBl9fdHJhcAC7BRVlbXNjcmlwdGVuX3N0YWNrX2luaXQAiwIZZW1zY3JpcHRlbl9zdGFja19nZXRfZnJlZQCMAhlfZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlAPcHF19lbXNjcmlwdGVuX3N0YWNrX2FsbG9jAPgHHGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2N1cnJlbnQA+QciX19jeGFfZGVjcmVtZW50X2V4Y2VwdGlvbl9yZWZjb3VudADsBSJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW50APEFJV9fdGhyb3duX29iamVjdF9mcm9tX3Vud2luZF9leGNlcHRpb24A9QcXX19nZXRfZXhjZXB0aW9uX21lc3NhZ2UA9gcJswsBAEEBC44GLJMGOTY6Ozw9Pj9AQUI7PENEP0BBRUZHSElKS0xNTk9QUVJTVFVWV1hZWkFbQFxdXl9gYVBRYmNkU2VPZmdoaWppa2xtbm9wQXFyT3N0QUB1dndZeDR5ent8fX57f4ABgQGCAYMBhAGFAYYBhwF7iAGJAYoBiwGMATVBjQGOAY8BkAGRAZIBe4gBkwFPlAFWlQFBlgGXAZgBmQGaAYcBe4gBmwGcAZ0BngE1QZ8BoAGhAaIBkAa9Ab4BuAEtLS4vMzi5AboBuwG+AbwBuQG6AbsBvAG/AcABwQHDAcQBxwHIAdMB1wHYAdkB2wHsAfMB9AH/AYAChAKFApgCmgK+AaECogKjAqQCpQKmAuwB7AGnAqgCqQKqAqsCqgKtAq8CrgKwAroCvAK7Ar0CzALPAtkC1QLWAtcC2ALRAtMC1ALLAdoC2wLcAsYB3QLeAt8C6wK+AbwB6QLmAucC6ALqAuwCugHuAu8CiQOOA4cCLcgEgQWDBYUFhwWJBYsFjQWPBZEFkwWVBZcFmQWbBcAEwQTHBNUE1gTXBNgE2QTaBJUC2wTcBN0EtwThBOIE5ATmBOcE7AHpBOoE8gTzBPYE9wT4BPoE/QT0BPUEuQHGAvkE+wT+BL4BvAG8AcoEywTMBM0EzgTPBNAE0QSVAtIE0wTUBLwB3gTeBN8E6gHqAeAE6gG8AesE7ATfBOwB7AHtBO4EvAHrBOwE3wTsAewB7QTuBLwB7wTwBN8E7AHsAfEE7gS8Ae8E8ATfBOwB7AHxBO4EvgG8AZoDmwOdA74BvAGeA58DoQO8AaIDpwOtA68DsQOxA7MDtQO5A7sDvQO8AcIDxAPIA8kDygPKA8sDzAPPA9AD0QO8AdMD1gPcA90D3gPfA+MD5AO8AeYD6APrA+wD7QPuA/AD8QO+AbwB9gP3A/gD+QP7A/0DgASABYQFiAWUBZgFjAWQBb4BvAH2A4IEgwSEBIYEiASLBIIFhgWKBZYFmgWOBZIFnQWcBYwEnQWcBY4EvAGPBI8EkASQBJAEkQTsAZIEkgS8AY8EjwSQBJAEkASRBOwBkgSSBLwBkwSTBJAEkASQBJQE7AGSBJIEvAGTBJMEkASQBJAElATsAZIEkgS8AZYEmwS8AaEEpAS8AaoErgS8Aa8EswS8AbQEtQSjArwBtAS2BKMCvgGvBfcFrwXrAbQFtQW4BcMFxAXFBcYF6wK8AeIF4wW8AeQF5QXjBewC6wUt8wX0Bb4BvAEtLfkFvAH7BYwGiQb+BbwBiwaIBv8FvAGKBoUGgQa8AYIGvAGOBrwBjwa8AY0Gkga6AZQGkgaSBpIGlAa8AZUG6wHrAesBrALNBqMCzwa+AbwBrwXQBrwB0wbUBrwB1Qa8Ad8G4AbhBuIG4wbkBrwB9ga8AfoGvAH7BrwB/Aa8Af0GvAH+BrwBgAe8AYEHvAGCB7wBgwe8AYQHvAGGB7wBiQe8AYsHvAGNB7wBjge8AY8HvAGQB7wBkge8AZMHvAGUB5UHvAGWB5cHvAGYB5kHvAGaB5sHvAGcB50HvAGeB7wBoAe8AaEHvAGiB7wBowe8AaYHvAGnB7wBqAe8AaoHvAGrB7wBrAe8Aa0HvAGuB7wBrwe8AbAHvAGxB7wBsge8AbMHvAG0B7UHvAG3B7wBuAe8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zKICNgIAQQAhASAAQdiiAkGOARDtBQwFGSADJAAgAywAK0EASARAIAMoAigaIAMoAiAQhwILCQALABkgAyQAIAMsABtBAEgEQCADKAIYGiADKAIQEIcCCwkACwAZIAMkACADLAAPQQBIBEAgAygCDBogAygCBBCHAgsJAAsAGSADJAAgAQRAIAIQ6gULCQALAAsgACgCBCIEIAQoAgAoAgQRAQAhBCABKAIAIAIoAgAgACgCBCIAIAAoAgAoAggRAQAgBBELACADQTBqJAAPCwALOQEBfyABIAAoAgQiBEEBdWohASAAKAIAIQAgASACIAMgBEEBcQR/IAEoAgAgAGooAgAFIAALEQsACwcAIAAoAgALNQEBfyABIAAoAgQiAkEBdWohASAAKAIAIQAgASACQQFxBH8gASgCACAAaigCAAUgAAsRAQALBgBBxOwAC2wBAn8jACEBQQgQsAUhAiAAKAIAIQAgAkEANgIEIAIgADYCAAZAQRAQsAUhARkgASQAIAJBADYCBCACEIcCCQALIAEgADYCDCABQY8BNgIEIAFB6O0ANgIAIAEgAEECdDYCCCACIAE2AgQgAgviAgIDfwF9IwBBIGsiAyQAAkACQCAAKAIAIgQgASgCBCABKAIAayIFQQJ1RgRAIAIoAgQgAigCAGsgBUYNAQtBASEBQe3/Ai0AAEEBRgRAIAMgBDYCAEHMzgAgAxDpAQtBCBDpBSECBkAgA0EEaiIEIAAoAgAQ3AUGQCADIARBq8AAENQFIgAoAgg2AhggAyAAKQIANwMQIABCADcCACAAQQA2AggGQCACIANBEGoQyAUiAEHMogI2AgBBACEBIABB2KICQY4BEO0FDAQZIAMkACADLAAbQQBIBEAgAygCGBogAygCEBCHAgsJAAsAGSADJAAgAywAD0EASARAIAMoAgwaIAMoAgQQhwILCQALABkgAyQAIAEEQCACEOoFCwkACwALIAAoAgQiBCAEKAIAKAIEEQEAIQQgASgCACACKAIAIAAoAgQiACAAKAIAKAIIEQEAIAQRCwAgA0EgaiQADwsACw0AIAAoAgBBBGsoAgALOAECfyAABEAgAEHQ7gA2AgAgACgCCCIBQQlPBEAjACECBkAgARAAGSACJAAQ9QUACwsgABCHAgsLYAEBfyMAQRBrIgIkACACIAE2AgwgAkHQgAM2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AhDNASEAGSAEJAAgAxCHAgkACyAAC1UBAn8jACEGIAAoAgQiBQRAIAUgBSgCACgCFBEDAAsGQAZAQZgCELAFIQUYASAFIAAoAgggASACIAMgBBCtASEBGSAGJAAgBRCHAgkACyAAIAE2AgQLPQEBfyABIAAoAgQiBkEBdWohASAAKAIAIQAgASACIAMgBCAFIAZBAXEEfyABKAIAIABqKAIABSAACxEKAAuNCQEGfyMAQdAAayIDJAAgACgCBCIEBEAgBCAEKAIAKAIUEQMACwJAQfT/AigCAEH7/wIsAAAiByAHQQBIGyIEQQFqIgVB+P///wdJBEACQAJAIAVBC08EQCAFQQdyIghBAWoQsAUhBiADIAU2AjQgAyAGNgIwIAMgCEH/////B2s2AjgMAQsgA0EANgI4IANCADcDMCADIAU6ADsgA0EwaiEGIARFDQELIARFDQAgBkHw/wJB8P8CKAIAIAdBAE4bIAT8CgAACyAEIAZqQS87AAAGQCADQTBqIAEoAgAgASABLAALIgRBAEgiBRsgASgCBCAEIAUbENMFIQEMAhkgAyQAIAMsADtBAEgEQCADKAI4GiADKAIwEIcCCwkACwALEDIACyADIAEoAgg2AkggAyABKQIANwNAIAFCADcCACABQQA2AgggAywAO0EASARAIAMoAjgaIAMoAjAQhwILBkAGQEGYAhCwBSEBBkAgACgCCCEEIAFCADcCBCABQfj1ADYCACABQgA3AgwgAUIANwIUIAFCADcCHCABQgA3AiQgAUEwakEAQfQA/AsAIwAhBSABQgA3A8gBIAFCADcDwAEgAUIANwO4ASABQgA3A7ABIAFCADcDqAEgAUIANwLsASABQQE6AOgBIAFCADcD4AEgAUKBgICAEDcD2AEgAUKAgICAgICAwD83A9ABIAFCADcC9AEgAUIANwL8ASABQYQCaiIGQgA3AgAgAUIANwKMAiABQYCAgPwDNgKUAgZAIAEgA0FAayAEIAIQ5AEZIAUkACAGEKUBIAFBxAFqEKUBIAEoApQBIgIEQCABIAI2ApgBIAEoApwBGiACEIcCCyABQewAahDQASABQcgAahDQAQkACxkgAyQAIAEQhwIJAAsgACABNgIEIAAQrgEHACEBIAMkAEHkogNB/NYANgIAQeCiA0EANgIAIAEQmwZB6KIDKAIAQQFGBEACQAZABkAgA0EwaiECIAEQ7gUiASABKAIAKAIIEQEAIQEYBSACIAEQMSEBBkAgA0EkakGLJhAxIQIGQCABIAIQpgFBf0cEQAZAQQgQ6QUhBBgIQQEhBQZAIANBDGoiBiAAKAIEKAIEENwFBkAgAyAGQcjGABDUBSIAKAIINgIgIAMgACkCADcDGCAAQgA3AgAgAEEANgIIBkAgBCADQRhqEMsFQQAhBUHkowJBAhDtBQwHGSADJAAgAywAI0EASARAIAMoAiAaIAMoAhgQhwILCQALABkgAyQAIAMsABdBAEgEQCADKAIUGiADKAIMEIcCCwkACwAZIAMkACAFBEAGQCAEEOoFGAoLCQALAAsQ8AUZIAMkACACLAALQQBIBEAgAigCCBogAigCABCHAgsJAAsZIAMkACABLAALQQBIBEAgASgCCBogASgCABCHAgsJAAsZIAMkAAZAEO8FGSADJAAQ9QUACwkACwsACwkACxkgAyQAIAMsAEtBAEgEQCADKAJIGiADKAJAEIcCCwkACyADLABLQQBIBEAgAygCSBogAygCQBCHAgsgA0HQAGokAAuNAgEEfyMAQRBrIgQkACABIAAoAgQiBUEBdWohBiAAKAIAIQEgBUEBcQRAIAYoAgAgAWooAgAhAQsCQCACKAIAIgBB+P///wdJBEACQAJAIABBC08EQCAAQQdyIgdBAWoQsAUhBSAEIAdB/////wdrNgIMIAQgBTYCBCAEIAA2AggMAQsgBCAAOgAPIARBBGohBSAARQ0BCyAARQ0AIAUgAkEEaiAA/AoAAAsgACAFakEAOgAABkAgBiAEQQRqIAMgAREFAAwCGSAEJAAgBCwAD0EASARAIAQoAgwaIAQoAgQQhwILCQALAAsQMgALIAQsAA9BAEgEQCAEKAIMGiAEKAIEEIcCCyAEQRBqJAAL2wQBBn8jAEEwayICJABB7f8CLQAAQQFGBEAgAiABKAIAIAEgASwAC0EASBs2AgBB2cwAIAIQ6QELAkAgACgCBEUEQAZABkBBCBDpBSEAGAMgAEGiOBDMBSEADAIZIAIkACAAEOoFCQALAAsCQEH0/wIoAgBB+/8CLAAAIgYgBkEASBsiA0EBaiIEQfj///8HSQRAAkACQCAEQQtPBEAgBEEHciIHQQFqELAFIQUgAiAENgIUIAIgBTYCECACIAdB/////wdrNgIYDAELIAJBADYCGCACQgA3AxAgAiAEOgAbIAJBEGohBSADRQ0BCyADRQ0AIAVB8P8CQfD/AigCACAGQQBOGyAD/AoAAAsgAyAFakEvOwAABkAgAkEQaiABKAIAIAEgASwACyIDQQBIIgQbIAEoAgQgAyAEGxDTBSEBDAIZIAIkACACLAAbQQBIBEAgAigCGBogAigCEBCHAgsJAAsACxAyAAsgAiABKAIINgIoIAIgASkCADcDICABQgA3AgAgAUEANgIIIAIsABtBAEgEQCACKAIYGiACKAIQEIcCCwZAIAAoAgQiACACQSBqIAAoAgAoAgwRAAAgAkECNgIMIAJB0IADNgIIBkBBACACQQhqEIEBGSACJAAgAkEIahAwCQALGSACJAAgAiwAK0EASARAIAIoAigaIAIoAiAQhwILCQALIAIoAgwiAEEJTwRABkAgABAAGSACJAAQ9QUACyACQQA2AgwLIAIsACtBAEgEQCACKAIoGiACKAIgEIcCCyACQTBqJAAPCyAAQeSjAkECEO0FAAvXAQECfyMAQRBrIgIkAAJAIAAoAgQiA0UEQAZABkBBCBDpBSEAGAMgAEGiOBDMBSEADAIZIAIkACAAEOoFCQALAAsgAyABEK8BAkACQCAAKAJgIAAsAGciAyIBIAFBAEgbRQ0AQez/Ai0AAEEBRw0AIABB3ABqIQFB7f8CLQAAQQFGBEAgAiAAKAJcIAEgA0EASBs2AgBB8swAIAIQ6QELIAAgARBkDAELQe3/Ai0AAEEBRw0AQdAjEPIBCyAAQQE6ADwgAkEQaiQADwsgAEHkowJBAhDtBQAL4AUBBH8jAEEwayIDJAACQCABKAIEIgFFBEAGQAZAQQgQ6QUhABgDIABBojgQzAUhAAwCGSADJAAgABDqBQkACwALBkAgA0EkaiABIAIQsAEGQCAAEAw2AgQgAEHQgAM2AgBBACEBIANBADYCGCADKAIkIgIgAygCKEcEQANABkAgAiABQQJ0aiEEIwBBIGsiASQAIAAoAgQhBSABIAMoAhg2AhggAUGwngIgAUEYaiIGEAoiAjYCFCABQdCAAzYCECABIAQqAgA4AhgGQCABQdSeAiAGEAoiBDYCDCABQdCAAzYCCAZAIAUgAiAEEA8ZIAEkACABQQhqEDAJAAsZIAEkACABQRBqEDAJAAsgBEEJTwRABkAgBBAAGSABJAAQ9QUACwsgAkEJTwRABkAgAhAAGSABJAAQ9QUACwsgAUEgaiQAGSADJAAgABAwCQALIAMgAygCGEEBaiIBNgIYIAEgAygCKCADKAIkIgJrQQJ1SQ0ACwsgAgRAIAMgAjYCKCADKAIsGiACEIcCCyADQTBqJAAPGSADJAAgAygCJCIABEAgAyAANgIoIAMoAiwaIAAQhwILCQALAAcAIQAgAyQAQeSiA0GM1wA2AgBB4KIDQQA2AgAgABCbBkEBIQICQEHoogMoAgBBAUYEQCAAEO4FIQBBCBDpBSEEBkAGQCADQQxqIQEgACAAKAIAKAIIEQEAIQAYBSABIAAQMSEABkAgAyAAQdTIABDUBSIBKAIINgIgIAMgASkCADcDGCABQgA3AgAgAUEANgIIBkAgBCADQRhqEMsFQQAhAkHkowJBAhDtBQwEGSADJAAgAywAI0EASARAIAMoAiAaIAMoAhgQhwILCQALABkgAyQAIAAsAAtBAEgEQCAAKAIIGiAAKAIAEIcCCwkACwAZIAMkACACBEAgBBDqBQsGQBDvBRkgAyQAEPUFAAsJAAsACwkBCwALAAsgAEHkowJBAhDtBQALUQECfyMAQRBrIgMkACABIAAoAgQiBEEBdWohASAAKAIAIQAgA0EIaiABIAIgBEEBcQR/IAEoAgAgAGooAgAFIAALEQUAIAMoAgwgA0EQaiQAC54LAgp/An0jAEHgAGsiBCQAAkAGQAJAIAAoAgQiC0UEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgFIABBojgQzAUhAAwCGSAEJAAGQCAAEOoFGAUJAAsACyABKAIEIgggASgCACIHa0ECdSIGIAAoAgAiBUcEQEEBIQZB7f8CLQAAQQFGBEAgBCAFNgIwQczOACAEQTBqEOkBCwZAQQgQ6QUhARgEBkAgBEE0aiICIAAoAgAQ3AUGQCAEIAJBq8AAENQFIgAoAgg2AkggBCAAKQIANwNAIABCADcCACAAQQA2AggGQCAEIARBQGtB9zoQ1gUiACgCCDYCWCAEIAApAgA3A1AgAEIANwIAIABBADYCCAZAIAEgBEHQAGoQyAUiAEHMogI2AgBBACEGIABB2KICQY4BEO0FDAcZIAQkACAELABbQQBIBEAgBCgCWBogBCgCUBCHAgsJAAsAGSAEJAAgBCwAS0EASARAIAQoAkgaIAQoAkAQhwILCQALABkgBCQAIAQsAD9BAEgEQCAEKAI8GiAEKAI0EIcCCwkACwAZIAQkACAGBEAGQCABEOoFGAYLCQALAAsCQCAALQBYQQFHDQAgByAIRiIJRQRAIAchBQNAIAUqAgAiDyAPlCAOkiEOIAVBBGoiBSAIRw0ACwsgCQ0AIA5DAAAAAF0gDkMAAAAAXnJFDQAgDouRIQ5BASAGIAZBAU0bIghBAXFBACEFIAZBAk8EQCAHQQRqIQwgCEF+cSEIQQAhBgNAIAcgBUECdCIKaiINIA0qAgAgDpU4AgAgCiAMaiIKIAoqAgAgDpU4AgAgBUECaiEFIAZBAmoiBiAIRw0ACwtFDQAgByAFQQJ0aiIFIAUqAgAgDpU4AgALIAsoAggiByAAKAIEIgUoAgRGBEBBASEFQe3/Ai0AAEEBRgRAIAQgBzYCAEGIyQAgBBDpAQsGQEEIEOkFIQEYBAZAIARBQGsiAiAAKAIEKAIEENwFBkAgBCACQd3FABDUBSIAKAIINgJYIAQgACkCADcDUCAAQgA3AgAgAEEANgIIBkAgASAEQdAAahDLBUEAIQVB5KMCQQIQ7QUMBhkgBCQAIAQsAFtBAEgEQCAEKAJYGiAEKAJQEIcCCwkACwAZIAQkACAELABLQQBIBEAgBCgCSBogBCgCQBCHAgsJAAsAGSAEJAAgBQRABkAgARDqBRgGCwkACwALAkACQAZAIAUgASgCACACIAMgBSgCACgCABEHACAAKAJgIAAsAGciAiIBIAFBAEgbRQ0BQez/Ai0AAEEBRw0BIABB3ABqIQFB7f8CLQAAQQFGBEAgBCAAKAJcIAEgAkEASBs2AiBB8swAIARBIGoQ6QELIAAgARBkDAIHACEAIAQkAEHkogNBnNcANgIAQeCiA0EANgIAIAAQmwYCQEHoogMoAgBBAUYEQCAAEO4FIQBB7f8CLQAAQQFGBEAGQCAAIAAoAgAoAggRAQAhARgJIAQgATYCEEHHzQAgBEEQahDpAQsGQEEIEOkFIQIYCEEBIQYGQAZAIARBQGshASAAIAAoAgAoAggRAQAhABgJIAEgABAxIQAGQCAEIABB1MgAENQFIgEoAgg2AlggBCABKQIANwNQIAFCADcCACABQQA2AggGQCACIARB0ABqEMsFQQAhBkHkowJBAhDtBQwEGSAEJAAgBCwAW0EASARAIAQoAlgaIAQoAlAQhwILCQALABkgBCQAIAAsAAtBAEgEQCAAKAIIGiAAKAIAEIcCCwkACwAZIAQkACAGBEAGQCACEOoFGAoLBkAQ7wUZIAQkABD1BQALCQALAAsJAQsACwALQe3/Ai0AAEEBRw0AQdAjEPIBCyAAQQE6ADwgBEHgAGokAA8LIABB5KMCQQIQ7QUZIAQkAAkACwsACzsBAX8gASAAKAIEIgVBAXVqIQEgACgCACEAIAEgAiADIAQgBUEBcQR/IAEoAgAgAGooAgAFIAALEQcAC/YOAgp/An0jAEGAAWsiBCQAAkAGQAJAIAAoAgQiBUUEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgFIABBojgQzAUhAAwCGSAEJAAGQCAAEOoFGAUJAAsACwJAIAEoAgQiByABKAIAIgZrQQxtIAIoAgQgAigCAGtBAnVHBEBB7f8CLQAAQQFGBEBBszcQ8gELBkAGQEEIEOkFIQAYBiAAQbM3EMwFIQAMAhkgBCQABkAgABDqBRgGCQALAAsCQCAGIAdGBEBB7f8CLQAAQQFGBEBBwzkQ8gELBkAGQEEIEOkFIQAYByAAQcM5EMwFIQAMAhkgBCQABkAgABDqBRgHCQALAAsCQCAAKAIEKAIEIgcgBSgCCCACKAIEIAIoAgBrQQJ1ak8EQANABkAgASgCBCABKAIAIgVrQQxtIAhNBEACQCAAKAJgIAAsAGciAiIBIAFBAEgbRQ0AQez/Ai0AAEEBRw0AIABB3ABqIQFB7f8CLQAAQQFGBEAgBCAAKAJcIAEgAkEASBs2AiBB8swAIARBIGoQ6QELIAAgARBkDAULQe3/Ai0AAEEBRw0EQdAjEPIBDAQLIAUgCEEMbGoiBSgCBCIJIAUoAgAiB2tBAnUiBiAAKAIAIgVHBEBBASEGQe3/Ai0AAEEBRgRAIAQgBTYCFCAEIAg2AhBB2s0AIARBEGoQ6QELBkBBCBDpBSECGAoGQCAEQTRqIgEgCBDcBQZAIAQgAUGbPxDUBSIBKAIINgJIIAQgASkCADcDQCABQgA3AgAgAUEANgIIBkAgBCAEQUBrQb7AABDWBSIBKAIINgJYIAQgASkCADcDUCABQgA3AgAgAUEANgIIBkAgBEEoaiIBIAAoAgAQ3AUGQCAEIARB0ABqIAQoAiggASAELAAzIgBBAEgiARsgBCgCLCAAIAEbENMFIgAoAgg2AmggBCAAKQIANwNgIABCADcCACAAQQA2AggGQCAEIARB4ABqQfc6ENYFIgAoAgg2AnggBCAAKQIANwNwIABCADcCACAAQQA2AggGQCACIARB8ABqEMgFIgBBzKICNgIAQQAhBiAAQdiiAkGOARDtBQwQGSAEJAAgBCwAe0EASARAIAQoAngaIAQoAnAQhwILCQALABkgBCQAIAQsAGtBAEgEQCAEKAJoGiAEKAJgEIcCCwkACwAZIAQkACAELAAzQQBIBEAgBCgCMBogBCgCKBCHAgsJAAsAGSAEJAAgBCwAW0EASARAIAQoAlgaIAQoAlAQhwILCQALABkgBCQAIAQsAEtBAEgEQCAEKAJIGiAEKAJAEIcCCwkACwAZIAQkACAELAA/QQBIBEAgBCgCPBogBCgCNBCHAgsJAAsAGSAEJAAgBgRABkAgAhDqBRgMCwkACwALAkAgAC0AWEEBRw0AQwAAAAAhDiAJIAciBUYiCkUEQANAIAUqAgAiDyAPlCAOkiEOIAVBBGoiBSAJRw0ACwsgCg0AIA5DAAAAAF0gDkMAAAAAXnJFDQAgDouRIQ5BASAGIAZBAU0bIglBAXFBACEFIAZBAk8EQCAHQQRqIQwgCUF+cSEJQQAhBgNAIAcgBUECdCILaiINIA0qAgAgDpU4AgAgCyAMaiILIAsqAgAgDpU4AgAgBUECaiEFIAZBAmoiBiAJRw0ACwtFDQAgByAFQQJ0aiIFIAUqAgAgDpU4AgALIAAoAgQiBSAHIAIoAgAgCEECdGooAgAgAyAFKAIAKAIAEQcABwAhACAEJABB5KIDQazXADYCAEHgogNBADYCACAAEJsGQQEhBgJAQeiiAygCAEEBRgRAIAAQ7gUhAAZAQQgQ6QUhAhgLBkAGQCAEQeAAaiEBIAAgACgCACgCCBEBACEAGAwgASAAEDEhAAZAIAQgAEHhPxDUBSIBKAIINgJ4IAQgASkCADcDcCABQgA3AgAgAUEANgIIBkAgAiAEQfAAahDLBUEAIQZB5KMCQQIQ7QUMBBkgBCQAIAQsAHtBAEgEQCAEKAJ4GiAEKAJwEIcCCwkACwAZIAQkACAALAALQQBIBEAgACgCCBogACgCABCHAgsJAAsAGSAEJAAgBgRABkAgAhDqBRgNCwZAEO8FGSAEJAAQ9QUACwkACwALCQELAAsgCEEBaiEIDAALAAtBASEGQe3/Ai0AAEEBRgRAIAQgBzYCAEGIyQAgBBDpAQsGQEEIEOkFIQEYBgZAIARB4ABqIgIgACgCBCgCBBDcBQZAIAQgAkHdxQAQ1AUiACgCCDYCeCAEIAApAgA3A3AgAEIANwIAIABBADYCCAZAIAEgBEHwAGoQywVBACEGQeSjAkECEO0FDAgZIAQkACAELAB7QQBIBEAgBCgCeBogBCgCcBCHAgsJAAsAGSAEJAAgBCwAa0EASARAIAQoAmgaIAQoAmAQhwILCQALABkgBCQAIAYEQAZAIAEQ6gUYCAsJAAsACyAAQQE6ADwgBEGAAWokAA8LIABB5KMCQQIQ7QUMAwsgAEHkowJBAhDtBQwCCyAAQeSjAkECEO0FGSAEJAAJAAsLAAujFgMMfwJ9An4jAEGQAWsiBCQAAkAGQAJAIAEoAgQiBUUEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgFIABBojgQzAUhAAwCGSAEJAAGQCAAEOoFGAUJAAsACwJAIAIoAgQgAigCAEYEQEHt/wItAABBAUYEQEHDORDyAQsGQAZAQQgQ6QUhABgGIABBwzkQzAUhAAwCGSAEJAAGQCAAEOoFGAYJAAsACyABKAIEKAIEIg4gBSgCCCACKAIEIAIoAgBrQQxtakkEQEEBIQBB7f8CLQAAQQFGBEAgBCAONgIAQYjJACAEEOkBCwZAQQgQ6QUhAhgFBkAgBEHwAGoiAyABKAIEKAIEENwFBkAgBCADQd3FABDUBSIBKAIINgKIASAEIAEpAgA3A4ABIAFCADcCACABQQA2AggGQCACIARBgAFqEMsFQQAhAEHkowJBAhDtBQwHGSAEJAAgBCwAiwFBAEgEQCAEKAKIARogBCgCgAEQhwILCQALABkgBCQAIAQsAHtBAEgEQCAEKAJ4GiAEKAJwEIcCCwkACwAZIAQkACAABEAGQCACEOoFGAcLCQALAAsCQAZAIAIoAgQgAigCAGtBDG0hCyADIQ4jACEKIAAiBUEANgIIIABCADcCAAJAAkAGQCABIgkoAgQaBkAgASgCBEJ/IRIoAswBIgAEQCAAIQMDQCASIAM1AggiEyASIBNVGyESIAMoAgAiAw0ACwsGQAJAIA5FDQADQCAARQ0BAkAgCSgCBCIDKAKIAiIBRQ0AIAMoAoQCAn8gACgCDCIGIAFBAWtxIAFpQQFLIgdFDQAaIAYgASAGSw0AGiAGIAFwCyIIQQJ0aigCACIDRQ0AIAMoAgAiA0UNAAJAIAdFBEAgAUEBayEBA0ACQCAGIAMoAgQiB0cEQCABIAdxIAhGDQEMBQsgAygCCCAGRg0DCyADKAIAIgMNAAsMAgsDQAJAIAYgAygCBCIHRwRAIAEgB00EfyAHIAFwBSAHCyAIRg0BDAQLIAMoAgggBkYNAgsgAygCACIDDQALDAELIAAoAgghBgJAIAUoAgQiASAFKAIIIghJBEAgASAGNgIAIAFBBGohAwwBCyABIAUoAgAiAWsiA0ECdSINQQFqIgdBgICAgARPBEAQNwwIC0H/////AyAIIAFrIghBAXUiDyAHIAcgD0kbIAhB/P///wdPGyIHQYCAgIAETwRAELMBDAgLIAdBAnQiCBCwBSIPIANqIgcgBjYCACAHIA1BAnRrIQYgAwRAIAYgASAD/AoAAAsgBSAIIA9qNgIIIAUgB0EEaiIDNgIEIAUgBjYCACABRQ0AIAEQhwILIAUgAzYCBCADIAUoAgBrQQJ1IAtGDQcLIAAoAgAhAAwACwALIAUoAgAhACAFKAIEIQMDQCADIABrIgZBAnUiASALTw0FIBJCAXwiEqchByAFKAIIIgggA0sEQCADIAc2AgAgBSADQQRqIgM2AgQMAQsgAUEBaiIDQYCAgIAETwRAEDcMBQtB/////wMgCCAAayIIQQF1Ig0gAyADIA1JGyAIQfz///8HTxsiA0GAgICABE8EQBCzAQwFCyADQQJ0IggQsAUiDSAGaiIDIAc2AgAgAyABQQJ0ayEBIAYEQCABIAAgBvwKAAALIAUgCCANajYCCCAFIANBBGoiAzYCBCAFIAE2AgAgAEUEQCABIQAgBSADNgIEDAELIAAQhwIgBSgCACEAIAUgAzYCBAwACwAZIAokAAkACwAZIAokACAFKAIAIQAJAAsAGSAKJAAgAARAIAUgADYCBCAFKAIIGiAAEIcCCwkACwALAAsDQAZABkAgAigCBCACKAIAIgBrQQxtIAxNBEACQCAJKAJgIAksAGciASIAIABBAEgbRQ0AQez/Ai0AAEEBRw0AIAlB3ABqIQBB7f8CLQAAQQFGBEAgBCAJKAJcIAAgAUEASBs2AjBB8swAIARBMGoQ6QELIAkgABBkDAYLQe3/Ai0AAEEBRw0FQdAjEPIBDAULIAAgDEEMbGoiACgCBCIGIAAoAgAiAWtBAnUiAyAJKAIAIgBHBEBBASEDQe3/Ai0AAEEBRgRAIAQgADYCJCAEIAw2AiBB2s0AIARBIGoQ6QELBkBBCBDpBSEBGAoGQCAEQcQAaiIAIAwQ3AUGQCAEIABBmz8Q1AUiACgCCDYCWCAEIAApAgA3A1AgAEIANwIAIABBADYCCAZAIAQgBEHQAGpBvsAAENYFIgAoAgg2AmggBCAAKQIANwNgIABCADcCACAAQQA2AggGQCAEQThqIgAgCSgCABDcBQZAIAQgBEHgAGogBCgCOCAAIAQsAEMiAEEASCICGyAEKAI8IAAgAhsQ0wUiACgCCDYCeCAEIAApAgA3A3AgAEIANwIAIABBADYCCAZAIAQgBEHwAGpB9zoQ1gUiACgCCDYCiAEgBCAAKQIANwOAASAAQgA3AgAgAEEANgIIBkAgASAEQYABahDIBSIAQcyiAjYCAEEAIQMgAEHYogJBjgEQ7QUMEBkgBCQAIAQsAIsBQQBIBEAgBCgCiAEaIAQoAoABEIcCCwkACwAZIAQkACAELAB7QQBIBEAgBCgCeBogBCgCcBCHAgsJAAsAGSAEJAAgBCwAQ0EASARAIAQoAkAaIAQoAjgQhwILCQALABkgBCQAIAQsAGtBAEgEQCAEKAJoGiAEKAJgEIcCCwkACwAZIAQkACAELABbQQBIBEAgBCgCWBogBCgCUBCHAgsJAAsAGSAEJAAgBCwAT0EASARAIAQoAkwaIAQoAkQQhwILCQALABkgBCQAIAMEQAZAIAEQ6gUYDAsJAAsACwJAIAktAFhBAUcNAEMAAAAAIRAgBiABIgBGIgpFBEADQCAAKgIAIhEgEZQgEJIhECAAQQRqIgAgBkcNAAsLIAoNACAQQwAAAABdIBBDAAAAAF5yRQ0AIBCLkSEQQQEgAyADQQFNGyIGQQFxQQAhACADQQJPBEAgAUEEaiEHIAZBfnEhBkEAIQMDQCABIABBAnQiC2oiCCAIKgIAIBCVOAIAIAcgC2oiCyALKgIAIBCVOAIAIABBAmohACADQQJqIgMgBkcNAAsLRQ0AIAEgAEECdGoiACAAKgIAIBCVOAIACyAJKAIEIgAgASAFKAIAIAxBAnRqKAIAIA4gACgCACgCABEHAAcAIQAgBCQAQeSiA0G81wA2AgBB4KIDQQA2AgAgABCbBgJAQeiiAygCAEEBRgRAIAAQ7gUhAEHt/wItAABBAUYEQAZAIAAgACgCACgCCBEBACEBGAwgBCABNgIQQb7LACAEQRBqEOkBCwZAQQgQ6QUhAhgLQQEhAwZABkAgBEHwAGohASAAIAAoAgAoAggRAQAhABgMIAEgABAxIQAGQCAEIABBkcAAENQFIgEoAgg2AogBIAQgASkCADcDgAEgAUIANwIAIAFBADYCCAZAIAIgBEGAAWoQywVBACEDQeSjAkECEO0FDAQZIAQkACAELACLAUEASARAIAQoAogBGiAEKAKAARCHAgsJAAsAGSAEJAAgACwAC0EASARAIAAoAggaIAAoAgAQhwILCQALABkgBCQAIAMEQAZAIAIQ6gUYDQsGQBDvBRkgBCQAEPUFAAsJAAsACwkBCwALGSAEJAAgBSgCACIABEAgBSAANgIEIAUoAggaIAAQhwILCQALIAxBAWohDAwACwAZIAQkAAkACwALIAlBAToAPCAEQZABaiQADwsgAEHkowJBAhDtBQwCCyAAQeSjAkECEO0FGSAEJAAJAAsLAAuZAQEDfyMAQRBrIgQkACAAKAIAIQUgBEEEaiIGIAEgACgCBCIAQQF1aiIBIAIgAyAAQQFxBH8gASgCACAFaigCAAUgBQsRBwAGQCAGELYBIQEZIAQkACAEKAIEIgAEQCAEIAA2AgggBCgCDBogABCHAgsJAAsgBCgCBCIABEAgBCAANgIIIAQoAgwaIAAQhwILIARBEGokACABC6oBAQN/IwAhAgJABkAgAS0APEEBRgRAIAEQrgELIABBADYCCCAAQgA3AgAgASgCRCIDIAEoAkAiBEYNAQZAIAMgBGsiAUEASARAEDcACyABELAFIQIZIAIkACAAKAIAIgEEQCAAIAE2AgQgACgCCBogARCHAgsJAAsZIAIkAAkACyAAIAI2AgAgACABIAJqIgM2AgggAQRAIAIgBCAB/AoAAAsgACADNgIECwuVAQEDfyMAQRBrIgIkACAAKAIAIQMgAkEEaiIEIAEgACgCBCIAQQF1aiIBIABBAXEEfyABKAIAIANqKAIABSADCxEAAAZAIAQQtgEhARkgAiQAIAIoAgQiAARAIAIgADYCCCACKAIMGiAAEIcCCwkACyACKAIEIgAEQCACIAA2AgggAigCDBogABCHAgsgAkEQaiQAIAELqgEBA38jACECAkAGQCABLQA8QQFGBEAgARCuAQsgAEEANgIIIABCADcCACABKAJQIgMgASgCTCIERg0BBkAgAyAEayIBQQBIBEAQNwALIAEQsAUhAhkgAiQAIAAoAgAiAQRAIAAgATYCBCAAKAIIGiABEIcCCwkACxkgAiQACQALIAAgAjYCACAAIAEgAmoiAzYCCCABBEAgAiAEIAH8CgAACyAAIAM2AgQLC2IBAX8jACEBAkAgACgCBCIARQRAQe3/Ai0AAEEBRgRAQaI4EPIBCwZABkBBCBDpBSEAGAMgAEGiOBDMBSEADAIZIAEkACAAEOoFCQALAAsgACgCBA8LIABB5KMCQQIQ7QUAC/0BAQJ/IwBBEGsiAiQABkACQCAAKAIEIgNFBEBB7f8CLQAAQQFGBEBBojgQ8gELBkAGQEEIEOkFIQAYBCAAQaI4EMwFIQAMAhkgAiQABkAgABDqBRgECQALAAsgAyABELEBAkACQCAAKAJgIAAsAGciAyIBIAFBAEgbRQ0AQez/Ai0AAEEBRw0AIABB3ABqIQFB7f8CLQAAQQFGBEAgAiAAKAJcIAEgA0EASBs2AgBB8swAIAIQ6QELIAAgARBkDAELQe3/Ai0AAEEBRw0AQdAjEPIBCyAAQQE6ADwgABCuASACQRBqJAAPCyAAQeSjAkECEO0FGSACJAAJAAsAC/4EAQN/IwBBMGsiAiQABkACQCAAKAIERQRAQe3/Ai0AAEEBRgRAQaI4EPIBCwZABkBBCBDpBSEAGAQgAEGiOBDMBSEADAIZIAIkAAZAIAAQ6gUYBAkACwALIAEoAgQhAyABKAIAIQEGQANAAkAgASADRgRAAkAgACgCYCAALABnIgMiASABQQBIG0UNAEHs/wItAABBAUcNACAAQdwAaiEBQe3/Ai0AAEEBRgRAIAIgACgCXCABIANBAEgbNgIQQfLMACACQRBqEOkBCyAAIAEQZAwCC0Ht/wItAABBAUcNAUHQIxDyAQwBCyAAKAIEIAEoAgAQsQEgAUEEaiEBDAELCyAAQQE6ADwgABCuAQcAIQAgAiQAQeSiA0HM1wA2AgBB4KIDQQA2AgAgABCbBgJAQeiiAygCAEEBRgRAIAAQ7gUhAUHt/wItAABBAUYEQAZAIAEgASgCACgCCBEBACEAGAYgAiAANgIAQaDLACACEOkBCwZAQQgQ6QUhAxgFQQEhAAZABkAgAkEUaiEEIAEgASgCACgCCBEBACEBGAYgBCABEDEhAQZAIAIgAUH2PxDUBSIAKAIINgIoIAIgACkCADcDICAAQgA3AgAgAEEANgIIQQEhAAZAIAMgAkEgahDLBUEAIQBB5KMCQQIQ7QUMBBkgAiQAIAIsACtBAEgEQCACKAIoGiACKAIgEIcCCwkACwAZIAIkACABLAALQQBIBEAgASgCCBogASgCABCHAgsJAAsAGSACJAAgAARABkAgAxDqBRgHCwZAEO8FGSACJAAQ9QUACwkACwALCQELAAsgAkEwaiQADwsgAEHkowJBAhDtBRkgAiQACQALAAv9AQECfyMAQRBrIgIkAAZAAkAgACgCBCIDRQRAQe3/Ai0AAEEBRgRAQaI4EPIBCwZABkBBCBDpBSEAGAQgAEGiOBDMBSEADAIZIAIkAAZAIAAQ6gUYBAkACwALIAMgARCyAQJAAkAgACgCYCAALABnIgMiASABQQBIG0UNAEHs/wItAABBAUcNACAAQdwAaiEBQe3/Ai0AAEEBRgRAIAIgACgCXCABIANBAEgbNgIAQfLMACACEOkBCyAAIAEQZAwBC0Ht/wItAABBAUcNAEHQIxDyAQsgAEEBOgA8IAAQrgEgAkEQaiQADwsgAEHkowJBAhDtBRkgAiQACQALAAtiAQF/IwAhAQJAIAAoAgQiAEUEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgDIABBojgQzAUhAAwCGSABJAAgABDqBQkACwALIAAoAggPCyAAQeSjAkECEO0FAAtiAQF/IwAhAQJAIAAoAgQiAEUEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgDIABBojgQzAUhAAwCGSABJAAgABDqBQkACwALIAAoAigPCyAAQeSjAkECEO0FAAtkAQF/IwAhAgJAIAAoAgQiAEUEQEHt/wItAABBAUYEQEGiOBDyAQsGQAZAQQgQ6QUhABgDIABBojgQzAUhAAwCGSACJAAgABDqBQkACwALIAAgATYCKA8LIABB5KMCQQIQ7QUAC/EQAgh/An0jAEGAAWsiBSQAAkAgASgCBCIGRQRAQe3/Ai0AAEEBRgRAQaI4EPIBCwZABkBBCBDpBSEAGAMgAEGiOBDMBSEADAIZIAUkACAAEOoFCQALAAsCQCACKAIEIAIoAgBrQQJ1IgcgASgCACIIRwRAQQEhBkHt/wItAABBAUYEQCAFIAc2AhQgBSAINgIQQbHPACAFQRBqEOkBC0EIEOkFIQMGQCAFQcQAaiIAIAEoAgAQ3AUGQCAFIABBlcQAENQFIgAoAgg2AlggBSAAKQIANwNQIABCADcCACAAQQA2AggGQCAFIAVB0ABqQco/ENYFIgAoAgg2AmggBSAAKQIANwNgIABCADcCACAAQQA2AggGQCAFQThqIgAgAigCBCACKAIAa0ECdRDcBQZAIAUgBUHgAGogBSgCOCAAIAUsAEMiAEEASCIBGyAFKAI8IAAgARsQ0wUiACgCCDYCeCAFIAApAgA3A3AgAEIANwIAIABBADYCCAZAIAUgBUHwAGpB9joQ1gUiACgCCDYCKCAFIAApAgA3AyAgAEIANwIAIABBADYCCAZAIAMgBUEgahDIBSIAQcyiAjYCAEEAIQYgAEHYogJBjgEQ7QUMCBkgBSQAIAUsACtBAEgEQCAFKAIoGiAFKAIgEIcCCwkACwAZIAUkACAFLAB7QQBIBEAgBSgCeBogBSgCcBCHAgsJAAsAGSAFJAAgBSwAQ0EASARAIAUoAkAaIAUoAjgQhwILCQALABkgBSQAIAUsAGtBAEgEQCAFKAJoGiAFKAJgEIcCCwkACwAZIAUkACAFLABbQQBIBEAgBSgCWBogBSgCUBCHAgsJAAsAGSAFJAAgBSwAT0EASARAIAUoAkwaIAUoAkQQhwILCQALABkgBSQAIAYEQCADEOoFCwkACwALIAYoAgQiBiADSQRAQQEhAkHt/wItAABBAUYEQCAFIAY2AgBB7s8AIAUQ6QELQQgQ6QUhAwZAIAVB4ABqIgAgASgCBCgCBBDcBQZAIAUgAEH0xwAQ1AUiACgCCDYCeCAFIAApAgA3A3AgAEIANwIAIABBADYCCAZAIAUgBUHwAGpB9joQ1gUiACgCCDYCKCAFIAApAgA3AyAgAEIANwIAIABBADYCCAZAIAMgBUEgahDIBSIAQcyiAjYCAEEAIQIgAEHYogJBjgEQ7QUMBRkgBSQAIAUsACtBAEgEQCAFKAIoGiAFKAIgEIcCCwkACwAZIAUkACAFLAB7QQBIBEAgBSgCeBogBSgCcBCHAgsJAAsAGSAFJAAgBSwAa0EASARAIAUoAmgaIAUoAmAQhwILCQALABkgBSQAIAIEQCADEOoFCwkACwALAkAgA0UEQEHt/wItAABBAUYEQEGyOhDyAQsGQAZAQQgQ6QUhABgFIABBsjoQqQEhAAwCGSAFJAAgABDqBQkACwALQQAhBwJAAkAgBCgCBCIGQQJrDgMBAAEAC0EMELAFIQcgBUHQgAM2AjAgBSAGNgI0BkAgBkEJTwRABkAgBhALGSAFJAAgBUEwahAwCQALIAUoAjQhBgsgB0HQ7gA2AgAGQCAGQQlPBEAgBhALCyAFIAY2AiBB9NcAIAVBIGoQCiEEGSAFJAAgBUEwahAwCQALGSAFJAAgBxCHAgkACyAHIAQ2AgggB0HQgAM2AgQgBSgCNCIEQQlJDQAGQCAEEAAZIAUkABD1BQALIAVBADYCNAsgAigCACEEAkAgAS0AWEEBRw0AIAIoAgQiBiAERiIIRQRAIAQhAgNAIAIqAgAiDiAOlCANkiENIAJBBGoiAiAGRw0ACwsgCA0AIA1DAAAAAF0gDUMAAAAAXnJFDQAgDYuRIQ1BASAGIARrQQJ1IgYgBkEBTRsiCEEBcUEAIQIgBkECTwRAIARBBGohCyAIQX5xIQhBACEGA0AgBCACQQJ0IglqIgwgDCoCACANlTgCACAJIAtqIgkgCSoCACANlTgCACACQQJqIQIgBkECaiIGIAhHDQALC0UNACAEIAJBAnRqIgIgAioCACANlTgCAAsgBUEgaiABKAIEIgEgBCADIAcgASgCACgCBBEKACAFKAIgIQEgBSgCJCECBkAgBRAMNgJkIAVB0IADNgJgBkAQDCEDIAIgAWtBA3UhAiAFIAM2AlQgBUHQgAM2AlAgBUHwAGpBBHIhAQZAAkACQANAAkAgBSACQQFrNgJEIAJBAEwEQCAHRQ0EIAdB0O4ANgIAIAcoAggiAUEJSQ0DBkAgARAADAIZIAUkABD1BQALAAsgBSAFKAIgKQIANwNwIAVB4ABqIAVBxABqIgIgBUHwAGoQqgEgBUHQAGogAiABEKsBIAVBIGoQrAEgBSgCRCECDAELCyAHQQA2AggLIAcQhwILIAAQDSICNgIEIABB0IADNgIABkAgBUGaExAOIgE2AnQgBUHQgAM2AnAGQCACIAEgBSgCZBAPGSAFJAAgBUHwAGoQMAkACyABQQlPBEAGQCABEAAZIAUkABD1BQALCyAFQe0REA4iATYCdCAFQdCAAzYCcAZAIAIgASAFKAJUEA8ZIAUkACAFQfAAahAwCQALGSAFJAAgABAwCQALGSAFJAAgBUHQAGoQMAkACxkgBSQAIAVB4ABqEDAJAAsZIAUkACAFKAIgIgAEQCAFIAA2AiQgBSgCKBogABCHAgsJAAsgAUEJTwRABkAgARAAGSAFJAAQ9QUACwsgBSgCVCIAQQlPBEAGQCAAEAAZIAUkABD1BQALCyAFKAJkIgBBCU8EQAZAIAAQABkgBSQAEPUFAAsLIAUoAiAiAARAIAUgADYCJCAFKAIoGiAAEIcCCyAFQYABaiQADwsgAEHYogJBjgEQ7QUACwALIABB5KMCQQIQ7QUACwkAIAEgABEDAAsGAEGw+AALDAAgAARAIAAQhwILCwcAIAARDwALBwBBARCwBQveAQEEfyMAQRBrIgIkAAJAIAEoAgAiA0H4////B0kEQAJAAkAgA0ELTwRAIANBB3IiBUEBahCwBSEEIAIgBUH/////B2s2AgwgAiAENgIEIAIgAzYCCAwBCyACIAM6AA8gAkEEaiEEIANFDQELIANFDQAgBCABQQRqIAP8CgAACyADIARqQQA6AAAGQCACQQRqIAARAwAMAhkgAiQAIAIsAA9BAEgEQCACKAIMGiACKAIEEIcCCwkACwALEDIACyACLAAPQQBIBEAgAigCDBogAigCBBCHAgsgAkEQaiQAC8oBAQF/IwBBEGsiASQAAkBB7P8CLQAADQAGQEHw/wJB4glBDhDSBSABIAAoAgAgACAALAALQQBIGzYCACABQfD/AkHw/wIoAgBB+/8CLAAAQQBOGzYCBEGn+wJB9PkAIAEQEBpB7P8CQQE6AAAgAUECNgIMIAFB0IADNgIIBkBBASABQQhqEIEBGSABJAAgAUEIahAwCQALGSABJAAJAAsgASgCDCIAQQlJDQAGQCAAEAAZIAEkABD1BQALIAFBADYCDAsgAUEQaiQACwkAQez/Ai0AAAteAQF/IwBBEGsiAyQAIAMgAjYCDCADQdCAAzYCCAZAIAEgA0EIaiAAEQAAGSADJAAgA0EIahAwCQALIAMoAgwiAEEJTwRABkAgABAAGSADJAAQ9QUACwsgA0EQaiQAC5cCAQJ/IwBBEGsiAiQAQe3/Ai0AAEEBRgRAQZ86EPIBCwJAQez/Ai0AAEUEQEHt/wItAABBAUYEQEHoKhDyAQsGQAZAQQgQ6QUhABgDIABB6CoQzAUhAAwCGSACJAAgABDqBQkACwALQeD/Ai0AAEEBRgRAQdz/AigCABoLQeD/AkEBOgAAQdz/AkHE/wI2AgAgAiABKAIEIgE2AgwgAkHQgAM2AgggAUEJTwRABkAgARALGSACJAAgAkEIahAwCQALC0Ho/wIoAgAiA0EJTwRABkAgAxAAGSACJAAQ9QUACwtB6P8CIAE2AgBB5P8CQdCAAzYCAEHu/wJBADoAACAAEBEgAkEQaiQADwsgAEHkowJBAhDtBQALCwBB7f8CIAA6AAALCQBB7v8CLQAAC+IBAQR/IwBBEGsiAiQAAkAgASgCACIDQfj///8HSQRAAkACQCADQQtPBEAgA0EHciIFQQFqELAFIQQgAiAFQf////8HazYCDCACIAQ2AgQgAiADNgIIDAELIAIgAzoADyACQQRqIQQgA0UNAQsgA0UNACAEIAFBBGogA/wKAAALIAMgBGpBADoAAAZAIAJBBGogABEBACEADAIZIAIkACACLAAPQQBIBEAgAigCDBogAigCBBCHAgsJAAsACxAyAAsgAiwAD0EASARAIAIoAgwaIAIoAgQQhwILIAJBEGokACAAC98MAgt/AX4jAEEwayIBJAACfwZAQfT/AigCAEH7/wIsAAAiBSAFQQBIGyIEQQFqIgJB+P///wdPBEAQMgALAkACQCACQQtPBEAgAkEHckEBaiIGELAFIQMgASACNgIMIAEgAzYCCCABIAZBgICAgHhyNgIQDAELIAFBADYCECABQgA3AwggASACOgATIAFBCGohAyAERQ0BCyAERQ0AIANB8P8CQfD/AigCACAFQQBOGyAE/AoAAAsgAyAEakEvOwAABkAgAUEIaiAAKAIAIAAgACwACyIEQQBIIgIbIAAoAgQgBCACGxDTBSEAGSABJAAgASwAE0EASARAIAEoAhAaIAEoAggQhwILCQALIAEgACgCCDYCICABIAApAgA3AxggAEIANwIAIABBADYCCCABLAATQQBIBEAg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IAALhgMBBH8gAiAAKAIAIAFBDGxqIgBHBEACQCACKAIEIgEhBCABIAIoAgAiAWtBAnUiBSAAKAIIIgIgACgCACIDa0ECdU0EQCAFIAAoAgQiAiADayIGQQJ1SwRAIAIgA0cEQCAGBEAgAyABIAb8CgAACyAAKAIEIQILIAQgASAGaiIDayEBAkAgAyAERg0AIAFFDQAgAiADIAH8CgAACyAAIAEgAmo2AgQMAgsgBCABayECAkAgASAERg0AIAJFDQAgAyABIAL8CgAACyAAIAIgA2o2AgQMAQsgAwRAIAAgAzYCBCADEIcCIABBADYCCCAAQgA3AgBBACECCwJAIAVBgICAgARPDQBB/////wMgAkEBdSIDIAUgAyAFSxsgAkH8////B08bIgJBgICAgARPDQAgACACQQJ0IgMQsAUiAjYCBCAAIAI2AgAgACACIANqNgIIIAQgAWshAwJAIAEgBEYNACADRQ0AIAIgASAD/AoAAAsgACACIANqNgIEDAELEDcACwtBAQsQACABIAIgAyAAKAIAEQQACwYAQaToAAvlAQEGfyAAKAIEIgIgACgCCCIESQRAIAIgASgCADYCACAAIAJBBGo2AgQPCwJAIAIgACgCACICayIFQQJ1IgdBAWoiA0GAgICABEkEQEH/////AyAEIAJrIgRBAXUiBiADIAMgBkkbIARB/P///wdPGyIDQYCAgIAETw0BIANBAnQiBBCwBSIGIAVqIgMgASgCADYCACADIAdBAnRrIQEgBQRAIAEgAiAF/AoAAAsgACAEIAZqNgIIIAAgA0EEaiIFNgIEIAAgATYCACACBEAgAhCHAgsgACAFNgIEDwsQNwALELMBAAtSAQJ/IwBBEGsiAyQAIAEgACgCBCIEQQF1aiEBIAAoAgAhACAEQQFxBEAgASgCACAAaigCACEACyADIAI2AgwgASADQQxqIAARAAAgA0EQaiQAC7sEAQl/IAAoAgQgACgCACIDa0ECdSIEIAFJBEACQCABIARrIgMgACIEKAIIIgUgACgCBCIBa0ECdU0EQAJAIANFDQAgAigCACECIAEhACADQQdxIgYEQANAIAAgAjYCACAAQQRqIQAgB0EBaiIHIAZHDQALCyADQQJ0IAFqIQEgA0EBa0H/////A3FBB0kNAANAIAAgAjYCHCAAIAI2AhggACACNgIU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BUEEajYCHAwACwALIAgoAgghAyACIAhBDGoiATYCNCACQThqIAIgASACQTRqEKcBIAIoAjggAzYCDAJAIAAoAgQiBCgCiAIiA0UNACAEKAKEAgJ/IAEoAgAiBCADQQFrcSADaUEBSyIFRQ0AGiAEIAMgBEsNABogBCADcAsiB0ECdGooAgAiAUUNACABKAIAIgFFDQAgBUUEQCADQQFrIQMDQAJAIAQgASgCBCIFRwRAIAMgBXEgB0YNAQwECyABKAIIIARGDQYLIAEoAgAiAQ0ACwwBCwNAAkAgBCABKAIEIgVHBEAgAyAFTQR/IAUgA3AFIAULIAdGDQEMAwsgASgCCCAERg0FCyABKAIAIgENAAsLIAgoAgghASAGIApJBEAgBiABNgIAIAIgBkEEaiIGNgIoDAMLIAYgCWsiBkECdSIFQQFqIgNBgICAgARPBEAQNwwCC0H/////AyAKIAlrIgRBAXUiCiADIAMgCkkbIARB/P///wdPGyIDQYCAgIAETwRAELMBDAILIANBAnQiChCwBSEDGSACJAAgAhClASACKAIYIgAEQCACIAA2AhwgAigCIBogABCHAgsgAigCJCIABEAgAiAANgIoIAIoAiwaIAAQhwILCQALIAMgBmoiBCABNgIAIAQgBUECdGshASAGBEAgASAJIAb8CgAACyACIAMgCmoiCjYCLCACIARBBGoiBjYCKCACIAE2AiQgCQRAIAkQhwILIAEhCSACIAY2AigMAQsLAAurBwEJfyMAQSBrIgMkAAJAIAAoAgggAUsEQAZABkBBCBDpBSEAGAMgAEGXERDMBSEADAIZIAMkACAAEOoFCQALAAsgACgCRCICBEAgAhDaARCHAgsGQAZAQTQQsAUhAhgCIAIgARDPASECGSADJAAgAhCHAgkACyAAIAI2AkQCQAJAIAAoApgBIgIgACgClAEiCGtBAnUiBCABSQRAAkAgASAEayIEIAAoApwBIgYgAmtBAnVNBEAgACAEBH8gBEECdCIEBEAgAkEAIAT8CwALIAIgBGoFIAILNgKYAQwBCwJAIAIgACgClAEiAmsiBUECdSIJIARqIgdBgICAgARJBEBBACEIQf////8DIAYgAmsiBkEBdSIKIAcgByAKSRsgBkH8////B08bIgcEQCAHQYCAgIAETw0CIAdBAnQQsAUhCAsgBSAIaiEGIARBAnQiBARAIAZBACAE/AsACyAGIAlBAnRrIQkgBQRAIAkgAiAF/AoAAAsgACAIIAdBAnRqNgKcASAAIAQgBmo2ApgBIAAgCTYClAEgAgRAIAIQhwILDAILEDcACxCzAQALIANBADYCFCADQgA3AgwgA0EAOgAcIAMgA0EMajYCGAwBCyABIARJBEAgACAIIAFBAnRqNgKYAQsgA0EANgIUIANCADcCDCADQQA6ABwgAyADQQxqNgIYIAFFDQELBkAgAUGr1arVAE8EQBA3AAsgAUEYbCICELAFIQUZIAMkACADQRhqEM4BCQALIAMgAiAFajYCFCACQRhrIgIgAkEYcGtBGGoiAgRAIAVBACAC/AsACyADIAIgBWo2AhALIAMgACgCbCICNgIMIAAgBTYCbCADKAIQIQQgAyAAKAJwIgU2AhAgACAENgJwIAMoAhQhBCADIAAoAnQ2AhQgACAENgJ0IAIEQCACIQQgAiAFRwRAA0AgAiAFQRhrIgVHDQALIAMoAgwhBAsgAyACNgIQIAMoAhQaIAQQhwILAkAgACgCjAEgACgCDCABbBCIAiICRQRABkAGQEEIEOkFIQAYBCAAQeMVEMwFIQAMAhkgAyQAIAAQ6gUJAAsACyAAIAI2AowBAkAgACgCkAEgAUECdBCIAiICRQRABkAGQEEIEOkFIQAYBSAAQfcREMwFIQAMAhkgAyQAIAAQ6gUJAAsACyAAIAE2AgQgACACNgKQASADQSBqJAAPCyAAQeSjAkECEO0FAAsgAEHkowJBAhDtBQALIABB5KMCQQIQ7QUAC8QFAQl/IwAhByABKAJIGgJABkAGQAJAAkACQCABKALIASIERQ0AIAEoAsQBAn8gBEEBayACcSAEaSIFQQFNDQAaIAIgAiAESQ0AGiACIARwCyIGQQJ0aigCACIDRQ0AIAMoAgAiA0UNAAJAIAVBAU0EQCAEQQFrIQQDQAJAIAMoAgQiBSACRwRAIAQgBXEgBkYNAQwFCyADKAIIIAJGDQMLIAMoAgAiAw0ACwwCCwNAAkAgAygCBCIFIAJHBEAgBCAFTQR/IAUgBHAFIAULIAZGDQEMBAsgAygCCCACRg0CCyADKAIAIgMNAAsMAQsgASgChAEgASgCjAEgAygCDCICIAEoAgxsamotAAJBAXFFDQELBkAGQEEIEOkFIQAYBiAAQaEjEMwFIQAMAhkgByQABkAgABDqBRgGCQALAAsgASgCqAEoAgAhCSABKAKAASABKAKMASABKAIMIQVBACEBIABBADYCCCAAQgA3AgAgAiAFbGpqIQVBACEGQQAhA0EAIQIDQAJAAkAgAiAJSQRAIAMgBkkEQCADIAUqAgA4AgAgA0EEaiEDDAMLBkAgAyABayIDQQJ1IgpBAWoiBEGAgICABE8EQBA3DAkLQf////8DIAYgAWsiBkEBdSIIIAQgBCAISRsgBkH8////B08bIgRBgICAgARPBEAQswEMCQsgBEECdCILELAFIQYMAhkgByQAIAAoAgAiAwRAIAAgAzYCBCAAKAIIGiADEIcCCwkACwALDwsgAyAGaiIIIAUqAgA4AgAgCCAKQQJ0ayEEIAMEQCAEIAEgA/wKAAALIAAgBiALaiIGNgIIIAAgCEEEaiIDNgIEIAAgBDYCACABBEAgARCHAgsgBCEBCyAAIAM2AgQgAkEBaiECIAVBBGohBQwACwALIABB5KMCQQIQ7QUZIAckAAkACxkgByQACQALCwALuwIBBX8jACEFIAAoAkgaBkAGQAJAAkACQCAAKALIASIDRQ0AIAAoAsQBAn8gA0EBayABcSADaSIEQQFNDQAaIAEgASADSQ0AGiABIANwCyIGQQJ0aigCACICRQ0AIAIoAgAiAkUNACAEQQFNBEAgA0EBayEDA0ACQCABIAIoAgQiBEcEQCADIARxIAZGDQEMBAsgAigCCCABRg0ECyACKAIAIgINAAsMAQsDQAJAIAEgAigCBCIERwRAIAMgBE0EfyAEIANwBSAECyAGRg0BDAMLIAIoAgggAUYNAwsgAigCACICDQALCwZABkBBCBDpBSEAGAUgAEGhIxDMBSEADAIZIAUkAAZAIAAQ6gUYBQkACwALIAAgAigCDBDlAQ8LIABB5KMCQQIQ7QUZIAUkAAkACxkgBSQACQALAAu7AgEFfyMAIQUgACgCSBoGQAZAAkACQAJAIAAoAsgBIgNFDQAgACgCxAECfyADQQFrIAFxIANpIgRBAU0NABogASABIANJDQAaIAEgA3ALIgZBAnRqKAIAIgJFDQAgAigCACICRQ0AIARBAU0EQCADQQFrIQMDQAJAIAEgAigCBCIERwRAIAMgBHEgBkYNAQwECyACKAIIIAFGDQQLIAIoAgAiAg0ACwwBCwNAAkAgASACKAIEIgRHBEAgAyAETQR/IAQgA3AFIAQLIAZGDQEMAwsgAigCCCABRg0DCyACKAIAIgINAAsLBkAGQEEIEOkFIQAYBSAAQaEjEMwFIQAMAhkgBSQABkAgABDqBRgFCQALAAsgACACKAIMENUBDwsgAEHkowJBAhDtBRkgBSQACQALGSAFJAAJAAsACzEBAX9BBBDpBSIAQZihAjYCACAAQfCgAjYCACAAQYShAjYCACAAQbyhAkGQARDtBQALPwECfyMAIQIGQAZAQQgQ6QUhARgBIAEgABDKBSIAQYSjAjYCABkgAiQAIAEQ6gUJAAsgAEGQowJBjgEQ7QUAC2sBBH8gACgCBCIEIAAoAggiAUcEQANAIAAgAUEMayICNgIIIAIoAgAiAwR/IAFBCGsgAzYCACABQQRrKAIAGiADEIcCIAAoAggFIAILIgEgBEcNAAsLIAAoAgAiAgRAIAAoAgwaIAIQhwILC5oBAQR/IwAhAkEMELAFIgFBADYCCCABQgA3AgAgACgCBCIDIAAoAgAiBEcEQAZAIAMgBGsiAEEASARAEDcACyAAELAFIQIZIAIkACABKAIAIgAEQCABIAA2AgQgASgCCBogABCHAgsgARCHAgkACyABIAI2AgAgASAAIAJqIgM2AgggAARAIAIgBCAA/AoAAAsgASADNgIECyABC84BAQF/IwAhAiAAQQA2AgQGQAJAIAFFBEBB7f8CLQAAQQFGBEBBgDcQ8gELBkAGQEEIEOkFIQEYBCABQYA3EMoFIQEMAhkgAiQABkAgARDqBRgECQALAAsgACABNgIAQRAQsAUiAiABNgIMIAJBkQE2AgQgAkG86wA2AgAgAiABQQJ0NgIIIAAgAjYCBCAADwsgAUHMogI2AgAgAUHYogJBjgEQ7QUZIAIkACAAKAIEIQEgAEEANgIEIAEEQCABIAEoAgAoAhARAwALCQALAAvYAQICfQJ/IAIoAgAiAkUEQEMAAAAADwsgAkEDcSEFAkAgAkEESQRADAELIAJBfHEhBkEAIQIDQCAAKgIMIAEqAgyTIgMgA5QgACoCCCABKgIIkyIDIAOUIAAqAgQgASoCBJMiAyADlCAAKgIAIAEqAgCTIgMgA5QgBJKSkpIhBCABQRBqIQEgAEEQaiEAIAJBBGoiAiAGRw0ACwsgBQRAQQAhAgNAIAAqAgAgASoCAJMiAyADlCAEkiEEIABBBGohACABQQRqIQEgAkEBaiICIAVHDQALCyAECwcAIAAoAggLBwAgACgCBAsHACAAQQxqCwcAIAAQhwIL7QECAX0GfwJAIAIoAgAiAkUEQAwBCyACQQNxIQYCQCACQQRJBEBBACECDAELIAJBfHEhCUEAIQIDQCAAIAJBAnQiBEEMciIFaioCACABIAVqKgIAlCAAIARBCHIiBWoqAgAgASAFaioCAJQgACAEQQRyIgVqKgIAIAEgBWoqAgCUIAAgBGoqAgAgASAEaioCAJQgA5KSkpIhAyACQQRqIQIgCEEEaiIIIAlHDQALCyAGRQ0AA0AgACACQQJ0IgRqKgIAIAEgBGoqAgCUIAOSIQMgAkEBaiECIAdBAWoiByAGRw0ACwtDAACAPyADkwsEACAAC/gEAgN/AXwjAEFAaiICJAACQAJAAkAgACgCCCIDQQJrDgMAAQABC0Ht/wItAABBAUYEQEHDNhDyAQsGQAZAQQgQ6QUhABgDIABBwzYQqQEhAAwCGSACJAAgABDqBQkACwALIAJB0IADNgIkIAJBADYCKCACIAE2AjggAkECNgIwIAJBADYCLAZAAkBBlIADLQAAQQFxBEBBkIADKAIAIQEMAQtBA0Gs7wBBABABIQFBlIADQQE6AABBkIADIAE2AgAgACgCCCEDCyABIANBtxwgAkEsaiACQTBqEAIhBRkgAiQAIAJBJGoQMAZACQEHACEAIAIkAEHkogNB3NcANgIAQeCiA0EANgIAIAAQmwYCQEHoogMoAgBBAUYEQCAAEO4FIQBB7f8CLQAAQQFGBEAgAiAAIAAoAgAoAggRAQA2AgBBr8wAIAIQ6QELQQgQ6QUhBEEBIQMGQAZAIAJBDGohASAAIAAoAgAoAggRAQAhABgGIAEgABAxIQAGQCACIABBqsUAENQFIgEoAgg2AiAgAiABKQIANwMYIAFCADcCACABQQA2AggGQCAEIAJBGGoQyAUiAUHMogI2AgBBACEDIAFB2KICQY4BEO0FDAQZIAIkACACLAAjQQBIBEAgAigCIBogAigCGBCHAgsJAAsAGSACJAAgACwAC0EASARAIAAoAggaIAAoAgAQhwILCQALABkgAiQAIAMEQCAEEOoFCwZAEO8FGSACJAAQ9QUACwkACwALCQELAAsACyACKAIsIgAEQAZAIAAQAxkgAiQAEPUFAAsLIAJBQGskACAFRAAAAAAAAAAAYg8LIABB2KICQY4BEO0FAAvGAwEFfyMAQSBrIgUkACAFIAI2AgwgAEE4aiEIBkACQAJAAkACQCAAKAI8IgZFDQAgCCgCAAJ/IAZBAWsgAnEgBmkiB0EBTQ0AGiACIAIgBkkNABogAiAGcAsiA0ECdGooAgAiBEUNACAEKAIAIgRFDQAgB0EBTQRAIAZBAWshBgNAAkAgAiAEKAIEIgdHBEAgBiAHcSADRg0BDAQLIAQoAgggAkYNBAsgBCgCACIEDQALDAELA0ACQCACIAQoAgQiB0cEQCAGIAdNBH8gByAGcAUgBwsgA0YNAQwDCyAEKAIIIAJGDQMLIAQoAgAiBA0ACwsgACgCDCIEIAAoAghPBEAGQAZAQQgQ6QUhABgGIABB7MoAEMwFIQAMBBkgBSQABkAgABDqBRgGCQALAAsgBSAFQQxqIgI2AhQgBUEYaiAIIAIgBUEUahCnASAFKAIYIAQ2AgwgACAAKAIMQQFqNgIMDAELIAQoAgwhBAsgACgCFCAAKAIEIAAoAhAgBGxqaiAFKAIMNgAAIAAoAhQiAgRAIAAoAgQgACgCECAEbGogASAC/AoAAAsgBUEgaiQADwsgAEHkowJBAhDtBRkgBSQACQALAAvcAwIEfwJ9IwBBEGsiByQABkAgASgCDCIGIANPBEAgAEEANgIIIABCADcCAAJAIAZFDQACfQNAAkAgAyAFTQRAIAAoAgAiBSAAKAIERw0BQ///f38MAwsgAiABKAIEIAEoAhAgBWxqIAEoAhwgASgCGBELACEJIAEoAhQgASgCBCABKAIQIAVsamooAgAhBgJAIAQEQCAEIAYgBCgCACgCABECAEUNAQsgByAGNgIMIAcgCTgCCCAAIAdBCGoQwgELIAVBAWohBQwBCwsgBSoCAAshCSADIQUDQCAFIAEoAgxPDQECQCACIAEoAgQgASgCECAFbGogASgCHCABKAIYEQsAIgogCV9FDQAgASgCFCABKAIEIAEoAhAgBWxqaigCACEGAkAgBARAIAQgBiAEKAIAKAIAEQIARQ0BCyAHIAY2AgwgByAKOAIIIAAgB0EIahDCAQsgAyAAKAIEIgggACgCACIGa0EDdUkEQCAAEKwBIAAoAgQhCCAAKAIAIQYLIAYgCEYNACAGKgIAIQkLIAVBAWohBQwACwALIAdBEGokAA8LBkBBmA1BiSBB5gBBwBsQEhgBABkgByQAIAAoAgAiAQRAIAAgATYCBCAAKAIIGiABEIcCCwkACwAL0gMCBn8CfQJAAkACQCAAKAIEIgMgACgCCCICSQRAIAMgASkCADcCACADQQhqIQEMAQsgAyAAKAIAIgZrIgdBA3UiBUEBaiIEQYCAgIACTw0BQf////8BIAIgBmsiA0ECdSICIAQgAiAESxsgA0H4////B08bIgJBgICAgAJPDQIgAkEDdCIDELAFIgIgB2oiBCABKQIANwIAIAQgBUEDdGshBSAHBEAgBSAGIAf8CgAACyAAIAIgA2o2AgggACAEQQhqIgE2AgQgACAFNgIAIAZFDQAgBhCHAgsgACABNgIEAkAgASAAKAIAIgRrQQN1IgBBAkgNAAJAIAQgAEECayIDQQF2IgVBA3RqIgIqAgAiCSABQQhrIgAqAgAiCF0EQCABQQRrKAIAIQEMAQsgCCAJXQ0BIAFBBGsoAgAiASACKAIETQ0BCyAAIAIpAgA3AgACQCADQQJJBEAgAiEADAELA0ACQCAEIAVBAWsiA0EBdiIFQQN0aiIAKgIAIgkgCF0NACAIIAldBEAgAiEADAMLIAAoAgQgAUkNACACIQAMAgsgAiAAKQIANwIAIAAhAiADQQFLDQALCyAAIAE2AgQgACAIOAIACw8LEDcACxCzAQAL+gMBBn8jAEEQayIFJAAgAEEANgIIIABCADcCAAJABkAgBSABIAIgAyAEIAEoAgAoAgQRCgAgBSgCBCIBIAUoAgAiAmtBA3UhBAZAIAEgAkcEQAJAIAQgACgCCCIGIAAoAgQiAWtBA3VNBEAgACAEBH8gBEEDdCICBEAgAUEAIAL8CwALIAEgAmoFIAELNgIEDAELAkAgASAAKAIAIgFrIgJBA3UiCCAEaiIHQYCAgIACSQRAQQAhA0H/////ASAGIAFrIgZBAnUiCSAHIAcgCUkbIAZB+P///wdPGyIHBEAgB0GAgICAAk8NAiAHQQN0ELAFIQMLIAIgA2ohBiAEQQN0IgkEQCAGQQAgCfwLAAsgBiAIQQN0ayEIIAIEQCAIIAEgAvwKAAALIAAgAyAHQQN0ajYCCCAAIAYgCWo2AgQgACAINgIAIAEEQCABEIcCCwwCCxA3AAsQswEACwsDQCAFKAIAIgEgBSgCBEYNAyAAKAIAIARBAWsiBEEDdGogASkCADcCACAFEKwBDAALABkgBSQAIAUoAgAiAQRAIAUgATYCBCAFKAIIGiABEIcCCyAAKAIAIQoJAAsAGSAFJAAgCgRAIAAgCjYCBCAAKAIIGiAKEIcCCwkACwALIAEEQCAFIAE2AgQgBSgCCBogARCHAgsgBUEQaiQAC8sBAQJ/IwBBwAFrIgIkAAJABkAGQCACQQRqIAEQxQEhARgCIAEgAEEIakEEEMECIAEgAEEQakEEEMECIAEgAEEMakEEEMECIAEgACgCBCAAKAIQIAAoAghsEMECIAFBBGoiABDNAg0BIAEgASgCAEEMaygCAGoiAyADKAIQQQRyEO0CGSACJAAgARDGARoJAAsLIAFByKcBKAIAIgM2AgAgASADQQxrKAIAakHUpwEoAgA2AgAgABDMAhogAUHoAGoQoAIgAkHAAWokAAvnAQEEfyMAIQMgAEEANgKEASAAQcCnATYCaCAAQcynASgCACICNgIAIAAgAkEMaygCAGpB0KcBKAIANgIAIABB6ABqIQQCQAZAIAAgACgCAEEMaygCAGoiAiAAQQRqIgUQ8QIgAkEAOgBQIAJBADYCSCAAQcCnATYCaCAAQaynATYCAAZAIAUQywIhAgZAIAIgASgCACABIAEsAAtBAEgbQRQQygINAyAAIAAoAgBBDGsoAgBqIgEgASgCEEEEchDtAhkgAyQAIAIQzAIaCQALGSADJAAJAAsZIAMkACAEEKACCQALCyAACzsBAX8gAEHIpwEoAgAiATYCACAAIAFBDGsoAgBqQdSnASgCADYCACAAQQRqEMwCGiAAQegAahCgAiAAC1ABAn8gAEHE8gA2AgAgACgCBBCHAiAAKAJAIgIEQANAIAIoAgAgAhCHAiICDQALCyAAKAI4IQEgAEEANgI4IAEEQCAAKAI8GiABEIcCCyAAC1MBAn8gAEHE8gA2AgAgACgCBBCHAiAAKAJAIgIEQANAIAIoAgAgAhCHAiICDQALCyAAKAI4IQEgAEEANgI4IAEEQCAAKAI8GiABEIcCCyAAEIcCC8wDAQV/AkACQAJAIAEEQCABQYCAgIAETw0BIAFBAnQiAhCwBSEFIAAoAgAhAyAAIAU2AgAgAwRAIAAoAgQaIAMQhwIgACgCACEFCyAAIAE2AgQgAgRAIAVBACAC/AsACyAAKAIIIgJFDQMgAEEIaiEAIAIoAgQhBCABIAFBAWsiA3FFDQIgASAETQRAIAQgAXAhBAsgBSAEQQJ0aiAANgIAA0AgAigCACIDRQ0EIAEgAygCBCIATQRAIAAgAXAhAAsgACAERgRAIAMhAgwBCyAFIABBAnRqIgYoAgAEQCACIAMoAgA2AgAgAyAGKAIAKAIANgIAIAYoAgAgAzYCAAUgBiACNgIAIAMhAiAAIQQLDAALAAsgACgCACEBIABBADYCACABBEAgACgCBBogARCHAgsgAEEANgIEDAILELMBAAsgBSADIARxIgRBAnRqIAA2AgAgAigCACIARQ0AIAFBAWshBgNAAkAgBCAAKAIEIAZxIgFGBEAgACECDAELIAUgAUECdGoiAygCAARAIAIgACgCADYCACAAIAMoAgAoAgA2AgAgAygCACAANgIADAELIAMgAjYCACAAIQIgASEECyACKAIAIgANAAsLC+4BAQR/IwAhAyAAQQA2AogBIABBpKYBNgJsIABBsKYBKAIAIgI2AgAgACACQQxrKAIAakG0pgEoAgA2AgAgAEEANgIEIABB7ABqIQQCQAZAIAAgACgCAEEMaygCAGoiAiAAQQhqIgUQ8QIgAkEAOgBQIAJBADYCSCAAQaSmATYCbCAAQZCmATYCAAZAIAUQywIhAgZAIAIgASgCACABIAEsAAtBAEgbQQwQygINAyAAIAAoAgBBDGsoAgBqIgEgASgCEEEEchDtAhkgAyQAIAIQzAIaCQALGSADJAAJAAsZIAMkACAEEKACCQALCyAACzsBAX8gAEGspgEoAgAiATYCACAAIAFBDGsoAgBqQbimASgCADYCACAAQQhqEMwCGiAAQewAahCgAiAAC+oCAQh/IAIoAgQhBQJAIAEoAgQiBGkiCEEBTQRAIARBAWsgBXEhBQwBCyAEIAVLDQAgBSAEcCEFCyABKAIAIgkgBUECdGoiBigCACEDA0AgAyIHKAIAIgMgAkcNAAsCQCABQQhqIgogB0cEQCAHKAIEIQMCQCAIQQFNBEAgAyAEQQFrcSEDDAELIAMgBEkNACADIARwIQMLIAMgBUYNAQsgAigCACIDBEAgAygCBCEDAkAgCEEBTQRAIAMgBEEBa3EhAwwBCyADIARJDQAgAyAEcCEDCyADIAVGDQELIAZBADYCAAsgBwJ/QQAgAigCACIGRQ0AGiAGKAIEIQMCQCAIQQFNBEAgAyAEQQFrcSEDDAELIAMgBEkNACADIARwIQMLIAYgAyAFRg0AGiAJIANBAnRqIAc2AgAgAigCAAs2AgAgAkEANgIAIAEgASgCDEEBazYCDCAAQQE6AAggACAKNgIEIAAgAjYCAAvIBgEGfyMAQRBrIgQkACAAQQA6AGcgACACNgIAIABBADoAXCAAQgA3AgQgAEIANwJAIABCADcCDCAAQgA3AhQgAEIANwIcIABCADcCJCAAQgA3AiwgAEIANwI0IABBADoAPCAAQgA3AkggAEIANwJQIABBADoAWCAAQUBrIQgGQAJAIABB3ABqIgIgA0YNACADLAALQQBOBEAgAiADKQIANwIAIAIgAygCCDYCCAwBCyADKAIAIQcgAygCBCEDIwBBEGsiBSQAIAItAAsiCUH/AHEhBgJAIANBCk0EQCACIAlBgAFxIANB/wBxcjoACyACIAItAAtB/wBxOgALAkAgA0UiBg0AIAYNACACIAcgA/wKAAALIAVBADoADyACIANqIAUtAA86AAAMAQsgAkEKIANBCmsgBkEAIAYgAyAHEM8FCyAFQRBqJAALAkACQAJAAkAgASgCBCABLAALIgMgA0EASBtBAmsOBQADAwMBAwsgASgCACABIANBAEgbIgIvAABB7OQARgRAQRAQsAUiASAAKAIAIgI2AgwgAUGRATYCBCABQbzrADYCACABIAJBAnQ2AggMAgsgAi8AAEHp4AFHDQJBEBCwBSIBIAAoAgAiAjYCDCABQY8BNgIEIAFB6O0ANgIAIAEgAkECdDYCCAwBCyABKAIAIAEgA0EASBtBoyJBBhDoAQ0BQRAQsAUiASAAKAIAIgI2AgwgAUGPATYCBCABQejtADYCACABIAJBAnQ2AgggAEEBOgBYCyAAIAE2AgggBEEQaiQAIAAPC0EBIQJB7f8CLQAAQQFGBEAgBCABKAIAIAEgA0EASBs2AgBBic0AIAQQ6QELBkBBCBDpBSEDGAEGQCAEQQRqIgUgARDbBQZAIAMgBRDIBSIBQcyiAjYCAEEAIQIgAUHYogJBjgEQ7QUZIAQkACAELAAPQQBIBEAgBCgCDBogBCgCBBCHAgsJAAsZIAQkACACBEAGQCADEOoFGAMLCQALGSAEJAAgACwAZ0EASARAIAAoAmQaIAAoAlwQhwILIAAoAkwiAQRAIAAgATYCUCAAKAJUGiABEIcCCyAIKAIAIgEEQCAAIAE2AkQgACgCSBogARCHAgsJAAsAC18BBX8CQCAALQAEDQAgACgCACICKAIAIgFFDQAgASEDIAIhBCACKAIEIgUgAUcEQANAIAEgBUEYayIFRw0ACyAAKAIAIgQoAgAhAwsgAiABNgIEIAQoAggaIAMQhwILC60CAQh/IwAhBCAAQgA3AgAgACABNgIwIABCADcCKCAAQgA3AiAgAEIANwIYIABCADcCECAAQgA3AghBACEBA0ACQAZAAkAgBUEATARAQQwQsAUiAyAAKAIwIgI2AgggA0H//wM7AQAGQEF/IAJBAXQgAkEASBsQsAUhAgwCGSAEJAAgAxCHAgkACwALIAAPCyADIAI2AgQgAQ0BIAAQ0QEZIAQkACAAENIBGgkACyAAKAIIIQcgACgCBCEGIAAoAhAhAQsgBiABQQh2Qfz//wdxaiICKAIAIgggAUH/B3FBAnRqIglBACAGIAdHGyAIRgR/IAJBBGsoAgBBgCBqBSAJC0EEayADNgIAIAAgAUEBayIBNgIQIAAgACgCFEEBajYCFCAFQQFqIQUMAAsAC0cBA38gACgCACIBBEAgASECIAAoAgQiAyABRwRAA0AgASADQRhrIgNHDQALIAAoAgAhAgsgACABNgIEIAAoAggaIAIQhwILC9kJAQp/IwBBIGsiAyQAAkAgACgCCCIBIAAoAgQiCWsiAkEIdEEBa0EAIAEgCUcbIAAoAhAiBCAAKAIUamtBgAhPBEAgACAEQYAIajYCECADIAFBBGsiASgCADYCDCAAIAE2AgggACADQQxqENwBDAELIAIgACgCDCIEIAAoAgAiAWsiBUkEQAJAIAEgCUcEQCADQYAgELAFNgIMIAAgA0EMahDcAQwBCyADQYAgELAFNgIMIANBDGohCAJAAkACQCAAKAIIIgIgACgCDEcEQCACIQEMAQsgACgCBCIFIAAoAgAiBksEQCACIAVrIQEgBSAFIAZrQQJ1QQFqQX5tQQJ0IgZqIQQgACACIAVHBH8gAQRAIAQgBSAB/AoAAAsgACgCBAUgBQsgBmo2AgQgASAEaiEBDAELQQEgAiAGa0EBdSACIAZGGyIBQYCAgIAETw0BIAFBAnQiBBCwBSIHIARqIQkgByABQXxxaiIEIQEgAiAFRwRAIAQgAiAFa2ohASAEIQIDQCACIAUoAgA2AgAgBUEEaiEFIAJBBGoiAiABRw0ACwsgACAJNgIMIAAgATYCCCAAIAQ2AgQgACAHNgIAIAZFDQAgBhCHAiAAKAIIIQELIAEgCCgCADYCACAAIAFBBGo2AggMAQsQswEACyADIAAoAghBBGsiASgCADYCDCAAIAE2AgggACAIENwBCyAAQYAEIAAoAhBBgAhqIAAoAgggACgCBGtBBEYbNgIQDAELIAMgAEEMajYCHAJABkAGQEEBIAVBAXUgASAERhsiAkGAgICABEkEQAZAIAJBAnQiBBCwBSEBGAUgAyABNgIUIAMgATYCDCADIAE2AhAgAyABIARqIgU2AhgGQEGAIBCwBSEKGAICQCACBEAgASECDAELIANBBBCwBSICNgIQIAMgAjYCDCADIAJBBGoiBTYCGCABEIcCIAAoAgQhCQsgAiAKNgIAIAMgAkEEaiIHNgIUIAIhASAFIQQDQCAAKAIIIAlGBEAgACgCACEBIAAgAygCDDYCACADKAIQIQIgACAHNgIIIAAgAjYCBCAAKAIMGiAAIAU2AgwgAEGABCAAKAIQQYAIaiAHIAJrQQRGGzYCECABRQ0FIAEQhwIMBQsCQCAEIAdHDQAgASACSwRAIAQgAWshCCABIAEgAmtBAnVBAWpBfm1BAnRqIQYCQCABIARGDQAgCEUNACAGIAEgCPwKAAALIAMgBjYCECAGIAhqIQcgBiEBDAELQQEgBCACa0EBdSACIARGGyIGQYCAgIAETwRAQQAhChCzAQALQQAhCiAGQQJ0IgUQsAUhCCAFIAhqIQUgCCAGQXxxaiIGIQcgASAERwRAIAYgBCABa2ohByAGIQQDQCAEIAEoAgA2AgAgAUEEaiEBIARBBGoiBCAHRw0ACwsgAyAFNgIYIAMgBjYCECADIAg2AgwgAhCHAiAIIQIgBiEBIAUhBAsgByAJKAIANgIAIAMgB0EEaiIHNgIUIAlBBGohCQwACwALBkAQswEYBAAZIAMkACAKBEAgChCHAgsJAAsAGSADJAAgAygCECIBIAMoAhQiAEcEQCADIAAgASAAa0EDakF8cWo2AhQLIAMoAgwiAARAIAMoAhgaIAAQhwILCQALAAsLIANBIGokAAvTAQEEfyAAQQA2AhQgACgCCCICIAAoAgQiAWtBAnUiA0EDTwRAA0AgASgCABCHAiAAIAAoAgRBBGoiATYCBCAAKAIIIgIgAWtBAnUiA0ECSw0ACwtBgAQhBAJAAkACQCADQQFrDgIBAAILQYAIIQQLIAAgBDYCEAsCQCABIAJGDQADQCABKAIAEIcCIAFBBGoiASACRw0ACyAAKAIEIgIgACgCCCIBRg0AIAAgASACIAFrQQNqQXxxajYCCAsgACgCACIBBEAgACgCDBogARCHAgsgAAvJAgECfyMAQSBrIgQkACAEIAI2AgwCQAJAIANFDQAgAC0A6AENAAZABkBBCBDpBSEAGAMgAEGvFBDMBSEADAIZIAQkACAAEOoFCQALAAsgACgCSBoCQAZAIANFBEAgACABIAIQ1AEMAgsGQCAAKAKQAgRAIAQgACgCjAIoAgg2AgggAEGEAmogBEEIahCoASAEIAAoAogBIAAoAowBIAAoAgwgBCgCCGxqaiIDKAAANgIEIAMgAjYAAAZAIABBxAFqIgMgBEEEahCoASAEKAIIIQIgBCAEQQxqIgU2AhQgBEEYaiADIAUgBEEUahCnASAEKAIYIAI2AgwgACAEKAIIENUBIAAgASAEKAIIENYBDAQZIAQkAAkACwALIAAgASACENQBGSAEJAAJAAsZIAQkAAkACwsgBEEgaiQADwsgAEHkowJBAhDtBQALlBAEEH8CfQF+AXwjAEEgayIEJAAgBCACNgIYIABBxAFqIQYCQAZAAkACQAJAIAAoAsgBIgVFDQAgBigCAAJ/IAVBAWsgAnEgBWkiB0EBTQ0AGiACIAIgBUkNABogAiAFcAsiCEECdGooAgAiA0UNACADKAIAIgNFDQACQCAHQQFNBEAgBUEBayEFA0ACQCACIAMoAgQiB0cEQCAFIAdxIAhGDQEMBQsgAygCCCACRg0DCyADKAIAIgMNAAsMAgsDQAJAIAIgAygCBCIHRwRAIAUgB00EfyAHIAVwBSAHCyAIRg0BDAQLIAMoAgggAkYNAgsgAygCACIDDQALDAELIAMoAgwhAgJAAkAgAC0A6AFBAUcNACAAKAKEASAAKAKMASAAKAIMIAJsamotAAJBAXFFDQAGQAZAQQgQ6QUhABgIIABB5jgQzAUhAAwCGSAEJAAGQCAAEOoFGAgJAAsACyAAKAKEASAAKAKMASAAKAIMIAJsamotAAJBAXEEQCAAIAIQ1QELIAAgASACENYBDAILIABB5KMCQQIQ7QUMBAsgACgCCCAAKAIETwRABkAGQEEIEOkFIQAYBiAAQaAOEMwFIQAMAxkgBCQABkAgABDqBRgGCQALAAsgACAAKAIIIgpBAWo2AgggBCAEQRhqIgI2AhwgBEEIaiAGIAIgBEEcahCnASAEKAIIIAo2AgwGQCAAKAJsGiAAQf////8HQQBB/////wdBACAAKALYASICIAJByNsCbiICQcjbAmxrQY/5AmwiAyACQccabCICSRsgAyACa2oiAiACQcjbAm4iA0HI2wJsa0GP+QJsIgUgA0HHGmwiA0kbIAUgA2tqIgM2AtgBIANBAWu4RAAAgP///99BoiACQQFruKBEAAAA////z0OjRAAAAAAAAAAAoBDmASEWGAQgACgClAEgCkECdGogACsDMCAWmqL8AiIJNgIAAkAGQCAJIAAoAkAiB0ohDyAEIAAoAngiBTYCHCAAKAIMIgIEQCAAKAKEASAAKAKMASACIApsampBACAC/AsACyAAKAKIASAAKAKMASAAKAIMIApsamogBCgCGDYCACAAKAKgASICBEAgACgCgAEgACgCjAEgACgCDCAKbGpqIAEgAvwKAAALBkACQAJAIAlFDQAgACgCECAJbEEBaiIDEIYCIQIgACgCkAEgCkECdGogAjYCACACRQRABkAGQEEIEOkFIQAYCyAAQc0LEMwFIQAMAxkgBCQABkAgABDqBRgLCQALAAsgA0UNACACQQAgA/wLAAsGQAJAAkACQCAFQX9HBEACQCAHIAlMDQAGQCABIAAoAoABIAAoAowBIAAoAgwgBWxqaiAAKAKoASAAKAKkARELACETGAcgByECA0AgAiAJTA0BIAJBAWshAkEBIQYDQCAGQQFxRQ0BIAAoAmwaIAAoApABIAVBAnRqKAIAIAAoAhAgAmxqIgNBBGohDCADLwEAIQtBACEGQQAhAwNAIAMgC08NASAMIANBAnRqKAIAIgggACgCBEsEQAZABkBBCBDpBSEAGBMgAEHYFRDMBSEADAkZIAQkAAZAIAAQ6gUYEwkACwALIAggBSABIAAoAoABIAAoAowBIAAoAgwgCGxqaiAAKAKo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ACEFQQAhAkEADAELBkAgAkECdCICELAFIQUZIAMkAAkACyACBEAgBUEAIAL8CwALIAIgBWoLIQYgAgRAIAUgCEEEaiAC/AoAAAsgBSICIAZHBEADQAZAIAMgA0EoaiACIAIQ4QEZIAMkACAFBEAgBRCHAgsJAAsgAkEEaiICIAZHDQALCyAFRQ0AIAUQhwILIAdBBGohBwwACwAZIAMkACAKBEAgChCHAgsJAAsAGSADJAAgAygCGCICBEADQCACKAIAIAIQhwIiAg0ACwsgAygCECEAIANBADYCECAABEAgAygCFBogABCHAgsgAygCMCICBEADQCACKAIAIAIQhwIiAg0ACwsgAygCKCEAIANBADYCKCAABEAgAygCLBogABCHAgsJAAsACyAKBEAgChCHAgsgAygCGCICBEADQCACKAIAIAIQhwIiAg0ACwsgAygCECECIANBADYCECACBEAgAygCFBogAhCHAgsgAygCMCICBEADQCACKAIAIAIQhwIiAg0ACwsgAygCKCECIANBADYCKCACBEAgAygCLBogAhCHAgsgDEEBaiEMDAALAAsgA0FAayQAC8gqAxR/A30BfiMAQRBrIggkACAAQQA2AgggAEIANwIABkACQAZAAkAgASgCCEUNAAZAIAIgASgCgAEgASgCjAEgASgCeCIKIAEoAgxsamogASgCqAEgASgCpAERCwAhGhgDIAEoAkAhDQNAIA1BAEoEQCANQQFrIQ1BASEGA0AgBkEBcUUNAiABKAKQASAKQQJ0aigCACABKAIQIA1saiIFLwEAIQwgASABKALkAUEBajYC5AEgASAMIAEoAuABajYC4AEgBUEEaiEJQQAhBkEAIQUDQCAFIAxPDQEgCSAFQQJ0aigCACIPIAEoAgRLBEAGQAZAQQgQ6QUhARgKIAFB2BUQzAUhAQwIGSAIJAAGQCABEOoFGAoGQAkBGAkACwALBkAgAiABKAKAASABKAKMASABKAIMIA9samogASgCqAEgASgCpAERCwAhGRgHIA8gCiAZIBpdIg8bIQogGSAaIA8bIRogBUEBaiEFIAYgD3IhBgwACwALAAsLAkAgASgCFARAQQAhDSACIQ8gASgCKCICIAMgAiADSxshEyAEIQwjAEEgayIHJAAgByAKNgIcIAEoAkQQ4wEiFS8BACEUIBUoAgQhFiAIQQA2AgggCEIANwIAIAdBADYCFCAHQgA3AgwCQAJAAkAGQAJAAkAgASgCjAEiAiABKAIMIApsIgRqIgUgASgChAFqLQACQQFxDQAgDARAIAwgBSABKAKIAWooAAAgDCgCACgCABECAEUNASABKAIMIAcoAhxsIQQgASgCjAEhAgsgByAPIAEoAoABIAIgBGpqIAEoAqgBIAEoAqQBEQsAIho4AgggCCAHQQhqIAdBHGoiAhDeASAHIAcqAgiMOAIEIAdBDGogB0EEaiACEN4BDAELIAdB////ezYCCCAHQQxqIAdBCGogB0EcahDeAUP//39/IRoLIBYgBygCHEEBdGogFDsBAANAAkAgBygCDCIGIAcoAhAiC0YNACAGKAIEIREgBioCAIwgGl4EQCAIKAIEIAgoAgBrQQN1IBNGDQELAkAgCyAGa0EDdSIOQQJIDQAgDkECa0EBdiESIAYpAgAhHEEAIQQgBiECA0AgBEEBdCIJQQFyIQUgAiIKIARBA3RqIhBBCGohAgJAIA4gCUECaiIJTARAIAUhBAwBCyAFIQQgECoCCCAQQRBqIgUqAgBdRQ0AIAUhAiAJIQQLIAogAikCADcCACAEIBJMDQALIAtBCGsiBCACRgRAIAIgHDcCAAwBCyACIAQpAgA3AgAgBCAcNwIAIAIgBmtBCGpBA3UiBEECSA0AIAIqAgAiGSAGIARBAmtBAXYiBEEDdGoiCioCAF5FDQAgAigCBCEFA0ACQCACIAoiAikCADcCACAERQ0AIAYgBEEBa0EBdiIEQQN0aiIKKgIAIBldDQELCyACIAU2AgQgAiAZOAIACyAHIAcoAhBBCGs2AhAgASgChAEgASgCjAEgASgCDCARbGpqIhcvAQAhEUEBIQogASABKALkAUEBajYC5AEgASARIAEoAuABajYC4AEDQCAKIBFLDQIgByAXIApBAnRqKAIAIgI2AggCQCAWIAJBAXRqIgQvAQAgFEYNACAEIBQ7AQAgByAPIAEoAoABIAEoAowBIAEoAgwgAmxqaiABKAKoASABKAKkARELACIZOAIEIBkgGl1FIBMgCCgCBCAIKAIAa0EDdU1xDQAgGYwhGQJAIAcoAhAiAiAHKAIUIgZJBEAgAiAZOAIAIAIgBygCCDYCBCACQQhqIQYMAQsgAiAHKAIMIgJrIgRBA3UiCUEBaiIFQYCAgIACTwRAEDcMCAtB/////wEgBiACayIGQQJ1IgsgBSAFIAtJGyAGQfj///8HTxsiBUGAgICAAk8EQBCzAQwICyAFQQN0IgYQsAUiCyAEaiIFIBk4AgAgBSAHKAIINgIEIAUgCUEDdGshCSAEBEAgCSACIAT8CgAACyAHIAYgC2o2AhQgByAFQQhqIgY2AhAgByAJNgIMIAJFDQAgAhCHAgsgByAGNgIQAkAgBiAHKAIMIglrQQN1IgJBAkgNACAGQQhrIgUqAgAiGSAJIAJBAmtBAXYiBEEDdGoiAioCAF5FDQAgBkEEaygCACEGA0ACQCAFIAIiBSkCADcCACAERQ0AIAkgBEEBa0EBdiIEQQN0aiICKgIAIBldDQELCyAFIAY2AgQgBSAZOAIACwJAIAEoAowBIAEoAgwgBygCCGxqIgIgASgChAFqLQACQQFxDQAgDARAIAwgAiABKAKIAWooAAAgDCgCACgCABECAEUNAQsgCCAHQQRqIAdBCGoQ3gELIBMgCCgCBCIOIAgoAgAiBmtBA3UiEEkEQAJAIBBBAkgNACAQQQJrQQF2IRggBikCACEcQQAhBCAGIQIDQCAEQQF0IgtBAXIhBSACIgkgBEEDdGoiEkEIaiECAkAgECALQQJqIgtMBEAgBSEEDAELIAUhBCASKgIIIBJBEGoiBSoCAF1FDQAgBSECIAshBAsgCSACKQIANwIAIAQgGEwNAAsgDkEIayIEIAJGBEAgAiAcNwIADAELIAIgBCkCADcCACAEIBw3AgAgAiAGa0EIakEDdSIEQQJIDQAgAioCACIZIAYgBEECa0EBdiIEQQN0aiIFKgIAXkUNACACKAIEIQkDQAJAIAIgBSICKQIANwIAIARFDQAgBiAEQQFrQQF2IgRBA3RqIgUqAgAgGV0NAQsLIAIgCTYCBCACIBk4AgALIAggCCgCBEEIayIONgIEIAgoAgAhBgsgBiAORg0AIAYqAgAhGgsgCkEBaiEKDAALAAsLIAEoAkQhBCAEKAIQIgINAQZAIAQQ0QEZIAckAAkACxkgByQAIAcoAgwiAQRAIAcgATYCECAHKAIUGiABEIcCCyAIKAIAIgEEQCAIIAE2AgQgCCgCCBogARCHAgsJAAsgBCgCECECCyAEKAIEIgUgAkEIdkH8//8HcWoiBigCACIKIAJB/wdxQQJ0aiIMQQAgBCgCCCAFRxsgCkYEfyAGQQRrKAIAQYAgagUgDAtBBGsgFTYCACAEIAJBAWs2AhAgBCAEKAIUQQFqNgIUIAcoAgwiAgRAIAcgAjYCECAHKAIUGiACEIcCCyAHQSBqJAAMAQsACwwBC0EAIQ0gAiEPIAEoAigiAiADIAIgA0sbIRMgBCEMIwBBIGsiByQAIAcgCiIENgIcIAEoAkQQ4wEiFS8BACEUIBUoAgQhFiAIQQA2AgggCEIANwIAIAdBADYCFCAHQgA3AgwCQAJAAkAGQAJAAkAgDARAIAwgASgCiAEgASgCjAEgASgCDCAEbGpqKAAAIAwoAgAoAgARAgBFDQEgBygCHCEECyAHIA8gASgCgAEgASgCjAEgASgCDCAEbGpqIAEoAqgBIAEoAqQBEQsAIho4AgggCCAHQQhqIAdBHGoiAhDeASAHIAcqAgiMOAIEIAdBDGogB0EEaiACEN4BDAELIAdB////ezYCCCAHQQxqIAdBCGogB0EcahDeAUP//39/IRoLIBYgBygCHEEBdGogFDsBAANAAkAgBygCDCIGIAcoAhAiC0YNACAGKAIEIREgBioCAIwgGl4EQCAMRQ0BIAgoAgQgCCgCAGtBA3UgE0YNAQsCQCALIAZrQQN1Ig5BAkgNACAOQQJrQQF2IRIgBikCACEcQQAhBCAGIQIDQCAEQQF0IglBAXIhBSACIgogBEEDdGoiEEEIaiECAkAgDiAJQQJqIglMBEAgBSEEDAELIAUhBCAQKgIIIBBBEGoiBSoCAF1FDQAgBSECIAkhBAsgCiACKQIANwIAIAQgEkwNAAsgC0EIayIEIAJGBEAgAiAcNwIADAELIAIgBCkCADcCACAEIBw3AgAgAiAGa0EIakEDdSIEQQJIDQAgAioCACIZIAYgBEECa0EBdiIEQQN0aiIKKgIAXkUNACACKAIEIQUDQAJAIAIgCiICKQIANwIAIARFDQAgBiAEQQFrQQF2IgRBA3RqIgoqAgAgGV0NAQsLIAIgBTYCBCACIBk4AgALIAcgBygCEEEIazYCECABKAKEASABKAKMASABKAIMIBFsamoiFy8BACERQQEhCiABIAEoAuQBQQFqNgLkASABIBEgASgC4AFqNgLgAQNAIAogEUsNAgJAIBYgFyAKQQJ0aigCACIJQQF0aiICLwEAIBRGDQAgAiAUOwEAIA8gASgCgAEgASgCjAEgASgCDCAJbGpqIAEoAqgBIAEoAqQBEQsAIhkgGl1FIBMgCCgCBCAIKAIAa0EDdU1xDQAgGYwhGwJAIAcoAhAiAiAHKAIUIgZJBEAgAiAJNgIEIAIgGzgCACACQQhqIQYMAQsgAiAHKAIMIgJrIgRBA3UiC0EBaiIFQYCAgIACTwRAEDcMCAtB/////wEgBiACayIGQQJ1Ig4gBSAFIA5JGyAGQfj///8HTxsiBUGAgICAAk8EQBCzAQwICyAFQQN0IgYQsAUiDiAEaiIFIAk2AgQgBSAbOAIAIAUgC0EDdGshCyAEBEAgCyACIAT8CgAACyAHIAYgDmo2AhQgByAFQQhqIgY2AhAgByALNgIMIAJFDQAgAhCHAgsgByAGNgIQAkAgBiAHKAIMIgtrQQN1IgJBAkgNACAGQQhrIgUqAgAiGyALIAJBAmtBAXYiBEEDdGoiAioCAF5FDQAgBkEEaygCACEGA0ACQCAFIAIiBSkCADcCACAERQ0AIAsgBEEBa0EBdiIEQQN0aiICKgIAIBtdDQELCyAFIAY2AgQgBSAbOAIACwJAIAwEQCAMIAEoAogBIAEoAowBIAEoAgwgCWxqaigAACAMKAIAKAIAEQIARQ0BCwJAIAgoAgQiAiAIKAIIIgZJBEAgAiAJNgIEIAIgGTgCACACQQhqIQYMAQsgAiAIKAIAIgJrIgRBA3UiC0EBaiIFQYCAgIACTwRAEDcMCQtB/////wEgBiACayIGQQJ1Ig4gBSAFIA5JGyAGQfj///8HTxsiBUGAgICAAk8EQBCzAQwJCyAFQQN0IgYQsAUiDiAEaiIFIAk2AgQgBSAZOAIAIAUgC0EDdGshCSAEBEAgCSACIAT8CgAACyAIIAYgDmo2AgggCCAFQQhqIgY2AgQgCCAJNgIAIAJFDQAgAhCHAgsgCCAGNgIEIAYgCCgCACIJa0EDdSICQQJIDQAgBkEIayIFKgIAIhkgCSACQQJrQQF2IgRBA3RqIgIqAgBeRQ0AIAZBBGsoAgAhBgNAAkAgBSACIgUpAgA3AgAgBEUNACAJIARBAWtBAXYiBEEDdGoiAioCACAZXQ0BCwsgBSAGNgIEIAUgGTgCAAsgEyAIKAIEIg4gCCgCACIGa0EDdSIQSQRAAkAgEEECSA0AIBBBAmtBAXYhGCAGKQIAIRxBACEEIAYhAgNAIARBAXQiC0EBciEFIAIiCSAEQQN0aiISQQhqIQICQCAQIAtBAmoiC0wEQCAFIQQMAQsgBSEEIBIqAgggEkEQaiIFKgIAXUUNACAFIQIgCyEECyAJIAIpAgA3AgAgBCAYTA0ACyAOQQhrIgQgAkYEQCACIBw3AgAMAQsgAiAEKQIANwIAIAQgHDcCACACIAZrQQhqQQN1IgRBAkgNACACKgIAIhkgBiAEQQJrQQF2IgRBA3RqIgUqAgBeRQ0AIAIoAgQhCQNAAkAgAiAFIgIpAgA3AgAgBEUNACAGIARBAWtBAXYiBEEDdGoiBSoCACAZXQ0BCwsgAiAJNgIEIAIgGTgCAAsgCCAIKAIEQQhrIg42AgQgCCgCACEGCyAGIA5GDQAgBioCACEaCyAKQQFqIQoMAAsACwsgASgCRCEEIAQoAhAiAg0BBkAgBBDRARkgByQACQALGSAHJAAgBygCDCIBBEAgByABNgIQIAcoAhQaIAEQhwILIAgoAgAiAQRAIAggATYCBCAIKAIIGiABEIcCCwkACyAEKAIQIQILIAQoAgQiBSACQQh2Qfz//wdxaiIGKAIAIgogAkH/B3FBAnRqIgxBACAEKAIIIAVHGyAKRgR/IAZBBGsoAgBBgCBqBSAMC0EEayAVNgIAIAQgAkEBazYCECAEIAQoAhRBAWo2AhQgBygCDCICBEAgByACNgIQIAcoAhQaIAIQhwILIAdBIGokAAwBCwALCyAIKAIIGiADIAgoAgQiBCAIKAIAIg1rQQN1Ig9JBEADQAJAIA9BAkgNACAPQQJrQQF2IQsgDSkCACEcQQAhBSANIQIDQCAFQQF0IgxBAXIhBiACIgogBUEDdGoiCUEIaiECAkAgDyAMQQJqIgxMBEAgBiEFDAELIAYhBSAJKgIIIAlBEGoiBioCAF1FDQAgBiECIAwhBQsgCiACKQIANwIAIAUgC0wNAAsgBEEIayIFIAJGBEAgAiAcNwIADAELIAIgBSkCADcCACAFIBw3AgAgAiANa0EIakEDdSIFQQJIDQAgAioCACIaIA0gBUECa0EBdiIFQQN0aiIGKgIAXkUNACACKAIEIQoDQAJAIAIgBiICKQIANwIAIAVFDQAgDSAFQQFrQQF2IgVBA3RqIgYqAgAgGl0NAQsLIAIgCjYCBCACIBo4AgALIARBCGsiBCANa0EDdSIPIANLDQALCwNAIAQgDUcEQCANKgIAIRogCCABKAKIASABKAKMASABKAIMIA0oAgRsamooAAA2AgQgCCAaOAIAIAAgCBDCAQJAIAQgDWtBA3UiDEECSA0AIAxBAmtBAXYhCSANKQIAIRxBACEFIA0hAgNAIAVBAXQiCkEBciEDIAIiBiAFQQN0aiIPQQhqIQICQCAMIApBAmoiCkwEQCADIQUMAQsgAyEFIA8qAgggD0EQaiIDKgIAXUUNACADIQIgCiEFCyAGIAIpAgA3AgAgBSAJTA0ACyAEQQhrIgMgAkYEQCACIBw3AgAgAyEEDAMLIAIgAykCADcCACADIBw3AgAgAiANa0EIakEDdSIDQQJIDQAgAioCACIaIA0gA0ECa0EBdiIFQQN0aiIDKgIAXkUNACACKAIEIQYDQAJAIAIgAyICKQIANwIAIAVFDQAgDSAFQQFrQQF2IgVBA3RqIgMqAgAgGl0NAQsLIAIgBjYCBCACIBo4AgALIARBCGshBAwBCwsgDUUNACANEIcCCyAIQRBqJAAPGSAIJAAgDQRAIA0QhwILCQALAAsgAUHkowJBAhDtBRkgCCQAIAAoAgAiAQRAIAAgATYCBCAAKAIIGiABEIcCCwkACwALsQMBBH8jAEHAAWsiAyQABkAGQCADQQRqIAEQxQEhAhgBIAIgAEGEAWpBBBDBAiACIABBBGpBBBDBAiACIABBCGpBBBDBAiACIABBDGpBBBDBAiACIABBiAFqQQQQwQIgAiAAQYABakEEEMECIAIgAEFAa0EEEMECIAIgAEH4AGpBBBDBAiACIABBHGpBBBDBAiACIABBIGpBBBDBAiACIABBGGpBBBDBAiACIABBMGpBCBDBAiACIABBJGpBBBDBAiACIAAoAowBIAAoAgwgACgCCGwQwQJBACEBA0AgACgCCCABTQRAIAJBBGoiABDNAkUEQCACIAIoAgBBDGsoAgBqIgEgASgCEEEEchDtAgsgAkHIpwEoAgAiATYCACACIAFBDGsoAgBqQdSnASgCADYCACAAEMwCGiACQegAahCgAiADQcABaiQADwsgAyABQQJ0IgUgACgClAFqKAIAIgQgACgCEGxBACAEQQBKGzYCACACIANBBBDBAiADKAIAIgQEQCACIAAoApABIAVqKAIAIAQQwQILIAFBAWohAQwACwAZIAMkACACEMYBGgkACwALjgMBA38gAEH49QA2AgAgACgCjAEQhwIgACgCCARAA0AgAUECdCICIAAoApQBaigCAEEASgRAIAAoApABIAJqKAIAEIcCCyABQQFqIgEgACgCCEkNAAsLIAAoApABEIcCIAAoAkQiAQRAIAEQ2gEQhwILIAAoAowCIgEEQANAIAEoAgAgARCHAiIBDQALCyAAKAKEAiEBIABBADYChAIgAQRAIAAoAogCGiABEIcCCyAAKALMASIBBEADQCABKAIAIAEQhwIiAQ0ACwsgACgCxAEhASAAQQA2AsQBIAEEQCAAKALIARogARCHAgsgACgClAEiAQRAIAAgATYCmAEgACgCnAEaIAEQhwILIAAoAmwiAwRAIAMiAiAAKAJwIgFHBEADQCADIAFBGGsiAUcNAAsgACgCbCECCyAAIAM2AnAgACgCdBogAhCHAgsgACgCSCIDBEAgAyICIAAoAkwiAUcEQANAIAMgAUEYayIBRw0ACyAAKAJIIQILIAAgAzYCTCAAKAJQGiACEIcCCyAAC6QBAQR/IAAoAhQiAQRAA0AgACgCBCIEIAAoAhAiA0EIdkH8//8HcWooAgAgA0H/B3FBAnRqKAIAIQIgACABQQFrNgIUIAAgA0EBaiIBNgIQIAFBgBBPBEAgBCgCABCHAiAAIAAoAgRBBGo2AgQgACAAKAIQQYAIazYCEAsgAgRAIAIoAgQiAQRAIAEQhwILIAIQhwILIAAoAhQiAQ0ACwsgABDSAQsKACAAENkBEIcCC7oCAQl/AkACQCAAKAIEIgMgACgCACIJRwRAIAMhAgwBCyAAKAIIIgUgACgCDCICSQRAIAUgAiAFa0ECdUEBakECbUECdCIEaiAFIANrIgZrIQIgACADIAVHBH8gBgRAIAIgAyAG/AoAAAsgACgCCAUgBQsgBGo2AggMAQtBASACIANrQQF1IAIgA0YbIgRBgICAgARPDQEgBEECdCICELAFIgggAmohCiAIIARBA2pBfHFqIgIhByADIAVHBEAgAiAFIANraiEHIAIhBiADIQQDQCAGIAQoAgA2AgAgBEEEaiEEIAZBBGoiBiAHRw0ACwsgACAKNgIMIAAgBzYCCCAAIAI2AgQgACAINgIAIANFDQAgCRCHAiAAKAIEIQILIAJBBGsiAiABKAIANgIAIAAgAjYCBA8LELMBAAvvDgMRfwJ9AX4jAEEgayIFJAAgBSACNgIcIAEoAkQQ4wEiES8BACEPIBEoAgQhEiAAQQA2AgggAEIANwIAIAVBADYCFCAFQgA3AgwCQAJABkACQCABKAKMASABKAIMIAJsaiICIAEoAoQBai0AAkEBcUUEQCAFIAMgAiABKAKAAWogASgCqAEgASgCpAERCwA4AgggACAFQQhqIAVBHGoiAhDeASAFIAUqAggiF4w4AgQgBUEMaiAFQQRqIAIQ3gEMAQsgBUH///97NgIIIAVBDGogBUEIaiAFQRxqEN4BQ///f38hFwsgEiAFKAIcQQF0aiAPOwEAIARBAWshEwNAAkAgBSgCDCIHIAUoAhAiDEYNACAHKAIEIQogByoCAIwgF14EQCABKAIkIAAoAgQgACgCAGtBA3VGDQELAkAgDCAHa0EDdSINQQJIDQAgDUECa0EBdiEQIAcpAgAhGEEAIQIgByEGA0AgAkEBdCIJQQFyIQggBiILIAJBA3RqIg5BCGohBgJAIA0gCUECaiIJTARAIAghAgwBCyAIIQIgDioCCCAOQRBqIggqAgBdRQ0AIAghBiAJIQILIAsgBikCADcCACACIBBMDQALIAxBCGsiAiAGRgRAIAYgGDcCAAwBCyAGIAIpAgA3AgAgAiAYNwIAIAYgB2tBCGpBA3UiAkECSA0AIAYqAgAiFiAHIAJBAmtBAXYiAkEDdGoiCyoCAF5FDQAgBigCBCEIA0ACQCAGIAsiBikCADcCACACRQ0AIAcgAkEBa0EBdiICQQN0aiILKgIAIBZdDQELCyAGIAg2AgQgBiAWOAIACyAFIAUoAhBBCGs2AhAgASgCbBoCfyAERQRAIAEoAoQBIAEoAowBIAEoAgwgCmxqagwBCyABKAKQASAKQQJ0aigCACABKAIQIBNsagsiAkEEaiEQIAIvAQAhFEEAIQsDQAJAAkAgCyAUSQRAIAUgECALQQJ0aigCACICNgIIIBIgAkEBdGoiBi8BACAPRg0CIAYgDzsBAAZAIAUgAyABKAKAASABKAKMASABKAIMIAJsamogASgCqAEgASgCpAERCwAiFjgCBCAWIBddRSABKAIkIAAoAgQgACgCAGtBA3VNcQ0DIBaMIRYCQCAFKAIQIgIgBSgCFCIHSQRAIAIgFjgCACACIAUoAgg2AgQgAkEIaiEHDAELIAIgBSgCDCICayIGQQN1IglBAWoiCEGAgICAAk8EQBA3DAsLQf////8BIAcgAmsiB0ECdSIKIAggCCAKSRsgB0H4////B08bIghBgICAgAJPBEAQswEMCwsgCEEDdCIHELAFIgogBmoiCCAWOAIAIAggBSgCCDYCBCAIIAlBA3RrIQkgBgRAIAkgAiAG/AoAAAsgBSAHIApqNgIUIAUgCEEIaiIHNgIQIAUgCTYCDCACRQ0AIAIQhwILIAUgBzYCEAJAIAcgBSgCDCIJa0EDdSICQQJIDQAgB0EIayIIKgIAIhYgCSACQQJrQQF2IgJBA3RqIgYqAgBeRQ0AIAdBBGsoAgAhBwNAAkAgCCAGIggpAgA3AgAgAkUNACAJIAJBAWtBAXYiAkEDdGoiBioCACAWXQ0BCwsgCCAHNgIEIAggFjgCAAsgASgChAEgASgCjAEgASgCDCAFKAIIbGpqLQACQQFxDQIgACAFQQRqIAVBCGoQ3gEMAhkgBSQACQALAAsMBAsgACgCBCIMIAAoAgAiB2tBA3UiDSABKAIkSwRAAkAgDUECSA0AIA1BAmtBAXYhFSAHKQIAIRhBACECIAchBgNAIAJBAXQiCkEBciEIIAYiCSACQQN0aiIOQQhqIQYCQCANIApBAmoiCkwEQCAIIQIMAQsgCCECIA4qAgggDkEQaiIIKgIAXUUNACAIIQYgCiECCyAJIAYpAgA3AgAgAiAVTA0ACyAMQQhrIgIgBkYEQCAGIBg3AgAMAQsgBiACKQIANwIAIAIgGDcCACAGIAdrQQhqQQN1IgJBAkgNACAGKgIAIhYgByACQQJrQQF2IgJBA3RqIggqAgBeRQ0AIAYoAgQhCQNAAkAgBiAIIgYpAgA3AgAgAkUNACAHIAJBAWtBAXYiAkEDdGoiCCoCACAWXQ0BCwsgBiAJNgIEIAYgFjgCAAsgACAAKAIEQQhrIgw2AgQgACgCACEHCyAHIAxGDQAgByoCACEXCyALQQFqIQsMAAsACwsgASgCRCEBIAEoAhAiBg0BBkAgARDRARkgBSQACQALGSAFJAAgBSgCDCIBBEAgBSABNgIQIAUoAhQaIAEQhwILIAAoAgAiAQRAIAAgATYCBCAAKAIIGiABEIcCCwkACyABKAIQIQYLIAEoAgQiACAGQQh2Qfz//wdxaiICKAIAIgMgBkH/B3FBAnRqIgRBACABKAIIIABHGyADRgR/IAJBBGsoAgBBgCBqBSAEC0EEayARNgIAIAEgBkEBazYCECABIAEoAhRBAWo2AhQgBSgCDCIABEAgBSAANgIQIAUoAhQaIAAQhwILIAVBIGokAA8LAAuDAwIGfwF9AkACQAJAIAAoAgQiAyAAKAIIIgZJBEAgAyABKgIAOAIAIAMgAigCADYCBCADQQhqIQMMAQsgAyAAKAIAIgVrIgNBA3UiCEEBaiIEQYCAgIACTw0BQf////8BIAYgBWsiBkECdSIHIAQgBCAHSRsgBkH4////B08bIgRBgICAgAJPDQIgBEEDdCIGELAFIgcgA2oiBCABKgIAOAIAIAQgAigCADYCBCAEIAhBA3RrIQEgAwRAIAEgBSAD/AoAAAsgACAGIAdqNgIIIAAgBEEIaiIDNgIEIAAgATYCACAFRQ0AIAUQhwILIAAgAzYCBAJAIAMgACgCACIFa0EDdSIAQQJIDQAgA0EIayICKgIAIgkgBSAAQQJrQQF2IgBBA3RqIgEqAgBeRQ0AIANBBGsoAgAhAwNAAkAgAiABIgIpAgA3AgAgAEUNACAFIABBAWtBAXYiAEEDdGoiASoCACAJXQ0BCwsgAiADNgIEIAIgCTgCAAsPCxA3AAsQswEAC50XAxB/AX0BfiMAQTBrIgUkACAFIAE2AiwgAEEcQSAgAxtqKAIAIREgACACIAAoAhgQ4gECQCAAKAIYIgEgAigCBCIJIAIoAgAiCGtBA3VJBEAGQAZAQQgQ6QUhABgDIABBqycQzAUhAAwCGSAFJAAgABDqBQkACwALIAVBADYCKCAFQgA3AiACQAZAIAEEQCABQYCAgIAETwRAEDcMAwsgBSABQQJ0IgYQsAUiATYCJCAFIAE2AiAgBSABIAZqNgIoCwNAIAggCUcEQAJAIAUoAiQiASAFKAIoIgpJBEAgASAIKAIENgIAIAFBBGohAQwBCyABIAUoAiAiBmsiAUECdSILQQFqIgdBgICAgARPBEAQNwwFC0H/////AyAKIAZrIgpBAXUiDCAHIAcgDEkbIApB/P///wdPGyIHQYCAgIAETwRAELMBDAULIAdBAnQiDBCwBSINIAFqIgcgCCgCBDYCACAHIAtBAnRrIQogAQRAIAogBiAB/AoAAAsgBSAMIA1qNgIoIAUgCjYCICAHQQRqIQEgBkUNACAGEIcCIAIoAgQhCSACKAIAIQgLIAUgATYCJAJAIAkgCGtBA3UiDEECSA0AIAxBAmtBAXYhDyAIKQIAIRZBACEBIAghBgNAIAFBAXQiC0EBciEHIAYiCiABQQN0aiINQQhqIQYCQCAMIAtBAmoiC0wEQCAHIQEMAQsgByEBIA0qAgggDUEQaiIHKgIAXUUNACAHIQYgCyEBCyAKIAYpAgA3AgAgASAPTA0ACyAJQQhrIgEgBkYEQCAGIBY3AgAMAQsgBiABKQIANwIAIAEgFjcCACAGIAhrQQhqQQN1IgFBAkgNACAGKgIAIhUgCCABQQJrQQF2IgFBA3RqIgcqAgBeRQ0AIAYoAgQhCgNAAkAgBiAHIgYpAgA3AgAgAUUNACAIIAFBAWtBAXYiAUEDdGoiByoCACAVXQ0BCwsgBiAKNgIEIAYgFTgCAAsgAiACKAIEQQhrIgk2AgQgAigCACEIDAELCyAFKAIsGiAFKAIkQQRrKAIAIRIGQEEAIAQgACgCbBsEQCMAQRBrIgAkACAAQcj4AjYCDCAAQT82AgggACAAKQIINwMAIwBBEGsiAiQAQRAQ6QUhAyACIAApAgA3AwggAiACKQMINwMABkAgAyACQbAJEOgFIQAZIAIkACADEOoFCQALIABBhJkCQfsDEO0FAAsgBSgCLCEBAn8gA0UEQCAAKAKEASAAKAKMASAAKAIMIAFsamoMAQsgACgCkAEgAUECdGooAgAgACgCECADQQFrbGoLIQICQAJAIAQNACACKAIARQ0ABkAGQEEIEOkFIQAYByAAQYUMEMwFIQAMAhkgBSQABkAgABDqBRgHCQALAAsgAiAFKAIkIgYgBSgCICIBa0ECdSIHOwEAAkAgASAGRg0AIAJBBGohCEEBIAcgB0EBTRshByAAKAKUASEKQQAhAgJAAkAgBARAA0AgAyAKIAEgAkECdCILaigCACIJQQJ0aigCAEoNAiAIIAtqIAk2AgAgAkEBaiICIAdHDQAMBAsACwNAIAggAkECdCILaiIJKAIABEAGQAZAQQgQ6QUhABgLIABBshoQzAUhAAwEGSAFJAAGQCAAEOoFGAsJAAsACyADIAogASALaigCACILQQJ0aigCAEoNASAJIAs2AgAgByACQQFqIgJHDQALDAILBkAGQEEIEOkFIQAYCCAAQf4cEMwFIQAZIAUkAAZAIAAQ6gUYCAkACyAAQeSjAkECEO0FDAULIABB5KMCQQIQ7QUMBAsgA0EBayETQQAhDAZAAkACQANAIAYgAWtBAnUgDE0EQCABBEAgBSABNgIkIAUoAigaIAEQhwILIAVBMGokACASDwsgACgCbBogASAMQQJ0IgtqKAIAGiAFKAIgIAtqKAIAIQICfyADRQRAIAAoAoQBIAAoAowBIAAoAgwgAmxqagwBCyAAKAKQASACQQJ0aigCACAAKAIQIBNsagsiDy8BACIIIBFLBEAGQAZAQQgQ6QUhABgLIABBsxYQzAUhAAwEGSAFJAAGQCAAEOoFGAsJAAsACyAFKAIsIgYgAkYEQAZABkBBCBDpBSEAGAsgAEGoIRDMBSEADAMZIAUkAAZAIAAQ6gUYCwkACwALAkAgACgClAEgAkECdGooAgAgA0gEQAZABkBBCBDpBSEAGAwgAEH+HBDMBSEADAIZIAUkAAZAIAAQ6gUYDAkACwALIA9BBGohDQJAAkAgBEUNAEEAIQEgCEUNAANAIA0gAUECdGooAgAgBkYNAiABQQFqIgEgCEcNAAsLIAggEUkEQCANIAhBAnRqIAY2AgAgDyAIQQFqOwEADAELIAUgACgCgAEiASAAKAKMASIHIAYgACgCDCIKbGpqIAcgAiAKbGogAWogACgCqAEgACgCpAERCwA4AhxBACEKIAVBADYCFCAFQgA3AgwCQAZAIAVBDGogBUEcaiAFQSxqEN4BAkADQAJAIAggCk0EQCAAIAVBDGogERDiASAFKAIQIgIgBSgCDCIIRw0BQQAhCQwDCyAAKAKAASIBIAAoAowBIgIgACgCDCIGIA0gCkECdGoiBygCAGxqaiACIAUoAiAgC2ooAgAgBmxqIAFqIAAoAqgBIAAoAqQBEQsAIRUCQCAFKAIQIgEgBSgCFCIJSQRAIAEgFTgCACABIAcoAgA2AgQgAUEIaiEGDAELIAEgBSgCDCIBayICQQN1IhBBAWoiBkGAgICAAk8EQBA3DBALQf////8BIAkgAWsiCUECdSIOIAYgBiAOSRsgCUH4////B08bIgZBgICAgAJPBEAQswEMEAsgBkEDdCIJELAFIg4gAmoiBiAVOAIAIAYgBygCADYCBCAGIBBBA3RrIQcgAgRAIAcgASAC/AoAAAsgBSAJIA5qNgIUIAUgBkEIaiIGNgIQIAUgBzYCDCABRQ0AIAEQhwILIAUgBjYCEAJAIAYgBSgCDCIJa0EDdSIBQQJIDQAgBkEIayIHKgIAIhUgCSABQQJrQQF2IgFBA3RqIgIqAgBeRQ0AIAZBBGsoAgAhBgNAAkAgByACIgcpAgA3AgAgAUUNACAJIAFBAWtBAXYiAUEDdGoiAioCACAVXQ0BCwsgByAGNgIEIAcgFTgCAAsgCkEBaiEKDAELCyACIAhrIQFBACEJA0AgDSAJQQJ0aiAIKAIENgIAAkAgAUEDdSIQQQJIDQAgEEECa0EBdiEUIAgpAgAhFkEAIQEgCCEGA0AgAUEBdCILQQFyIQcgBiIKIAFBA3RqIg5BCGohBgJAIBAgC0ECaiILTARAIAchAQwBCyAHIQEgDioCCCAOQRBqIgcqAgBdRQ0AIAchBiALIQELIAogBikCADcCACABIBRMDQALIAJBCGsiASAGRgRAIAYgFjcCAAwBCyAGIAEpAgA3AgAgASAWNwIAIAYgCGtBCGpBA3UiAUECSA0AIAYqAgAiFSAIIAFBAmtBAXYiAUEDdGoiByoCAF5FDQAgBigCBCECA0ACQCAGIAciBikCADcCACABRQ0AIAggAUEBa0EBdiIBQQN0aiIHKgIAIBVdDQELCyAGIAI2AgQgBiAVOAIACyAFIAUoAhBBCGsiAjYCECAJQQFqIQkgAiAFKAIMIghrIQEgAiAIRw0ACwsgDyAJOwEAIAhFDQEgBSAINgIQIAUoAhQaIAgQhwIZIAUkACAFKAIMIgAEQCAFIAA2AhAgBSgCFBogABCHAgsJAAsLCyAMQQFqIQwgBSgCICEBIAUoAiQhBgwBCwsgAEHkowJBAhDtBQwGCyAAQeSjAkECEO0FDAULIABB5KMCQQIQ7QUMBBkgBSQABkAJARgDAAsACyAAQeSjAkECEO0FGSAFJAAJAAsZIAUkACAFKAIgIgAEQCAFIAA2AiQgBSgCKBogABCHAgsJAAsLAAsgAEHkowJBAhDtBQALxA0DCn8CfQF+IwBBMGsiByQAIAcgAjYCLCAEIAVIBEAgASAAKAKAASAAKAKMASAAKAIMIAJsamogACgCqAEgACgCpAERCwAhECAFIQgDQCAIIgpBAWshCANAIAAoAmwaAn8gCkUEQCAAKAKEASAAKAKMASAAKAIMIAJsamoMAQsgACgCkAEgAkECdGooAgAgACgCECAIbGoLIgYvAQAiDARAIAZBBGohDUEAIQZBACEJA0AGQCABIAAoAoABIAAoAowBIA0gBkECdGooAgAiCyAAKAIMbGpqIAAoAqgBIAAoAqQBEQsAIREZIAckAAkACyALIAIgECARXiILGyECIBEgECALGyEQIAkgC3IhCSAGQQFqIgYgDEcNAAsgCUEBcQ0BCwsgBCAISA0ACwsgBCAFTARAA0ACQAJAAkAgBEEATgRAIAdBHGogACACIAEgBBDdASAHQQA2AhQgB0IANwIMIAcoAiAhBQZAA0AgBygCHCIGIAVHBEACQCAGKAIEIANGDQACQCAHKAIQIgUgBygCFCIKSQRAIAUgBikCADcCACAFQQhqIQgMAQsgBSAHKAIMIgVrIghBA3UiC0EBaiIJQYCAgIACTwRAEDcMCQtB/////wEgCiAFayIKQQJ1IgwgCSAJIAxJGyAKQfj///8HTxsiCUGAgICAAk8EQBCzAQwJCyAJQQN0IgoQsAUiDCAIaiIJIAYpAgA3AgAgCSALQQN0ayEGIAgEQCAGIAUgCPwKAAALIAcgCiAMajYCFCAHIAlBCGoiCDYCECAHIAY2AgwgBUUNACAFEIcCCyAHIAg2AhAgCCAHKAIMIgprQQN1IgVBAkgNACAIQQhrIgkqAgAiECAKIAVBAmtBAXYiBkEDdGoiBSoCAF5FDQAgCEEEaygCACEIA0ACQCAJIAUiCSkCADcCACAGRQ0AIAogBkEBa0EBdiIGQQN0aiIFKgIAIBBdDQELCyAJIAg2AgQgCSAQOAIACwJAIAcoAiAiDiAHKAIcIglrQQN1IgxBAkgNACAMQQJrQQF2IQ8gCSkCACESQQAhBiAJIQUDQCAGQQF0IgtBAXIhCCAFIgogBkEDdGoiDUEIaiEFAkAgDCALQQJqIgtMBEAgCCEGDAELIAghBiANKgIIIA1BEGoiCCoCAF1FDQAgCCEFIAshBgsgCiAFKQIANwIAIAYgD0wNAAsgDkEIayIGIAVGBEAgBSASNwIADAELIAUgBikCADcCACAGIBI3AgAgBSAJa0EIakEDdSIGQQJIDQAgBSoCACIQIAkgBkECa0EBdiIGQQN0aiIIKgIAXkUNACAFKAIEIQoDQAJAIAUgCCIFKQIANwIAIAZFDQAgCSAGQQFrQQF2IgZBA3RqIggqAgAgEF0NAQsLIAUgCjYCBCAFIBA4AgALIAcgBygCIEEIayIFNgIgDAELCyAHKAIMIgYgBygCEEYNAwJAIAAoAowBIAAoAgwgBygCLGxqIgIgACgChAFqLQACQQFxRQ0AIAcgASACIAAoAoABaiAAKAKoASAAKAKkARELADgCCCAHQQxqIAdBCGogB0EsahDeASAHKAIQIg0gBygCDCIIa0EDdSILIAAoAiRNDQACQCALQQJIDQAgC0ECa0EBdiEOIAgpAgAhEkEAIQYgCCEFA0AgBkEBdCIKQQFyIQIgBSIJIAZBA3RqIgxBCGohBQJAIAsgCkECaiIKTARAIAIhBgwBCyACIQYgDCoCCCAMQRBqIgIqAgBdRQ0AIAIhBSAKIQYLIAkgBSkCADcCACAGIA5MDQALIA1BCGsiAiAFRgRAIAUgEjcCAAwBCyAFIAIpAgA3AgAgAiASNwIAIAUgCGtBCGpBA3UiAkECSA0AIAUqAgAiECAIIAJBAmtBAXYiBkEDdGoiCSoCAF5FDQAgBSgCBCECA0ACQCAFIAkiBSkCADcCACAGRQ0AIAggBkEBa0EBdiIGQQN0aiIJKgIAIBBdDQELCyAFIAI2AgQgBSAQOAIACyAHIAcoAhBBCGs2AhALIAAgAyAHQQxqIARBARDfASECDAIZIAckACAHKAIMIgAEQCAHIAA2AhAgBygCFBogABCHAgsgBygCHCIABEAgByAANgIgIAcoAiQaIAAQhwILCQALAAsgB0EwaiQADwsgBygCDCEGCyAGBEAgByAGNgIQIAcoAhQaIAYQhwILIAcoAhwiBQRAIAcgBTYCICAHKAIkGiAFEIcCCyAEQQFrIQQMAQsLAAsGQAZAQQgQ6QUhABgBIABBwhwQzAUhABkgByQAIAAQ6gUJAAsgAEHkowJBAhDtBQAL3AUCBn8CfSMAIQggAigCACEGIAACfwJAIAEoAgQiBEUNACABKAIAAn8gBEEBayAGcSAEaSIHQQFNDQAaIAYgBCAGSw0AGiAGIARwCyIFQQJ0aigCACICRQ0AIAIoAgAiAkUNACAHQQFNBEAgBEEBayEHA0ACQCAGIAIoAgQiCUcEQCAHIAlxIAVHDQQMAQsgAigCCCAGRw0AQQAMBAsgAigCACICDQALDAELA0ACQCAGIAIoAgQiB0cEQCAEIAdNBH8gByAEcAUgBwsgBUcNAwwBCyACKAIIIAZHDQBBAAwDCyACKAIAIgINAAsLQQwQsAUiAiAGNgIEIAJBADYCACACIAMoAgA2AgggASoCECEKIAEoAgxBAWqzIQsCQCAEBEAgCiAEs5QgC11FDQELQQIhBQJABkACQCAEIARBAWtxQQBHIARBA0lyIARBAXRyIgMgCyAKlY38ASIHIAMgB0sbIgNBAUYNACADIANBAWtxRQRAIAMhBQwBCyADEJICIQUgASgCBCEECyAEIAVPBEAgBCAFTQ0CIAEoAgyzIAEqAhCVjfwBIQMgBQJ/AkAgBEEDSQ0AIARpQQFLDQAgA0EBQSAgA0EBa2drdCADQQJJGwwBCyADEJICCyIDIAMgBUkbIgUgBE8NAgsgASAFEMkBGSAIJAAgAhCHAgkACwsgASgCBCIEIARBAWsiA3FFBEAgAyAGcSEFDAELIAQgBksEQCAGIQUMAQsgBiAEcCEFCwJAIAEoAgAiBiAFQQJ0aiIFKAIAIgNFBEAgAiABQQhqIgMoAgA2AgAgASACNgIIIAUgAzYCACACKAIAIgNFDQEgAygCBCEDAkAgBCAEQQFrIgVxRQRAIAMgBXEhAwwBCyADIARJDQAgAyAEcCEDCyAGIANBAnRqIAI2AgAMAQsgAiADKAIANgIAIAMgAjYCAAsgASABKAIMQQFqNgIMQQELOgAEIAAgAjYCAAvzCwMLfwJ9AX4jAEEwayIFJAACQCABKAIEIgMgASgCACIEa0EDdSACSQ0AIAVBADYCKCAFQgA3AiAgBUEANgIcIAVCADcCFANABkAgAyAERgRAIAUoAhghBiAFKAIUIQMCQANAIAYgA2siB0EDdSEIAkADQCAFKAIgIgQgBSgCJEYNASACIAhNDQEgBCgCACEJIAQoAgQhCiAFQSBqEKwBIAlBgICAgHhzviEOIAMhBANAIAQgBkcEQCAAKAKAASILIAAoAowBIgwgACgCDCINIAQoAgRsamogDCAKIA1saiALaiAAKAKoASAAKAKkARELACEPIARBCGohBCAOIA9eRQ0BDAILCwsgBSgCHCILIAZLBEAgBiAKNgIEIAYgCTYCACAFIAZBCGoiBjYCGAwCCyAIQQFqIgRBgICAgAJPBEAQNwwDC0H/////ASALIANrIgZBAnUiCyAEIAQgC0kbIAZB+P///wdPGyIEQYCAgIACTwRAELMBDAMLIARBA3QiCxCwBSIMIAdqIgYgCjYCBCAGIAk2AgAgBiAIQQN0ayEEIAcEQCAEIAMgB/wKAAALIAUgCyAMajYCHCAFIAZBCGoiBjYCGCAFIAQ2AhQgAwRAIAMQhwILIAQhAyAFIAY2AhgMAQsLIAVBCGpBBHIhAiADIQADQCAAIAZGBEAgAwRAIAUgAzYCGCAFKAIcGiADEIcCCyAFKAIgIgBFDQYgBSAANgIkIAUoAigaIAAQhwIMBgsgBSAAKQIAIhA3AwggBSAQp0GAgICAeHM2AgQgASAFQQRqIAIQ3gEgAEEIaiEADAALAAsACyAFIAQqAgCMOAIIAkACQAJAAkAgBSgCJCIDIAUoAigiCEkEQCADIAUqAgg4AgAgAyAEKAIENgIEIANBCGohBgwBCyADIAUoAiAiA2siBkEDdSIJQQFqIgdBgICAgAJPDQFB/////wEgCCADayIIQQJ1IgogByAHIApJGyAIQfj///8HTxsiB0GAgICAAk8NAiAHQQN0IggQsAUiCiAGaiIHIAUqAgg4AgAgByAEKAIENgIEIAcgCUEDdGshBCAGBEAgBCADIAb8CgAACyAFIAggCmo2AiggBSAHQQhqIgY2AiQgBSAENgIgIANFDQAgAxCHAgsgBSAGNgIkAkAgBiAFKAIgIgdrQQN1IgNBAkgNAAJAIAcgA0ECayIDQQF2IghBA3RqIgQqAgAiDyAGQQhrIgkqAgAiDl0EQCAGQQRrKAIAIQYMAQsgDiAPXQ0BIAZBBGsoAgAiBiAEKAIETQ0BCyAJIAQpAgA3AgACQCADQQJJBEAgBCEDDAELA0ACQCAHIAhBAWsiCUEBdiIIQQN0aiIDKgIAIg8gDl0NACAOIA9dBEAgBCEDDAMLIAMoAgQgBkkNACAEIQMMAgsgBCADKQIANwIAIAMhBCAJQQFLDQALCyADIAY2AgQgAyAOOAIACwwCCxA3AAsQswEACxkgBSQAIAUoAhQiAARAIAUgADYCGCAFKAIcGiAAEIcCCyAFKAIgIgAEQCAFIAA2AiQgBSgCKBogABCHAgsJAAsCQCABKAIEIgwgASgCACIHa0EDdSIKQQJIDQAgCkECa0EBdiENIAcpAgAhEEEAIQQgByEDA0AgBEEBdCIJQQFyIQYgAyIIIARBA3RqIgtBCGohAwJAIAogCUECaiIJTARAIAYhBAwBCyAGIQQgCyoCCCALQRBqIgYqAgBdRQ0AIAYhAyAJIQQLIAggAykCADcCACAEIA1MDQALIAxBCGsiBCADRgRAIAMgEDcCAAwBCyADIAQpAgA3AgAgBCAQNwIAIAMgB2tBCGpBA3UiBEECSA0AIAMqAgAiDiAHIARBAmtBAXYiBEEDdGoiBioCAF5FDQAgAygCBCEIA0ACQCADIAYiAykCADcCACAERQ0AIAcgBEEBa0EBdiIEQQN0aiIGKgIAIA5dDQELCyADIAg2AgQgAyAOOAIACyABIAEoAgRBCGsiAzYCBCABKAIAIQQMAAsACyAFQTBqJAALkgIBBH8jACECAkAgACgCFCIDBEAgACgCBCIEIAAoAhAiAkEIdkH8//8HcWooAgAgAkH/B3FBAnRqKAIAIQEgACADQQFrNgIUIAAgAkEBaiICNgIQIAJBgBBJDQEgBCgCABCHAiAAIAAoAgRBBGo2AgQgACAAKAIQQYAIazYCEAwBCwZAQQwQsAUiASAAKAIwIgA2AgggAUH//wM7AQAGQEF/IABBAXQgAEEASBsQsAUhABkgAiQAIAEQhwIJAAsZIAIkAAkACyABIAA2AgQLIAEgAS8BAEEBaiIAOwEAIAAgAEH//wNxRwRAIAEoAghBAXQiAARAIAEoAgRBACAA/AsACyABIAEvAQBBAWo7AQALIAELgxABBH8jAEGQAmsiBCQAAkAGQAZAIARBzABqIAEQygEhBRgCAkAgBSgCSEUEQAZABkBBCBDpBSEAGAUgAEG0IhDMBSEADAIZIAQkAAZAIAAQ6gUYBQkACwALIAVCAEECELkCIARBOGogBRC4AiAFQgBBABC5AiAFIABBhAFqQQQQtwIgBSAAQQRqQQQQtwIgBSAAQQhqQQQQtwIgACAAKAIEIAMgAyAAKAIISRsiBjYCBCAFIABBDGpBBBC3AiAFIABBiAFqQQQQtwIgBSAAQYABakEEELcCIAUgAEFAa0EEELcCIAUgAEH4AGpBBBC3AiAFIABBHGpBBBC3AiAFIABBIGpBBBC3AiAFIABBGGpBBBC3AiAFIABBMGpBCBC3AiAFIABBJGpBBBC3AiAAIAIgAigCACgCABEBADYCoAEgACACIAIoAgAoAgQRAQA2AqQBIAAgAiACKAIAKAIIEQEANgKoASAEQShqIAUQuAIgBSAAKAIMIAAoAghsrUEBELkCQQAhAgJAA0AgACgCCCACTQRAIARBGGogBRC4AiAEKQMgIAQpA0BSBEAGQAZAQQgQ6QUhABgIIABBmSQQzAUhAAwEGSAEJAAGQCAAEOoFGAgJAAsACyAFIAUoAgBBDGsoAgBqQQAQ7QIgBSAEKQMwQQAQuQIgACAAKAIMIAZsEIYCIgE2AowBAkAgAUUEQAZABkBBCBDpBSEAGAkgAEHoNRDMBSEADAIZIAQkAAZAIAAQ6gUYCQkACwALIAUgASAAKAIMIAAoAghsELcCIAAgACgCHEECdEEEajYCECAAIAAoAiBBAnRBBGo2AnxBACEBIARBADYCICAEQgA3AhggBEEAOgAMIAQgBEEYajYCCEEAIQIgBgRABkAgBkGr1arVAE8EQBA3DAkLIAZBGGwiARCwBSECGSAEJAAgBEEIahDOAQkACyABQRhrIgMgA0EYcGtBGGoiAwRAIAJBACAD/AsACyACIANqIQcgASACaiEBCyAEIAAoAmwiAzYCGCAAIAI2AmwgBCAAKAJwIgI2AhwgACAHNgJwIAQgACgCdDYCICAAIAE2AnQgAwRAIAMiASACRwRAA0AgAyACQRhrIgJHDQALIAQoAiAaIAQoAhghAQsgBCADNgIcIAEQhwILIARBADYCICAEQgA3AhggBEEAOgAMIAQgBEEYajYCCAZAQYCA4AAQsAUhARkgBCQAIARBCGoQzgEJAAsgAUEAQYCA4AD8CwAgBCAAKAJIIgM2AhggACABNgJIIAQgACgCTCICNgIcIAAgAUGAgOAAaiIBNgJMIAQgACgCUDYCICAAIAE2AlAgAwRAIAMiASACRwRAA0AgAyACQRhrIgJHDQALIAQoAiAaIAQoAhghAQsgBCADNgIcIAEQhwILQTQQsAUhAQZAIAEgBhDPASEBGSAEJAAgARCHAgkACyAAIAE2AkQgACAGQQJ0IgEQhgIiAjYCkAECQCACRQRABkAGQEEIEOkFIQAYCiAAQZMQEMwFIQAMAhkgBCQABkAgABDqBRgKCQALAAsCfyAGRQRAQQAhA0EAIQJBAAwBCyABELAFIQIgAQRAIAJBACAB/AsACyACIAZBAnRqIQMgASACagshBiAAKAKUASIBBEAgACABNgKYASAAKAKcARogARCHAiAAQQA2ApwBIABCADcClAELIAAgAzYCnAEgACAGNgKYASAAIAI2ApQBIABBCjYCKCAARAAAAAAAAPA/IAArAzCjOQM4IABBxAFqIQNBACECA0AgACgCCCACTQRAIABBhAJqIQFBACECA0AgACgCCCACTQRAIAVBCGoiABDNAkUEQCAFIAUoAgBBDGsoAgBqIgEgASgCEEEEchDtAgsgBUGspgEoAgAiATYCACAFIAFBDGsoAgBqQbimASgCADYCACAAEMwCGiAFQewAahCgAiAEQZACaiQADwsCQCAAKAKEASAAKAKMASAAKAIMIAJsamotAAJBAXFFDQAgACAAKAIUQQFqNgIUIAAtAOgBQQFHDQAgBCACNgIIIARBGGogASAEQQhqIgMgAxDhAQsgAkEBaiECDAALAAsgBCAAKAKIASAAKAKMASAAKAIMIAJsamooAAA2AgQgBCAEQQRqIgE2AgggBEEYaiIGIAMgASAEQQhqEKcBIAQoAhggAjYCDCAFIAZBBBC3AiAEKAIYIgFFBEAgAkECdCIBIAAoApQBakEANgIAIAAoApABIAFqQQA2AgAgAkEBaiECDAELIAJBAnQiBiAAKAKUAWogASAAKAIQbjYCACAEKAIYIgcQhgIhASAAKAKQASAGaiABNgIAAkAgAUUEQAZABkBBCBDpBSEAGAwgAEGUCxDMBSEADAIZIAQkAAZAIAAQ6gUYDAkACwALIAUgASAHELcCIAJBAWohAgwBCwsgAEHkowJBAhDtBQwHCyAAQeSjAkECEO0FDAYLIABB5KMCQQIQ7QUMBQsgBEEYaiAFELgCAkACQCAEKQMgQgBZBEAgBEEIaiAFELgCIAQpAxAgBCkDQFMNAQsGQAZAQQgQ6QUhABgIIABBmSQQzAUhAAwCGSAEJAAGQCAAEOoFGAgJAAsACyAFIARBGGpBBBC3AiAEKAIYIgEEQCAFIAGtQQEQuQILIAJBAWohAgwBCwsgAEHkowJBAhDtBQwDCyAAQeSjAkECEO0FDAILIABB5KMCQQIQ7QUZIAQkACAFEMsBGgkACwsAC9YBAQJ/IwBBEGsiAiQAIAIgATYCBAJAAkAgACgCCCABSwRAIAAoAoQBIAAoAowBIAAoAgwgAigCBGxqaiIBLQACIgNBAXENASABIANBAXI6AAIgACAAKAIUQQFqNgIUIAAtAOgBQQFHDQIGQCACQQhqIABBhAJqIAJBBGoiACAAEOEBDAMZIAIkAAkACwALQa8NQakfQZMGQb0dEBIACwZABkBBCBDpBSEAGAIgAEHZJBDMBSEAGSACJAAgABDqBQkACyAAQeSjAkECEO0FAAsgAkEQaiQAC+QEAwF/BnwCfiAAvSIIQjCIpyEBIAhCgICAgICAgPc/fUL//////5/CAVgEQCAIQoCAgICAgID4P1EEQEQAAAAAAAAAAA8LIABEAAAAAAAA8L+gIgAgACAARAAAAAAAAKBBoiICoCACoSICIAKiQdD6ACsDACIFoiIGoCIHIAAgACAAoiIDoiIEIAQgBCAEQaD7ACsDAKIgA0GY+wArAwCiIABBkPsAKwMAokGI+wArAwCgoKCiIANBgPsAKwMAoiAAQfj6ACsDAKJB8PoAKwMAoKCgoiADQej6ACsDAKIgAEHg+gArAwCiQdj6ACsDAKCgoKIgACACoSAFoiAAIAKgoiAGIAAgB6GgoKCgDwsCQCABQfD/AWtBn4B+TQRAIABEAAAAAAAAAABhBEAjAEEQayIBRAAAAAAAAPC/OQMIIAErAwhEAAAAAAAAAACjDwsgCEKAgICAgICA+P8AUQ0BIAFB8P8BcUHw/wFHIAFB//8BTXFFBEAgACAAoSIAIACjDwsgAEQAAAAAAAAwQ6K9QoCAgICAgICgA30hCAsgCEKAgICAgICA8z99IglCNIentyIDQZj6ACsDAKIgCUItiKdB/wBxQQR0IgFBsPsAaisDAKAiBCABQaj7AGorAwAgCCAJQoCAgICAgIB4g32/IAFBqIsBaisDAKEgAUGwiwFqKwMAoaIiAKAiBSAAIAAgAKIiAqIgAiAAQcj6ACsDAKJBwPoAKwMAoKIgAEG4+gArAwCiQbD6ACsDAKCgoiACQaj6ACsDAKIgA0Gg+gArAwCiIAAgBCAFoaCgoKCgIQALIAAL5QEBAn8gAkEARyEDAkACQAJAIABBA3FFDQAgAkUNACABQf8BcSEEA0AgAC0AACAERg0CIAJBAWsiAkEARyEDIABBAWoiAEEDcUUNASACDQALCyADRQ0BAkAgAUH/AXEiAyAALQAARg0AIAJBBEkNACADQYGChAhsIQMDQEGAgoQIIAAoAgAgA3MiBGsgBHJBgIGChHhxQYCBgoR4Rw0CIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELIAFB/wFxIQEDQCABIAAtAABGBEAgAA8LIABBAWohACACQQFrIgINAAsLQQALgQEBAn8CQAJAIAJBBE8EQCAAIAFyQQNxDQEDQCAAKAIAIAEoAgBHDQIgAUEEaiEBIABBBGohACACQQRrIgJBA0sNAAsLIAJFDQELA0AgAC0AACIDIAEtAAAiBEYEQCABQQFqIQEgAEEBaiEAIAJBAWsiAg0BDAILCyADIARrDwtBAAsrAQF/IwBBEGsiAiQAIAIgATYCDEH49QIgACABQQBBABD4ARogAkEQaiQACwQAQQELBABBAAsEAEEAC1kBAX8gACAAKAJIIgFBAWsgAXI2AkggACgCACIBQQhxBEAgACABQSByNgIAQX8PCyAAQgA3AgQgACAAKAIsIgE2AhwgACABNgIUIAAgASAAKAIwajYCEEEAC4kEAQN/IAJBgARPBEAgAgRAIAAgASAC/AoAAAsgAA8LIAAgAmohAwJAIAAgAXNBA3FFBEACQCAAQQNxRQRAIAAhAgwBCyACRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAkEDcUUNASACIANJDQALCyADQXxxIQQCQCADQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0EEayIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvEAQEDfwJAIAIoAhAiAwR/IAMFIAIQ7QENASACKAIQCyACKAIUIgRrIAFJBEAgAiAAIAEgAigCJBEEAA8LAkACQCACKAJQQQBIDQAgAUUNACABIQMDQCAAIANqIgVBAWstAABBCkcEQCADQQFrIgMNAQwCCwsgAiAAIAMgAigCJBEEACIEIANJDQIgASADayEBIAIoAhQhBAwBCyAAIQVBACEDCyAEIAUgARDuARogAiACKAIUIAFqNgIUIAEgA2ohBAsgBAtCAQF/IAEgAmwhBCAEAn8gAygCTEEASARAIAAgBCADEO8BDAELIAAgBCADEO8BCyIARgRAIAJBACABGw8LIAAgAW4LfQECfyMAQRBrIgEkACABQQo6AA8CQAJAIAAoAhAiAgR/IAIFIAAQ7QENAiAAKAIQCyAAKAIUIgJGDQAgACgCUEEKRg0AIAAgAkEBajYCFCACQQo6AAAMAQsgACABQQ9qQQEgACgCJBEEAEEBRw0AIAEtAA8aCyABQRBqJAALYgBBxPYCKAIAGgJAIABBASAAEPUBIgBB+PUCEPABIABHDQACQEHI9gIoAgBBCkYNAEGM9gIoAgAiAEGI9gIoAgBGDQBBjPYCIABBAWo2AgAgAEEKOgAADAELQfj1AhDxAQsL9AIBB38jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEFQQIhBwJ/AkACQAJAIAAoAjwgA0EQaiIBQQIgA0EMahAcIgQEf0HoiQMgBDYCAEF/BUEACwRAIAEhBAwBCwNAIAUgAygCDCIGRg0CIAZBAEgEQCABIQQMBAsgAUEIQQAgBiABKAIEIghLIgkbaiIEIAYgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAGayEFIAAoAjwgBCIBIAcgCWsiByADQQxqEBwiBgR/QeiJAyAGNgIAQX8FQQALRQ0ACwsgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAHQQJGDQAaIAIgBCgCBGsLIANBIGokAAsEAEIAC30BA38CQAJAIAAiAUEDcUUNACABLQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQFBgIKECCACKAIAIgNrIANyQYCBgoR4cUGAgYKEeEYNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEPYBIQAgASgCAEFAags2AgAgAA8LIAEgAkH+B2s2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsL8AICAn8BfgJAIAJFDQAgACABOgAAIAAgAmoiA0EBayABOgAAIAJBA0kNACAAIAE6AAIgACABOgABIANBA2sgAToAACADQQJrIAE6AAAgAkEHSQ0AIAAgAToAAyADQQRrIAE6AAAgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgA2AgAgAyACIARrQXxxIgJqIgFBBGsgADYCACACQQlJDQAgAyAANgIIIAMgADYCBCABQQhrIAA2AgAgAUEMayAANgIAIAJBGUkNACADIAA2AhggAyAANgIUIAMgADYCECADIAA2AgwgAUEQayAANgIAIAFBFGsgADYCACABQRhrIAA2AgAgAUEcayAANgIAIAIgA0EEcUEYciIBayICQSBJDQAgAK1CgYCAgBB+IQUgASADaiEBA0AgASAFNwMYIAEgBTcDECABIAU3AwggASAFNwMAIAFBIGohASACQSBrIgJBH0sNAAsLC8MCAQR/IwBB0AFrIgUkACAFIAI2AswBIAVBoAFqIgJBAEEo/AsAIAUgBSgCzAE2AsgBAkBBACABIAVByAFqIAVB0ABqIAIgAyAEEPkBQQBIBEBBfyEEDAELIAAoAkxBAEggACAAKAIAIghBX3E2AgACQAJAAkAgACgCMEUEQCAAQdAANgIwIABBADYCHCAAQgA3AxAgACgCLCEGIAAgBTYCLAwBCyAAKAIQDQELQX8hAiAAEO0BDQELIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQ+QEhAgsgBgRAIABBAEEAIAAoAiQRBAAaIABBADYCMCAAIAY2AiwgAEEANgIcIAAoAhQhASAAQgA3AxAgAkF/IAEbIQILIAAgACgCACIAIAhBIHFyNgIAQX8gAiAAQSBxGyEEDQALIAVB0AFqJAAgBAuREwISfwJ+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IAQgBkkNASAEKAIIIgEgBkkNASABIAA2AgwgBCAANgIIIABBADYCGCAAIAQ2AgwgACABNgIICw8LEIMCAAtSAQJ/QaT4AigCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNG0UEQCAAPwBBEHRNDQEgABAgDQELQeiJA0EwNgIAQX8PC0Gk+AIgADYCACABCw4AQfCiByQCQfCiAyQBCwcAIwAjAWsLBAAjAgsEACMBC1ABAX4CQCADQcAAcQRAIAEgA0FAaq2GIQJCACEBDAELIANFDQAgAiADrSIEhiABQcAAIANrrYiEIQIgASAEhiEBCyAAIAE3AwAgACACNwMIC1ABAX4CQCADQcAAcQRAIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC/UDAgJ+BX8jAEEgayIFJAAgAUL///////8/gyECAn4gAUIwiEL//wGDIgOnIgRBgfgAa0H9D00EQCACQgSGIABCPIiEIQIgBEGA+ABrrSEDAkAgAEL//////////w+DIgBCgYCAgICAgIAIWgRAIAJCAXwhAgwBCyAAQoCAgICAgICACFINACACQgGDIAJ8IQILQgAgAiACQv////////8HViIEGyEAIAStIAN8DAELAkAgACAChFANACADQv//AVINACACQgSGIABCPIiEQoCAgICAgIAEhCEAQv8PDAELIARB/ocBSwRAQgAhAEL/DwwBC0GA+ABBgfgAIANQIgcbIgggBGsiBkHwAEoEQEIAIQBCAAwBCyAFQRBqIAAgAiACQoCAgICAgMAAhCAHGyICQYABIAZrEI8CIAUgACACIAYQkAIgBSkDCEIEhiAFKQMAIgJCPIiEIQACQCAEIAhHIAUpAxAgBSkDGIRCAFJxrSACQv//////////D4OEIgJCgYCAgICAgIAIWgRAIABCAXwhAAwBCyACQoCAgICAgICACFINACAAQgGDIAB8IQALIABCgICAgICAgAiFIAAgAEL/////////B1YiBBshACAErQshAiAFQSBqJAAgAUKAgICAgICAgIB/gyACQjSGhCAAhL8LtwwBB38jAEEQayIEJAAgBCAANgIMAkAgAEHTAU0EQEGgnwFB4KABIARBDGoQkwIoAgAhAAwBCyAA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BAseACAAIAAoAhBBAXI2AhAgAC0AFEEBcQRAEPAFAAsLRwECfyAAIAE3A3AgACAAKAIsIAAoAgQiA2usNwN4IAAoAgghAgJAIAFQDQAgASACIANrrFkNACADIAGnaiECCyAAIAI2AmgLjAICA38CfgJAIAApA3AiBEIAUiAEIAApA3ggACgCBCIBIAAoAiwiAmusfCIFV3FFBEAjAEEQayICJABBfyEBAkAgABCdAg0AIAAgAkEPakEBIAAoAiARBABBAUcNACACLQAPIQELIAJBEGokACABIgNBAE4NASAAKAIEIQEgACgCLCECCyAAQn83A3AgACABNgJoIAAgBSACIAFrrHw3A3hBfw8LIAVCAXwhBSAAKAIEIQEgACgCCCECAkAgACkDcCIEUA0AIAQgBX0iBCACIAFrrFkNACABIASnaiECCyAAIAI2AmggACAFIAAoAiwiACABa6x8NwN4IAAgAU8EQCABQQFrIAM6AAALIAMLhQECAn8BfiMAQRBrIgMkACAAAn4gAUUEQEIADAELIAMgASABQR91IgJzIAJrIgKtQgAgAmciAkHRAGoQjwIgAykDCEKAgICAgIDAAIVBnoABIAJrrUIwhnxCgICAgICAgICAf0IAIAFBAEgbhCEEIAMpAwALNwMAIAAgBDcDCCADQRBqJAALxQoCBX8PfiMAQeAAayIFJAAgBEL///////8/gyEMIAIgBIVCgICAgICAgICAf4MhCiACQv///////z+DIg1CIIghDiAEQjCIp0H//wFxIQcCQAJAIAJCMIinQf//AXEiCUH//wFrQYKAfk8EQCAHQf//AWtBgYB+Sw0BCyABUCACQv///////////wCDIgtCgICAgICAwP//AFQgC0KAgICAgIDA//8AURtFBEAgAkKAgICAgIAghCEKDAILIANQIARC////////////AIMiAkKAgICAgIDA//8AVCACQoCAgICAgMD//wBRG0UEQCAEQoCAgICAgCCEIQogAyEBDAILIAEgC0KAgICAgIDA//8AhYRQBEAgAiADhFAEQEKAgICAgIDg//8AIQpCACEBDAMLIApCgICAgICAwP//AIQhCkIAIQEMAgsgAyACQoCAgICAgMD//wCFhFAEQCABIAuEQgAhAVAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeULAAEIAIAYbfKciBkEPaxCPAkEQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeULAAEIAIAgbfKciCEEPaxCPAiAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg0IAUgRAIAZBAWohBgwBCyALQj+IIARCAYYgAkI/iIQhBCACQgGGIAFCP4iEIQIgC0IBhiELIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQjwIgBUEgaiACIAQgBhCPAiAFQRBqIAsgASAHEJACIAUgAiAEIAcQkAIgBSkDMCAFKQM4hEIAUq0gBSkDICAFKQMQhIQhCyAFKQMoIAUpAxiEIQEgBSkDACECIAUpAwgMAgtCACEBDAILIARC////////P4MgBq1CMIaECyAKhCEKIAtQIAFCAFkgAUKAgICAgICAgIB/URtFBEAgCiACQgF8IgFQrXwhCgwBCyALIAFCgICAgICAgICAf4WEQgBSBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQAC9UJAgR/BH4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACACIAEgA4UgAiAEhUKAgICAgICAgIB/hYRQIgUbIQRCACABIAUbIQMMAgsgAyAJQoCAgICAgMD//wCFhFANASABIAqEUARAIAMgCYRCAFINAiABIAODIQMgAiAEgyEEDAILIAMgCYRCAFINACABIQMgAiEEDAELIAMgASABIANUIAkgClYgCSAKURsiCBshCiAEIAIgCBsiDEL///////8/gyEJIAIgBCAIGyILQjCIp0H//wFxIQcgDEIwiKdB//8BcSIFRQRAIAZB4ABqIAogCSAKIAkgCVAiBRt5QsAAQgAgBRt8pyIFQQ9rEI8CIAYpA2ghCSAGKQNgIQpBECAFayEFCyABIAMgCBshAyALQv///////z+DIQEgBwR+IAEFIAZB0ABqIAMgASADIAEgAVAiBxt5QsAAQgAgBxt8pyIHQQ9rEI8CQRAgB2shByAGKQNQIQMgBikDWAtCA4YgA0I9iIRCgICAgICAgASEIQEgCUIDhiAKQj2IhCACIASFIQQCfiADQgOGIgIgBSAHRg0AGiAFIAdrIgdB/wBLBEBCACEBQgEMAQsgBkFAayACIAFBgAEgB2sQjwIgBkEwaiACIAEgBxCQAiAGKQM4IQEgBikDMCAGKQNAIAYpA0iEQgBSrYQLIQlCgICAgICAgASEIQsgCkIDhiEKAkAgBEIAUwRAQgAhA0IAIQQgCSAKhSABIAuFhFANAiAKIAl9IQIgCyABfSAJIApWrX0iBEL/////////A1YNASAGQSBqIAIgBCACIAQgBFAiBxt5QsAAQgAgBxt8p0EMayIHEI8CIAUgB2shBSAGKQMoIQQgBikDICECDAELIAkgCnwiAiAJVK0gASALfHwiBEKAgICAgICACINQDQAgCUIBgyAEQj+GIAJCAYiEhCECIAVBAWohBSAEQgGIIQQLIAxCgICAgICAgICAf4MhAyAFQf//AU4EQCADQoCAgICAgMD//wCEIQRCACEDDAELQQAhBwJAIAVBAEoEQCAFIQcMAQsgBkEQaiACIAQgBUH/AGoQjwIgBiACIARBASAFaxCQAiAGKQMAIAYpAxAgBikDGIRCAFKthCECIAYpAwghBAsgBEI9hiACQgOIhCEBIARCA4hC////////P4MgB61CMIaEIAOEIQQCQAJAIAKnQQdxIgVBBEcEQCAEIAEgASAFQQRLrXwiA1atfCEEDAELIAQgASABIAFCAYN8IgNWrXwhBAwBCyAFRQ0BCwsgACADNwMAIAAgBDcDCCAGQfAAaiQAC9ABAgR+An8jAEEQayIGJAAgAb0iBUL/////////B4MhAiAAAn4gBUI0iEL/D4MiA0IAUgRAIANC/w9SBEAgAkIEiCEEIANCgPgAfCEDIAJCPIYMAgsgAkIEiCEEQv//ASEDIAJCPIYMAQsgAlAEQEIAIQNCAAwBCyAGIAJCACACeaciB0ExahCPAiAGKQMIQoCAgICAgMAAhSEEQYz4ACAHa60hAyAGKQMACzcDACAAIAVCgICAgICAgICAf4MgA0IwhoQgBIQ3AwggBkEQaiQAC9sBAgF/An5BASEEAkAgAEIAUiABQv///////////wCDIgVCgICAgICAwP//AFYgBUKAgICAgIDA//8AURsNACACQgBSIANC////////////AIMiBkKAgICAgIDA//8AViAGQoCAgICAgMD//wBRGw0AIAAgAoQgBSAGhIRQBEBBAA8LIAEgA4NCAFkEQCAAIAJUIAEgA1MgASADURsEQEF/DwsgACAChSABIAOFhEIAUg8LIAAgAlYgASADVSABIANRGwRAQX8PCyAAIAKFIAEgA4WEQgBSIQQLIAQLwAECAX8CfkF/IQMCQCAAQgBSIAFC////////////AIMiBEKAgICAgIDA//8AViAEQoCAgICAgMD//wBRGw0AIAJC////////////AIMiBUKAgICAgIDA//8AViAFQoCAgICAgMD//wBScQ0AIAAgBCAFhIRQBEBBAA8LIAEgAoNCAFkEQCABIAJSIAEgAlNxDQEgACABIAKFhEIAUg8LIABCAFIgASACVSABIAJRGw0AIAAgASAChYRCAFIhAwsgAwupAQEBfEQAAAAAAADwPyEBAkAgAEGACE4EQEQAAAAAAADgfyEBIABB/w9JBEAgAEH/B2shAAwCC0QAAAAAAADwfyEBQf0XIAAgAEH9F08bQf4PayEADAELIABBgXhKDQBEAAAAAAAAYAMhASAAQbhwSwRAIABByQdqIQAMAQtEAAAAAAAAAAAhAUHwaCAAIABB8GhNG0GSD2ohAAsgASAAQf8Haq1CNIa/ogs8ACAAIAE3AwAgACACQv///////z+DIAJCgICAgICAwP//AINCMIinIANCMIinQYCAAnFyrUIwhoQ3AwgLZwIBfwF+IwBBEGsiAiQAIAACfiABRQRAQgAMAQsgAiABrUIAQfAAIAFnIgFBH3NrEI8CIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQMgAikDAAs3AwAgACADNwMIIAJBEGokAAtFAQF/IwBBEGsiBSQAIAUgASACIAMgBEKAgICAgICAgIB/hRD3AiAFKQMAIQEgACAFKQMINwMIIAAgATcDACAFQRBqJAALxAIBAX8jAEHQAGsiBCQAAkAgA0GAgAFOBEAgBEEgaiABIAJCAEKAgICAgICA//8AEPYCIAQpAyghAiAEKQMgIQEgA0H//wFJBEAgA0H//wBrIQMMAgsgBEEQaiABIAJCAEKAgICAgICA//8AEPYCQf3/AiADIANB/f8CTxtB/v8BayEDIAQpAxghAiAEKQMQIQEMAQsgA0GBgH9KDQAgBEFAayABIAJCAEKAgICAgICAORD2AiAEKQNIIQIgBCkDQCEBIANB9IB+SwRAIANBjf8AaiEDDAELIARBMGogASACQgBCgICAgICAgDkQ9gJB6IF9IAMgA0HogX1NG0Ga/gFqIQMgBCkDOCECIAQpAzAhAQsgBCABIAJCACADQf//AGqtQjCGEPYCIAAgBCkDCDcDCCAAIAQpAwA3AwAgBEHQAGokAAt1AQF+IAAgASAEfiACIAN+fCADQiCIIgIgAUIgiCIEfnwgA0L/////D4MiAyABQv////8PgyIBfiIFQiCIIAMgBH58IgNCIIh8IAEgAn4gA0L/////D4N8IgFCIIh8NwMIIAAgBUL/////D4MgAUIghoQ3AwALwg8CBX8PfiMAQdACayIFJAAgBEL///////8/gyEKIAJC////////P4MhCyACIASFQoCAgICAgICAgH+DIQwgBEIwiKdB//8BcSEIAkACQCACQjCIp0H//wFxIglB//8Ba0GCgH5PBEAgCEH//wFrQYGAfksNAQsgAVAgAkL///////////8AgyINQoCAgICAgMD//wBUIA1CgICAgICAwP//AFEbRQRAIAJCgICAgICAIIQhDAwCCyADUCAEQv///////////wCDIgJCgICAgICAwP//AFQgAkKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEMIAMhAQwCCyABIA1CgICAgICAwP//AIWEUARAIAMgAkKAgICAgIDA//8AhYRQBEBCACEBQoCAgICAgOD//wAhDAwDCyAMQoCAgICAgMD//wCEIQxCACEBDAILIAMgAkKAgICAgIDA//8AhYRQBEBCACEBDAILIAEgDYRQBEBCgICAgICA4P//ACAMIAIgA4RQGyEMQgAhAQwCCyACIAOEUARAIAxCgICAgICAwP//AIQhDEIAIQEMAgsgDUL///////8/WARAIAVBwAJqIAEgCyABIAsgC1AiBht5QsAAQgAgBht8pyIGQQ9rEI8CQRAgBmshBiAFKQPIAiELIAUpA8ACIQELIAJC////////P1YNACAFQbACaiADIAogAyAKIApQIgcbeULAAEIAIAcbfKciB0EPaxCPAiAGIAdqQRBrIQYgBSkDuAIhCiAFKQOwAiEDCyAFQaACaiAKQoCAgICAgMAAhCISQg+GIANCMYiEIgJCAEKAgICAsOa8gvUAIAJ9IgRCABCAAyAFQZACakIAIAUpA6gCfUIAIARCABCAAyAFQYACaiAFKQOYAkIBhiAFKQOQAkI/iIQiBEIAIAJCABCAAyAFQfABaiAEQgBCACAFKQOIAn1CABCAAyAFQeABaiAFKQP4AUIBhiAFKQPwAUI/iIQiBEIAIAJCABCAAyAFQdABaiAEQgBCACAFKQPoAX1CABCAAyAFQcABaiAFKQPYAUIBhiAFKQPQAUI/iIQiBEIAIAJCABCAAyAFQbABaiAEQgBCACAFKQPIAX1CABCAAyAFQaABaiACQgAgBSkDuAFCAYYgBSkDsAFCP4iEQgF9IgJCABCAAyAFQZABaiADQg+GQgAgAkIAEIADIAVB8ABqIAJCAEIAIAUpA6gBIAUpA6ABIg0gBSkDmAF8IgQgDVStfCAEQgFWrXx9QgAQgAMgBUGAAWpCASAEfUIAIAJCABCAAyAGIAkgCGtqIQYCfyAFKQNwIhNCAYYiDiAFKQOIASIPQgGGIAUpA4ABQj+IhHwiEELn7AB9IhRCIIgiAiALQoCAgICAgMAAhCIVQgGGIhZCIIgiBH4iESABQgGGIg1CIIgiCiAQIBRWrSAOIBBWrSAFKQN4QgGGIBNCP4iEIA9CP4h8fHxCAX0iE0IgiCIQfnwiDiARVK0gDiAOIBNC/////w+DIhMgAUI/iCIXIAtCAYaEQv////8PgyILfnwiDlatfCAEIBB+fCAEIBN+IhEgCyAQfnwiDyARVK1CIIYgD0IgiIR8IA4gDiAPQiCGfCIOVq18IA4gDiAUQv////8PgyIUIAt+IhEgAiAKfnwiDyARVK0gDyAPIBMgDUL+////D4MiEX58Ig9WrXx8Ig5WrXwgDiAEIBR+IhggECARfnwiBCACIAt+fCILIAogE358IhBCIIggCyAQVq0gBCAYVK0gBCALVq18fEIghoR8IgQgDlStfCAEIA8gAiARfiICIAogFH58IgpCIIggAiAKVq1CIIaEfCICIA9UrSACIBBCIIZ8IAJUrXx8IgIgBFStfCIEQv////////8AWARAIBYgF4QhFSAFQdAAaiACIAQgAyASEIADIAFCMYYgBSkDWH0gBSkDUCIBQgBSrX0hCkIAIAF9IQsgBkH+/wBqDAELIAVB4ABqIARCP4YgAkIBiIQiAiAEQgGIIgQgAyASEIADIAFCMIYgBSkDaH0gBSkDYCINQgBSrX0hCkIAIA19IQsgASENIAZB//8AagsiBkH//wFOBEAgDEKAgICAgIDA//8AhCEMQgAhAQwBCwJ+IAZBAEoEQCAKQgGGIAtCP4iEIQEgBEL///////8/gyAGrUIwhoQhCiALQgGGDAELIAZBj39MBEBCACEBDAILIAVBQGsgAiAEQQEgBmsQkAIgBUEwaiANIBUgBkHwAGoQjwIgBUEgaiADIBIgBSkDQCICIAUpA0giChCAAyAFKQM4IAUpAyhCAYYgBSkDICIBQj+IhH0gBSkDMCIEIAFCAYYiDVStfSEBIAQgDX0LIQQgBUEQaiADIBJCA0IAEIADIAUgAyASQgVCABCAAyAKIAIgAiADIAQgAkIBgyIEfCIDVCABIAMgBFStfCIBIBJWIAEgElEbrXwiAlatfCIEIAIgAiAEQoCAgICAgMD//wBUIAMgBSkDEFYgASAFKQMYIgRWIAEgBFEbca18IgJWrXwiBCACIARCgICAgICAwP//AFQgAyAFKQMAViABIAUpAwgiA1YgASADURtxrXwiASACVK18IAyEIQwLIAAgATcDACAAIAw3AwggBUHQAmokAAvKBgIEfwN+IwBBgAFrIgUkAAJAAkACQCADIARCAEIAEPkCRQ0AAn8gBEL///////8/gyEKAn8gBEIwiKdB//8BcSIHQf//AUcEQEEEIAcNARpBAkEDIAMgCoRQGwwCCyADIAqEUAsLRQ0AIAJCMIinIghB//8BcSIGQf//AUcNAQsgBUEQaiABIAIgAyAEEPYCIAUgBSkDECICIAUpAxgiASACIAEQgQMgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRD5AkEATARAIAEgCiADIAkQ+QIEQCABIQQMAgsgBUHwAGogASACQgBCABD2AiAFKQN4IQIgBSkDcCEEDAELIARCMIinQf//AXEhByAGBH4gAQUgBUHgAGogASAKQgBCgICAgICAwLvAABD2AiAFKQNoIgpCMIinQfgAayEGIAUpA2ALIQQgB0UEQCAFQdAAaiADIAlCAEKAgICAgIDAu8AAEPYCIAUpA1giCUIwiKdB+ABrIQcgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSgRAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABD2AiAFKQMoIQIgBSkDICEEDAULIAlCAYYgBEI/iIQMAQsgCkIBhiAEQj+IhAshCiAEQgGGIQQgBkEBayIGIAdKDQALIAchBgsCQCAKIAt9IAMgBFatfSIJQgBTBEAgCiEJDAELIAkgBCADfSIEhEIAUg0AIAVBMGogASAC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QAJAIAItAAAiBkErayIIDgMBAAEACyAGQS5GDQJBASEDIAZBMGtB/wFxQQpJDQMMAQsgB0EBRg0CAkAgCA4DAAMAAwsgAi0AASIGQS5GDQFBASEDIAZBMGtB/wFxQQlNDQILAkACfyAALQDLAUEHdgRAIAAoAsQBDAELIAAtAMsBQf8AcQtFDQAgAC0AB0EBcUUNACAAKAIMIgMgAEEQamtBnwFKDQAgACADQQRqNgIMIAMgACgCCDYCAAsgBSACIAAoArABIAQQugM5AwAgAEHAAWogAEEQaiAAKAIMIAQQrAMgAEH8AWogAEH4AWoQswIEQCAEIAQoAgBBAnI2AgALIAAoAvwBIAEQ0AUaIABBwAFqENAFGiAAQYACaiQADAQLQQEhAwsgAEH8AWoQtAIaDAALABkgACQAIAEQ0AUaIABBwAFqENAFGgkACwALC8UBAgR/AXwjAEEQayIDJAACQAJAAkAgACABRwRAQeiJAygCACEFQeiJA0EANgIAIANBDGohBhC+AxojAEEQayIEJAAgBCAAIAZBARCZAyAEKQMAIAQpAwgQkQIhByAEQRBqJAACQEHoiQMoAgAiAARAIAMoAgwgAUYNAQwDC0HoiQMgBTYCACADKAIMIAFHDQIMBAsgAEHEAEcNAwwCCyACQQQ2AgAMAgtEAAAAAAAAAAAhBwsgAkEENgIACyADQRBqJAAgBwuCBwIDfwF+An8jAEGQAmsiACQAIAAgAjYCiAIgACABNgKMAiAAQdABaiADIABB4AFqIABB3wFqIABB3gFqELYDBkAjAEEQayICJAAgAEHEAWoiAUIANwIAIAFBADYCCCACQRBqJAAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEMkCIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgLAASAAIABBIGo2AhwgAEEANgIYIABBAToAFyAAQcUAOgAWQQAhAwNAAkACQAJAIABBjAJqIABBiAJqELMCDQAgACgCwAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshBiABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EMkCIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxDJAiAAIAYCfyABLQALQQd2BEAgASgCAAwBCyABCyICajYCwAELAn8gACgCjAIiBigCDCIHIAYoAhBGBEAgBiAGKAIAKAIkEQEADAELIActAAALwCAAQRdqIABBFmogAiAAQcABaiAALADfASAALADeASAAQdABaiAAQSBqIABBHGogAEEYaiAAQeABahC3Aw0AIAMNAUEAIQMgACgCwAEgAmsiB0EATA0CAkACQCACLQAAIgZBK2siCA4DAQABAAsgBkEuRg0CQQEhAyAGQTBrQf8BcUEKSQ0DDAELIAdBAUYNAgJAIAgOAwADAAMLIAItAAEiBkEuRg0BQQEhAyAGQTBrQf8BcUEJTQ0CCwJAAn8gAC0A2wFBB3YEQCAAKALUAQwBCyAALQDbAUH/AHELRQ0AIAAtABdBAXFFDQAgACgCHCIDIABBIGprQZ8BSg0AIAAgA0EEajYCHCADIAAoAhg2AgALIAAgAiAAKALAASAEELwDIAApAwghCSAFIAApAwA3AwAgBSAJNwMIIABB0AFqIABBIGogACgCHCAEEKwDIABBjAJqIABBiAJqELMCBEAgBCAEKAIAQQJyNgIACyAAKAKMAiABENAFGiAAQdABahDQBRogAEGQAmokAAwEC0EBIQMLIABBjAJqELQCGgwACwAZIAAkACABENAFGiAAQdABahDQBRoJAAsACwu2AgIEfgZ/IwBBIGsiCCQAAkACQAJAIAEgAkcEQEHoiQMoAgAhDEHoiQNBADYCACAIQRxqIQ0jAEEQayIJJAAQvgMaIwBBEGsiCiQAIwBBEGsiCyQAIAsgASANQQIQmQMgCykDACEEIAogCykDCDcDCCAKIAQ3AwAgC0EQaiQAIAopAwAhBCAJIAopAwg3AwggCSAENwMAIApBEGokACAJKQMAIQQgCCAJKQMINwMQIAggBDcDCCAJQRBqJAAgCCkDECEEIAgpAwghBUHoiQMoAgAiAUUNASAIKAIcIAJHDQIgBSEGIAQhByABQcQARw0DDAILIANBBDYCAAwCC0HoiQMgDDYCACAIKAIcIAJGDQELIANBBDYCACAGIQUgByEECyAAIAU3AwAgACAENwMIIAhBIGokAAvrBQEDfyMAQYACayIAJAAgACACNgL4ASAAIAE2AvwBIwBBEGsiASQAIABBxAFqIgZCADcC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ASAEELoDOQMAIABBzAFqIABBEGogACgCDCAEEKwDIABB3AJqIABB2AJqEMICBEAgBCAEKAIAQQJyNgIACyAAKALcAiABENAFGiAAQcwBahDQBRogAEHgAmokAAwEC0EBIQMLIABB3AJqEMMCGgwACwAZIAAkACABENAFGiAAQcwBahDQBRoJAAsACwuBBwIDfwF+An8jAEHwAmsiACQAIAAgAjYC6AIgACABNgLsAiAAQdwBaiADIABB8AFqIABB7AFqIABB6AFqEM0DBkAjAEEQayICJAAgAEHQAWoiAUIANwIAIAFBADYCCCACQRBqJAAgASABLQALQQd2BH8gASgCCEH/////B3FBAWsFQQoLEMkCIAACfyABLQALQQd2BEAgASgCAAwBCyABCyICNgLMASAAIABBIGo2AhwgAEEANgIYIABBAToAFyAAQcUAOgAWQQAhAwNAAkACQAJAIABB7AJqIABB6AJqEMICDQAgACgCzAECfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQsgAmpGBEACfyABLQALQQd2BEAgASgCBAwBCyABLQALQf8AcQshBiABAn8gAS0AC0EHdgRAIAEoAgQMAQsgAS0AC0H/AHELQQF0EMkCIAEgAS0AC0EHdgR/IAEoAghB/////wdxQQFrBUEKCxDJAiAAIAYCfyABLQALQQd2BEAgASgCAAwBCyABCyICajYCzAELAn8gACgC7AIiBigCDCIHIAYoAhBGBEAgBiAGKAIAKAIkEQEADAELIAcoAgALIABBF2ogAEEWaiACIABBzAFqIAAoAuwBIAAoAugBIABB3AFqIABBIGogAEEcaiAAQRhqIABB8AFqEM4DDQAgAw0BQQAhAyAAKALMASACayIHQQBMDQICQAJAIAItAAAiBkErayIIDgMBAAEACyAGQS5GDQJBASEDIAZBMGtB/wFxQQpJDQMMAQsgB0EBRg0CAkAgCA4DAAMAAwsgAi0AASIGQS5GDQFBASEDIAZBMGtB/wFxQQlNDQILAkACfyAALQDnAUEHdgRAIAAoAuABDAELIAAtAOcBQf8AcQtFDQAgAC0AF0EBcUUNACAAKAIcIgMgAEEgamtBnwFKDQAgACADQQRqNgIcIAMgACgCGDYCAAsgACACIAAoAswBIAQQvAMgACkDCCEJIAUgACkDADcD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AhCmAyAKKAIARQRAELMFDAMLIAooAgAhCwsgAEHMAWoiCCADKAIcIgc2AgAgB0GIkQNHBEAgByAHKAIEQQFqNgIECwZAIAhBwJIDEKUDIhAiByAAKALMAiIIIAggCWogCyAHKAIAKAIgEQYAGgZAIAIgCUEATAR/QQAFIAAoAswCLQAAQS1GCyIRIABBzAFqIABByAFqIABBxwFqIABBxgFqIwBBEGsiAiQAIABBuAFqIgxCADcCACAMQQA2AgggAkEQaiQAIAwjAEEQayICJAAgAEGsAWoiB0IANwIAIAdBADYCCCACQRBqJAAgByMAQRBrIgIkACAAQaABaiIIQgA3AgAgCEEANgIIIAJBEGokACAIIABBnAFqEKsEIABB7QE2AjAgAEEoakEAIABBMGoiAhDOAiENBkACQAJ/IAAoApwBIg4gCUgEQAJ/IActAAtBB3YEQCAHKAIEDAELIActAAtB/wBxCwJ/IAgtAAtBB3YEQCAIKAIEDAELIAgtAAtB/wBxCyAJIA5rQQF0amogDmpBAWoMAQsgACgCnAECfyAILQALQQd2BEAgCCgCBAwBCyAILQALQf8AcQsCfyAHLQALQQd2BEAgBygCBAwBCyAHLQALQf8AcQtqakECagsiDkHlAEkNACANIA4QhgIQpgMgDSgCACICDQAQswUMBQsgAiAAQSRqIABBIGogAygCBCALIAkgC2ogECARIABByAFqIAAsAMcBIAAsAMYBIAwgByAIIAAoApwBEKwEIAEgAiAAKAIkIAAoAiAgAyAEENsDIQEZIAAkACANQQAQpgMJAAsZIAAkACAIENAFGiAHENAFGiAMENAFGgkACxkgACQAIABBzAFqEKMDCQALGSAAJAAgCkEAEKYDIA9BABCmAwkACyANQQAQpgMgCBDQBRogBxDQBRogDBDQBRogAEHMAWoQowMgCkEAEKYDIA9BABCmAyAAQcADaiQAIAEPCwALlgIBAX8jAEEQayIKJAACfyAABEAgAkG4kAMQpQMMAQsgAkGwkAMQpQMLIQACQCABBEAgCkEEaiIBIAAgACgCACgCLBEAACADIAooAgQ2AAAgASAAIAAoAgAoAiARAAAMAQsgCkEEaiIBIAAgACgCACgCKBEAACADIAooAgQ2AAAgASAAIAAoAgAoAhwRAAALIAggARDHAiABENAFGiAE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QQQQ4QIZIAEkABD1BQALCxkBAX8gARCgBSECIAAgATYCBCAAIAI2AgALHAAgAEH/////A0sEQBCzAQALIABBAnRBBBDjAgsgACAAAn8gAC0AC0EHdgRAIAAoAgAMAQsgAAsgARCiBQtKAQF/IwBBEGsiAyQAAn8gAC0AC0EHdgRAIAAoAgQMAQsgAC0ACwsaIAAgAhCeBCADQQA6AA8gASACaiADLQAPOgAAIANBEGokAAs2AQF/IwBBEGsiAyQAIAMgATYCDCADIAI2AgggACADKAIMNgIAIAAgAygCCDYCBCADQRBqJAALTwEBfyMAQRBrIgMkACADIAE2AgggAyAANgIMIAMgAjYCBEEAIQEgA0EEaiIAKAIAIAMoAgxPBEAgACgCACADKAIISSEBCyADQRBqJAAgAQs+AQJ/IwBBEGsiASQAIAEgADYCDCABKAIMIQIjAEEQayIAJAAgACACNgIMIAAoAgwgAEEQaiQAIAFBEGokAAs8AQF/IwBBEGsiAyQAIAMgARClBTYCDCADIAIQpQU2AgggACADKAIMNgIAIAAgAygCCDYCBCADQRBqJAALVgECfyMAQRBrIgQkACAEIAI2AgwCQCACIAFrIgJFIgUNACAFDQAgAyABIAL8CgAACyAEIAIgA2o2AgggACAEKAIMNgIAIAAgBCgCCDYCBCAEQRBqJAALWwEEfyMAQRBrIgAkACAAQf////8DNgIMIABB/////wc2AggjAEEQayIBJAAgAEEIaiICKAIAIABBDGoiAygCAEkhBCABQRBqJAAgAiADIAQbKAIAIABBEGokAAtJAQF/IwBBEGsiAyQAAkACQCACQR5LDQAgAS0AeEEBcQ0AIAFBAToAeAwBCyACEKAFIQELIANBEGokACAAIAI2AgQgACABNgIACycBAX8gACgCBCECA0AgASACRkUEQCACQQRrIQIMAQsLIAAgATYCBAstAQF/IwBBEGsiAiQAAkAgACABRgRAIABBADoAeAwBCyABEJ4FCyACQRBqJAALSwECfyAAKAIEIQEDQCABIAAoAggiAkZFBEAgACgCEBogACACQQRrNgIIDAELCyAAKAIAIgEEQCAAQQxqKAIAGiAAKAIQIAEQqwULCyMBAn8gACEBA0AgASICQQRqIQEgAigCAA0ACyACIABrQQJ1CwoAIAAQvgM2AgAL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fyMAIQIgAEGYoQI2AgAgAEGcogI2AgAGQCAAQQRqIAEQyQUZIAIkAAkACyAACzcBAn8jACECBkAGQEEIEOkFIQEYASABIAAQzAUhABkgAiQAIAEQ6gUJAAsgAEHkowJBAhDtBQALHQAgAEEAIABBmQFNG0EBdEHwkwJqLwEAQe+EAmoLuQMBBX8jAEEQayIIJAAgAUF/c0H3////B2ogAk8EQAJ/IAAtAAtBB3YEQCAAKAIADAELIAALIQogCEEEaiIJIAFB8////wNJBH8gCCABQQF0NgIMIAggASACajYCBCMAQRBrIgIkACAJKAIAIAhBDGoiCygCAEkhDCACQRBqJAAgCyAJIAwbKAIAIgJBC08EfyACQQhqQXhxIgIgAkEBayICIAJBC0YbBUEKC0EBagVB9////wcLEOICIAgoAgQhAiAIKAIIGiAEBEACQCAERSIJDQAgCQ0AIAIgCiAE/AoAAAsLIAYEQCACIARqIQkCQCAGRSILDQAgCw0AIAkgByAG/AoAAAsLIAMgBCAFaiIJayEHIAMgCUcEQCACIARqIAZqIQMgBCAKaiAFaiEFAkAgB0UiCQ0AIAkNACADIAUgB/wKAAALCyABQQpHBEAgChDgAgsgACACNgIAIAAgACgCCEGAgICAeHEgCCgCCEH/////B3FyNgIIIAAgACgCCEGAgICAeHI2AgggACAEIAZqIAdqIgA2AgQgCEEAOgAMIAAgAmogCC0ADDoAACAIQRBqJAAPCxAyAAsdACAALQALQQd2BEAgACgCCBogACgCABDgAgsgAAtEAQF/IwBBEGsiAyQAIAMgAjoADyADQQ9qIQIDQCABBEAgACACLQAAOgAAIAFBAWshASAAQQFqIQAMAQsLIANBEGokAAucAQECfyAALQALQQd2BH8gACgCCEH/////B3FBAWsFQQoLIQMCfyAALQALQQd2BEAgACgCBAwBCyAALQALQf8AcQshBCACIANNBEACfyAALQALQQd2BEAgACgCAAwBCyAACyEDAkAgAkUiBA0AIAQNACADIAEgAvwKAAALIAAgAyACEKIFDwsgACADIAIgA2sgBEEAIAQgAiABEM8FC9QBAQV/IwBBEGsiBSQAAkAgAiAALQALQQd2BH8gACgCCEH/////B3FBAWsFQQoLIgMCfyAALQALQQd2BEAgACgCBAwB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ACAINwIIIAEpAgghCCAAIAc2AhwgACAINwIUIAAgASkCADcCICABQTBqJAAgACEBCyAGEIgHIAQoAgAgBCgCBDYCAAsgAkGgAWokACABC+QDAQR/IwBBMGsiAiQAAkACQCAAEOUGIgMEQCADLQACIgVBCEYEQCACIABBhANqNgIoIAIgAC0AhAM6ACwgAEEAOgCEAyAALQCFAyABQQBHckEBcSEDIAIgAEGFA2o2AiAgAiAALQCFAzoAJCAAIAM6AIUDBkAgABCjBiEDDAMZIAIkACACKAIgIAItACQ6AAAgAigCKCACLQAsOgAACQALAAsgBUEKSw0CIAVBBEYEQCADLQADQQFxRQ0DCyACQShqIgEgAxDvBiAAIAEQtAYhBAwCCyACIAJBFGpB7h0QxQQpAgA3AwgCQCAAIAJBCGoQngYEQCACIAAQyQYiATYCKCABRQ0BIABBmANqQQwQygYgAigCKCEBQRRBAEEBQQFBARDMBiIAIAE2AgggAEH81QI2AgAgACEEDAMLIABB9gAQoAZFDQIgACgCACIBIAAoAgRHBH8gASwAAAVBAAvAQTBrQf8BcUEJSw0CIAAgACgCAEEBajYCACACIAAQyQYiATYCKCABRQ0AIAAgAkEoahC2ByEEDAILDAELIAIgAzYCHCADBEAgAQRAIAFBAToAAAsgACACQRxqELYHIQQLIAIoAiAgAi0AJDoAACACKAIoIAItACw6AAALIAJBMGokACAEC5YBAQN/IwBBEGsiAyQAIAAtABBFBEAgA0EIaiICIABBEGo2AgAgAiAALQAQOgAEIABBAToAEAZAAn8gACgCDCIALwAFIgTAQUBOBEAgBEH/AXFBwABJDAELIAAgASAAKAIAKAIAEQIACyEEGSADJAAgAigCACACLQAEOgAACQALIAIoAgAgAi0ABDoAAAsgA0EQaiQAIAQLkQEBA38jAEEQayIDJAAgAC0AEEUEQCADQQhqIgIgAEEQajYCACACIAAtABA6AAQgAEEBOgAQBkACfyAAKAIMIgAtAAZBA3EiBEECRwRAIARFDAELIAAgASAAKAIAKAIEEQIACyEEGSADJAAgAigCACACLQAEOgAACQALIAIoAgAgAi0ABDoAAAsgA0EQaiQAIAQLlAEBA38jAEEQayIDJAAgAC0AEEUEQCADQQhqIgIgAEEQajYCACACIAAtABA6AAQgAEEBOgAQBkACfyAAKAIMIgAvAAVBCnZBA3EiBEECRwRAIARFDAELIAAgASAAKAIAKAIIEQIACyEEGSADJAAgAigCACACLQAEOgAACQALIAIoAgAgAi0ABDoAAAsgA0EQaiQAIAQLeQECfyMAQRBrIgMkACAALQAQRQRAIANBCGoiAiAAQRBqNgIAIAIgAC0AEDoABCAAQQE6ABAGQCAAKAIMIgAgASAAKAIAKAIMEQIAIQAZIAMkACACKAIAIAItAAQ6AAAJAAsgAigCACACLQAEOgAACyADQRBqJAAgAAt1AQJ/IwBBEGsiAyQAIAAtABBFBEAgA0EIaiICIABBEGo2AgAgAiAALQAQOgAEIABBAToAEAZAIAAoAgwiACABIAAoAgAoAhARAAAZIAMkACACKAIAIAItAAQ6AAAJAAsgAigCACACLQAEOgAACyADQRBqJAALdQECfyMAQRBrIgMkACAALQAQRQRAIANBCGoiAiAAQRBqNgIAIAIgAC0AEDoABCAAQQE6ABAGQCAAKAIMIgAgASAAKAIAKAIUEQAAGSADJAAgAigCACACLQAEOgAACQALIAIoAgAgAi0ABDoAAAsgA0EQaiQAC7cBAQZ/AkAgACgCBCAAKAIAIgJrQQJJDQBBPSEBA0AgASADRwRAIAEgASADakEBdiIFAn9BASAFQQN0QfCqAmoiASwAACIEIAIsAAAiBkgNABpBACAEIAZHDQAaIAEsAAEgAiwAAUgLIgQbIQEgBUEBaiADIAQbIQMMAQsLIANBA3RB8KoCaiIBLQAAIAItAABGBH8gAS0AASACLQABRgVBAAtBAXMNACAAIAJBAmo2AgAgAQ8LQQALlAICA38BfiMAQdAAayICJAAgACABKAIEEMUEIQACQAJAIAEtAAJBCksNACACIAApAgA3A0ggAkFAa0GFFRDFBCEBIAIgAikDSDcDMCACIAEpAgA3AyggAkEwaiACQShqEKkGRQ0BIAAgACgCAEEIajYCACAAIAAoAgRBCGs2AgQgAiAAKQIAIgU3AwggAiAFNwM4IwBBEGsiASQAIAJBCGoiBCgCBARAIAEgBBCoBjYCDCABKAIMLQAAQSBGIQMLIAFBEGokACADRQ0AIAAgACgCAEEBajYCACAAIAAoAgRBAWs2AgQLIAJB0ABqJAAPCyACQYw9NgIYIAJByRY2AhQgAkHDHzYCEEGWFCACQRBqEPIFAAubAQICfwF+IwBBEGsiAyQAIAMgAjYCDCADIAAQtQYiAjYCCCACBH8jAEEQayICJAAgAEGYA2pBFBDKBiACIAEpAgAiBTcDCCADKAIMIQEgAygCCCEEIAIgBTcDAEHCACABQQFBAUEBEMwGIgBB0K8CNgIAIAIpAgAhBSAAIAQ2AhAgACAFNwIIIAJBEGokACAABUEACyADQRBqJAALawIBfwF+IwBBEGsiBCQAIABBmANqQRQQygYgASgCACEBIAQgAikCACIFNwMIIAMoAgAhAiAEIAU3AwBBPyACQQFBAUEBEMwGIgAgATYCCCAAQcS0AjYCACAAIAQpAgA3AgwgBEEQaiQAIAAL8wEBA38jAEFAaiIBJAAgASABQThqQd0qEMUEKQIANwMYAkAgACABQRhqEJ4GBEAgAEH/EhCyBiEDDAELIAEgAUEwakH+GRDFBCkCADcDECAAIAFBEGoQngYEQCAAENYGGiABQShqIgIgAEEAEKEGIABB3wAQoAZFDQEgACACEO4GIQMMAQsgASABQSBqQeIrEMUEKQIANwMIIAAgAUEIahCeBkUNACABQShqIgIgAEEAEKEGIAIoAgRFDQAgAEHwABCgBkUNACAAENYGGiACIABBABChBiAAQd8AEKAGRQ0AIAAgAhDuBiEDCyABQUBrJAAgAwusAwEEfyMAQRBrIgIkAAJ/AkACQCAAKAIAIgEgACgCBEcEfyABLAAABUEAC0H/AXFB5ABHDQAgACgCBCAAKAIAIgFrQQFLBH8gASwAAQVBAAvAIgFB2ABHBEAgAUH/AXEiAUH4AEcEQCABQekARw0CIAAgACgCAEECajYCACACIAAQyQYiATYCDCABRQ0DIAIgABDqBiIBNgIIIAFFDQMgAkEAOgAEIAAgAkEMaiACQQhqIAJBBGoQ8AYMBAsgACAAKAIAQQJqNgIAIAIgABC1BiIBNgIMIAFFDQIgAiAAEOoGIgE2AgggAUUNAiACQQE6AAQgACACQQxqIAJBCGogAkEEahDwBgwDCyAAIAAoAgBBAmo2AgAgAiAAELUGIgE2AgwgAUUNASACIAAQtQYiATYCCCABRQ0BIAIgABDqBiIBNgIEIAFFDQEgAEGYA2pBFBDKBiACKAIMIQEgAigCCCEDIAIoAgQhBEHSAEEAQQFBAUEBEMwGIgAgBDYCECAAIAM2AgwgACABNgIIIABBgMoCNgIAIAAMAgsgABC1BgwBC0EACyACQRBqJAALRwECfyMAQRBrIgIkACAAQZgDakEcEMoGIAJBCGpB6MgAEMUEIQMgASgCACEBIAIgAykCADcDACACIAFBABCFByACQRBqJAALrAECA38CfiMAQRBrIgMkACADQQhqIgQgAEEBEKEGAkAgBCgCBEUNACAAQcUAEKAGRQ0AIwBBIGsiAiQAIABBmANqQRgQygYgAiABKQIAIgU3AxggAiAEKQIAIgY3AxAgAiAFNwMIIAIgBjcDAEHNAEEAQQFBAUEBEMwGIgBB0LgCNgIAIAAgAikCCDcCCCAAIAIpAgA3AhAgAkEgaiQAIAAhAgsgA0EQaiQAIAILNwAgAEGYA2pBCBDKBiABKAIAQQBHIQFByQBBAEEBQQFBARDMBiIAIAE6AAcgAEG8uQI2AgAgAAtXAgF/AX4jAEEQayICJAAgAEGYA2pBEBDKBiACIAEpAgAiAzcDACACIAM3AwhBwwBBAEEBQQFBARDMBiIAQdTGAjYCACAAIAIpAgA3AgggAkEQaiQAIAALDQAgACABKAIEEMUEGgtQACAAQZgDakEUEMoGIAEoAgAhASACKAIAIQIgAy0AACEDQdEAQQBBAUEBQQEQzAYiACADOgAQIAAgAjYCDCAAIAE2AgggAEGYyQI2AgAgAAuTAQECfyMAQRBrIgIkAAJAAkAgACgCACIBIAAoAgRHBH8gASwAAAVBAAvAIgFBxABHBEAgAUH/AXFB1ABHDQEgAiAAELgGIgE2AgwgAUUNAiAAQZQBaiACQQxqEK4GDAILIAIgABC2BiIBNgIIIAFFDQEgAEGUAWogAkEIahCuBgwBCyAAENcGIQELIAJBEGokACABC3oBA38jAEEQayICJAAgAiAAEMkGIgE2AgwCQCABRQRAQQAhAQwBCyAAKAIAIgMgACgCBEcEfyADLAAABUEAC0H/AXFByQBHDQAgAiAAQQAQuQYiATYCCCABBH8gACACQQxqIAJBCGoQugYFQQALIQELIAJBEGokACABC0EAIABBmANqQRAQygYgASgCACEBIAIoAgAhAkEXQQBBAUEBQQEQzAYiACACNgIMIAAgATYCCCAAQbjTAjYCACAAC+cCAQN/IwBBMGsiAiQAAkAgACgCACIDIAAoAgRHBH8gAywAAAVBAAvAQTBrQQlNBEAgABDyBiEBDAELIAIgAkEoakHKGxDFBCkCADcDECAAIAJBEGoQngYEQCMAQRBrIgMkACADAn8gACgCACIBIAAoAgRHBH8gASwAAAVBAAvAQTBrQQlNBEAgABDyBgwBCyAAEPEGCyIBNgIMIAEEfyAAQZgDakEMEMoGIAMoAgwhAUEyQQBBAUEBQQEQzAYiACABNgIIIABBpNQCNgIAIAAFQQALIQEgA0EQaiQADAELIAIgAkEgakG9GxDFBCkCADcDCCAAIAJBCGoQngYaIAIgAEEAEN4GIgM2AhwgA0UNACADIQEgACgCACIDIAAoAgRHBH8gAywAAAVBAAtB/wFxQckARw0AIAIgAEEAELkGIgE2AhggAQR/IAAgAkEcaiACQRhqELoGBUEACyEBCyACQTBqJAAgAQszACAAQZgDakEMEMoGIAEoAgAhAUEuQQBBAUEBQQEQzAYiACABNgIIIABB6NYCNgIAIAALhwMCBH8BfiMAQZABayICJAACQCABKAIUDQAgAiAAKQIMNwOIASACQYABakGKMxDFBCEDIAIgAikDiAE3A0AgAiADKQIANwM4IAJBQGsgAkE4ahDGBEUEQCACIAApAgw3A3ggAkHwAGpB8jIQxQQhAyACIAIpA3g3AzAgAiADKQIANwMoIAJBMGogAkEoahDGBEUNAQsgAUEoEPcGQQEhBAsgACgCCCABQQ8gAC8ABUEadEEadSIDIANBEUYiBRsgA0ERRxD4BiACIAApAgw3A2ggAkHgAGpBmzsQxQQhAyACIAIpA2g3AyAgAiADKQIANwMYIAJBIGogAkEYahDGBEUEQCACIAJB2ABqQYbJABDFBCkCADcDECABIAJBEGoQzgYaCyACIAApAgwiBjcDCCACIAY3A1AgASACQQhqEM4GIAIgAkHIAGpBhskAEMUEKQIANwMAIAIQzgYhASAAKAIUIAEgAC8ABUEadEEadSAFEPgGIAQEQCABQSkQ+QYLIAJBkAFqJAALFwAgACAAKAIUQQFqNgIUIAAgARCdBhoLgQEAIAIgA2ogAC8ABUEadEEadU0EQCABQSgQ9wYgACABIAAoAgAoAhARAAAgAC8ABUHAAXFBwABHBEAgACABIAAoAgAoAhQRAAALIAFBKRD5Bg8LIAAgASAAKAIAKAIQEQAAIAAvAAVBwAFxQcAARwRAIAAgASAAKAIAKAIUEQAACwsXACAAIAAoAhRBAWs2AhQgACABEJ0GGgtJAgF/AX4jAEEQayICJAAgAiAAKQIIIgM3AwAgAiADNwMIIAEgAhDOBiEBIAAoAhAgASAALwAFQRp0QRp1QQAQ+AYgAkEQaiQAC0gCAX8BfiMAQRBrIgIkACAAKAIIIAEgAC8ABUEadEEadUEBEPgGIAIgACkCDCIDNwMAIAIgAzcDCCABIAIQzgYaIAJBEGokAAs3ACAAKAIIIAEgAC8ABUEadEEadUEAEPgGIAFB2wAQ9wYgACgCDCABQRNBABD4BiABQd0AEPkGC2ACAX8BfiMAQRBrIgIkACAAKAIIIAEgAC8ABUEadEEadUEBEPgGIAIgACkCDCIDNwMAIAIgAzcDCCABIAIQzgYhASAAKAIUIAEgAC8ABUEadEEadUEAEPgGIAJBEGokAAuZAgECfyMAQUBqIgIkACAALQAcQQFGBEAgAiACQThqQfE0EMUEKQIANwMYIAEgAkEYahDOBhoLIAIgAkEwakHxChDFBCkCADcDECABIAJBEGoQzgYhASAALQAdQQFGBEAgAiACQShqQdkpEMUEKQIANwMIIAEgAkEIahDOBhoLIABBCGoiAygCBARAIAFBKBD3BiADIAEQ/wYgAUEpEPkGCyACIAJBIGpBhskAEMUEKQIANwMAIAEgAhDOBiEBIAAoAhAiAyABIAMoAgAoAhARAAAgAy8ABUHAAXFBwABHBEAgAyABIAMoAgAoAhQRAAALIABBFGoiACgCBARAIAFBKBD3BiAAIAEQ/wYgAUEpEPkGCyACQUBrJAALjgEBBn8jAEEQayICJABBASEDA0AgACgCBCAERwRAIAEoAgQhBSADQQFxRQRAIAIgAkEIakH5yAAQxQQpAgA3AwAgASACEM4GGgsgASgCBCAAKAIAIARBAnRqKAIAIAFBEkEAEPgGIARBAWohBCABKAIERgR/IAEgBTYCBCADBUEACyEDDAELCyACQRBqJAALvgEBAX8jAEEwayICJAAgAC0ADEEBRgRAIAIgAkEoakHxNBDFBCkCADcDECABIAJBEGoQzgYaCyACIAJBIGpB+yEQxQQpAgA3AwggASACQQhqEM4GIQEgAC0ADUEBRgRAIAIgAkEYakHZKRDFBCkCADcDACABIAIQzgYaCyABQSAQnQYhASAAKAIIIgAgASAAKAIAKAIQEQAAIAAvAAVBwAFxQcAARwRAIAAgASAAKAIAKAIUEQAACyACQTBqJAALTwEBfyAAKAIIIgIgASACKAIAKAIQEQAAIAIvAAVBwAFxQcAARwRAIAIgASACKAIAKAIUEQAACyABQSgQ9wYgAEEMaiABEP8GIAFBKRD5BgtdAQF/IAFBKBD3BiAAKAIIIgIgASACKAIAKAIQEQAAIAIvAAVBwAFxQcAARwRAIAIgASACKAIAKAIUEQAACyABQSkQ+QYgAUEoEPcGIABBDGogARD/BiABQSkQ+QYLhAEBAX8jAEEgayICJAAgACgCCCABIAAvAAVBGnRBGnVBABD4BiACIAJBGGpBycQAEMUEKQIANwMIIAEgAkEIahDOBiEBIAAoAgwgAUETQQAQ+AYgAiACQRBqQeTIABDFBCkCADcDACABIAIQzgYhASAAKAIQIAFBEUEBEPgGIAJBIGokAAvrAQIDfwF+IwBBQGoiAiQAIAIgACkCCCIFNwMYIAIgBTcDOCACQTBqIgMgASACQRhqEM4GIgQiAUEUajYCACADIAEoAhQ2AgQgAUEANgIUIAMhASACIAJBKGpB2TQQxQQpAgA3AxAgBCACQRBqEM4GIQMGQCAAKAIQIgQgAyAEKAIAKAIQEQAAGSACJAAgASgCACABKAIENgIACQALIAIgAkEgakGKMxDFBCkCADcDCCADIAJBCGoQzgYhAyABKAIAIAEoAgQ2AgAgA0EoEPcGIAAoAhQgA0ETQQAQ+AYgA0EpEPkGIAJBQGskAAs9AQF+IABBPCADQQFBAUEBEMwGIgBB5LcCNgIAIAEpAgAhBCAAIAI2AhAgACAENwIIIABBFGpCADcCACAAC48BAgJ/AX4jAEEgayICJAAgAiAAKQIIIgQ3AwggAiAENwMYIAEgAkEIahDOBiIBQSgQ9wYgACgCECIDIAEgAygCACgCEBEAACADLwAFQcABcUHAAEcEQCADIAEgAygCACgCFBEAAAsgAUEpEPkGIAIgACkCFCIENwMAIAIgBDcDECABIAIQzgYaIAJBIGokAAtUAQJ/IwBBEGsiAiQAIAAgATYCACAAIAEoAtACIAEoAswCa0ECdTYCBCAAQQhqEKYGIQEgACgCACACIAE2AgxBzAJqIAJBDGoQrgYgAkEQaiQAIAALcwEDfyMAQRBrIgEkAAZAIAAoAgQiAyAAKAIAQcwCaiICKAIEIAIoAgBrQQJ1SwRAIAFB1dAANgIIIAFBzxQ2AgQgAUHDHzYCAEGWFCABEPIFAAsgAiADEMQGGSABJAAQ9QUACyAAQQhqEKUGIAFBEGokAAvpAQIFfwF+IwBBQGoiAiQAIABBCGoiAygCBEEETwRAIAFBKBD3BiACIAMpAgAiBzcDGCACIAc3AzggASACQRhqEM4GQSkQ+QYLAkAgAEEQaiIAKAIALQAAQe4ARgRAIAFBLRCdBiAAKAIAQQFqIQYgAkEwaiIEIAAoAgRBAWs2AgQgBCAGNgIAIAIgBCkCADcDCCACQQhqEIoHGgwBCyACIAApAgAiBzcDECACIAc3AyggASACQRBqEM4GGgsgAygCBEEDTQRAIAIgAykCACIHNwMAIAIgBzcDICABIAIQzgYaCyACQUBrJAALMAIBfwF+IwBBEGsiAiQAIAIgASkCACIDNwMAIAIgAzcDCCAAIAIQzgYgAkEQaiQACzgBAX8jAEEQayICJAAgAiACQQhqQekhQY8iIAAtAAcbEMUEKQIANwMAIAEgAhDOBhogAkEQaiQACy4BAn8jAEEQayIBJAAgAUEMaiICIAAoAgAgACgCBGo2AgAgAigCACABQRBqJAAL7gEBBX8jAEFAaiICJAAgAEEIaiIAKAIEQQhPBEAgAkE8aiEDIAAoAgAhBUEAIQADQCAAQQhHBEAgA0FQQal/IAAgBWoiBCwAASIGQTBrQQpJGyAGakEJQQAgBCwAACIEQTBrQQpPGyAEakEEdGo6AAAgA0EBaiEDIABBAmohAAwBCwsgAkE8aiADEPMDIAJCADcDMCACQgA3AyggAkIANwMgIAIgAioCPLs5AxAgAkEYaiIAIAJBIGoiA0EYQdQhIAJBEGoQjwM2AgQgACADNgIAIAIgACkCADcDCCABIAJBCGoQzgYaCyACQUBrJAAL+AEBBX8jAEHQAGsiAiQAIABBCGoiACgCBEEQTwRAIAJByABqIQMgACgCACEFQQAhAANAIABBEEcEQCADQVBBqX8gACAFaiIELAABIgZBMGtBCkkbIAZqQQlBACAELAAAIgRBMGtBCk8bIARqQQR0ajoAACADQQFqIQMgAEECaiEADAELCyACQcgAaiADEPMDIAJCADcDOCACQgA3AzAgAkIANwMoIAJCADcDICACIAIrA0g5AxAgAkEYaiIAIAJBIGoiA0EgQZwpIAJBEGoQjwM2AgQgACADNgIAIAIgACkCADcDCCABIAJBCGoQzgYaCyACQdAAaiQAC+8BAQV/IwBB8ABrIgIkACAAQQhqIgAoAgRBIE8EQCACQeAAaiEDIAAoAgAhBUEAIQADQCAAQSBHBEAgA0FQQal/IAAgBWoiBCwAASIGQTBrQQpJGyAGakEJQQAgBCwAACIEQTBrQQpPGyAEakEEdGo6AAAgA0EBaiEDIABBAmohAAwBCwsgAkHgAGogAxDzAyACQTBqIgBBAEEq/AsAIAIgAikDYDcDECACIAIpA2g3AxggAkEoaiIDIABBKkHlKyACQRBqEI8DNgIEIAMgADYCACACIAMpAgA3AwggASACQQhqEM4GGgsgAkHwAGokAAuBAQEBfyMAQSBrIgIkACACIAJBGGpB2DQQxQQpAgA3AwggASACQQhqEM4GIQEgACgCCCIAIAEgACgCACgCEBEAACAALwAFQcABcUHAAEcEQCAAIAEgACgCACgCFBEAAAsgAiACQRBqQe89EMUEKQIANwMAIAEgAhDOBhogAkEgaiQAC50BAQN/IwBBEGsiAiQAIAIgATYCDCAAKAIAIgMgAUECdGoiASABKAKMAyIBQQFqNgKMAyACIAE2AgggA0GYA2pBEBDKBiACKAIMIQMgAigCCCEEQSFBAEEBQQFBARDMBiIBIAQ2AgwgASADNgIIIAFByL4CNgIAIAIgATYCBCAAKAIEKAIAIgAEQCAAIAJBBGoQrgYLIAJBEGokACABC2cCAX8BfiMAQTBrIgIkACACIAJBKGpB8CUQxQQpAgA3AxAgASACQRBqEM4GIAIgACkCCCIDNwMIIAIgAzcDICACQQhqEM4GIAIgAkEYakHHPRDFBCkCADcDACACEM4GGiACQTBqJAAL5QECA38CfiMAQSBrIgIkAAJAIAICfwJAAkACQCAAKAIIDgMAAQIECyACQRhqQeUqEMUEDAILIAJBEGpB0ysQxQQMAQsgAkEIakHhKhDFBAspAgA3AwAgASACEM4GGgsgACgCDCIABEAgAEEBa60hBSMAQTBrIgAkACAAQTBqIQMDQCADQQFrIgMgBSAFQgqAIgZCCn59p0EwcjoAACAFQglWIAYhBQ0ACyAAQRBqIgQgAEEwaiADazYCBCAEIAM2AgAgACAEKQIANwMIIAEgAEEIahDOBhogAEEwaiQACyACQSBqJAALLgAjAEEQayIAJAAgACAAQQhqQeHDABDFBCkCADcDACABIAAQzgYaIABBEGokAAs1ACAAKAIIIgAgASAAKAIAKAIQEQAAIAAvAAVBwAFxQcAARwRAIAAgASAAKAIAKAIUEQAACwtjAQF/IwBBEGsiAiQAIAAoAggiACABIAAoAgAoAhARAAAgAC8ABUHAAXFBwABHBEAgACABIAAoAgAoAhQRAAALIAIgAkEIakGGyQAQxQQpAgA3AwAgASACEM4GGiACQRBqJAALNQAgACgCDCIAIAEgACgCACgCEBEAACAALwAFQcABcUHAAEcEQCAAIAEgACgCACgCFBEAAAsLeQECfyMAQRBrIgIkACAAKAIMIgMgASADKAIAKAIQEQAAAn8gACgCDCIALwAFIgPAQUBOBEAgA0H/AXFBwABJDAELIAAgASAAKAIAKAIAEQIAC0UEQCACIAJBCGpBhskAEMUEKQIANwMAIAEgAhDOBhoLIAJBEGokAAtLAQF/IAAoAggiAiABIAIoAgAoAhARAAAgAi8ABUHAAXFBwABHBEAgAiABIAIoAgAoAhQRAAALIAAoAgwiACABIAAoAgAoAhQRAAALngEBAn8jAEEwayICJAAgAkEoaiIDIAFBFGo2AgAgAyABKAIUNgIEIAFBADYCFCACIAJBIGpBvDQQxQQpAgA3AxAGQCAAQQxqIAEgAkEQahDOBiIAEP8GGSACJAAgAygCACADKAIENgIACQALIAIgAkEYakHfwwAQxQQpAgA3AwggACACQQhqEM4GGiADKAIAIAMoAgQ2AgAgAkEwaiQAC58BAQJ/IwBBEGsiAiQAIAAoAggiAyABIAMoAgAoAhARAAAgAy8ABUHAAXFBwABHBEAgAyABIAMoAgAoAhQRAAALIAAoAhQEQCACIAJBCGpBjMEAEMUEKQIANwMAIAEgAhDOBiEBIAAoAhQiACABIAAoAgAoAhARAAAgAC8ABUHAAXFBwABHBEAgACABIAAoAgAoAhQRAAALCyACQRBqJAALQwEBfyMAQRBrIgIkACAAKAIIIgAgASAAKAIAKAIQEQAAIAIgAkEIakGuOhDFBCkCADcDACABIAIQzgYaIAJBEGokAAsWACAAKAIIIgAgASAAKAIAKAIUEQAAC28CAX8BfiMAQTBrIgIkACACIAJBKGpBlCkQxQQpAgA3AxAgASACQRBqEM4GIAIgACkCICIDNwMIIAIgAzcDICACQQhqEM4GIQEgAiACQRhqQcc9EMUEKQIANwMAIAAgASACEM4GEJ8HIAJBMGokAAuZAwEDfyMAQeAAayICJAAgAEEIaiIEKAIEBEAgAkHYAGoiAyABQRRqNgIAIAMgASgCFDYCBCABQQA2AhQgAiACQdAAakHZNBDFBCkCADcDKAZAIAQgASACQShqEM4GIgQQ/wYZIAIkACADKAIAIAMoAgQ2AgAJAAsgAiACQcgAakGKMxDFBCkCADcDICAEIAJBIGoQzgYaIAMoAgAgAygCBDYCAAsgACgCEARAIAIgAkFAa0GMwQAQxQQpAgA3AxggASACQRhqEM4GIQQgACgCECIDIAQgAygCACgCEBEAACADLwAFQcABcUHAAEcEQCADIAQgAygCACgCFBEAAAsgAiACQThqQYbJABDFBCkCADcDECAEIAJBEGoQzgYaCyABQSgQ9wYgAEEUaiABEP8GIAFBKRD5BiAAKAIcBEAgAiACQTBqQYzBABDFBCkCADcDCCABIAJBCGoQzgYhASAAKAIcIgAgASAAKAIAKAIQEQAAIAAvAAVBwAFxQcAARwRAIAAgASAAKAIAKAIUEQAACwsgAkHgAGokAAtlAQF/IwBBIGsiAiQAIAIgAkEYakHZKRDFBCkCADcDCCABIAJBCGoQzgYhASAAKAIIIgAtAARBNEYEQCAAIAEQnwcLIAIgAkEQakGKCBDFBCkCADcDACABIAIQzgYaIAJBIGokAAvIAQIDfwF+IwBBIGsiAiQAIAFBKBD3BiAAKAIIIgMgASADKAIAKAIQEQAAIAMvAAVBwAFxQcAARwRAIAMgASADKAIAKAIUEQAACyABQSkQ+QYCQCAAQQxqIgAoAgAtAABB7gBGBEAgAUEtEJ0GIAAoAgBBAWohBCACQRhqIgEgACgCBEEBazYCBCABIAQ2AgAgAiABKQIANwMAIAIQigcaDAELIAIgACkCACIFNwMIIAIgBTcDECABIAJBCGoQigcaCyACQSBqJAALTAIBfwF+IwBBIGsiAiQAIAIgAkEYakH+GRDFBCkCADcDCCABIAJBCGoQzgYgAiAAKQIIIgM3AwAgAiADNwMQIAIQzgYaIAJBIGokAAvxAgIDfwF+IwBBgAFrIgIkACACIAA2AnwgAiABNgJ4IAFBKBD3BiAAKAIMIgNFIAAtABgiBEEBRnFFBEACQCAEBEAgAyABQQNBARD4BgwBCyACQfgAahCkBwsgAiACQfAAakGGyQAQxQQpAgA3AzggASACQThqEIoHIAIgACkCECIFNwMwIAIgBTcDaCACQTBqEIoHIAIgAkHgAGpBhskAEMUEKQIANwMoIAJBKGoQigcaCyACIAJB2ABqQa46EMUEKQIANwMgIAEgAkEgahCKByEBAkAgAC0AGEUEQCAAKAIMRQ0BCyACIAJB0ABqQYbJABDFBCkCADcDGCABIAJBGGoQigcgAiAAKQIQIgU3AxAgAiAFNwNIIAJBEGoQigcgAiACQUBrQYbJABDFBCkCADcDCCACQQhqEIoHIQMgAC0AGEEBRgRAIAJB+ABqEKQHDAELIAAoAgwgA0EDQQEQ+AYLIAFBKRD5BiACQYABaiQAC28BA38jAEEQayICJAAgACgCBCEBIAAoAgBBKBD3BiACQQRqIAEoAggQpQciASAAKAIAIgMgASgCACgCEBEAACABLwAFQcABcUHAAEcEQCABIAMgASgCACgCFBEAAAsgACgCAEEpEPkGIAJBEGokAAsjACAAQSpBAEEBQQFBARDMBiIAIAE2AgggAEGkyAI2AgAgAAv/AgEHfyMAQTBrIgIkACACQShqIgUgAUEMajYCACAFIAEoAgw2AgQgAUF/NgIMIAJBIGoiBiABQRBqNgIAIAYgASgCEDYCBCABQX82AhAgASgCBCEEBkAgACgCCCIDIAEgAygCACgCEBEAACADLwAFQcABcUHAAEcEQCADIAEgAygCACgCFBEAAAtBASEDAkACQAJAAkAgASgCECIIQQFqDgICAAELIAEgBDYCBAwCCwNAIAMgCE8NAiACIAJBEGpB+cgAEMUEKQIANwMAIAEgAhDOBiEHIAEgAzYCDCAAKAIIIgQgByAEKAIAKAIQEQAAIAQvAAVBwAFxQcAARwRAIAQgByAEKAIAKAIUEQAACyADQQFqIQMMAAsACyACIAJBGGpBrjoQxQQpAgA3AwggASACQQhqEM4GGgsgBigCACAGKAIENgIAIAUoAgAgBSgCBDYCACACQTBqJAAPGSACJAAgBigCACAGKAIENgIAIAUoAgAgBSgCBDYCAAkACwALjwIBA38jAEEQayIEJAACQCAALQAQQQFGBEAgAUHbABCdBiECIAAoAggiAyACIAMoAgAoAhARAAAgAy8ABUHAAXFBwABHBEAgAyACIAMoAgAoAhQRAAALIAJB3QAQnQYaDAELIAFBLhCdBiECIAAoAggiAyACIAMoAgAoAhARAAAgAy8ABUHAAXFBwABHBEAgAyACIAMoAgAoAhQRAAALCyAAKAIMIgItAARB0QBrQf8BcUECTwRAIAQgBEEIakHSxAAQxQQpAgA3AwAgASAEEM4GGiAAKAIMIQILIAIgASACKAIAKAIQEQAAIAIvAAVBwAFxQcAARwRAIAIgASACKAIAKAIUEQAACyAEQRBqJAALlwIBAn8jAEEgayIDJAAgAUHbABCdBiEBIAAoAggiAiABIAIoAgAoAhARAAAgAi8ABUHAAXFBwABHBEAgAiABIAIoAgAoAhQRAAALIAMgA0EYakHzyAAQxQQpAgA3AwggASADQQhqEM4GIQEgACgCDCICIAEgAigCACgCEBEAACACLwAFQcABcUHAAEcEQCACIAEgAigCACgCFBEAAAsgAUHdABCdBiECIAAoAhAiAS0ABEHRAGtB/wFxQQJPBEAgAyADQRBqQdLEABDFBCkCADcDACACIAMQzgYaIAAoAhAhAQsgASACIAEoAgAoAhARAAAgAS8ABUHAAXFBwABHBEAgASACIAEoAgAoAhQRAAALIANBIGokAAsuACAAQcYAQQBBAUEBQQEQzAYiACABNgIIIABB7MoCNgIAIAAgAikCADcCDCAAC1cBAX8gACgCCCICBEAgAiABIAIoAgAoAhARAAAgAi8ABUHAAXFBwABHBEAgAiABIAIoAgAoAhQRAAALCyAAQQxqIAFB+wAQnQYiABD/BiAAQf0AEJ0GGguGAQEBfyABQSgQ9wYgACgCCCICIAEgAigCACgCEBEAACACLwAFQcABcUHAAEcEQCACIAEgAigCACgCFBEAAAsgAUEpEPkGIAFBKBD3BiAAKAIMIgAgASAAKAIAKAIQEQAAIAAvAAVBwAFxQcAARwRAIAAgASAAKAIAKAIUEQAACyABQSkQ+QYLqAIB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AiACQQhqQfE0EMUEKQIANwMAIAEgAhDOBiEBIAAoAggiACABIAAoAgAoAhARAAAgAC8ABUHAAXFBwABHBEAgACABIAAoAgAoAhQRAAALIAJBEGokAAsWACAAIAEoAggiACAAKAIAKAIYEQAACyMAIAAgAkEAQQFBAUEBEMwGIgAgATYCCCAAQZTZAjYCACAAC0sBAX8jAEEgayICJAAgAiACQRhqQe40EMUEKQIANwMIIAEgAkEIahCKByACQRBqIAAQvgcgAiACKQIQNwMAIAIQigcaIAJBIGokAAuhAQEBfyMAQTBrIgIkACAAIAEQvwcCQCABKAIIQQFLBEAgAiAAKQIANwMoIAJBIGpBnykQxQQhASACIAIpAyg3AxggAiABKQIANwMQIAJBGGogAkEQahCpBkUNASAAIAAoAgBBBmo2AgAgACAAKAIEQQZrNgIECyACQTBqJAAPCyACQdXQADYCCCACQakNNgIEIAJBwx82AgBBlhQgAhDyBQALGAAgACABKAIIQQJ0QdT1AmooAgAQxQQaC8gBAQF/IwBB0ABrIgIkACACIAJByABqQe40EMUEKQIANwMgIAEgAkEgahCKByACQUBrIAAgACgCACgCGBEAACACIAIpAkA3AxggAkEYahCKByEBIAAoAghBAUsEQCACIAJBOGpBhDEQxQQpAgA3AxAgASACQRBqEIoHIQEgACgCCEECRgRAIAIgAkEwakGiMRDFBCkCADcDCCABIAJBCGoQigcaCyACIAJBKGpBijMQxQQpAgA3AwAgASACEIoHGgsgAkHQAGokAAt7AgJ/AX4jAEEwayICJAAgACgCCCIDIAEgAygCACgCEBEAACACIAJBKGpB2zQQxQQpAgA3AxAgASACQRBqEM4GIAIgACkCDCIENwMIIAIgBDcDICACQQhqEM4GIAIgAkEYakGZKhDFBCkCADcDACACEM4GGiACQTBqJAALTwAgAEGYA2pBFBDKBiABKAIAIQEgAi0AACECIAMoAgAhA0ExQQBBAUEBQQEQzAYiACADNgIQIAAgAjoADCAAIAE2AgggAEGc2wI2AgAgAAscACABQdsAEPcGIABBCGogARD/BiABQd0AEPkGC2YBAX8jAEEgayICJAAgAC0ADEEBRgRAIAIgAkEYakGICBDFBCkCADcDCCABIAJBCGoQzgYaCyAC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X2xvY2s6OmxvY2s6IHJlZmVyZW5jZXMgbnVsbCBtdXRleAAgY29tcGxleAAvaG5zd2xpYi1pbmRleABpbml0SW5kZXgAcmVzaXplSW5kZXgAd3JpdGVJbmRleAByZWFkSW5kZXgAd2J4AHcrYngARHgALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB3K3gAdHcAdGhyb3cAX19uZXh0X3ByaW1lIG92ZXJmbG93AG9wZXJhdG9yIG5ldwBEdwBOb3YARHYAVGh1AFR1AEF1Z3VzdAAgY29uc3QATm90IGVub3VnaCBtZW1vcnk6IGxvYWRJbmRleCBmYWlsZWQgdG8gYWxsb2NhdGUgbGlua2xpc3QATm90IGVub3VnaCBtZW1vcnk6IGFkZFBvaW50IGZhaWxlZCB0byBhbGxvY2F0ZSBsaW5rbGlzdABUaGUgbmV3bHkgaW5zZXJ0ZWQgZWxlbWVudCBzaG91bGQgaGF2ZSBibGFuayBsaW5rIGxpc3QAY29uc3RfY2FzdAByZWludGVycHJldF9jYXN0AHN0ZDo6YmFkX2Nhc3QAc3RhdGljX2Nhc3QAZHluYW1pY19jYXN0AHVuc2lnbmVkIHNob3J0ACBub2V4Y2VwdABrIDw9IGN1cl9lbGVtZW50X2NvdW50AGludGVybmFsSWQgPCBjdXJfZWxlbWVudF9jb3VudABnZXRDdXJyZW50Q291bnQAZ2V0UG9pbnQAbm9ybWFsaXplUG9pbnQAcmVtb3ZlUG9pbnQAYWRkUG9pbnQAdW5zaWduZWQgaW50AF9CaXRJbnQAVGhlIG51bWJlciBvZiBlbGVtZW50cyBleGNlZWRzIHRoZSBzcGVjaWZpZWQgbGltaXQAb3BlcmF0b3IgY29fYXdhaXQAdW5jYXVnaHQAc2V0AHJldABnZXQAc3RydWN0ACByZXN0cmljdABvYmpjX29iamVjdABPY3QAcG9zaXhfc3RhdABmbG9hdABWZWN0b3JWZWN0b3JGbG9hdABfRmxvYXQAU2F0AHN0ZDo6bnVsbHB0cl90AHdjaGFyX3QAY2hhcjhfdABjaGFyMTZfdABjaGFyMzJfdABVdABUdABTdABjaGVja0ZpbGVFeGlzdHMATm90IGVub3VnaCBtZW1vcnk6IGxvYWRJbmRleCBmYWlsZWQgdG8gYWxsb2NhdGUgbGlua2xpc3RzAE5vdCBlbm91Z2ggbWVtb3J5OiBIaWVyYXJjaGljYWxOU1cgZmFpbGVkIHRvIGFsbG9jYXRlIGxpbmtsaXN0cwBhZGRQb2ludHMAQ2Fubm90IHJlc2l6ZSwgbWF4IGVsZW1lbnQgaXMgbGVzcyB0aGFuIHRoZSBjdXJyZW50IG51bWJlciBvZiBlbGVtZW50cwBnZXRNYXhFbGVtZW50cwBuZWlnaGJvcnMATm90IGVub3VnaCBtZW1vcnk6IHJlc2l6ZUluZGV4IGZhaWxlZCB0byBhbGxvY2F0ZSBvdGhlciBsYXllcnMAZ2V0TnVtRGltZW5zaW9ucwBtYXJrRGVsZXRlSXRlbXMAYWRkSXRlbXMAZ2V0RGVsZXRlZExhYmVscwBnZXRVc2VkTGFiZWxzAHRoaXMAc2V0RGVidWdMb2dzAHJlcXVpcmVzAGRpc3RhbmNlcwBUcwB0ZXJtaW5hdGluZyBkdWUgdG8gJXMgZXhjZXB0aW9uIG9mIHR5cGUgJXMAdGVybWluYXRpbmcgZHVlIHRvICVzIGV4Y2VwdGlvbiBvZiB0eXBlICVzOiAlcwBmaWxlc3lzdGVtIGVycm9yOiAlcwAlczolZDogJXMAbnVsbHB0cgBzcgBBcHIAUmVwbGFjZW1lbnQgb2YgZGVsZXRlZCBlbGVtZW50cyBpcyBkaXNhYmxlZCBpbiBjb25zdHJ1Y3RvcgBDdXN0b21GaWx0ZXJGdW5jdG9yAHZlY3RvcgBvcGVyYXRvcgBhbGxvY2F0b3IAdW5zcGVjaWZpZWQgaW9zdHJlYW1fY2F0ZWdvcnkgZXJyb3IAbW9uZXlfZ2V0IGVycm9yAExldmVsIGVycm9yAGNhbmQgZXJyb3IATm90IGVub3VnaCBtZW1vcnk6IHJlc2l6ZUluZGV4IGZhaWxlZCB0byBhbGxvY2F0ZSBiYXNlIGxheWVyAHJlYWRFbmNvZGVkUG9pbnRlcgBCYWQgdmFsdWUgb2Ygc3pfbGlua19saXN0X290aGVyAEVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcgBPY3RvYmVyAE5vdmVtYmVyAFNlcHRlbWJlcgBEZWNlbWJlcgB1bnNpZ25lZCBjaGFyAGlvc19iYXNlOjpjbGVhcgBNYXIAcnEAc3AAL2Vtc2RrL2Vtc2NyaXB0ZW4vc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL2N4YV9wZXJzb25hbGl0eS5jcHAAL2Vtc2RrL2Vtc2NyaXB0ZW4vc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL2N4YV9leGNlcHRpb25fanNfdXRpbHMuY3BwAC9lbXNkay9lbXNjcmlwdGVuL3N5c3RlbS9saWIvbGliY3h4YWJpL3NyYy9wcml2YXRlX3R5cGVpbmZvLmNwcAAvZW1zZGsvZW1zY3JpcHRlbi9zeXN0ZW0vbGliL2xpYmN4eGFiaS9zcmMvY3hhX2RlbWFuZ2xlLmNwcAAvZW1zZGsvZW1zY3JpcHRlbi9zeXN0ZW0vbGliL2xpYmN4eGFiaS9zcmMvZmFsbGJhY2tfbWFsbG9jLmNwcABvcABmcABTZXAAVHAAJUk6JU06JVMgJXAAIGF1dG8Ab2JqY3Byb3RvAHNvAERvAFN1bgBKdW4AUG9zc2libGUgbWVtb3J5IGNvcnJ1cHRpb24Ac3RkOjpleGNlcHRpb24AdGVybWluYXRpbmcgZHVlIHRvICVzIGZvcmVpZ24gZXhjZXB0aW9uAHRlcm1pbmF0ZV9oYW5kbGVyIHVuZXhwZWN0ZWRseSB0aHJldyBhbiBleGNlcHRpb24AdW5pb24ATW9uAHNlYXJjaEtubgBkbgBuYW4ASmFuAFRuAERuAGVudW0Ac3lzdGVtAGluaXRpYWxpemVGaWxlU3lzdGVtAGJhc2ljX2lvc3RyZWFtAGJhc2ljX29zdHJlYW0AYmFzaWNfaXN0cmVhbQBKdWwAdGwAYm9vbAB1bGwAY2FsbABBcHJpbABMZXZlbCBvZiBpdGVtIHRvIGJlIHVwZGF0ZWQgY2Fubm90IGJlIGJpZ2dlciB0aGFuIG1heCBsZXZlbABUcnlpbmcgdG8gbWFrZSBhIGxpbmsgb24gYSBub24tZXhpc3RlbnQgbGV2ZWwAc3RyaW5nIGxpdGVyYWwAdW5tYXJrRGVsZXRlZEludGVybmFsAFVsAHlwdG5rAHB1c2hfYmFjawBUawBGcmkAcGkAbGkAYmFkX2FycmF5X25ld19sZW5ndGgAZmFpbGVkIHRvIGRldGVybWluZSBhdHRyaWJ1dGVzIGZvciB0aGUgc3BlY2lmaWVkIHBhdGgAc2V0RWZTZWFyY2gAZ2V0RWZTZWFyY2gAQnJ1dGVmb3JjZVNlYXJjaABNYXJjaAAvZW1zZGsvZW1zY3JpcHRlbi9zeXN0ZW0vbGliL2xpYmN4eGFiaS9zcmMvZGVtYW5nbGUvVXRpbGl0eS5oAC4vLi9zcmMvaG5zd2xpYi9obnN3YWxnLmgAL2Vtc2RrL2Vtc2NyaXB0ZW4vc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL2RlbWFuZ2xlL0l0YW5pdW1EZW1hbmdsZS5oAC4vLi9zcmMvaG5zd2xpYi9icnV0ZWZvcmNlLmgAQXVnAHVuc2lnbmVkIGxvbmcgbG9uZwB1bnNpZ25lZCBsb25nAHRlcm1pbmF0aW5nAHN0ZDo6d3N0cmluZwBiYXNpY19zdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAX191dWlkb2YAaW5mAFRyeWluZyB0byBjb25uZWN0IGFuIGVsZW1lbnQgdG8gaXRzZWxmAGhhbGYAJWFmACUuMExmACVMZgByZXNpemUAdHJ1ZQBUdWUAb3BlcmF0b3IgZGVsZXRlAHVubWFya0RlbGV0ZQBmYWxzZQBkZWNsdHlwZQBKdW5lAGNvc2luZQAgdm9sYXRpbGUAQ2Fubm90IG9wZW4gZmlsZQBsb25nIGRvdWJsZQBfYmxvY2tfaW52b2tlAF9fZ2V0X2V4Y2VwdGlvbl9tZXNzYWdlAGRpc3RhbmNlAElubmVyUHJvZHVjdFNwYWNlAEwyU3BhY2UAVGUAc3RkAExhYmVsIG5vdCBmb3VuZAAlMCpsbGQAJSpsbGQAKyVsbGQAJSsuNGxkAHZvaWQAQXV0b1NhdmUgbm90IGVuYWJsZWQgb3Igbm90IGluaXRpYWxpemVkAGlzSW5kZXhJbml0aWFsaXplZABpc0luaXRpYWxpemVkAEluZGV4IHNlZW1zIHRvIGJlIGNvcnJ1cHRlZCBvciB1bnN1cHBvcnRlZABsb2NhbGUgbm90IHN1cHBvcnRlZABUaGUgcmVxdWVzdGVkIHRvIGRlbGV0ZSBlbGVtZW50IGlzIGFscmVhZHkgZGVsZXRlZABUaGUgcmVxdWVzdGVkIHRvIHVuZGVsZXRlIGVsZW1lbnQgaXMgbm90IGRlbGV0ZWQAdW5leHBlY3RlZAB0ZXJtaW5hdGVfaGFuZGxlciB1bmV4cGVjdGVkbHkgcmV0dXJuZWQAJ3VubmFtZWQAbXV0ZXggbG9jayBmYWlsZWQAVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGhhcyBiZWVuIHJlYWNoZWQAZS4gSURCRlMgaGFzIHN5bmNlZABjLiBJREJGUyBoYXMgc3luY2VkAGlzU3luY2VkAHNldElkYmZzU3luY2VkAFdlZAAlWS0lbS0lZABVbmtub3duIGVycm9yICVkAHN0ZDo6YmFkX2FsbG9jAG1jAFNob3VsZCBiZSBub3QgYmUgbW9yZSB0aGFuIE1fIGNhbmRpZGF0ZXMgcmV0dXJuZWQgYnkgdGhlIGhldXJpc3RpYwBnZW5lcmljAERlYwB3YgByYgBGZWIAc2Nhbl9laF90YWIAVWIAdytiAHIrYgBhK2IAcndhAE5vdCBlbm91Z2ggbWVtb3J5OiBsb2FkSW5kZXggZmFpbGVkIHRvIGFsbG9jYXRlIGRhdGEATm90IGVub3VnaCBtZW1vcnk6IEJydXRlZm9yY2VTZWFyY2ggZmFpbGVkIHRvIGFsbG9jYXRlIGRhdGEAJ2xhbWJkYQAlYQBiYXNpY18Ab3BlcmF0b3JeAG9wZXJhdG9yIG5ld1tdAG9wZXJhdG9yW10Ab3BlcmF0b3IgZGVsZXRlW10AZmlsZXN5c3RlbSBlcnJvcjogJXMgWyIlcyJdAGZpbGVzeXN0ZW0gZXJyb3I6ICVzIFsiJXMiXSBbIiVzIl0AcGl4ZWwgdmVjdG9yWwBzWgBfX19fWgAlYSAlYiAlZCAlSDolTTolUyAlWQBQT1NJWABIaWVyYXJjaGljYWxOU1cAZnBUACRUVAAkVABFbXNjcmlwdGVuRmlsZVN5c3RlbU1hbmFnZXIgbXVzdCBiZSBpbml0aWFsaXplZCBiZWZvcmUgY2FsbGluZyBzeW5jRlMAJUg6JU06JVMAclEAc1AARE8Ac3JOAF9HTE9CQUxfX04ATkFOACROAFBNAEFNACVIOiVNAGZMACVMYUwATENfQUxMAFVhOWVuYWJsZV9pZkkAQVNDSUkATEFORwBJTkYAYWN0aW9ucyAmIF9VQV9DTEVBTlVQX1BIQVNFAGFjdGlvbnMgJiBfVUFfU0VBUkNIX1BIQVNFAFJFAE9FAGIxRQBiMEUAcmVzdWx0cy5yZWFzb24gPT0gX1VSQ19IQU5ETEVSX0ZPVU5EAERDAGNhdGNoaW5nIGEgY2xhc3Mgd2l0aG91dCBhbiBvYmplY3Q/AG9wZXJhdG9yPwBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBvcGVyYXRvcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4APGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4ALCBzdGQ6OmFsbG9jYXRvcjxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBvcGVyYXRvcj4+AG9wZXJhdG9yPD0+AG9wZXJhdG9yLT4Ab3BlcmF0b3J8PQBvcGVyYXRvcj0Ab3BlcmF0b3JePQBvcGVyYXRvcj49AG9wZXJhdG9yPj49AG9wZXJhdG9yPT0Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8PQBvcGVyYXRvci89AG9wZXJhdG9yLT0Ab3BlcmF0b3IrPQBvcGVyYXRvcio9AG9wZXJhdG9yJj0Ab3BlcmF0b3IlPQBvcGVyYXRvciE9AG9wZXJhdG9yPAB0ZW1wbGF0ZTwAaWQ8AG9wZXJhdG9yPDwALjwAIjwAW2FiaToAIFtlbmFibGVfaWY6AHN0ZDo6ADAxMjM0NTY3ODkAdW5zaWduZWQgX19pbnQxMjgAX19mbG9hdDEyOABkZWNpbWFsMTI4AEMuVVRGLTgAZGVjaW1hbDY0AFZlY3RvclVpbnQzMgBkZWNpbWFsMzIAX19neHhfcGVyc29uYWxpdHlfd2FzbTAATm90IGVub3VnaCBtZW1vcnk6IGxvYWRJbmRleCBmYWlsZWQgdG8gYWxsb2NhdGUgbGV2ZWwwAG9wZXJhdG9yLwBGYWlsZWQgdG8gcmVhZCB0aGUgaW5kZXguAEludmFsaWQgY2FsbGJhY2sgZnVuY3Rpb24gZm9yIEN1c3RvbUZpbHRlckZ1bmN0b3IuAG9wZXJhdG9yLgBJbnZhbGlkIHRoZSBmaXJzdCBhcmd1bWVudCB0eXBlLCBtdXN0IGJlIGEgbnVtYmVyLgBUaGUgbnVtYmVyIG9mIHZlY3RvcnMgYW5kIGlkcyBtdXN0IGJlIHRoZSBzYW1lLgBDcmVhdGluZyBhbiBFeHBsaWNpdE9iamVjdFBhcmFtZXRlciB3aXRob3V0IGEgdmFsaWQgQmFzZSBOb2RlLgBTZWFyY2ggaW5kZXggaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkLCBjYWxsIGBpbml0SW5kZXhgIGluIGFkdmFuY2UuAENhbid0IHVzZSBhZGRQb2ludCB0byB1cGRhdGUgZGVsZXRlZCBlbGVtZW50cyBpZiByZXBsYWNlbWVudCBvZiBkZWxldGVkIGVsZW1lbnRzIGlzIGVuYWJsZWQuAFRoZSBudW1iZXIgb2YgdmVjdG9ycyBhbmQgaWRzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDAuAGQuIENhbGxpbmcgc3luYyBjYWxsYmFjay4uLgBzaXplb2YuLi4AYS4gc3RhcnQgc3luY0ZTLi4uAEludmFsaWQgdGhlIG51bWJlciBvZiBrLW5lYXJlc3QgbmVpZ2hib3JzIChtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyKS4Ab3BlcmF0b3ItAC1pbi0Ab3BlcmF0b3ItLQBvcGVyYXRvciwAdysAb3BlcmF0b3IrAGErAG9wZXJhdG9yKysAb3BlcmF0b3IqAG9wZXJhdG9yLT4qADo6KgBvcGVyYXRvci4qACBkZWNsdHlwZShhdXRvKQAobnVsbCkAKGFub255bW91cyBuYW1lc3BhY2UpAGFjdGlvbnMgJiAoX1VBX1NFQVJDSF9QSEFTRSB8IF9VQV9GT1JDRV9VTldJTkQpAGFjdGlvbnMgJiAoX1VBX1NFQVJDSF9QSEFTRSB8IF9VQV9IQU5ETEVSX0ZSQU1FIHwgX1VBX0ZPUkNFX1VOV0lORCkAb3BlcmF0b3IoKQAgKABvcGVyYXRvciBuYW1lIGRvZXMgbm90IHN0YXJ0IHdpdGggJ29wZXJhdG9yJwAnYmxvY2stbGl0ZXJhbCcAb3BlcmF0b3ImAG9wZXJhdG9yJiYAICYmACAmAG9wZXJhdG9yJQA+IgAoYmFzZSAhPSAwKSAmJiAiRFdfRUhfUEVfZGF0YXJlbCBpcyBpbnZhbGlkIHdpdGggYSBiYXNlIG9mIDAiAEludmFsaWQgYWNjZXNzIQBQb3BwaW5nIGVtcHR5IHZlY3RvciEAb3BlcmF0b3IhAHNocmlua1RvU2l6ZSgpIGNhbid0IGV4cGFuZCEAUHVyZSB2aXJ0dWFsIGZ1bmN0aW9uIGNhbGxlZCEASW52YWxpZCB2ZWN0b3Igc2l6ZSBhdCBpbmRleCAAdGhyb3cgAG5vZXhjZXB0IAAsIGJ1dCBnb3QgACBhdCBvZmZzZXQgAENvdWxkIG5vdCBhZGRQb2ludHMgAENvdWxkIG5vdCBtYXJrRGVsZXRlSXRlbXMgAENvdWxkIG5vdCBhZGRJdGVtcyAAdGhpcyAASW52YWxpZCB2ZWN0b3Igc2l6ZS4gTXVzdCBiZSBlcXVhbCB0byB0aGUgZGltZW5zaW9uIG9mIHRoZSBzcGFjZS4gVGhlIGRpbWVuc2lvbiBvZiB0aGUgc3BhY2UgaXMgACByZXF1aXJlcyAAb3BlcmF0b3IgAHJlZmVyZW5jZSB0ZW1wb3JhcnkgZm9yIAB0ZW1wbGF0ZSBwYXJhbWV0ZXIgb2JqZWN0IGZvciAAdHlwZWluZm8gZm9yIAB0aHJlYWQtbG9jYWwgd3JhcHBlciByb3V0aW5lIGZvciAAdGhyZWFkLWxvY2FsIGluaXRpYWxpemF0aW9uIHJvdXRpbmUgZm9yIAB0eXBlaW5mbyBuYW1lIGZvciAAY29uc3RydWN0aW9uIHZ0YWJsZSBmb3IgAGd1YXJkIHZhcmlhYmxlIGZvciAAVlRUIGZvciAAY292YXJpYW50IHJldHVybiB0aHVuayB0byAAbm9uLXZpcnR1YWwgdGh1bmsgdG8gAGludm9jYXRpb24gZnVuY3Rpb24gZm9yIGJsb2NrIGluIABhbGlnbm9mIABzaXplb2YgAD4gdHlwZW5hbWUgAGluaXRpYWxpemVyIGZvciBtb2R1bGUgADo6ZnJpZW5kIAB0eXBlaWQgAEludmFsaWQgdGhlIGdpdmVuIGFycmF5IGxlbmd0aCAoZXhwZWN0ZWQgAHVuc2lnbmVkIAAgPyAAIC0+IAAgPSAARmFpbGVkIHRvIHJlYWQgdGhlIGluZGV4OiAARmFpbGVkIHRvIG5vcm1hbGl6ZSB0aGUgcG9pbnQsIGNoZWNrIHZlY3RvciBkaW1lbnNpb25zOiAARmFpbGVkIHRvIGNhbGwgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uOiAAbGliYysrYWJpOiAAVGhlIG1heGltdW0gbnVtYmVyIG9mIGVsZW1lbnRzIGhhcyBiZWVuIHJlYWNoZWQgaW4gaW5kZXgsIHBsZWFzZSBpbmNyZWFzZWQgdGhlIGluZGV4IG1heF9zaXplLiAgbWF4X3NpemU6IABUaGUgbWF4aW11bSBudW1iZXIgb2YgZWxlbWVudHMgaW4gdGhlIGluZGV4IGhhcyBiZWVuIHJlYWNoZWQuICwgcGxlYXNlIGluY3JlYXNlZCB0aGUgaW5kZXggbWF4X3NpemUuICBtYXhfc2l6ZTogAGludmFsaWQgc3BhY2Ugc2hvdWxkIGJlIGV4cGVjdGVkIGwyLCBpcCwgb3IgY29zaW5lLCBuYW1lOiAASW52YWxpZCB0aGUgbnVtYmVyIG9mIGstbmVhcmVzdCBuZWlnaGJvcnMgKGNhbm5vdCBiZSBnaXZlbiBhIHZhbHVlIGdyZWF0ZXIgdGhhbiBgbWF4RWxlbWVudHNgOiAASE5TV0xJQiBFUlJPUjogACA6IABzaXplb2YuLi4gACAuLi4gACwgAG9wZXJhdG9yIiIgAFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBoYXMgYmVlbiByZWFjaGVkIGluIGluZGV4LCBwbGVhc2UgaW5jcmVhc2VkIHRoZSBpbmRleCBtYXhfc2l6ZS4gIG1heF9zaXplOiAlenUKAFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbGVtZW50cyBpbiB0aGUgaW5kZXggaGFzIGJlZW4gcmVhY2hlZC4gLCBwbGVhc2UgaW5jcmVhc2VkIHRoZSBpbmRleCBtYXhfc2l6ZS4gIG1heF9zaXplOiAlenUKAFRoZSBudW1iZXIgb2YgZWxlbWVudHMgZXhjZWVkcyB0aGUgc3BlY2lmaWVkIGxpbWl0CgBDb3VsZCBub3QgbWFya0RlbGV0ZUl0ZW1zICVzCgBDb3VsZCBub3QgYWRkSXRlbXMgJXMKAEZhaWxlZCB0byByZWFkIHRoZSBpbmRleDogJXMKAEZhaWxlZCB0byBub3JtYWxpemUgdGhlIHBvaW50LCBjaGVjayB2ZWN0b3IgZGltZW5zaW9uczogJXMKAEZhaWxlZCB0byBjYWxsIHRoZSBjYWxsYmFjayBmdW5jdGlvbjogJXMKAFdyaXRlSW5kZXggZmlsZW5hbWU6ICVzCgBBdXRvU2F2ZSBmaWxlbmFtZTogJXMKAGludmFsaWQgc3BhY2Ugc2hvdWxkIGJlIGV4cGVjdGVkIGwyLCBpcCwgb3IgY29zaW5lLCBuYW1lOiAlcwoASE5TV0xJQiBFUlJPUjogJXMKAEludmFsaWQgdmVjdG9yIHNpemUgYXQgaW5kZXggJXp1LiBNdXN0IGJlIGVxdWFsIHRvIHRoZSBkaW1lbnNpb24gb2YgdGhlIHNwYWNlLiBUaGUgZGltZW5zaW9uIG9mIHRoZSBzcGFjZSBpcyAlZC4KAEludmFsaWQgdmVjdG9yIHNpemUuIE11c3QgYmUgZXF1YWwgdG8gdGhlIGRpbWVuc2lvbiBvZiB0aGUgc3BhY2UuIFRoZSBkaW1lbnNpb24gb2YgdGhlIHNwYWNlIGlzICVkLgoASW52YWxpZCB0aGUgZ2l2ZW4gYXJyYXkgbGVuZ3RoIChleHBlY3RlZCAlbHUsIGJ1dCBnb3QgJXp1KS4KAEludmFsaWQgdGhlIG51bWJlciBvZiBrLW5lYXJlc3QgbmVpZ2hib3JzIChjYW5ub3QgYmUgZ2l2ZW4gYSB2YWx1ZSBncmVhdGVyIHRoYW4gYG1heEVsZW1lbnRzYDogJXp1KS4KAAkAAAB0jwAAYCgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0l3TlNfMTFjaGFyX3RyYWl0c0l3RUVOU185YWxsb2NhdG9ySXdFRUVFAAB0jwAAqCgAAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEc05TXzExY2hhcl90cmFpdHNJRHNFRU5TXzlhbGxvY2F0b3JJRHNFRUVFAAAAdI8AAPQoAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAHSPAABAKQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJY0VFAAB0jwAAaCkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWFFRQAAdI8AAJApAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAHSPAAC4KQAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAB0jwAA4CkAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAdI8AAAgqAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAHSPAAAwKgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAB0jwAAWCoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAdI8AAIAqAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAHSPAACoKgAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeEVFAAB0jwAA0CoAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXlFRQAAdI8AAPgqAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lmRUUAAHSPAAAgKwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZEVFAAD/AA0BAgABAQAAAACkkAAA/wAZAQIABQEAAn0DfQAAAOSRAACkkAAAAAAAAP8ADQECAAEBAAAAAKSQAAD/AA0BAgABAQAAAADkkQAA/wANAQIAAQEAAAAA5JEAAP8ADQECAAEBAAAAAKSQAAD/AA0BAgABAQAAAACkkAAA/wANAQIAAQEAAAAApJAAAP8ADQECAAEBAAAAAKSQAAD/AA0BAgABAQAAAACkkAAArI4AAPQrAAB0jwAA/CsAAE4xMGVtc2NyaXB0ZW4zdmFsRQAA+I8AADgsAAAAAAAAAwAAAFAsAAAAAAAAnC0AAAAAAADMLQAAAAAAAE5TdDNfXzI4b3B0aW9uYWxJZkVFAAAAAJyPAABcLAAAjCwAAE5TdDNfXzIyN19fb3B0aW9uYWxfbW92ZV9hc3NpZ25fYmFzZUlmTGIxRUVFAAAAAJyPAACYLAAAyCwAAE5TdDNfXzIyN19fb3B0aW9uYWxfY29weV9hc3NpZ25fYmFzZUlmTGIxRUVFAAAAAJyPAADULAAA/CwAAE5TdDNfXzIyMF9fb3B0aW9uYWxfbW92ZV9iYXNlSWZMYjFFRUUAAACcjwAACC0AADAtAABOU3QzX18yMjBfX29wdGlvbmFsX2NvcHlfYmFzZUlmTGIxRUVFAAAAnI8AADwtAABoLQAATlN0M19fMjIzX19vcHRpb25hbF9zdG9yYWdlX2Jhc2VJZkxiMEVFRQAAAAB0jwAAcC0AAE5TdDNfXzIyNF9fb3B0aW9uYWxfZGVzdHJ1Y3RfYmFzZUlmTGIxRUVFAAAAdI8AAKQtAABOU3QzX18yMThfX3NmaW5hZV9jdG9yX2Jhc2VJTGIxRUxiMUVFRQAAdI8AANQtAABOU3QzX18yMjBfX3NmaW5hZV9hc3NpZ25fYmFzZUlMYjFFTGIxRUVFAAAAAHSPAAAILgAATlN0M19fMjZ2ZWN0b3JJZk5TXzlhbGxvY2F0b3JJZkVFRUUAVJAAADwuAAAAAAAAAC4AAFBOU3QzX18yNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRQAAAABUkAAAdC4AAAEAAAAALgAAUEtOU3QzX18yNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRQBwcAB2AHZwAAAALC4AAKyOAAAsLgAAVI8AAHZwcGYAAAAAAAAAAKyOAAAsLgAAMI8AAFSPAAB2cHBwZgAAADCPAABkLgAAcHBwABAsAAAALgAAMI8AAHBwcHAAQYDeAAvUC8SOAAAALgAAMI8AAFSPAABpcHBwZgAAAPiPAABALwAAAAAAAAMAAAB0LwAAAAAAAJwtAAAAAAAAzC0AAAAAAABOU3QzX18yOG9wdGlvbmFsSU5TXzZ2ZWN0b3JJZk5TXzlhbGxvY2F0b3JJZkVFRUVFRQAAnI8AAIAvAADMLwAATlN0M19fMjI3X19vcHRpb25hbF9tb3ZlX2Fzc2lnbl9iYXNlSU5TXzZ2ZWN0b3JJZk5TXzlhbGxvY2F0b3JJZkVFRUVMYjBFRUUAAJyPAADYLwAAJDAAAE5TdDNfXzIyN19fb3B0aW9uYWxfY29weV9hc3NpZ25fYmFzZUlOU182dmVjdG9ySWZOU185YWxsb2NhdG9ySWZFRUVFTGIwRUVFAACcjwAAMDAAAHQwAABOU3QzX18yMjBfX29wdGlvbmFsX21vdmVfYmFzZUlOU182dmVjdG9ySWZOU185YWxsb2NhdG9ySWZFRUVFTGIwRUVFAJyPAACAMAAAxDAAAE5TdDNfXzIyMF9fb3B0aW9uYWxfY29weV9iYXNlSU5TXzZ2ZWN0b3JJZk5TXzlhbGxvY2F0b3JJZkVFRUVMYjBFRUUAnI8AANAwAAAYMQAATlN0M19fMjIzX19vcHRpb25hbF9zdG9yYWdlX2Jhc2VJTlNfNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRUxiMEVFRQAAdI8AACAxAABOU3QzX18yMjRfX29wdGlvbmFsX2Rlc3RydWN0X2Jhc2VJTlNfNnZlY3RvcklmTlNfOWFsbG9jYXRvcklmRUVFRUxiMEVFRQB0jwAAcDEAAE5TdDNfXzI2dmVjdG9ySU5TMF9JZk5TXzlhbGxvY2F0b3JJZkVFRUVOUzFfSVMzX0VFRUUAAAAAVJAAALgxAAAAAAAAaDEAAFBOU3QzX18yNnZlY3RvcklOUzBfSWZOU185YWxsb2NhdG9ySWZFRUVFTlMxX0lTM19FRUVFAAAAVJAAAAAyAAABAAAAaDEAAFBLTlN0M19fMjZ2ZWN0b3JJTlMwX0lmTlNfOWFsbG9jYXRvcklmRUVFRU5TMV9JUzNfRUVFRQAAqDEAAKyOAACoMQAAAC4AAHZwcHAAAAAArI4AAKgxAAAwjwAAAC4AAHZwcHBwAAAAMI8AAPAxAAAYLwAAaDEAADCPAAAAAAAAxI4AAGgxAAAwjwAAAC4AAGlwcHBwAAAA+I8AAMAyAAAAAAAAAwAAANgyAAAAAAAAnC0AAAAAAADMLQAAAAAAAE5TdDNfXzI4b3B0aW9uYWxJakVFAAAAAJyPAADkMgAAFDMAAE5TdDNfXzIyN19fb3B0aW9uYWxfbW92ZV9hc3NpZ25fYmFzZUlqTGIxRUVFAAAAAJyPAAAgMwAAUDMAAE5TdDNfXzIyN19fb3B0aW9uYWxfY29weV9hc3NpZ25fYmFzZUlqTGIxRUVFAAAAAJyPAABcMwAAhDMAAE5TdDNfXzIyMF9fb3B0aW9uYWxfbW92ZV9iYXNlSWpMYjFFRUUAAACcjwAAkDMAALgzAABOU3QzX18yMjBfX29wdGlvbmFsX2NvcHlfYmFzZUlqTGIxRUVFAAAAnI8AAMQzAADwMwAATlN0M19fMjIzX19vcHRpb25hbF9zdG9yYWdlX2Jhc2VJakxiMEVFRQAAAAB0jwAA+DMAAE5TdDNfXzIyNF9fb3B0aW9uYWxfZGVzdHJ1Y3RfYmFzZUlqTGIxRUVFAAAAdI8AACw0AABOU3QzX18yNnZlY3RvcklqTlNfOWFsbG9jYXRvcklqRUVFRQBUkAAAYDQAAAAAAAAkNAAAUE5TdDNfXzI2dmVjdG9ySWpOU185YWxsb2NhdG9ySWpFRUVFAAAAAFSQAACYNAAAAQAAACQ0AABQS05TdDNfXzI2dmVjdG9ySWpOU185YWxsb2NhdG9ySWpFRUVFAAAAUDQAAKyOAABQNAAAGI8AAHZwcGkAQeDpAAu1AqyOAABQNAAAMI8AABiPAAB2cHBwaQAAADCPAACINAAAmDIAACQ0AAAwjwAAAAAAAMSOAAAkNAAAMI8AABiPAABpcHBwaQAAAAAuAAAALgAAcHBwAHSPAAA8NQAATjEwZW1zY3JpcHRlbjdMMlNwYWNlRQAAVJAAAGQ1AAAAAAAANDUAAFBOMTBlbXNjcmlwdGVuN0wyU3BhY2VFAFSQAACMNQAAAQAAADQ1AABQS04xMGVtc2NyaXB0ZW43TDJTcGFjZUUAAAAAVDUAABiPAABwcGkAAAAAANA1AACYAAAAmQAAAJoAAACbAAAAnAAAAJyPAADcNQAA8DUAAE43aG5zd2xpYjdMMlNwYWNlRQAAdI8AAPg1AABON2huc3dsaWIxNFNwYWNlSW50ZXJmYWNlSWZFRQBBoOwAC4UCVI8AAFQ1AAAALgAAAC4AAGZwcHBwAAAAGI8AAFQ1AABpcHAAdI8AAEw2AABOMTBlbXNjcmlwdGVuMTdJbm5lclByb2R1Y3RTcGFjZUUAAABUkAAAgDYAAAAAAABENgAAUE4xMGVtc2NyaXB0ZW4xN0lubmVyUHJvZHVjdFNwYWNlRQAAVJAAALQ2AAABAAAARDYAAFBLTjEwZW1zY3JpcHRlbjE3SW5uZXJQcm9kdWN0U3BhY2VFAHA2AAAYjwAAAAAAAPw2AACdAAAAngAAAJ8AAACbAAAAoAAAAJyPAAAINwAA8DUAAE43aG5zd2xpYjE3SW5uZXJQcm9kdWN0U3BhY2VFAEGw7gALtQVUjwAAcDYAAAAuAAAALgAAGI8AAHA2AAAAAAAAVDcAAKEAAACcjwAAYDcAAIQ3AABOMTBlbXNjcmlwdGVuMTlDdXN0b21GaWx0ZXJGdW5jdG9yRQB0jwAAjDcAAE43aG5zd2xpYjE3QmFzZUZpbHRlckZ1bmN0b3JFAAAAxI4AAPQrAAAwjwAAVJAAAMg3AAAAAAAAVDcAAFBOMTBlbXNjcmlwdGVuMTlDdXN0b21GaWx0ZXJGdW5jdG9yRQAAAABUkAAAADgAAAEAAABUNwAAUEtOMTBlbXNjcmlwdGVuMTlDdXN0b21GaWx0ZXJGdW5jdG9yRQAAALg3AAD0KwAAxI4AALg3AAAwjwAAaXBwcAAAAAB0jwAATDgAAE4xMGVtc2NyaXB0ZW4xNkJydXRlZm9yY2VTZWFyY2hFAAAAAFSQAACAOAAAAAAAAEQ4AABQTjEwZW1zY3JpcHRlbjE2QnJ1dGVmb3JjZVNlYXJjaEUAAABUkAAAtDgAAAEAAABEOAAAUEtOMTBlbXNjcmlwdGVuMTZCcnV0ZWZvcmNlU2VhcmNoRQAAcDgAAOQ4AAAYjwAAdI8AAOw4AABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQBwcHBpAKyOAABwOAAAGI8AAAAAAABcOQAAogAAAKMAAACkAAAApQAAAKYAAACnAAAAnI8AAGg5AACIOQAATjdobnN3bGliMTZCcnV0ZWZvcmNlU2Vh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U3QzX18yMTNiYXNpY19vc3RyZWFtSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAABsAAAAAAAAAGRTAADXAAAA2AAAAJT///+U////ZFMAANkAAADaAAAAEFMAAEhTAABcUwAAJFMAAGwAAAAAAAAAdFIAAMUAAADGAAAAlP///5T///90UgAAxwAAAMgAAACcjwAAcFMAAHRSAABOU3QzX18yMTRiYXNpY19pZnN0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQBoAAAAAAAAAABUAADbAAAA3AAAAJj///+Y////AFQAAN0AAADeAAAArFMAAORTAAD4UwAAwFMAAGgAAAAAAAAAvFIAAMkAAADKAAAAmP///5j///+8UgAAywAAAMwAAACcjwAADFQAALxSAABOU3QzX18yMTRiYXNpY19vZnN0cmVhbUljTlNfMTFjaGFyX3RyYWl0c0ljRUVFRQCcjwAASFQAADhSAABOU3QzX18yMTNiYXNpY19maWxlYnVmSWNOU18xMWNoYXJfdHJhaXRzSWNFRUVFAAB0jwAAgFQAAE5TdDNfXzIxNGVycm9yX2NhdGVnb3J5RQAAAAAAAAAAKFUAAOAAAADhAAAA4gAAAOMAAADkAAAA5QAAAOYAAAAAAAAAAFUAAN8AAADnAAAA6AAAAAAAAADkVAAA6QAAAOoAAAB0jwAA7FQAAE5TdDNfXzI4aW9zX2Jhc2VFAAAAnI8AAAxVAACEjAAATlN0M19fMjhpb3NfYmFzZTdmYWlsdXJlRQAAAJyPAAA0VQAAqIwAAE5TdDNfXzIxOV9faW9zdHJlYW1fY2F0ZWdvcnlFAEHgqgEL0wTRdJ4AV529KoBwUg///z4nCgAAAGQAAADoAwAAECcAAKCGAQBAQg8AgJaYAADh9QUYAAAANQAAAHEAAABr////zvv//5K///8AAAAAAAAAAP////////////////////////////////////////////////////////////////8AAQIDBAUGBwgJ/////////woLDA0ODxAREhMUFRYXGBkaGxwdHh8gISIj////////CgsMDQ4PEBESExQVFhcYGRobHB0eHyAhIiP/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAECBAcDBgUAAAAAAAAAAgAAwAMAAMAEAADABQAAwAYAAMAHAADACAAAwAkAAMAKAADACwAAwAwAAMANAADADgAAwA8AAMAQAADAEQAAwBIAAMATAADAFAAAwBUAAMAWAADAFwAAwBgAAMAZAADAGgAAwBsAAMAcAADAHQAAwB4AAMAfAADAAAAAswEAAMMCAADDAwAAwwQAAMMFAADDBgAAwwcAAMMIAADDCQAAwwoAAMMLAADDDAAAww0AANMOAADDDwAAwwAADLsBAAzDAgAMwwMADMMEAAzbAAAAAN4SBJUAAAAA////////////////kFcAABQAAABDLlVURi04AEHgrwELAqRXAEGAsAELR0xDX0NUWVBFAAAAAExDX05VTUVSSUMAAExDX1RJTUUAAAAAAExDX0NPTExBVEUAAExDX01PTkVUQVJZAExDX01FU1NBR0VTAEHUsAELLYDeKACAyE0AAKd2AAA0ngCAEscAgJ/uAAB+FwGAXEABgOlnAQDIkAEAVbgBLgBBkLEBC9YCU3VuAE1vbgBUdWUAV2VkAFRodQBGcmkAU2F0AFN1bmRheQBNb25kYXkAVHVlc2RheQBXZWRuZXNkYXkAVGh1cnNkYXkARnJpZGF5AFNhdHVyZGF5AEphbgBGZWIATWFyAEFwcgBNYXkASnVuAEp1bABBdWcAU2VwAE9jdABOb3YARGVjAEphbnVhcnkARmVicnVhcnkATWFyY2gAQXByaWwATWF5AEp1bmUASnVseQBBdWd1c3QAU2VwdGVtYmVyAE9jdG9iZXIATm92ZW1iZXIARGVjZW1iZXIAQU0AUE0AJWEgJWIgJWUgJVQgJVkAJW0vJWQvJXkAJUg6JU06JVMAJUk6JU06JVMgJXAAAAAlbS8lZC8leQAwMTIzNDU2Nzg5ACVhICViICVlICVUICVZACVIOiVNOiVTAAAAAABeW3lZXQBeW25OXQB5ZXMAbm8AAPBbAEH0twEL+QMBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAA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AABlAAAAcAAAAAAAAABPAAAAYwAAAHQAAAAAAAAATgAAAG8AAAB2AAAAAAAAAEQAAABlAAAAYwAAAAAAAABBAAAATQAAAAAAAABQAAAATQBBxIECC6QSsHUAAJYBAACXAQAAmAEAAJkBAACaAQAAmwEAAJwBAAAAAAAAoHYAAKYBAACnAQAAqAEAAKkBAACqAQAAqwEAAKwBAAAAAAAAHIEAAO8BAADwAQAA8QEAAHSPAAAkgQAATlN0M19fMjE0X19zaGFyZWRfY291bnRFAAAAAAAAAABcgQAA7wEAAPIBAADxAQAA8wEAAPEBAAD4jwAAdIEAAAAAAAABAAAAHIEAAAAAAABOU3QzX18yMTlfX3NoYXJlZF93ZWFrX2NvdW50RQAAAAAAAACogQAA9AEAAPUBAAD2AQAAnI8AALSBAACEjAAATlN0M19fMjEwZmlsZXN5c3RlbTE2ZmlsZXN5c3RlbV9lcnJvckUAAAAAAAD4gQAA9wEAAPgBAAD5AQAA8wEAAPoBAACcjwAABIIAAFyBAABOU3QzX18yMjBfX3NoYXJlZF9wdHJfZW1wbGFjZUlOU18xMGZpbGVzeXN0ZW0xNmZpbGVzeXN0ZW1fZXJyb3I4X1N0b3JhZ2VFTlNfOWFsbG9jYXRvcklTM19FRUVFAAYFCAIIBAgBCAMIB05vIGVycm9yIGluZm9ybWF0aW9uAElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE11bHRpaG9wIGF0dGVtcHRlZABSZXF1aXJlZCBrZXkgbm90IGF2YWlsYWJsZQBLZXkgaGFzIGV4cGlyZWQAS2V5IGhhcyBiZWVuIHJldm9rZWQAS2V5IHdhcyByZWplY3RlZCBieSBzZXJ2aWNlAEHykwILlgGlAlsA8AG1BYwFJQGDBh0DlAT/AMcDMQMLBrwBjwF/A8oEKwDaBq8AQgNOA9wBDgQVAKEGDQGUAgsCOAZkArwC/wJdA+cECwfPAssF7wXbBeECHgZFAoUAggJsA28E8QDzAxgF2QDaA0wGVAJ7AZ0DvQQAAFEAFQK7ALMDbQD/AYUELwX5BDgAZQFGAZ8AtwaoAXMCUwEAQbiVAgsMIQQAAAAAAAAAAC8CAEHYlQILBjUERwRWBABB7pUCCwKgBABBgpYCCyJGBWAFbgVhBgAAzwEAAAAAAAAAAMkG6Qb5Bh4HOQdJB14HAEG0lgIL9A4KAAAAZAAAAOgDAAAQJwAAoIYBAEBCDwCA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YXNzX2Z1bmN0aW9uCRlfZW1iaW5kX3JlZ2lzdGVyX29wdGlvbmFsChFfZW12YWxfdGFrZV92YWx1ZQsNX2VtdmFsX2luY3JlZgwQX2VtdmFsX25ld19hcnJheQ0RX2VtdmFsX25ld19vYmplY3QOEl9lbXZhbF9uZXdfY3N0cmluZw8TX2VtdmFsX3NldF9wcm9wZXJ0eRAYZW1zY3JpcHRlbl9hc21fY29uc3RfaW50EQpzeW5jSWRiX2pzEg1fX2Fzc2VydF9mYWlsExVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQUFV9lbWJpbmRfcmVnaXN0ZXJfYm9vbBUYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyFhdfZW1iaW5kX3JlZ2lzdGVyX2JpZ2ludBcWX2VtYmluZF9yZWdpc3Rlcl9mbG9hdBgbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nGRxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nGhZfZW1iaW5kX3JlZ2lzdGVyX2VtdmFsGxxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3HA9fX3dhc2lfZmRfd3JpdGUdCV9hYm9ydF9qcx4PX193YXNpX2ZkX2Nsb3NlHw5fX3dhc2lfZmRfc2VlayAWZW1zY3JpcHRlbl9yZXNpemVfaGVhcCEQX19zeXNjYWxsX29wZW5hdCIRX19zeXNjYWxsX2ZjbnRsNjQjD19fc3lzY2FsbF9pb2N0bCQOX193YXNpX2ZkX3JlYWQlGF9fd2FzaV9lbnZpcm9uX3NpemVzX2dldCYSX193YXNpX2Vudmlyb25fZ2V0JwlfdHpzZXRfanMoEF9fc3lzY2FsbF9zdGF0NjQpIl9fdGhyb3dfZXhjZXB0aW9uX3dpdGhfc3RhY2tfdHJhY2UqEV9fd2FzbV9jYWxsX2N0b3JzKw1fX2dldFR5cGVOYW1lLBVlbWJpbmRfaW5pdF9idWlsdGluKCktF19fY3h4X2dsb2JhbF9hcnJheV9kdG9yLhlfX2N4eF9nbG9iYWxfYXJyYXlfZHRvci40LxlfX2N4eF9nbG9iYWxfYXJyYXlfZHRvci42MBdlbXNjcmlwdGVuOjp2YWw6On52YWwoKTGAAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YmFzaWNfc3RyaW5nW2FiaTpuZTE5MDEwNl08MD4oY2hhciBjb25zdCopMoABc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpfX3Rocm93X2xlbmd0aF9lcnJvclthYmk6bmUxOTAxMDZdKCkgY29uc3QzGV9fY3h4X2dsb2JhbF9hcnJheV9kdG9yLjg0DnNldElkYmZzU3luY2VkNU9zdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OnNpemVbYWJpOm5lMTkwMTA2XSgpIGNvbnN0NltlbXNjcmlwdGVuOjpub3JtYWxpemVQb2ludHNQdXJlKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYpN19zdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46Ol9fdGhyb3dfbGVuZ3RoX2Vycm9yW2FiaTpuZTE5MDEwNl0oKSBjb25zdDghZW1zY3JpcHRlbjo6ZW1iaW5kX2luaXRfaG5zd2xpYigpOekCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0Jj46Omludm9rZShzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gKCopKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYpLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qKTpadm9pZCBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEFjdHVhbFR5cGU8ZW1zY3JpcHRlbjo6TDJTcGFjZT4oZW1zY3JpcHRlbjo6TDJTcGFjZSopO1R2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpyYXdfZGVzdHJ1Y3RvcjxlbXNjcmlwdGVuOjpMMlNwYWNlPihlbXNjcmlwdGVuOjpMMlNwYWNlKik8rgFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjp0YWtlX293bmVyc2hpcCwgZW1zY3JpcHRlbjo6TDJTcGFjZSosIHVuc2lnbmVkIGludCYmPjo6aW52b2tlKGVtc2NyaXB0ZW46OkwyU3BhY2UqICgqKSh1bnNpZ25lZCBpbnQmJiksIHVuc2lnbmVkIGludCk9amVtc2NyaXB0ZW46OkwyU3BhY2UqIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8ZW1zY3JpcHRlbjo6TDJTcGFjZSwgdW5zaWduZWQgaW50Pih1bnNpZ25lZCBpbnQmJik+lQFlbXNjcmlwdGVuOjpMMlNwYWNlOjpkaXN0YW5jZShzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmKT+hBWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCBmbG9hdCAoZW1zY3JpcHRlbjo6TDJTcGFjZTo6Kikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0Jiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiksIGZsb2F0LCBlbXNjcmlwdGVuOjpMMlNwYWNlKiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0Jiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0Jj46Omludm9rZShmbG9hdCAoZW1zY3JpcHRlbjo6TDJTcGFjZTo6KiBjb25zdCYpKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYpLCBlbXNjcmlwdGVuOjpMMlNwYWNlKiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Kiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+KilAJ2Vtc2NyaXB0ZW46OkwyU3BhY2U6OmdldE51bURpbWVuc2lvbnMoKUHmAWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB1bnNpZ25lZCBpbnQgKGVtc2NyaXB0ZW46OkwyU3BhY2U6OiopKCksIHVuc2lnbmVkIGludCwgZW1zY3JpcHRlbjo6TDJTcGFjZSo+OjppbnZva2UodW5zaWduZWQgaW50IChlbXNjcmlwdGVuOjpMMlNwYWNlOjoqIGNvbnN0JikoKSwgZW1zY3JpcHRlbjo6TDJTcGFjZSopQm52b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxlbXNjcmlwdGVuOjpJbm5lclByb2R1Y3RTcGFjZT4oZW1zY3JpcHRlbjo6SW5uZXJQcm9kdWN0U3BhY2UqKUN+ZW1zY3JpcHRlbjo6SW5uZXJQcm9kdWN0U3BhY2UqIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8ZW1zY3JpcHRlbjo6SW5uZXJQcm9kdWN0U3BhY2UsIHVuc2lnbmVkIGludD4odW5zaWduZWQgaW50JiYpRJ8BZW1zY3JpcHRlbjo6SW5uZXJQcm9kdWN0U3BhY2U6OmRpc3RhbmNlKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYpRXJ2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yPihlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yKilGbHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPGVtc2NyaXB0ZW46OkN1c3RvbUZpbHRlckZ1bmN0b3I+KGVtc2NyaXB0ZW46OkN1c3RvbUZpbHRlckZ1bmN0b3IqKUfUAWVtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OnRha2Vfb3duZXJzaGlwLCBlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yKiwgZW1zY3JpcHRlbjo6dmFsJiY+OjppbnZva2UoZW1zY3JpcHRlbjo6Q3VzdG9tRmlsdGVyRnVuY3RvciogKCopKGVtc2NyaXB0ZW46OnZhbCYmKSwgZW1zY3JpcHRlbjo6X0VNX1ZBTCopSIgBZW1zY3JpcHRlbjo6Q3VzdG9tRmlsdGVyRnVuY3RvciogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yLCBlbXNjcmlwdGVuOjp2YWw+KGVtc2NyaXB0ZW46OnZhbCYmKUm2AmVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCBib29sIChlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yOjoqKSh1bnNpZ25lZCBsb25nKSwgYm9vbCwgZW1zY3JpcHRlbjo6Q3VzdG9tRmlsdGVyRnVuY3RvciosIHVuc2lnbmVkIGxvbmc+OjppbnZva2UoYm9vbCAoZW1zY3JpcHRlbjo6Q3VzdG9tRmlsdGVyRnVuY3Rvcjo6KiBjb25zdCYpKHVuc2lnbmVkIGxvbmcpLCBlbXNjcmlwdGVuOjpDdXN0b21GaWx0ZXJGdW5jdG9yKiwgdW5zaWduZWQgbG9uZylKbHZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g+KGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2gqKUtmdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8ZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaD4oZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCopTPsDZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6dGFrZV9vd25lcnNoaXAsIGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2gqLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4mJiwgdW5zaWduZWQgaW50JiY+OjppbnZva2UoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCogKCopKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiYmLCB1bnNpZ25lZCBpbnQmJiksIGVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4sIHZvaWQ+OjondW5uYW1lZCcqLCB1bnNpZ25lZCBpbnQpTaoCZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4sIHVuc2lnbmVkIGludD4oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+JiYsIHVuc2lnbmVkIGludCYmKU41ZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6aW5pdEluZGV4KHVuc2lnbmVkIGludClPpgJlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgdm9pZCAoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6KikodW5zaWduZWQgaW50KSwgdm9pZCwgZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCosIHVuc2lnbmVkIGludD46Omludm9rZSh2b2lkIChlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoOjoqIGNvbnN0JikodW5zaWduZWQgaW50KSwgZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCosIHVuc2lnbmVkIGludClQMmVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OmlzSW5kZXhJbml0aWFsaXplZCgpUZMCZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIGVtc2NyaXB0ZW46OnZhbCAoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6KikoKSwgZW1zY3JpcHRlbjo6dmFsLCBlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoKj46Omludm9rZShlbXNjcmlwdGVuOjp2YWwgKGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OiogY29uc3QmKSgpLCBlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoKilShAFlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoOjpyZWFkSW5kZXgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JilTkAVlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgdm9pZCAoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6Kikoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiksIHZvaWQsIGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2gqLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmPjo6aW52b2tlKHZvaWQgKGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OiogY29uc3QmKShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKSwgZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCosIGVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4sIHZvaWQ+OjondW5uYW1lZCcqKVSFAWVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OndyaXRlSW5kZXgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JilVcGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OmFkZFBvaW50KHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHVuc2lnbmVkIGludClWkARlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgdm9pZCAoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6Kikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50KSwgdm9pZCwgZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCosIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHVuc2lnbmVkIGludD46Omludm9rZSh2b2lkIChlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoOjoqIGNvbnN0Jikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50KSwgZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaCosIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiosIHVuc2lnbmVkIGludClXN2Vtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OnJlbW92ZVBvaW50KHVuc2lnbmVkIGludClYggFlbXNjcmlwdGVuOjpCcnV0ZWZvcmNlU2VhcmNoOjpzZWFyY2hLbm4oc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjp2YWwpWfoEZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIGVtc2NyaXB0ZW46OnZhbCAoZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6Kikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjp2YWwpLCBlbXNjcmlwdGVuOjp2YWwsIGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2gqLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OnZhbD46Omludm9rZShlbXNjcmlwdGVuOjp2YWwgKGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2g6OiogY29uc3QmKShzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OnZhbCksIGVtc2NyaXB0ZW46OkJydXRlZm9yY2VTZWFyY2gqLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qLCB1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46Ol9FTV9WQUwqKVouZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6Z2V0TWF4RWxlbWVudHMoKVsvZW1zY3JpcHRlbjo6QnJ1dGVmb3JjZVNlYXJjaDo6Z2V0Q3VycmVudENvdW50KClcanZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVz4oZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKildZHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVz4oZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKileyAZlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjp0YWtlX293bmVyc2hpcCwgZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50JiYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCY+OjppbnZva2UoZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiAoKikoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50JiYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYpLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+LCB2b2lkPjo6J3VubmFtZWQnKiwgdW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+LCB2b2lkPjo6J3VubmFtZWQnKilf7gNlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1cqIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCY+KHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHVuc2lnbmVkIGludCYmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKWBeZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjppbml0SW5kZXgodW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KWHKA2Vtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkIChlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OiopKHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCksIHZvaWQsIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyosIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludD46Omludm9rZSh2b2lkIChlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OiogY29uc3QmKSh1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQpLCBlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1cqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQpYpEBZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpyZWFkSW5kZXgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50KWPEBWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkIChlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OiopKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHVuc2lnbmVkIGludCksIHZvaWQsIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyosIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHVuc2lnbmVkIGludD46Omludm9rZSh2b2lkIChlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OiogY29uc3QmKShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCB1bnNpZ25lZCBpbnQpLCBlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1cqLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+LCB2b2lkPjo6J3VubmFtZWQnKiwgdW5zaWduZWQgaW50KWSEAWVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6d3JpdGVJbmRleChzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKWU2ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpyZXNpemVJbmRleCh1bnNpZ25lZCBpbnQpZjNlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OmdldFBvaW50KHVuc2lnbmVkIGludClnwwJlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgZW1zY3JpcHRlbjo6dmFsIChlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OiopKHVuc2lnbmVkIGludCksIGVtc2NyaXB0ZW46OnZhbCwgZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiwgdW5zaWduZWQgaW50Pjo6aW52b2tlKGVtc2NyaXB0ZW46OnZhbCAoZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjoqIGNvbnN0JikodW5zaWduZWQgaW50KSwgZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiwgdW5zaWduZWQgaW50KWh1ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjphZGRQb2ludChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIGJvb2wpaaQEZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIHZvaWQgKGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6Kikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBib29sKSwgdm9pZCwgZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBib29sPjo6aW52b2tlKHZvaWQgKGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6KiBjb25zdCYpKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHVuc2lnbmVkIGludCwgYm9vbCksIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyosIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiosIHVuc2lnbmVkIGludCwgYm9vbClqjgJlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OmFkZFBvaW50cyhzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiBjb25zdCYsIHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+IGNvbnN0JiwgYm9vbClrwwFlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OmFkZEl0ZW1zKHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+IGNvbnN0JiwgYm9vbClskwhlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4gKGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6Kikoc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Pj4gY29uc3QmLCBib29sKSwgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4sIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyosIHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+IGNvbnN0JiwgYm9vbD46Omludm9rZShzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiAoZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjoqIGNvbnN0Jikoc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Pj4gY29uc3QmLCBib29sKSwgZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXKiwgc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Pj4qLCBib29sKW0sZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpnZXRVc2VkTGFiZWxzKClupQNlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4gKGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6KikoKSwgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4sIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyo+OjppbnZva2Uoc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4gKGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVzo6KiBjb25zdCYpKCksIGVtc2NyaXB0ZW46OkhpZXJhcmNoaWNhbE5TVyopby9lbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OmdldERlbGV0ZWRMYWJlbHMoKXAtZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpnZXRNYXhFbGVtZW50cygpcTVlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6Om1hcmtEZWxldGUodW5zaWduZWQgaW50KXJ2ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjptYXJrRGVsZXRlSXRlbXMoc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4gY29uc3QmKXM3ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjp1bm1hcmtEZWxldGUodW5zaWduZWQgaW50KXQ0ZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpnZXRDdXJyZW50Q291bnQoKSBjb25zdHUwZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpnZXRFZlNlYXJjaCgpIGNvbnN0djZlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OnNldEVmU2VhcmNoKHVuc2lnbmVkIGludCl3gQFlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OnNlYXJjaEtubihzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OnZhbCl4b2Vtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkLCBib29sPjo6aW52b2tlKHZvaWQgKCopKGJvb2wpLCBib29sKXmCAXZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPGVtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcj4oZW1zY3JpcHRlbjo6RW1zY3JpcHRlbkZpbGVTeXN0ZW1NYW5hZ2VyKil6fHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPGVtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcj4oZW1zY3JpcHRlbjo6RW1zY3JpcHRlbkZpbGVTeXN0ZW1NYW5hZ2VyKil7qgFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjp0YWtlX293bmVyc2hpcCwgZW1zY3JpcHRlbjo6RW1zY3JpcHRlbkZpbGVTeXN0ZW1NYW5hZ2VyKj46Omludm9rZShlbXNjcmlwdGVuOjpFbXNjcmlwdGVuRmlsZVN5c3RlbU1hbmFnZXIqICgqKSgpKXx2ZW1zY3JpcHRlbjo6RW1zY3JpcHRlbkZpbGVTeXN0ZW1NYW5hZ2VyKiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6b3BlcmF0b3JfbmV3PGVtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcj4oKX2iA2Vtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmPjo6aW52b2tlKHZvaWQgKCopKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYpLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+LCB2b2lkPjo6J3VubmFtZWQnKil+mgFlbXNjcmlwdGVuOjpFbXNjcmlwdGVuRmlsZVN5c3RlbU1hbmFnZXI6OmluaXRpYWxpemVGaWxlU3lzdGVtKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYpfzhlbXNjcmlwdGVuOjpFbXNjcmlwdGVuRmlsZVN5c3RlbU1hbmFnZXI6OmlzSW5pdGlhbGl6ZWQoKYABpwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgdm9pZCwgYm9vbCwgZW1zY3JpcHRlbjo6dmFsPjo6aW52b2tlKHZvaWQgKCopKGJvb2wsIGVtc2NyaXB0ZW46OnZhbCksIGJvb2wsIGVtc2NyaXB0ZW46Ol9FTV9WQUwqKYEBRmVtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcjo6c3luY0ZTKGJvb2wsIGVtc2NyaXB0ZW46OnZhbCmCATtlbXNjcmlwdGVuOjpFbXNjcmlwdGVuRmlsZVN5c3RlbU1hbmFnZXI6OnNldERlYnVnTG9ncyhib29sKYMBM2Vtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcjo6aXNTeW5jZWQoKYQBogNlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgYm9vbCwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0Jj46Omludm9rZShib29sICgqKShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKSwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Piwgdm9pZD46Oid1bm5hbWVkJyophQGVAWVtc2NyaXB0ZW46OkVtc2NyaXB0ZW5GaWxlU3lzdGVtTWFuYWdlcjo6Y2hlY2tGaWxlRXhpc3RzKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYphgGaAXZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4oc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+KimHAZQBdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+PihzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qKYgBjgFzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+PigpiQFac3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+OjpwdXNoX2JhY2tbYWJpOm5lMTkwMTA2XShmbG9hdCBjb25zdCYpigH7AmVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkIChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OiopKGZsb2F0IGNvbnN0JiksIHZvaWQsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiosIGZsb2F0IGNvbnN0Jj46Omludm9rZSh2b2lkIChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OiogY29uc3QmKShmbG9hdCBjb25zdCYpLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qLCBmbG9hdCmLAVhzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OnJlc2l6ZSh1bnNpZ25lZCBsb25nLCBmbG9hdCBjb25zdCYpjAG3A2Vtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCB2b2lkIChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OiopKHVuc2lnbmVkIGxvbmcsIGZsb2F0IGNvbnN0JiksIHZvaWQsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiosIHVuc2lnbmVkIGxvbmcsIGZsb2F0IGNvbnN0Jj46Omludm9rZSh2b2lkIChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj46OiogY29uc3QmKSh1bnNpZ25lZCBsb25nLCBmbG9hdCBjb25zdCYpLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qLCB1bnNpZ25lZCBsb25nLCBmbG9hdCmNAacBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlZlY3RvckFjY2VzczxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+OjpnZXQoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZymOAdUDZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkZ1bmN0aW9uSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgc3RkOjpfXzI6Om9wdGlvbmFsPGZsb2F0PiAoKikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZyksIHN0ZDo6X18yOjpvcHRpb25hbDxmbG9hdD4sIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmc+OjppbnZva2Uoc3RkOjpfXzI6Om9wdGlvbmFsPGZsb2F0PiAoKiopKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmcpLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4qLCB1bnNpZ25lZCBsb25nKY8BrwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6VmVjdG9yQWNjZXNzPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj46OnNldChzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4mLCB1bnNpZ25lZCBsb25nLCBmbG9hdCBjb25zdCYpkAG1A2Vtc2NyaXB0ZW46OmludGVybmFsOjpGdW5jdGlvbkludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIGJvb2wgKCopKHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiYsIHVuc2lnbmVkIGxvbmcsIGZsb2F0IGNvbnN0JiksIGJvb2wsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiYsIHVuc2lnbmVkIGxvbmcsIGZsb2F0IGNvbnN0Jj46Omludm9rZShib29sICgqKikoc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+JiwgdW5zaWduZWQgbG9uZywgZmxvYXQgY29uc3QmKSwgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+KiwgdW5zaWduZWQgbG9uZywgZmxvYXQpkQHSAnZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+PihzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiopkgHMAnZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJhd19kZXN0cnVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+PihzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiopkwHkAXN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+OjpwdXNoX2JhY2tbYWJpOm5lMTkwMTA2XShzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmKZQB4gFzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+Pjo6cmVzaXplKHVuc2lnbmVkIGxvbmcsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYplQGrAXN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+OjpzaXplW2FiaTpuZTE5MDEwNl0oKSBjb25zdJYB3wJlbXNjcmlwdGVuOjppbnRlcm5hbDo6VmVjdG9yQWNjZXNzPHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+Pjo6Z2V0KHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZymXAc8HZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkZ1bmN0aW9uSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgc3RkOjpfXzI6Om9wdGlvbmFsPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4gKCopKHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZyksIHN0ZDo6X18yOjpvcHRpb25hbDxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+LCBzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmc+OjppbnZva2Uoc3RkOjpfXzI6Om9wdGlvbmFsPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4gKCoqKShzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmcpLCBzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiosIHVuc2lnbmVkIGxvbmcpmAGVA2Vtc2NyaXB0ZW46OmludGVybmFsOjpWZWN0b3JBY2Nlc3M8c3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Pj4+OjpzZXQoc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Pj4mLCB1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4gY29uc3QmKZkB3gdlbXNjcmlwdGVuOjppbnRlcm5hbDo6RnVuY3Rpb25JbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCBib29sICgqKShzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiYsIHVuc2lnbmVkIGxvbmcsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCYpLCBib29sLCBzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6dmVjdG9yPGZsb2F0LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGZsb2F0Pj4+PiYsIHVuc2lnbmVkIGxvbmcsIHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBjb25zdCY+OjppbnZva2UoYm9vbCAoKiopKHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+JiwgdW5zaWduZWQgbG9uZywgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+IGNvbnN0JiksIHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4+KiwgdW5zaWduZWQgbG9uZywgc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+KimaAbYBdm9pZCBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEFjdHVhbFR5cGU8c3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4+KHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+KimbAW9zdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+Pjo6cHVzaF9iYWNrW2FiaTpuZTE5MDEwNl0odW5zaWduZWQgaW50IGNvbnN0JimcAc8DZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIHZvaWQgKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+OjoqKSh1bnNpZ25lZCBpbnQgY29uc3QmKSwgdm9pZCwgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4qLCB1bnNpZ25lZCBpbnQgY29uc3QmPjo6aW52b2tlKHZvaWQgKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+OjoqIGNvbnN0JikodW5zaWduZWQgaW50IGNvbnN0JiksIHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+KiwgdW5zaWduZWQgaW50KZ0BbXN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+OjpyZXNpemUodW5zaWduZWQgbG9uZywgdW5zaWduZWQgaW50IGNvbnN0JimeAYsEZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcsIHZvaWQgKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+OjoqKSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBpbnQgY29uc3QmKSwgdm9pZCwgc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4qLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBpbnQgY29uc3QmPjo6aW52b2tlKHZvaWQgKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+OjoqIGNvbnN0JikodW5zaWduZWQgbG9uZywgdW5zaWduZWQgaW50IGNvbnN0JiksIHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+KiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgaW50KZ8BwwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6VmVjdG9yQWNjZXNzPHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+Pjo6Z2V0KHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZymgAaIEZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkZ1bmN0aW9uSW52b2tlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6cnZwOjpkZWZhdWx0X3RhZywgc3RkOjpfXzI6Om9wdGlvbmFsPHVuc2lnbmVkIGludD4gKCopKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZyksIHN0ZDo6X18yOjpvcHRpb25hbDx1bnNpZ25lZCBpbnQ+LCBzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmc+OjppbnZva2Uoc3RkOjpfXzI6Om9wdGlvbmFsPHVuc2lnbmVkIGludD4gKCoqKShzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiBjb25zdCYsIHVuc2lnbmVkIGxvbmcpLCBzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiosIHVuc2lnbmVkIGxvbmcpoQHSAWVtc2NyaXB0ZW46OmludGVybmFsOjpWZWN0b3JBY2Nlc3M8c3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4+OjpzZXQoc3RkOjpfXzI6OnZlY3Rvcjx1bnNpZ25lZCBpbnQsIHN0ZDo6X18yOjphbGxvY2F0b3I8dW5zaWduZWQgaW50Pj4mLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBpbnQgY29uc3QmKaIBiQRlbXNjcmlwdGVuOjppbnRlcm5hbDo6RnVuY3Rpb25JbnZva2VyPGVtc2NyaXB0ZW46OmludGVybmFsOjpydnA6OmRlZmF1bHRfdGFnLCBib29sICgqKShzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiYsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGludCBjb25zdCYpLCBib29sLCBzdGQ6Ol9fMjo6dmVjdG9yPHVuc2lnbmVkIGludCwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+PiYsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGludCBjb25zdCY+OjppbnZva2UoYm9vbCAoKiopKHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+JiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgaW50IGNvbnN0JiksIHN0ZDo6X18yOjp2ZWN0b3I8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGludD4+KiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgaW50KaMBYmhuc3dsaWI6OkJydXRlZm9yY2VTZWFyY2g8ZmxvYXQ+OjpCcnV0ZWZvcmNlU2VhcmNoKGhuc3dsaWI6OlNwYWNlSW50ZXJmYWNlPGZsb2F0PiosIHVuc2lnbmVkIGxvbmcppAGpAWhuc3dsaWI6OkJydXRlZm9yY2VTZWFyY2g8ZmxvYXQ+Ojpsb2FkSW5kZXgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgaG5zd2xpYjo6U3BhY2VJbnRlcmZhY2U8ZmxvYXQ+KimlAeABc3RkOjpfXzI6OnVub3JkZXJlZF9tYXA8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgc3RkOjpfXzI6Omhhc2g8dW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjplcXVhbF90bzx1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6cGFpcjx1bnNpZ25lZCBsb25nIGNvbnN0LCB1bnNpZ25lZCBsb25nPj4+Ojp+dW5vcmRlcmVkX21hcFthYmk6bmUxOTAxMDZdKCmmAdoBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpmaW5kW2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgbG9uZykgY29uc3SnAZoHc3RkOjpfXzI6OnBhaXI8c3RkOjpfXzI6Ol9faGFzaF9pdGVyYXRvcjxzdGQ6Ol9fMjo6X19oYXNoX25vZGU8c3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCB2b2lkKj4qPiwgYm9vbD4gc3RkOjpfXzI6Ol9faGFzaF90YWJsZTxzdGQ6Ol9fMjo6X19oYXNoX3ZhbHVlX3R5cGU8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjpfX3Vub3JkZXJlZF9tYXBfaGFzaGVyPHVuc2lnbmVkIGxvbmcsIHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6Omhhc2g8dW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjplcXVhbF90bzx1bnNpZ25lZCBsb25nPiwgdHJ1ZT4sIHN0ZDo6X18yOjpfX3Vub3JkZXJlZF9tYXBfZXF1YWw8dW5zaWduZWQgbG9uZywgc3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6ZXF1YWxfdG88dW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjpoYXNoPHVuc2lnbmVkIGxvbmc+LCB0cnVlPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6X19oYXNoX3ZhbHVlX3R5cGU8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4+Pjo6X19lbXBsYWNlX3VuaXF1ZV9rZXlfYXJnczx1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6cGllY2V3aXNlX2NvbnN0cnVjdF90IGNvbnN0Jiwgc3RkOjpfXzI6OnR1cGxlPHVuc2lnbmVkIGxvbmcgY29uc3QmPiwgc3RkOjpfXzI6OnR1cGxlPD4+KHVuc2lnbmVkIGxvbmcgY29uc3QmLCBzdGQ6Ol9fMjo6cGllY2V3aXNlX2NvbnN0cnVjdF90IGNvbnN0Jiwgc3RkOjpfXzI6OnR1cGxlPHVuc2lnbmVkIGxvbmcgY29uc3QmPiYmLCBzdGQ6Ol9fMjo6dHVwbGU8PiYmKagBywR1bnNpZ25lZCBsb25nIHN0ZDo6X18yOjpfX2hhc2hfdGFibGU8c3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6X191bm9yZGVyZWRfbWFwX2hhc2hlcjx1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6X19oYXNoX3ZhbHVlX3R5cGU8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjpoYXNoPHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6ZXF1YWxfdG88dW5zaWduZWQgbG9uZz4sIHRydWU+LCBzdGQ6Ol9fMjo6X191bm9yZGVyZWRfbWFwX2VxdWFsPHVuc2lnbmVkIGxvbmcsIHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6OmVxdWFsX3RvPHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6aGFzaDx1bnNpZ25lZCBsb25nPiwgdHJ1ZT4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+Pj46Ol9fZXJhc2VfdW5pcXVlPHVuc2lnbmVkIGxvbmc+KHVuc2lnbmVkIGxvbmcgY29uc3QmKakBQnN0ZDo6aW52YWxpZF9hcmd1bWVudDo6aW52YWxpZF9hcmd1bWVudFthYmk6bmUxOTAxMDZdKGNoYXIgY29uc3QqKaoBP3ZvaWQgZW1zY3JpcHRlbjo6dmFsOjpzZXQ8aW50LCBmbG9hdD4oaW50IGNvbnN0JiwgZmxvYXQgY29uc3QmKasBT3ZvaWQgZW1zY3JpcHRlbjo6dmFsOjpzZXQ8aW50LCB1bnNpZ25lZCBsb25nPihpbnQgY29uc3QmLCB1bnNpZ25lZCBsb25nIGNvbnN0JimsAe4Bc3RkOjpfXzI6OnByaW9yaXR5X3F1ZXVlPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6cGFpcjxmbG9hdCwgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGxvbmc+Pj4sIHN0ZDo6X18yOjpsZXNzPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBsb25nPj4+Ojpwb3AoKa0BkwFobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+OjpIaWVyYXJjaGljYWxOU1coaG5zd2xpYjo6U3BhY2VJbnRlcmZhY2U8ZmxvYXQ+KiwgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgYm9vbCmuATBlbXNjcmlwdGVuOjpIaWVyYXJjaGljYWxOU1c6OnVwZGF0ZUxhYmVsQ2FjaGVzKCmvATtobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+OjpyZXNpemVJbmRleCh1bnNpZ25lZCBsb25nKbABf3N0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+PiBobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+OjpnZXREYXRhQnlMYWJlbDxmbG9hdD4odW5zaWduZWQgbG9uZykgY29uc3SxATpobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+OjptYXJrRGVsZXRlKHVuc2lnbmVkIGxvbmcpsgE8aG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6dW5tYXJrRGVsZXRlKHVuc2lnbmVkIGxvbmcpswExc3RkOjpfX3Rocm93X2JhZF9hcnJheV9uZXdfbGVuZ3RoW2FiaTpuZTE5MDEwNl0oKbQBOXN0ZDo6X18yOjpfX3Rocm93X2xlbmd0aF9lcnJvclthYmk6bmUxOTAxMDZdKGNoYXIgY29uc3QqKbUBqwFzdGQ6Ol9fMjo6X19zcGxpdF9idWZmZXI8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj4mPjo6fl9fc3BsaXRfYnVmZmVyKCm2AbICc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6R2VuZXJpY0JpbmRpbmdUeXBlPHN0ZDo6X18yOjp2ZWN0b3I8ZmxvYXQsIHN0ZDo6X18yOjphbGxvY2F0b3I8ZmxvYXQ+Pj46OnRvV2lyZVR5cGU8c3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+Jj4oc3RkOjpfXzI6OnZlY3RvcjxmbG9hdCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxmbG9hdD4+JiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OnJ2cDo6ZGVmYXVsdF90YWcptwEqZW1zY3JpcHRlbjo6TDJTcGFjZTo6TDJTcGFjZSh1bnNpZ25lZCBpbnQpuAE1aG5zd2xpYjo6TDJTcXIodm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0Kim5ASFobnN3bGliOjpMMlNwYWNlOjpnZXRfZGF0YV9zaXplKCm6ASFobnN3bGliOjpMMlNwYWNlOjpnZXRfZGlzdF9mdW5jKCm7ASdobnN3bGliOjpMMlNwYWNlOjpnZXRfZGlzdF9mdW5jX3BhcmFtKCm8ARxobnN3bGliOjpMMlNwYWNlOjp+TDJTcGFjZSgpvQFEaG5zd2xpYjo6SW5uZXJQcm9kdWN0RGlzdGFuY2Uodm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0Kim+ATFobnN3bGliOjpTcGFjZUludGVyZmFjZTxmbG9hdD46On5TcGFjZUludGVyZmFjZSgpvwE6ZW1zY3JpcHRlbjo6Q3VzdG9tRmlsdGVyRnVuY3Rvcjo6b3BlcmF0b3IoKSh1bnNpZ25lZCBsb25nKcABTGhuc3dsaWI6OkJydXRlZm9yY2VTZWFyY2g8ZmxvYXQ+OjphZGRQb2ludCh2b2lkIGNvbnN0KiwgdW5zaWduZWQgbG9uZywgYm9vbCnBAWpobnN3bGliOjpCcnV0ZWZvcmNlU2VhcmNoPGZsb2F0Pjo6c2VhcmNoS25uKHZvaWQgY29uc3QqLCB1bnNpZ25lZCBsb25nLCBobnN3bGliOjpCYXNlRmlsdGVyRnVuY3RvciopIGNvbnN0wgGVAnN0ZDo6X18yOjpwcmlvcml0eV9xdWV1ZTxzdGQ6Ol9fMjo6cGFpcjxmbG9hdCwgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBsb25nPj4+LCBzdGQ6Ol9fMjo6bGVzczxzdGQ6Ol9fMjo6cGFpcjxmbG9hdCwgdW5zaWduZWQgbG9uZz4+Pjo6cHVzaChzdGQ6Ol9fMjo6cGFpcjxmbG9hdCwgdW5zaWduZWQgbG9uZz4mJinDAXdobnN3bGliOjpBbGdvcml0aG1JbnRlcmZhY2U8ZmxvYXQ+OjpzZWFyY2hLbm5DbG9zZXJGaXJzdCh2b2lkIGNvbnN0KiwgdW5zaWduZWQgbG9uZywgaG5zd2xpYjo6QmFzZUZpbHRlckZ1bmN0b3IqKSBjb25zdMQBiAFobnN3bGliOjpCcnV0ZWZvcmNlU2VhcmNoPGZsb2F0Pjo6c2F2ZUluZGV4KHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYpxQG2AXN0ZDo6X18yOjpiYXNpY19vZnN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpiYXNpY19vZnN0cmVhbShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCB1bnNpZ25lZCBpbnQpxgFOc3RkOjpfXzI6OmJhc2ljX29mc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19vZnN0cmVhbSgpxwE1aG5zd2xpYjo6QnJ1dGVmb3JjZVNlYXJjaDxmbG9hdD46On5CcnV0ZWZvcmNlU2VhcmNoKCnIATlobnN3bGliOjpCcnV0ZWZvcmNlU2VhcmNoPGZsb2F0Pjo6fkJydXRlZm9yY2VTZWFyY2goKV8yNTnJAa8Edm9pZCBzdGQ6Ol9fMjo6X19oYXNoX3RhYmxlPHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6Ol9fdW5vcmRlcmVkX21hcF9oYXNoZXI8dW5zaWduZWQgbG9uZywgc3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6aGFzaDx1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6OmVxdWFsX3RvPHVuc2lnbmVkIGxvbmc+LCB0cnVlPiwgc3RkOjpfXzI6Ol9fdW5vcmRlcmVkX21hcF9lcXVhbDx1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6X19oYXNoX3ZhbHVlX3R5cGU8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjplcXVhbF90bzx1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6Omhhc2g8dW5zaWduZWQgbG9uZz4sIHRydWU+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPj4+OjpfX2RvX3JlaGFzaDx0cnVlPih1bnNpZ25lZCBsb25nKcoBtgFzdGQ6Ol9fMjo6YmFzaWNfaWZzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6YmFzaWNfaWZzdHJlYW0oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50KcsBTnN0ZDo6X18yOjpiYXNpY19pZnN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfaWZzdHJlYW0oKcwBiwVzdGQ6Ol9fMjo6X19oYXNoX3RhYmxlPHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6Ol9fdW5vcmRlcmVkX21hcF9oYXNoZXI8dW5zaWduZWQgbG9uZywgc3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCBzdGQ6Ol9fMjo6aGFzaDx1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6OmVxdWFsX3RvPHVuc2lnbmVkIGxvbmc+LCB0cnVlPiwgc3RkOjpfXzI6Ol9fdW5vcmRlcmVkX21hcF9lcXVhbDx1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6X19oYXNoX3ZhbHVlX3R5cGU8dW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZz4sIHN0ZDo6X18yOjplcXVhbF90bzx1bnNpZ25lZCBsb25nPiwgc3RkOjpfXzI6Omhhc2g8dW5zaWduZWQgbG9uZz4sIHRydWU+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpfX2hhc2hfdmFsdWVfdHlwZTx1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nPj4+OjpyZW1vdmUoc3RkOjpfXzI6Ol9faGFzaF9jb25zdF9pdGVyYXRvcjxzdGQ6Ol9fMjo6X19oYXNoX25vZGU8c3RkOjpfXzI6Ol9faGFzaF92YWx1ZV90eXBlPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+LCB2b2lkKj4qPinNAfQBZW1zY3JpcHRlbjo6SGllcmFyY2hpY2FsTlNXOjpIaWVyYXJjaGljYWxOU1coc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKc4BsAFzdGQ6Ol9fMjo6X19leGNlcHRpb25fZ3VhcmRfZXhjZXB0aW9uczxzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjptdXRleCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6bXV0ZXg+Pjo6X19kZXN0cm95X3ZlY3Rvcj46On5fX2V4Y2VwdGlvbl9ndWFyZF9leGNlcHRpb25zW2FiaTpuZTE5MDEwNl0oKc8BM2huc3dsaWI6OlZpc2l0ZWRMaXN0UG9vbDo6VmlzaXRlZExpc3RQb29sKGludCwgaW50KdABYHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6Om11dGV4LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjptdXRleD4+Ojp+dmVjdG9yW2FiaTpuZTE5MDEwNl0oKdEBanN0ZDo6X18yOjpkZXF1ZTxobnN3bGliOjpWaXNpdGVkTGlzdCosIHN0ZDo6X18yOjphbGxvY2F0b3I8aG5zd2xpYjo6VmlzaXRlZExpc3QqPj46Ol9fYWRkX2Zyb250X2NhcGFjaXR5KCnSAWpzdGQ6Ol9fMjo6ZGVxdWU8aG5zd2xpYjo6VmlzaXRlZExpc3QqLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGhuc3dsaWI6OlZpc2l0ZWRMaXN0Kj4+Ojp+ZGVxdWVbYWJpOm5lMTkwMTA2XSgp0wFLaG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6YWRkUG9pbnQodm9pZCBjb25zdCosIHVuc2lnbmVkIGxvbmcsIGJvb2wp1AFKaG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6YWRkUG9pbnQodm9pZCBjb25zdCosIHVuc2lnbmVkIGxvbmcsIGludCnVAURobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+Ojp1bm1hcmtEZWxldGVkSW50ZXJuYWwodW5zaWduZWQgaW50KdYBTmhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OnVwZGF0ZVBvaW50KHZvaWQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIGZsb2F0KdcBaWhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OnNlYXJjaEtubih2b2lkIGNvbnN0KiwgdW5zaWduZWQgbG9uZywgaG5zd2xpYjo6QmFzZUZpbHRlckZ1bmN0b3IqKSBjb25zdNgBhwFobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+OjpzYXZlSW5kZXgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JinZATNobnN3bGliOjpIaWVyYXJjaGljYWxOU1c8ZmxvYXQ+Ojp+SGllcmFyY2hpY2FsTlNXKCnaASxobnN3bGliOjpWaXNpdGVkTGlzdFBvb2w6On5WaXNpdGVkTGlzdFBvb2woKdsBN2huc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46On5IaWVyYXJjaGljYWxOU1coKV8yODjcAYgBc3RkOjpfXzI6Ol9fc3BsaXRfYnVmZmVyPGhuc3dsaWI6OlZpc2l0ZWRMaXN0KiosIHN0ZDo6X18yOjphbGxvY2F0b3I8aG5zd2xpYjo6VmlzaXRlZExpc3QqKj4+OjpwdXNoX2Zyb250KGhuc3dsaWI6OlZpc2l0ZWRMaXN0KiogY29uc3QmKd0BUGhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OnNlYXJjaEJhc2VMYXllcih1bnNpZ25lZCBpbnQsIHZvaWQgY29uc3QqLCBpbnQp3gGbAnZvaWQgc3RkOjpfXzI6OnByaW9yaXR5X3F1ZXVlPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBpbnQ+LCBzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBpbnQ+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpwYWlyPGZsb2F0LCB1bnNpZ25lZCBpbnQ+Pj4sIGhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OkNvbXBhcmVCeUZpcnN0Pjo6ZW1wbGFjZTxmbG9hdCwgdW5zaWduZWQgaW50Jj4oZmxvYXQmJiwgdW5zaWduZWQgaW50JinfAcICaG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6bXV0dWFsbHlDb25uZWN0TmV3RWxlbWVudCh2b2lkIGNvbnN0KiwgdW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6cHJpb3JpdHlfcXVldWU8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4sIHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4+PiwgaG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6Q29tcGFyZUJ5Rmlyc3Q+JiwgaW50LCBib29sKeABbmhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OnJlcGFpckNvbm5lY3Rpb25zRm9yVXBkYXRlKHZvaWQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgaW50LCBpbnQp4QHMAnN0ZDo6X18yOjpwYWlyPHN0ZDo6X18yOjpfX2hhc2hfaXRlcmF0b3I8c3RkOjpfXzI6Ol9faGFzaF9ub2RlPHVuc2lnbmVkIGludCwgdm9pZCo+Kj4sIGJvb2w+IHN0ZDo6X18yOjpfX2hhc2hfdGFibGU8dW5zaWduZWQgaW50LCBzdGQ6Ol9fMjo6aGFzaDx1bnNpZ25lZCBpbnQ+LCBzdGQ6Ol9fMjo6ZXF1YWxfdG88dW5zaWduZWQgaW50Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBpbnQ+Pjo6X19lbXBsYWNlX3VuaXF1ZV9rZXlfYXJnczx1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCBjb25zdCY+KHVuc2lnbmVkIGludCBjb25zdCYsIHVuc2lnbmVkIGludCBjb25zdCYp4gGqAmhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OmdldE5laWdoYm9yc0J5SGV1cmlzdGljMihzdGQ6Ol9fMjo6cHJpb3JpdHlfcXVldWU8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4sIHN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OnBhaXI8ZmxvYXQsIHVuc2lnbmVkIGludD4+PiwgaG5zd2xpYjo6SGllcmFyY2hpY2FsTlNXPGZsb2F0Pjo6Q29tcGFyZUJ5Rmlyc3Q+JiwgdW5zaWduZWQgbG9uZynjAS5obnN3bGliOjpWaXNpdGVkTGlzdFBvb2w6OmdldEZyZWVWaXNpdGVkTGlzdCgp5AG3AWhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46OmxvYWRJbmRleChzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCBobnN3bGliOjpTcGFjZUludGVyZmFjZTxmbG9hdD4qLCB1bnNpZ25lZCBsb25nKeUBQmhuc3dsaWI6OkhpZXJhcmNoaWNhbE5TVzxmbG9hdD46Om1hcmtEZWxldGVkSW50ZXJuYWwodW5zaWduZWQgaW50KeYBA2xvZ+cBBm1lbWNocugBBm1lbWNtcOkBB2lwcmludGbqAQpfX2xvY2tmaWxl6wEVZW1zY3JpcHRlbl9mdXRleF93YWtl7AEUX19wdGhyZWFkX211dGV4X2xvY2vtAQlfX3Rvd3JpdGXuAQhfX21lbWNwee8BCV9fZndyaXRlePABBmZ3cml0ZfEBCl9fb3ZlcmZsb3fyAQRwdXRz8wENX19zdGRpb193cml0ZfQBGF9fZW1zY3JpcHRlbl9zdGRvdXRfc2Vla/UBBnN0cmxlbvYBBWZyZXhw9wEIX19tZW1zZXT4ARNfX3ZmcHJpbnRmX2ludGVybmFs+QELcHJpbnRmX2NvcmX6AQNvdXT7AQZnZXRpbnT8AQdwb3BfYXJn/QEFZm10X3X+AQNwYWT/AQZmbXRfZnCAAhNwb3BfYXJnX2xvbmdfZG91YmxlgQIHd2NydG9tYoICBndjdG9tYoMCBWFib3J0hAINX19zdGRpb19jbG9zZYUCDF9fc3RkaW9fc2Vla4YCGWVtc2NyaXB0ZW5fYnVpbHRpbl9tYWxsb2OHAhdlbXNjcmlwdGVuX2J1aWx0aW5fZnJlZYgCGmVtc2NyaXB0ZW5fYnVpbHRpbl9yZWFsbG9jiQINZGlzcG9zZV9jaHVua4oCBHNicmuLAhVlbXNjcmlwdGVuX3N0YWNrX2luaXSMAhllbXNjcmlwdGVuX3N0YWNrX2dldF9mcmVljQIZZW1zY3JpcHRlbl9zdGFja19nZXRfYmFzZY4CGGVtc2NyaXB0ZW5fc3RhY2tfZ2V0X2VuZI8CCV9fYXNobHRpM5ACCV9fbHNocnRpM5ECDF9fdHJ1bmN0ZmRmMpICJXN0ZDo6X18yOjpfX25leHRfcHJpbWUodW5zaWduZWQgbG9uZymTAtcBdW5zaWduZWQgaW50IGNvbnN0KiBzdGQ6Ol9fMjo6bG93ZXJfYm91bmRbYWJpOm5lMTkwMTA2XTx1bnNpZ25lZCBpbnQgY29uc3QqLCB1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6X19sZXNzPHZvaWQsIHZvaWQ+Pih1bnNpZ25lZCBpbnQgY29uc3QqLCB1bnNpZ25lZCBpbnQgY29uc3QqLCB1bnNpZ25lZCBsb25nIGNvbnN0Jiwgc3RkOjpfXzI6Ol9fbGVzczx2b2lkLCB2b2lkPimUAjtzdGQ6Ol9fMjo6X190aHJvd19vdmVyZmxvd19lcnJvclthYmk6bmUxOTAxMDZdKGNoYXIgY29uc3QqKZUCcnVuc2lnbmVkIGludCBjb25zdCYgc3RkOjpfXzI6Ol9faWRlbnRpdHk6Om9wZXJhdG9yKClbYWJpOm5lMTkwMTA2XTx1bnNpZ25lZCBpbnQgY29uc3QmPih1bnNpZ25lZCBpbnQgY29uc3QmKSBjb25zdJYCC19fc3RyY2hybnVslwIGc3RyY2hymAIMX19zdGRpb19yZWFkmQIGZmZsdXNomgIGZmNsb3NlmwIRX19mc2Vla29fdW5sb2NrZWScAghfX2ZzZWVrb50CCF9fdG9yZWFkngIFZnJlYWSfAhFfX2Z0ZWxsb191bmxvY2tlZKACRHN0ZDo6X18yOjpiYXNpY19pb3M8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX2lvcygpoQJQc3RkOjpfXzI6OmJhc2ljX3N0cmVhbWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfc3RyZWFtYnVmKCmiAlRzdGQ6Ol9fMjo6YmFzaWNfc3RyZWFtYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19zdHJlYW1idWYoKV80NDijAlxzdGQ6Ol9fMjo6YmFzaWNfc3RyZWFtYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OmltYnVlKHN0ZDo6X18yOjpsb2NhbGUgY29uc3QmKaQCUXN0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2V0YnVmKGNoYXIqLCBsb25nKaUCe3N0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2Vla29mZihsb25nIGxvbmcsIHN0ZDo6X18yOjppb3NfYmFzZTo6c2Vla2RpciwgdW5zaWduZWQgaW50KaYCcHN0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2Vla3BvcyhzdGQ6Ol9fMjo6ZnBvczxfX21ic3RhdGVfdD4sIHVuc2lnbmVkIGludCmnAlFzdGQ6Ol9fMjo6YmFzaWNfc3RyZWFtYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OnhzZ2V0bihjaGFyKiwgbG9uZymoAklzdGQ6Ol9fMjo6YmFzaWNfc3RyZWFtYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OnVuZGVyZmxvdygpqQJFc3RkOjpfXzI6OmJhc2ljX3N0cmVhbWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp1ZmxvdygpqgJMc3RkOjpfXzI6OmJhc2ljX3N0cmVhbWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpwYmFja2ZhaWwoaW50KasCV3N0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6eHNwdXRuKGNoYXIgY29uc3QqLCBsb25nKawCTHN0ZDo6X18yOjpiYXNpY19pc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19pc3RyZWFtKCmtAlBzdGQ6Ol9fMjo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfaXN0cmVhbSgpXzQ3Mq4CXXZpcnR1YWwgdGh1bmsgdG8gc3RkOjpfXzI6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX2lzdHJlYW0oKa8CUHN0ZDo6X18yOjpiYXNpY19pc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19pc3RyZWFtKClfNDc0sAJhdmlydHVhbCB0aHVuayB0byBzdGQ6Ol9fMjo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfaXN0cmVhbSgpXzQ3NbECjQFzdGQ6Ol9fMjo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpzZW50cnk6OnNlbnRyeShzdGQ6Ol9fMjo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+JiwgYm9vbCmyAkNzdGQ6Ol9fMjo6YmFzaWNfb3N0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpmbHVzaCgpswLcAWJvb2wgc3RkOjpfXzI6Om9wZXJhdG9yPT1bYWJpOm5lMTkwMTA2XTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4gY29uc3QmLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+IGNvbnN0Jim0AlxzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpvcGVyYXRvcisrW2FiaTpuZTE5MDEwNl0oKbUCVHN0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2J1bXBjW2FiaTpuZTE5MDEwNl0oKbYCOHN0ZDo6X18yOjppb3NfYmFzZTo6c2V0c3RhdGVbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBpbnQptwJNc3RkOjpfXzI6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6cmVhZChjaGFyKiwgbG9uZym4AkNzdGQ6Ol9fMjo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp0ZWxsZygpuQJpc3RkOjpfXzI6OmJhc2ljX2lzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2Vla2cobG9uZyBsb25nLCBzdGQ6Ol9fMjo6aW9zX2Jhc2U6OnNlZWtkaXIpugJQc3RkOjpfXzI6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX29zdHJlYW0oKV81MTa7Al12aXJ0dWFsIHRodW5rIHRvIHN0ZDo6X18yOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19vc3RyZWFtKCm8AlBzdGQ6Ol9fMjo6YmFzaWNfb3N0cmVhbTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfb3N0cmVhbSgpXzUxOL0CYXZpcnR1YWwgdGh1bmsgdG8gc3RkOjpfXzI6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX29zdHJlYW0oKV81MTm+AocBc3RkOjpfXzI6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2VudHJ5OjpzZW50cnkoc3RkOjpfXzI6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiYpvwJNc3RkOjpfXzI6OmJhc2ljX29zdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2VudHJ5Ojp+c2VudHJ5KCnAAl9zdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpvcGVyYXRvcj1bYWJpOm5lMTkwMTA2XShjaGFyKcECVHN0ZDo6X18yOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OndyaXRlKGNoYXIgY29uc3QqLCBsb25nKcIC7gFib29sIHN0ZDo6X18yOjpvcGVyYXRvcj09W2FiaTpuZTE5MDEwNl08d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PihzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+IGNvbnN0Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiBjb25zdCYpwwJic3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pjo6b3BlcmF0b3IrK1thYmk6bmUxOTAxMDZdKCnEAlpzdGQ6Ol9fMjo6YmFzaWNfc3RyZWFtYnVmPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj46OnNidW1wY1thYmk6bmUxOTAxMDZdKCnFAmhzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+OjpvcGVyYXRvcj1bYWJpOm5lMTkwMTA2XSh3Y2hhcl90KcYCWHN0ZDo6X18yOjpiYXNpY19zdHJlYW1idWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6Z3B0clthYmk6bmUxOTAxMDZdKCkgY29uc3THAsUBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpvcGVyYXRvcj1bYWJpOm5lMTkwMTA2XShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4mJinIAnl2b2lkIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6X19pbml0PGNoYXIqLCAwPihjaGFyKiwgY2hhciopyQJ5c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpyZXNpemVbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nKcoCW3N0ZDo6X18yOjpiYXNpY19maWxlYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46Om9wZW4oY2hhciBjb25zdCosIHVuc2lnbmVkIGludCnLAktzdGQ6Ol9fMjo6YmFzaWNfZmlsZWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpiYXNpY19maWxlYnVmKCnMAkxzdGQ6Ol9fMjo6YmFzaWNfZmlsZWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ojp+YmFzaWNfZmlsZWJ1ZigpzQJDc3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6Y2xvc2UoKc4C1gFzdGQ6Ol9fMjo6dW5pcXVlX3B0cjxfSU9fRklMRSwgaW50ICgqKShfSU9fRklMRSopPjo6dW5pcXVlX3B0clthYmk6bmUxOTAxMDZdPHRydWUsIHZvaWQ+KF9JT19GSUxFKiwgc3RkOjpfXzI6Ol9fZGVwZW5kZW50X3R5cGU8c3RkOjpfXzI6Ol9fdW5pcXVlX3B0cl9kZWxldGVyX3NmaW5hZTxpbnQgKCopKF9JT19GSUxFKik+LCB0cnVlPjo6X19nb29kX3J2YWxfcmVmX3R5cGUpzwJQc3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX2ZpbGVidWYoKV81OTjQAlJzdGQ6Ol9fMjo6dW5pcXVlX3B0cjxfSU9fRklMRSwgaW50ICgqKShfSU9fRklMRSopPjo6cmVzZXRbYWJpOm5lMTkwMTA2XShfSU9fRklMRSop0QJHc3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6dW5kZXJmbG93KCnSAipzdGQ6Ol9fMjo6X190aHJvd19iYWRfY2FzdFthYmk6bmUxOTAxMDZdKCnTAkpzdGQ6Ol9fMjo6YmFzaWNfZmlsZWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpwYmFja2ZhaWwoaW50KdQCSXN0ZDo6X18yOjpiYXNpY19maWxlYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46Om92ZXJmbG93KGludCnVAk9zdGQ6Ol9fMjo6YmFzaWNfZmlsZWJ1ZjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpzZXRidWYoY2hhciosIGxvbmcp1gJ5c3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c2Vla29mZihsb25nIGxvbmcsIHN0ZDo6X18yOjppb3NfYmFzZTo6c2Vla2RpciwgdW5zaWduZWQgaW50KdcCbnN0ZDo6X18yOjpiYXNpY19maWxlYnVmPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OnNlZWtwb3Moc3RkOjpfXzI6OmZwb3M8X19tYnN0YXRlX3Q+LCB1bnNpZ25lZCBpbnQp2AJCc3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6c3luYygp2QJac3RkOjpfXzI6OmJhc2ljX2ZpbGVidWY8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6aW1idWUoc3RkOjpfXzI6OmxvY2FsZSBjb25zdCYp2gJSc3RkOjpfXzI6OmJhc2ljX2lmc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19pZnN0cmVhbSgpXzYyNdsCX3ZpcnR1YWwgdGh1bmsgdG8gc3RkOjpfXzI6OmJhc2ljX2lmc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19pZnN0cmVhbSgp3AJjdmlydHVhbCB0aHVuayB0byBzdGQ6Ol9fMjo6YmFzaWNfaWZzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX2lmc3RyZWFtKClfNjI33QJSc3RkOjpfXzI6OmJhc2ljX29mc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19vZnN0cmVhbSgpXzYyON4CX3ZpcnR1YWwgdGh1bmsgdG8gc3RkOjpfXzI6OmJhc2ljX29mc3RyZWFtPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46On5iYXNpY19vZnN0cmVhbSgp3wJjdmlydHVhbCB0aHVuayB0byBzdGQ6Ol9fMjo6YmFzaWNfb2ZzdHJlYW08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6fmJhc2ljX29mc3RyZWFtKClfNjMw4AKBAXN0ZDo6X18yOjphbGxvY2F0b3JfdHJhaXRzPHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpkZWFsbG9jYXRlW2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiYsIGNoYXIqLCB1bnNpZ25lZCBsb25nKeECUHN0ZDo6X18yOjpfX2xpYmNwcF9kZWFsbG9jYXRlW2FiaTpuZTE5MDEwNl0odm9pZCosIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcp4gJJc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPjo6YWxsb2NhdGVfYXRfbGVhc3RbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nKeMCR3N0ZDo6X18yOjpfX2xpYmNwcF9hbGxvY2F0ZVthYmk6bmUxOTAxMDZdKHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcp5AJmc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6X190ZXN0X2Zvcl9lb2ZbYWJpOm5lMTkwMTA2XSgpIGNvbnN05QJsc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pjo6X190ZXN0X2Zvcl9lb2ZbYWJpOm5lMTkwMTA2XSgpIGNvbnN05gI8c3RkOjpfXzI6OmVycm9yX2NhdGVnb3J5OjpkZWZhdWx0X2Vycm9yX2NvbmRpdGlvbihpbnQpIGNvbnN05wJRc3RkOjpfXzI6OmVycm9yX2NhdGVnb3J5OjplcXVpdmFsZW50KGludCwgc3RkOjpfXzI6OmVycm9yX2NvbmRpdGlvbiBjb25zdCYpIGNvbnN06AJMc3RkOjpfXzI6OmVycm9yX2NhdGVnb3J5OjplcXVpdmFsZW50KHN0ZDo6X18yOjplcnJvcl9jb2RlIGNvbnN0JiwgaW50KSBjb25zdOkCK3N0ZDo6X18yOjpfX2lvc3RyZWFtX2NhdGVnb3J5OjpuYW1lKCkgY29uc3TqAjFzdGQ6Ol9fMjo6X19pb3N0cmVhbV9jYXRlZ29yeTo6bWVzc2FnZShpbnQpIGNvbnN06wInc3RkOjpfXzI6Omlvc19iYXNlOjpmYWlsdXJlOjp+ZmFpbHVyZSgp7AIrc3RkOjpfXzI6Omlvc19iYXNlOjpmYWlsdXJlOjp+ZmFpbHVyZSgpXzcxNO0CJ3N0ZDo6X18yOjppb3NfYmFzZTo6Y2xlYXIodW5zaWduZWQgaW50Ke4CH3N0ZDo6X18yOjppb3NfYmFzZTo6fmlvc19iYXNlKCnvAiNzdGQ6Ol9fMjo6aW9zX2Jhc2U6On5pb3NfYmFzZSgpXzcyMfACNHN0ZDo6X18yOjpfX3Rocm93X2ZhaWx1cmVbYWJpOm5lMTkwMTA2XShjaGFyIGNvbnN0KinxAh9zdGQ6Ol9fMjo6aW9zX2Jhc2U6OmluaXQodm9pZCop8gI3c3RkOjpfXzI6Omlvc19iYXNlOjpfX3NldF9iYWRiaXRfYW5kX2NvbnNpZGVyX3JldGhyb3coKfMCB19fc2hsaW30AghfX3NoZ2V0Y/UCC19fZmxvYXRzaXRm9gIIX19tdWx0ZjP3AghfX2FkZHRmM/gCDV9fZXh0ZW5kZGZ0ZjL5AgdfX2xldGYy+gIHX19nZXRmMvsCBnNjYWxibvwCCWNvcHlzaWdubP0CDV9fZmxvYXR1bnNpdGb+AghfX3N1YnRmM/8CB3NjYWxibmyAAwhfX211bHRpM4EDCF9fZGl2dGYzggMFZm1vZGyDAwtfX2Zsb2F0c2NhboQDB3NjYW5leHCFAwxfX3RydW5jdGZzZjKGAwdtYnJ0b3djhwMJc3RvcmVfaW50iAMHdnNzY2FuZokDC3N0cmluZ19yZWFkigMGZ2V0ZW52iwMGc3RyY21wjAMMX19nZXRfbG9jYWxljQMJdnNucHJpbnRmjgMIc25fd3JpdGWPAwhzbnByaW50ZpADD19fbmxfbGFuZ2luZm9fbJEDBnN0cnRveJIDCHdlZWtfbnVtkwMMX19zdHJmdGltZV9slAMHaXNfbGVhcJUDBnNzY2FuZpYDCmZyZWVsb2NhbGWXAwZzdHJjcHmYAwltYnNydG93Y3OZAwpzdHJ0b3hfODMzmgNdc3RkOjpfXzI6OmNvbGxhdGU8Y2hhcj46OmRvX2NvbXBhcmUoY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCopIGNvbnN0mwNFc3RkOjpfXzI6OmNvbGxhdGU8Y2hhcj46OmRvX3RyYW5zZm9ybShjaGFyIGNvbnN0KiwgY2hhciBjb25zdCopIGNvbnN0nAOaAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YmFzaWNfc3RyaW5nW2FiaTpuZTE5MDEwNl08Y2hhciBjb25zdCosIDA+KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KimdA0BzdGQ6Ol9fMjo6Y29sbGF0ZTxjaGFyPjo6ZG9faGFzaChjaGFyIGNvbnN0KiwgY2hhciBjb25zdCopIGNvbnN0ngNsc3RkOjpfXzI6OmNvbGxhdGU8d2NoYXJfdD46OmRvX2NvbXBhcmUod2NoYXJfdCBjb25zdCosIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0Kiwgd2NoYXJfdCBjb25zdCopIGNvbnN0nwNOc3RkOjpfXzI6OmNvbGxhdGU8d2NoYXJfdD46OmRvX3RyYW5zZm9ybSh3Y2hhcl90IGNvbnN0Kiwgd2NoYXJfdCBjb25zdCopIGNvbnN0oAOdAXZvaWQgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjpfX2luaXQ8d2NoYXJfdCBjb25zdCosIDA+KHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0KimhA0lzdGQ6Ol9fMjo6Y29sbGF0ZTx3Y2hhcl90Pjo6ZG9faGFzaCh3Y2hhcl90IGNvbnN0Kiwgd2NoYXJfdCBjb25zdCopIGNvbnN0ogOWAnN0ZDo6X18yOjpudW1fZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgYm9vbCYpIGNvbnN0owMbc3RkOjpfXzI6OmxvY2FsZTo6fmxvY2FsZSgppAOqBXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCogc3RkOjpfXzI6Ol9fc2Nhbl9rZXl3b3JkW2FiaTpuZTE5MDEwNl08c3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0Kiwgc3RkOjpfXzI6OmN0eXBlPGNoYXI+PihzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0Kiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0Kiwgc3RkOjpfXzI6OmN0eXBlPGNoYXI+IGNvbnN0JiwgdW5zaWduZWQgaW50JiwgYm9vbCmlAzhzdGQ6Ol9fMjo6bG9jYWxlOjp1c2VfZmFjZXQoc3RkOjpfXzI6OmxvY2FsZTo6aWQmKSBjb25zdKYDWXN0ZDo6X18yOjp1bmlxdWVfcHRyPHVuc2lnbmVkIGNoYXIsIHZvaWQgKCopKHZvaWQqKT46OnJlc2V0W2FiaTpuZTE5MDEwNl0odW5zaWduZWQgY2hhcioppwOWAnN0ZDo6X18yOjpudW1fZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgbG9uZyYpIGNvbnN0qAM5c3RkOjpfXzI6Ol9fbnVtX2dldF9iYXNlOjpfX2dldF9iYXNlKHN0ZDo6X18yOjppb3NfYmFzZSYpqQNIc3RkOjpfXzI6Ol9fbnVtX2dldDxjaGFyPjo6X19zdGFnZTJfaW50X3ByZXAoc3RkOjpfXzI6Omlvc19iYXNlJiwgY2hhciYpqgPkAXN0ZDo6X18yOjpfX251bV9nZXQ8Y2hhcj46Ol9fc3RhZ2UyX2ludF9sb29wKGNoYXIsIGludCwgY2hhciosIGNoYXIqJiwgdW5zaWduZWQgaW50JiwgY2hhciwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50KiwgdW5zaWduZWQgaW50KiYsIGNoYXIgY29uc3QqKasDamxvbmcgc3RkOjpfXzI6Ol9fbnVtX2dldF9zaWduZWRfaW50ZWdyYWxbYWJpOm5lMTkwMTA2XTxsb25nPihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCYsIGludCmsA6QBc3RkOjpfXzI6Ol9fY2hlY2tfZ3JvdXBpbmcoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50KiwgdW5zaWduZWQgaW50KiwgdW5zaWduZWQgaW50JimtA5sCc3RkOjpfXzI6Om51bV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBsb25nIGxvbmcmKSBjb25zdK4DdGxvbmcgbG9uZyBzdGQ6Ol9fMjo6X19udW1fZ2V0X3NpZ25lZF9pbnRlZ3JhbFthYmk6bmUxOTAxMDZdPGxvbmcgbG9uZz4oY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQmLCBpbnQprwOgAnN0ZDo6X18yOjpudW1fZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdW5zaWduZWQgc2hvcnQmKSBjb25zdLADgAF1bnNpZ25lZCBzaG9ydCBzdGQ6Ol9fMjo6X19udW1fZ2V0X3Vuc2lnbmVkX2ludGVncmFsW2FiaTpuZTE5MDEwNl08dW5zaWduZWQgc2hvcnQ+KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50JiwgaW50KbEDngJzdGQ6Ol9fMjo6bnVtX2dldDxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHVuc2lnbmVkIGludCYpIGNvbnN0sgN8dW5zaWduZWQgaW50IHN0ZDo6X18yOjpfX251bV9nZXRfdW5zaWduZWRfaW50ZWdyYWxbYWJpOm5lMTkwMTA2XTx1bnNpZ25lZCBpbnQ+KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50JiwgaW50KbMDpAJzdGQ6Ol9fMjo6bnVtX2dldDxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHVuc2lnbmVkIGxvbmcgbG9uZyYpIGNvbnN0tAOIAXVuc2lnbmVkIGxvbmcgbG9uZyBzdGQ6Ol9fMjo6X19udW1fZ2V0X3Vuc2lnbmVkX2ludGVncmFsW2FiaTpuZTE5MDEwNl08dW5zaWduZWQgbG9uZyBsb25nPihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCYsIGludCm1A5cCc3RkOjpfXzI6Om51bV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBmbG9hdCYpIGNvbnN0tgNYc3RkOjpfXzI6Ol9fbnVtX2dldDxjaGFyPjo6X19zdGFnZTJfZmxvYXRfcHJlcChzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyKiwgY2hhciYsIGNoYXImKbcD7wFzdGQ6Ol9fMjo6X19udW1fZ2V0PGNoYXI+OjpfX3N0YWdlMl9mbG9hdF9sb29wKGNoYXIsIGJvb2wmLCBjaGFyJiwgY2hhciosIGNoYXIqJiwgY2hhciwgY2hhciwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JiwgdW5zaWduZWQgaW50KiwgdW5zaWduZWQgaW50KiYsIHVuc2lnbmVkIGludCYsIGNoYXIqKbgDXWZsb2F0IHN0ZDo6X18yOjpfX251bV9nZXRfZmxvYXRbYWJpOm5lMTkwMTA2XTxmbG9hdD4oY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQmKbkDmAJzdGQ6Ol9fMjo6bnVtX2dldDxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIGRvdWJsZSYpIGNvbnN0ugNfZG91YmxlIHN0ZDo6X18yOjpfX251bV9nZXRfZmxvYXRbYWJpOm5lMTkwMTA2XTxkb3VibGU+KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50Jim7A50Cc3RkOjpfXzI6Om51bV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBsb25nIGRvdWJsZSYpIGNvbnN0vANpbG9uZyBkb3VibGUgc3RkOjpfXzI6Ol9fbnVtX2dldF9mbG9hdFthYmk6bmUxOTAxMDZdPGxvbmcgZG91YmxlPihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCYpvQOXAnN0ZDo6X18yOjpudW1fZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50Jiwgdm9pZComKSBjb25zdL4DEnN0ZDo6X18yOjpfX2Nsb2MoKb8DTHN0ZDo6X18yOjpfX2xpYmNwcF9zc2NhbmZfbChjaGFyIGNvbnN0KiwgX19sb2NhbGVfc3RydWN0KiwgY2hhciBjb25zdCosIC4uLinAA2JjaGFyIGNvbnN0KiBzdGQ6Ol9fMjo6ZmluZFthYmk6bmUxOTAxMDZdPGNoYXIgY29uc3QqLCBjaGFyPihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QmKcEDV3N0ZDo6X18yOjpfX2xpYmNwcF9sb2NhbGVfZ3VhcmQ6Ol9fbGliY3BwX2xvY2FsZV9ndWFyZFthYmk6bmUxOTAxMDZdKF9fbG9jYWxlX3N0cnVjdComKcIDqwJzdGQ6Ol9fMjo6bnVtX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIGJvb2wmKSBjb25zdMMD5gVzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj4gY29uc3QqIHN0ZDo6X18yOjpfX3NjYW5fa2V5d29yZFthYmk6bmUxOTAxMDZdPHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiBjb25zdCosIHN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90Pj4oc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiYsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiBjb25zdCosIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiBjb25zdCosIHN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90PiBjb25zdCYsIHVuc2lnbmVkIGludCYsIGJvb2wpxAOrAnN0ZDo6X18yOjpudW1fZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgbG9uZyYpIGNvbnN0xQNNc3RkOjpfXzI6Ol9fbnVtX2dldDx3Y2hhcl90Pjo6X19kb193aWRlbihzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB3Y2hhcl90KikgY29uc3TGA05zdGQ6Ol9fMjo6X19udW1fZ2V0PHdjaGFyX3Q+OjpfX3N0YWdlMl9pbnRfcHJlcChzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB3Y2hhcl90JinHA/ABc3RkOjpfXzI6Ol9fbnVtX2dldDx3Y2hhcl90Pjo6X19zdGFnZTJfaW50X2xvb3Aod2NoYXJfdCwgaW50LCBjaGFyKiwgY2hhciomLCB1bnNpZ25lZCBpbnQmLCB3Y2hhcl90LCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCB1bnNpZ25lZCBpbnQqLCB1bnNpZ25lZCBpbnQqJiwgd2NoYXJfdCBjb25zdCopyAOwAnN0ZDo6X18yOjpudW1fZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgbG9uZyBsb25nJikgY29uc3TJA7UCc3RkOjpfXzI6Om51bV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB1bnNpZ25lZCBzaG9ydCYpIGNvbnN0ygOzAnN0ZDo6X18yOjpudW1fZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdW5zaWduZWQgaW50JikgY29uc3TLA7kCc3RkOjpfXzI6Om51bV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB1bnNpZ25lZCBsb25nIGxvbmcmKSBjb25zdMwDrAJzdGQ6Ol9fMjo6bnVtX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIGZsb2F0JikgY29uc3TNA2RzdGQ6Ol9fMjo6X19udW1fZ2V0PHdjaGFyX3Q+OjpfX3N0YWdlMl9mbG9hdF9wcmVwKHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3QqLCB3Y2hhcl90Jiwgd2NoYXJfdCYpzgP+AXN0ZDo6X18yOjpfX251bV9nZXQ8d2NoYXJfdD46Ol9fc3RhZ2UyX2Zsb2F0X2xvb3Aod2NoYXJfdCwgYm9vbCYsIGNoYXImLCBjaGFyKiwgY2hhciomLCB3Y2hhcl90LCB3Y2hhcl90LCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCB1bnNpZ25lZCBpbnQqLCB1bnNpZ25lZCBpbnQqJiwgdW5zaWduZWQgaW50Jiwgd2NoYXJfdCopzwOtAnN0ZDo6X18yOjpudW1fZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgZG91YmxlJikgY29uc3TQA7ICc3RkOjpfXzI6Om51bV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBsb25nIGRvdWJsZSYpIGNvbnN00QOsAnN0ZDo6X18yOjpudW1fZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50Jiwgdm9pZComKSBjb25zdNIDdHdjaGFyX3QgY29uc3QqIHN0ZDo6X18yOjpmaW5kW2FiaTpuZTE5MDEwNl08d2NoYXJfdCBjb25zdCosIHdjaGFyX3Q+KHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0Kiwgd2NoYXJfdCBjb25zdCYp0wPKAXN0ZDo6X18yOjpudW1fcHV0PGNoYXIsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgY2hhciwgYm9vbCkgY29uc3TUA2tzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46OmJlZ2luW2FiaTpuZTE5MDEwNl0oKdUDaXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6ZW5kW2FiaTpuZTE5MDEwNl0oKdYDygFzdGQ6Ol9fMjo6bnVtX3B1dDxjaGFyLCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIGNoYXIsIGxvbmcpIGNvbnN01wNOc3RkOjpfXzI6Ol9fbnVtX3B1dF9iYXNlOjpfX2Zvcm1hdF9pbnQoY2hhciosIGNoYXIgY29uc3QqLCBib29sLCB1bnNpZ25lZCBpbnQp2ANXc3RkOjpfXzI6Ol9fbGliY3BwX3NucHJpbnRmX2woY2hhciosIHVuc2lnbmVkIGxvbmcsIF9fbG9jYWxlX3N0cnVjdCosIGNoYXIgY29uc3QqLCAuLi4p2QNVc3RkOjpfXzI6Ol9fbnVtX3B1dF9iYXNlOjpfX2lkZW50aWZ5X3BhZGRpbmcoY2hhciosIGNoYXIqLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UgY29uc3QmKdoDdXN0ZDo6X18yOjpfX251bV9wdXQ8Y2hhcj46Ol9fd2lkZW5fYW5kX2dyb3VwX2ludChjaGFyKiwgY2hhciosIGNoYXIqLCBjaGFyKiwgY2hhciomLCBjaGFyKiYsIHN0ZDo6X18yOjpsb2NhbGUgY29uc3QmKdsDkAJzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+IHN0ZDo6X18yOjpfX3BhZF9hbmRfb3V0cHV0W2FiaTpuZTE5MDEwNl08Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PihzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyKdwDzwFzdGQ6Ol9fMjo6bnVtX3B1dDxjaGFyLCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIGNoYXIsIGxvbmcgbG9uZykgY29uc3TdA9MBc3RkOjpfXzI6Om51bV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCB1bnNpZ25lZCBsb25nKSBjb25zdN4D2AFzdGQ6Ol9fMjo6bnVtX3B1dDxjaGFyLCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIGNoYXIsIHVuc2lnbmVkIGxvbmcgbG9uZykgY29uc3TfA8wBc3RkOjpfXzI6Om51bV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCBkb3VibGUpIGNvbnN04ANKc3RkOjpfXzI6Ol9fbnVtX3B1dF9iYXNlOjpfX2Zvcm1hdF9mbG9hdChjaGFyKiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCnhA0lzdGQ6Ol9fMjo6X19saWJjcHBfYXNwcmludGZfbChjaGFyKiosIF9fbG9jYWxlX3N0cnVjdCosIGNoYXIgY29uc3QqLCAuLi4p4gN3c3RkOjpfXzI6Ol9fbnVtX3B1dDxjaGFyPjo6X193aWRlbl9hbmRfZ3JvdXBfZmxvYXQoY2hhciosIGNoYXIqLCBjaGFyKiwgY2hhciosIGNoYXIqJiwgY2hhciomLCBzdGQ6Ol9fMjo6bG9jYWxlIGNvbnN0JinjA9EBc3RkOjpfXzI6Om51bV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCBsb25nIGRvdWJsZSkgY29uc3TkA9EBc3RkOjpfXzI6Om51bV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCB2b2lkIGNvbnN0KikgY29uc3TlA4UBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpiYXNpY19zdHJpbmdbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nLCBjaGFyKeYD3AFzdGQ6Ol9fMjo6bnVtX3B1dDx3Y2hhcl90LCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3QsIGJvb2wpIGNvbnN05wNyc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjplbmRbYWJpOm5lMTkwMTA2XSgp6APcAXN0ZDo6X18yOjpudW1fcHV0PHdjaGFyX3QsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgd2NoYXJfdCwgbG9uZykgY29uc3TpA4EBc3RkOjpfXzI6Ol9fbnVtX3B1dDx3Y2hhcl90Pjo6X193aWRlbl9hbmRfZ3JvdXBfaW50KGNoYXIqLCBjaGFyKiwgY2hhciosIHdjaGFyX3QqLCB3Y2hhcl90KiYsIHdjaGFyX3QqJiwgc3RkOjpfXzI6OmxvY2FsZSBjb25zdCYp6gOuAnN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4gc3RkOjpfXzI6Ol9fcGFkX2FuZF9vdXRwdXRbYWJpOm5lMTkwMTA2XTx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0Kiwgd2NoYXJfdCBjb25zdCosIHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3Qp6wPhAXN0ZDo6X18yOjpudW1fcHV0PHdjaGFyX3QsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgd2NoYXJfdCwgbG9uZyBsb25nKSBjb25zdOwD5QFzdGQ6Ol9fMjo6bnVtX3B1dDx3Y2hhcl90LCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3QsIHVuc2lnbmVkIGxvbmcpIGNvbnN07QPqAXN0ZDo6X18yOjpudW1fcHV0PHdjaGFyX3QsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgd2NoYXJfdCwgdW5zaWduZWQgbG9uZyBsb25nKSBjb25zdO4D3gFzdGQ6Ol9fMjo6bnVtX3B1dDx3Y2hhcl90LCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3QsIGRvdWJsZSkgY29uc3TvA4MBc3RkOjpfXzI6Ol9fbnVtX3B1dDx3Y2hhcl90Pjo6X193aWRlbl9hbmRfZ3JvdXBfZmxvYXQoY2hhciosIGNoYXIqLCBjaGFyKiwgd2NoYXJfdCosIHdjaGFyX3QqJiwgd2NoYXJfdComLCBzdGQ6Ol9fMjo6bG9jYWxlIGNvbnN0JinwA+MBc3RkOjpfXzI6Om51bV9wdXQ8d2NoYXJfdCwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB3Y2hhcl90LCBsb25nIGRvdWJsZSkgY29uc3TxA+MBc3RkOjpfXzI6Om51bV9wdXQ8d2NoYXJfdCwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB3Y2hhcl90LCB2b2lkIGNvbnN0KikgY29uc3TyA5EBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjpiYXNpY19zdHJpbmdbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nLCB3Y2hhcl90KfMDX3ZvaWQgc3RkOjpfXzI6Ol9fcmV2ZXJzZVthYmk6bmUxOTAxMDZdPHN0ZDo6X18yOjpfQ2xhc3NpY0FsZ1BvbGljeSwgY2hhciosIGNoYXIqPihjaGFyKiwgY2hhciop9ANrdm9pZCBzdGQ6Ol9fMjo6X19yZXZlcnNlW2FiaTpuZTE5MDEwNl08c3RkOjpfXzI6Ol9DbGFzc2ljQWxnUG9saWN5LCB3Y2hhcl90Kiwgd2NoYXJfdCo+KHdjaGFyX3QqLCB3Y2hhcl90Kin1A6wCc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+OjpnZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdG0qLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCopIGNvbnN09gNxc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19kYXRlX29yZGVyKCkgY29uc3T3A5oCc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXRfdGltZShzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB0bSopIGNvbnN0+AOaAnN0ZDo6X18yOjp0aW1lX2dldDxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fZ2V0X2RhdGUoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdG0qKSBjb25zdPkDnQJzdGQ6Ol9fMjo6dGltZV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldF93ZWVrZGF5KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHRtKikgY29uc3T6A6sCc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+OjpfX2dldF93ZWVrZGF5bmFtZShpbnQmLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiwgdW5zaWduZWQgaW50Jiwgc3RkOjpfXzI6OmN0eXBlPGNoYXI+IGNvbnN0JikgY29uc3T7A58Cc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19nZXRfbW9udGhuYW1lKHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHRtKikgY29uc3T8A6kCc3RkOjpfXzI6OnRpbWVfZ2V0PGNoYXIsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+OjpfX2dldF9tb250aG5hbWUoaW50Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiYsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHVuc2lnbmVkIGludCYsIHN0ZDo6X18yOjpjdHlwZTxjaGFyPiBjb25zdCYpIGNvbnN0/QOaAnN0ZDo6X18yOjp0aW1lX2dldDxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Pjo6ZG9fZ2V0X3llYXIoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdG0qKSBjb25zdP4DpAJzdGQ6Ol9fMjo6dGltZV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46Ol9fZ2V0X3llYXIoaW50Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiYsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHVuc2lnbmVkIGludCYsIHN0ZDo6X18yOjpjdHlwZTxjaGFyPiBjb25zdCYpIGNvbnN0/wOvAmludCBzdGQ6Ol9fMjo6X19nZXRfdXBfdG9fbl9kaWdpdHNbYWJpOm5lMTkwMTA2XTxjaGFyLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+PihzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiwgdW5zaWduZWQgaW50Jiwgc3RkOjpfXzI6OmN0eXBlPGNoYXI+IGNvbnN0JiwgaW50KYAEoQJzdGQ6Ol9fMjo6dGltZV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB0bSosIGNoYXIsIGNoYXIpIGNvbnN0gQTHAnN0ZDo6X18yOjp0aW1lX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6Z2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHRtKiwgd2NoYXJfdCBjb25zdCosIHdjaGFyX3QgY29uc3QqKSBjb25zdIIErwJzdGQ6Ol9fMjo6dGltZV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldF90aW1lKHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHRtKikgY29uc3SDBK8Cc3RkOjpfXzI6OnRpbWVfZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXRfZGF0ZShzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB0bSopIGNvbnN0hASyAnN0ZDo6X18yOjp0aW1lX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fZ2V0X3dlZWtkYXkoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdG0qKSBjb25zdIUEwwJzdGQ6Ol9fMjo6dGltZV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46Ol9fZ2V0X3dlZWtkYXluYW1lKGludCYsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4mLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCB1bnNpZ25lZCBpbnQmLCBzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD4gY29uc3QmKSBjb25zdIYEtAJzdGQ6Ol9fMjo6dGltZV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldF9tb250aG5hbWUoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgdG0qKSBjb25zdIcEwQJzdGQ6Ol9fMjo6dGltZV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46Ol9fZ2V0X21vbnRobmFtZShpbnQmLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgdW5zaWduZWQgaW50Jiwgc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+IGNvbnN0JikgY29uc3SIBK8Cc3RkOjpfXzI6OnRpbWVfZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXRfeWVhcihzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCB0bSopIGNvbnN0iQS8AnN0ZDo6X18yOjp0aW1lX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6X19nZXRfeWVhcihpbnQmLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgdW5zaWduZWQgaW50Jiwgc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+IGNvbnN0JikgY29uc3SKBMcCaW50IHN0ZDo6X18yOjpfX2dldF91cF90b19uX2RpZ2l0c1thYmk6bmUxOTAxMDZdPHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4mLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCB1bnNpZ25lZCBpbnQmLCBzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD4gY29uc3QmLCBpbnQpiwS2AnN0ZDo6X18yOjp0aW1lX2dldDx3Y2hhcl90LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHVuc2lnbmVkIGludCYsIHRtKiwgY2hhciwgY2hhcikgY29uc3SMBNwBc3RkOjpfXzI6OnRpbWVfcHV0PGNoYXIsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Piwgc3RkOjpfXzI6Omlvc19iYXNlJiwgY2hhciwgdG0gY29uc3QqLCBjaGFyLCBjaGFyKSBjb25zdI0ESnN0ZDo6X18yOjpfX3RpbWVfcHV0OjpfX2RvX3B1dChjaGFyKiwgY2hhciomLCB0bSBjb25zdCosIGNoYXIsIGNoYXIpIGNvbnN0jgTuAXN0ZDo6X18yOjp0aW1lX3B1dDx3Y2hhcl90LCBzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Pjo6ZG9fcHV0KHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4sIHN0ZDo6X18yOjppb3NfYmFzZSYsIHdjaGFyX3QsIHRtIGNvbnN0KiwgY2hhciwgY2hhcikgY29uc3SPBDtzdGQ6Ol9fMjo6bW9uZXlwdW5jdDxjaGFyLCBmYWxzZT46OmRvX2RlY2ltYWxfcG9pbnQoKSBjb25zdJAENnN0ZDo6X18yOjptb25leXB1bmN0PGNoYXIsIGZhbHNlPjo6ZG9fZ3JvdXBpbmcoKSBjb25zdJEEO3N0ZDo6X18yOjptb25leXB1bmN0PGNoYXIsIGZhbHNlPjo6ZG9fbmVnYXRpdmVfc2lnbigpIGNvbnN0kgQ4c3RkOjpfXzI6Om1vbmV5cHVuY3Q8Y2hhciwgZmFsc2U+Ojpkb19wb3NfZm9ybWF0KCkgY29uc3STBD5zdGQ6Ol9fMjo6bW9uZXlwdW5jdDx3Y2hhcl90LCBmYWxzZT46OmRvX2RlY2ltYWxfcG9pbnQoKSBjb25zdJQEPnN0ZDo6X18yOjptb25leXB1bmN0PHdjaGFyX3QsIGZhbHNlPjo6ZG9fbmVnYXRpdmVfc2lnbigpIGNvbnN0lQS/AXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YmFzaWNfc3RyaW5nKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYplgSlAnN0ZDo6X18yOjptb25leV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBib29sLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBsb25nIGRvdWJsZSYpIGNvbnN0lwSIA3N0ZDo6X18yOjptb25leV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46Ol9fZG9fZ2V0KHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4mLCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBib29sLCBzdGQ6Ol9fMjo6bG9jYWxlIGNvbnN0JiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQmLCBib29sJiwgc3RkOjpfXzI6OmN0eXBlPGNoYXI+IGNvbnN0Jiwgc3RkOjpfXzI6OnVuaXF1ZV9wdHI8Y2hhciwgdm9pZCAoKikodm9pZCopPiYsIGNoYXIqJiwgY2hhciopmARfc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6b3BlcmF0b3IrK1thYmk6bmUxOTAxMDZdKGludCmZBHR2b2lkIHN0ZDo6X18yOjpfX2RvdWJsZV9vcl9ub3RoaW5nW2FiaTpuZTE5MDEwNl08Y2hhcj4oc3RkOjpfXzI6OnVuaXF1ZV9wdHI8Y2hhciwgdm9pZCAoKikodm9pZCopPiYsIGNoYXIqJiwgY2hhciomKZoElAF2b2lkIHN0ZDo6X18yOjpfX2RvdWJsZV9vcl9ub3RoaW5nW2FiaTpuZTE5MDEwNl08dW5zaWduZWQgaW50PihzdGQ6Ol9fMjo6dW5pcXVlX3B0cjx1bnNpZ25lZCBpbnQsIHZvaWQgKCopKHZvaWQqKT4mLCB1bnNpZ25lZCBpbnQqJiwgdW5zaWduZWQgaW50KiYpmwTuAnN0ZDo6X18yOjptb25leV9nZXQ8Y2hhciwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBib29sLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4mKSBjb25zdJwE2AFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4mIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YXBwZW5kW2FiaTpuZTE5MDEwNl08Y2hhciosIDA+KGNoYXIqLCBjaGFyKimdBNcBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpfX2dyb3dfYnlfd2l0aG91dF9yZXBsYWNlW2FiaTpuZTE5MDEwNl0odW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymeBH1zdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46Ol9fc2V0X3NpemVbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nKZ8EQXN0ZDo6X18yOjpfX3dyYXBfaXRlcjxjaGFyKj46Om9wZXJhdG9yK1thYmk6bmUxOTAxMDZdKGxvbmcpIGNvbnN0oARzc3RkOjpfXzI6OnVuaXF1ZV9wdHI8Y2hhciwgdm9pZCAoKikodm9pZCopPjo6b3BlcmF0b3I9W2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OnVuaXF1ZV9wdHI8Y2hhciwgdm9pZCAoKikodm9pZCopPiYmKaEEugJzdGQ6Ol9fMjo6bW9uZXlfZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19nZXQoc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Piwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgYm9vbCwgc3RkOjpfXzI6Omlvc19iYXNlJiwgdW5zaWduZWQgaW50JiwgbG9uZyBkb3VibGUmKSBjb25zdKIEqQNzdGQ6Ol9fMjo6bW9uZXlfZ2V0PHdjaGFyX3QsIHN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+OjpfX2RvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+Jiwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgYm9vbCwgc3RkOjpfXzI6OmxvY2FsZSBjb25zdCYsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50JiwgYm9vbCYsIHN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90PiBjb25zdCYsIHN0ZDo6X18yOjp1bmlxdWVfcHRyPHdjaGFyX3QsIHZvaWQgKCopKHZvaWQqKT4mLCB3Y2hhcl90KiYsIHdjaGFyX3QqKaMEZXN0ZDo6X18yOjppc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj46Om9wZXJhdG9yKytbYWJpOm5lMTkwMTA2XShpbnQppASMA3N0ZDo6X18yOjptb25leV9nZXQ8d2NoYXJfdCwgc3RkOjpfXzI6OmlzdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+Pj46OmRvX2dldChzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBzdGQ6Ol9fMjo6aXN0cmVhbWJ1Zl9pdGVyYXRvcjx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4+LCBib29sLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCB1bnNpZ25lZCBpbnQmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj4mKSBjb25zdKUE8wFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj4mIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+Pjo6YXBwZW5kW2FiaTpuZTE5MDEwNl08d2NoYXJfdCosIDA+KHdjaGFyX3QqLCB3Y2hhcl90KimmBOABc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjpfX2dyb3dfYnlfd2l0aG91dF9yZXBsYWNlW2FiaTpuZTE5MDEwNl0odW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZymnBMQBd2NoYXJfdCogc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjpfX2NvcHlfbm9uX292ZXJsYXBwaW5nX3JhbmdlW2FiaTpuZTE5MDEwNl08d2NoYXJfdCosIHdjaGFyX3QqPih3Y2hhcl90Kiwgd2NoYXJfdCosIHdjaGFyX3QqKagE1wFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj46Om9wZXJhdG9yPVthYmk6bmUxOTAxMDZdKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiYmKakERHN0ZDo6X18yOjpfX3dyYXBfaXRlcjx3Y2hhcl90Kj46Om9wZXJhdG9yK1thYmk6bmUxOTAxMDZdKGxvbmcpIGNvbnN0qgTZAXN0ZDo6X18yOjptb25leV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBib29sLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCBsb25nIGRvdWJsZSkgY29uc3SrBIgDc3RkOjpfXzI6Ol9fbW9uZXlfcHV0PGNoYXI+OjpfX2dhdGhlcl9pbmZvKGJvb2wsIGJvb2wsIHN0ZDo6X18yOjpsb2NhbGUgY29uc3QmLCBzdGQ6Ol9fMjo6bW9uZXlfYmFzZTo6cGF0dGVybiYsIGNoYXImLCBjaGFyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+Jiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+Jiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+JiwgaW50JimsBNYDc3RkOjpfXzI6Ol9fbW9uZXlfcHV0PGNoYXI+OjpfX2Zvcm1hdChjaGFyKiwgY2hhciomLCBjaGFyKiYsIHVuc2lnbmVkIGludCwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBzdGQ6Ol9fMjo6Y3R5cGU8Y2hhcj4gY29uc3QmLCBib29sLCBzdGQ6Ol9fMjo6bW9uZXlfYmFzZTo6cGF0dGVybiBjb25zdCYsIGNoYXIsIGNoYXIsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIGludCmtBJwBY2hhciogc3RkOjpfXzI6OmNvcHlbYWJpOm5lMTkwMTA2XTxzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhciBjb25zdCo+LCBjaGFyKj4oc3RkOjpfXzI6Ol9fd3JhcF9pdGVyPGNoYXIgY29uc3QqPiwgc3RkOjpfXzI6Ol9fd3JhcF9pdGVyPGNoYXIgY29uc3QqPiwgY2hhcioprgSpAnN0ZDo6X18yOjptb25leV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OmRvX3B1dChzdGQ6Ol9fMjo6b3N0cmVhbWJ1Zl9pdGVyYXRvcjxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBib29sLCBzdGQ6Ol9fMjo6aW9zX2Jhc2UmLCBjaGFyLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmKSBjb25zdK8E6wFzdGQ6Ol9fMjo6bW9uZXlfcHV0PHdjaGFyX3QsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgYm9vbCwgc3RkOjpfXzI6Omlvc19iYXNlJiwgd2NoYXJfdCwgbG9uZyBkb3VibGUpIGNvbnN0sASjA3N0ZDo6X18yOjpfX21vbmV5X3B1dDx3Y2hhcl90Pjo6X19nYXRoZXJfaW5mbyhib29sLCBib29sLCBzdGQ6Ol9fMjo6bG9jYWxlIGNvbnN0Jiwgc3RkOjpfXzI6Om1vbmV5X2Jhc2U6OnBhdHRlcm4mLCB3Y2hhcl90Jiwgd2NoYXJfdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiYsIGludCYpsQSDBHN0ZDo6X18yOjpfX21vbmV5X3B1dDx3Y2hhcl90Pjo6X19mb3JtYXQod2NoYXJfdCosIHdjaGFyX3QqJiwgd2NoYXJfdComLCB1bnNpZ25lZCBpbnQsIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0Kiwgc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+IGNvbnN0JiwgYm9vbCwgc3RkOjpfXzI6Om1vbmV5X2Jhc2U6OnBhdHRlcm4gY29uc3QmLCB3Y2hhcl90LCB3Y2hhcl90LCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pj4gY29uc3QmLCBpbnQpsgSuAXdjaGFyX3QqIHN0ZDo6X18yOjpjb3B5W2FiaTpuZTE5MDEwNl08c3RkOjpfXzI6Ol9fd3JhcF9pdGVyPHdjaGFyX3QgY29uc3QqPiwgd2NoYXJfdCo+KHN0ZDo6X18yOjpfX3dyYXBfaXRlcjx3Y2hhcl90IGNvbnN0Kj4sIHN0ZDo6X18yOjpfX3dyYXBfaXRlcjx3Y2hhcl90IGNvbnN0Kj4sIHdjaGFyX3QqKbMExAJzdGQ6Ol9fMjo6bW9uZXlfcHV0PHdjaGFyX3QsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Pj4+Ojpkb19wdXQoc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+PiwgYm9vbCwgc3RkOjpfXzI6Omlvc19iYXNlJiwgd2NoYXJfdCwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+IGNvbnN0JikgY29uc3S0BJ0Bc3RkOjpfXzI6Om1lc3NhZ2VzPGNoYXI+Ojpkb19vcGVuKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYsIHN0ZDo6X18yOjpsb2NhbGUgY29uc3QmKSBjb25zdLUEkwFzdGQ6Ol9fMjo6bWVzc2FnZXM8Y2hhcj46OmRvX2dldChsb25nLCBpbnQsIGludCwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JikgY29uc3S2BJ8Bc3RkOjpfXzI6Om1lc3NhZ2VzPHdjaGFyX3Q+Ojpkb19nZXQobG9uZywgaW50LCBpbnQsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+PiBjb25zdCYpIGNvbnN0twQ5c3RkOjpfXzI6OmNvZGVjdnQ8d2NoYXJfdCwgY2hhciwgX19tYnN0YXRlX3Q+Ojp+Y29kZWN2dCgpuAR+c3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIHN0ZDo6X18yOjpfX3Nzb19hbGxvY2F0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCAzMHVsPj46On52ZWN0b3JbYWJpOm5lMTkwMTA2XSgpuQSIAXN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCBzdGQ6Ol9fMjo6X19zc29fYWxsb2NhdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgMzB1bD4+OjpfX2NvbnN0cnVjdF9hdF9lbmQodW5zaWduZWQgbG9uZym6BM4Bc3RkOjpfXzI6Ol9fZXhjZXB0aW9uX2d1YXJkX2V4Y2VwdGlvbnM8c3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIHN0ZDo6X18yOjpfX3Nzb19hbGxvY2F0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCAzMHVsPj46Ol9fZGVzdHJveV92ZWN0b3I+Ojp+X19leGNlcHRpb25fZ3VhcmRfZXhjZXB0aW9uc1thYmk6bmUxOTAxMDZdKCm7BH5zdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0Kiwgc3RkOjpfXzI6Ol9fc3NvX2FsbG9jYXRvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIDMwdWw+Pjo6X19jbGVhclthYmk6bmUxOTAxMDZdKCm8BB1zdGQ6Ol9fMjo6bG9jYWxlOjppZDo6X19nZXQoKb0EQHN0ZDo6X18yOjpsb2NhbGU6Ol9faW1wOjppbnN0YWxsKHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgbG9uZym+BJMBc3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIHN0ZDo6X18yOjpfX3Nzb19hbGxvY2F0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCAzMHVsPj46Ol9fZGVzdHJveV92ZWN0b3I6Om9wZXJhdG9yKClbYWJpOm5lMTkwMTA2XSgpvwSHAXN0ZDo6X18yOjp1bmlxdWVfcHRyPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0LCBzdGQ6Ol9fMjo6KGFub255bW91cyBuYW1lc3BhY2UpOjpyZWxlYXNlcj46OnJlc2V0W2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqKcAEIXN0ZDo6X18yOjpsb2NhbGU6Ol9faW1wOjp+X19pbXAoKcEEJnN0ZDo6X18yOjpsb2NhbGU6Ol9faW1wOjp+X19pbXAoKV8xNDU1wgR+c3RkOjpfXzI6OnZlY3RvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIHN0ZDo6X18yOjpfX3Nzb19hbGxvY2F0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCAzMHVsPj46Ol9fYXBwZW5kKHVuc2lnbmVkIGxvbmcpwwQuc3RkOjpfXzI6OmxvY2FsZTo6X19pbXA6Omhhc19mYWNldChsb25nKSBjb25zdMQEGnN0ZDo6X18yOjpsb2NhbGU6OmxvY2FsZSgpxQRsc3RkOjpfXzI6OmJhc2ljX3N0cmluZ192aWV3PGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj46OmJhc2ljX3N0cmluZ192aWV3W2FiaTpuZTE5MDEwNl0oY2hhciBjb25zdCopxgTpAWJvb2wgc3RkOjpfXzI6Om9wZXJhdG9yPT1bYWJpOm5lMTkwMTA2XTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCBzdGQ6Ol9fMjo6dHlwZV9pZGVudGl0eTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46OnR5cGUpxwQrc3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQ6Ol9fb25femVyb19zaGFyZWQoKcgEbHZvaWQgc3RkOjpfXzI6Ol9fY2FsbF9vbmNlX3Byb3h5W2FiaTpuZTE5MDEwNl08c3RkOjpfXzI6OnR1cGxlPHN0ZDo6X18yOjpsb2NhbGU6OmlkOjpfX2dldCgpOjokXzAmJj4+KHZvaWQqKckEyAFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46OmJhc2ljX3N0cmluZ1thYmk6bmUxOTAxMDZdKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiYmKcoEPXN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90Pjo6ZG9faXModW5zaWduZWQgbG9uZywgd2NoYXJfdCkgY29uc3TLBFVzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD46OmRvX2lzKHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0KiwgdW5zaWduZWQgbG9uZyopIGNvbnN0zARZc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+Ojpkb19zY2FuX2lzKHVuc2lnbmVkIGxvbmcsIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0KikgY29uc3TNBFpzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD46OmRvX3NjYW5fbm90KHVuc2lnbmVkIGxvbmcsIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0KikgY29uc3TOBDNzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD46OmRvX3RvdXBwZXIod2NoYXJfdCkgY29uc3TPBERzdGQ6Ol9fMjo6Y3R5cGU8d2NoYXJfdD46OmRvX3RvdXBwZXIod2NoYXJfdCosIHdjaGFyX3QgY29uc3QqKSBjb25zdNAEM3N0ZDo6X18yOjpjdHlwZTx3Y2hhcl90Pjo6ZG9fdG9sb3dlcih3Y2hhcl90KSBjb25zdNEERHN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90Pjo6ZG9fdG9sb3dlcih3Y2hhcl90Kiwgd2NoYXJfdCBjb25zdCopIGNvbnN00gRMc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+Ojpkb193aWRlbihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHdjaGFyX3QqKSBjb25zdNMEOHN0ZDo6X18yOjpjdHlwZTx3Y2hhcl90Pjo6ZG9fbmFycm93KHdjaGFyX3QsIGNoYXIpIGNvbnN01ARWc3RkOjpfXzI6OmN0eXBlPHdjaGFyX3Q+Ojpkb19uYXJyb3cod2NoYXJfdCBjb25zdCosIHdjaGFyX3QgY29uc3QqLCBjaGFyLCBjaGFyKikgY29uc3TVBB9zdGQ6Ol9fMjo6Y3R5cGU8Y2hhcj46On5jdHlwZSgp1gQkc3RkOjpfXzI6OmN0eXBlPGNoYXI+Ojp+Y3R5cGUoKV8xNTAw1wQtc3RkOjpfXzI6OmN0eXBlPGNoYXI+Ojpkb190b3VwcGVyKGNoYXIpIGNvbnN02AQ7c3RkOjpfXzI6OmN0eXBlPGNoYXI+Ojpkb190b3VwcGVyKGNoYXIqLCBjaGFyIGNvbnN0KikgY29uc3TZBC1zdGQ6Ol9fMjo6Y3R5cGU8Y2hhcj46OmRvX3RvbG93ZXIoY2hhcikgY29uc3TaBDtzdGQ6Ol9fMjo6Y3R5cGU8Y2hhcj46OmRvX3RvbG93ZXIoY2hhciosIGNoYXIgY29uc3QqKSBjb25zdNsERnN0ZDo6X18yOjpjdHlwZTxjaGFyPjo6ZG9fd2lkZW4oY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyKikgY29uc3TcBDJzdGQ6Ol9fMjo6Y3R5cGU8Y2hhcj46OmRvX25hcnJvdyhjaGFyLCBjaGFyKSBjb25zdN0ETXN0ZDo6X18yOjpjdHlwZTxjaGFyPjo6ZG9fbmFycm93KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgY2hhciwgY2hhciopIGNvbnN03gSEAXN0ZDo6X18yOjpjb2RlY3Z0PGNoYXIsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6ZG9fb3V0KF9fbWJzdGF0ZV90JiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiYsIGNoYXIqLCBjaGFyKiwgY2hhciomKSBjb25zdN8EYHN0ZDo6X18yOjpjb2RlY3Z0PGNoYXIsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6ZG9fdW5zaGlmdChfX21ic3RhdGVfdCYsIGNoYXIqLCBjaGFyKiwgY2hhciomKSBjb25zdOAEcnN0ZDo6X18yOjpjb2RlY3Z0PGNoYXIsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6ZG9fbGVuZ3RoKF9fbWJzdGF0ZV90JiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKSBjb25zdOEEPnN0ZDo6X18yOjpjb2RlY3Z0PHdjaGFyX3QsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6fmNvZGVjdnQoKV8xNTE44gSQAXN0ZDo6X18yOjpjb2RlY3Z0PHdjaGFyX3QsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6ZG9fb3V0KF9fbWJzdGF0ZV90Jiwgd2NoYXJfdCBjb25zdCosIHdjaGFyX3QgY29uc3QqLCB3Y2hhcl90IGNvbnN0KiYsIGNoYXIqLCBjaGFyKiwgY2hhciomKSBjb25zdOMEWnN0ZDo6X18yOjpfX2xpYmNwcF93Y3J0b21iX2xbYWJpOm5lMTkwMTA2XShjaGFyKiwgd2NoYXJfdCwgX19tYnN0YXRlX3QqLCBfX2xvY2FsZV9zdHJ1Y3QqKeQEjwFzdGQ6Ol9fMjo6Y29kZWN2dDx3Y2hhcl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX2luKF9fbWJzdGF0ZV90JiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiYsIHdjaGFyX3QqLCB3Y2hhcl90Kiwgd2NoYXJfdComKSBjb25zdOUEcHN0ZDo6X18yOjpfX2xpYmNwcF9tYnJ0b3djX2xbYWJpOm5lMTkwMTA2XSh3Y2hhcl90KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcsIF9fbWJzdGF0ZV90KiwgX19sb2NhbGVfc3RydWN0KinmBGNzdGQ6Ol9fMjo6Y29kZWN2dDx3Y2hhcl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX3Vuc2hpZnQoX19tYnN0YXRlX3QmLCBjaGFyKiwgY2hhciosIGNoYXIqJikgY29uc3TnBEJzdGQ6Ol9fMjo6Y29kZWN2dDx3Y2hhcl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX2VuY29kaW5nKCkgY29uc3ToBD9zdGQ6Ol9fMjo6X19saWJjcHBfbWJfY3VyX21heF9sW2FiaTpuZTE5MDEwNl0oX19sb2NhbGVfc3RydWN0KinpBHVzdGQ6Ol9fMjo6Y29kZWN2dDx3Y2hhcl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX2xlbmd0aChfX21ic3RhdGVfdCYsIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykgY29uc3TqBERzdGQ6Ol9fMjo6Y29kZWN2dDx3Y2hhcl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX21heF9sZW5ndGgoKSBjb25zdOsElAFzdGQ6Ol9fMjo6Y29kZWN2dDxjaGFyMTZfdCwgY2hhciwgX19tYnN0YXRlX3Q+Ojpkb19vdXQoX19tYnN0YXRlX3QmLCBjaGFyMTZfdCBjb25zdCosIGNoYXIxNl90IGNvbnN0KiwgY2hhcjE2X3QgY29uc3QqJiwgY2hhciosIGNoYXIqLCBjaGFyKiYpIGNvbnN07ASTAXN0ZDo6X18yOjpjb2RlY3Z0PGNoYXIxNl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX2luKF9fbWJzdGF0ZV90JiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiYsIGNoYXIxNl90KiwgY2hhcjE2X3QqLCBjaGFyMTZfdComKSBjb25zdO0EdnN0ZDo6X18yOjpjb2RlY3Z0PGNoYXIxNl90LCBjaGFyLCBfX21ic3RhdGVfdD46OmRvX2xlbmd0aChfX21ic3RhdGVfdCYsIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZykgY29uc3TuBEVzdGQ6Ol9fMjo6Y29kZWN2dDxjaGFyMTZfdCwgY2hhciwgX19tYnN0YXRlX3Q+Ojpkb19tYXhfbGVuZ3RoKCkgY29uc3TvBJQBc3RkOjpfXzI6OmNvZGVjdnQ8Y2hhcjMyX3QsIGNoYXIsIF9fbWJzdGF0ZV90Pjo6ZG9fb3V0KF9fbWJzdGF0ZV90JiwgY2hhcjMyX3QgY29uc3QqLCBjaGFyMzJfdCBjb25zdCosIGNoYXIzMl90IGNvbnN0KiYsIGNoYXIqLCBjaGFyKiwgY2hhciomKSBjb25zdPAEkwFzdGQ6Ol9fMjo6Y29kZWN2dDxjaGFyMzJfdCwgY2hhciwgX19tYnN0YXRlX3Q+Ojpkb19pbihfX21ic3RhdGVfdCYsIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdComLCBjaGFyMzJfdCosIGNoYXIzMl90KiwgY2hhcjMyX3QqJikgY29uc3TxBHZzdGQ6Ol9fMjo6Y29kZWN2dDxjaGFyMzJfdCwgY2hhciwgX19tYnN0YXRlX3Q+Ojpkb19sZW5ndGgoX19tYnN0YXRlX3QmLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcpIGNvbnN08gQlc3RkOjpfXzI6Om51bXB1bmN0PGNoYXI+Ojp+bnVtcHVuY3QoKfMEKnN0ZDo6X18yOjpudW1wdW5jdDxjaGFyPjo6fm51bXB1bmN0KClfMTU3MvQEKHN0ZDo6X18yOjpudW1wdW5jdDx3Y2hhcl90Pjo6fm51bXB1bmN0KCn1BC1zdGQ6Ol9fMjo6bnVtcHVuY3Q8d2NoYXJfdD46On5udW1wdW5jdCgpXzE1NzT2BDJzdGQ6Ol9fMjo6bnVtcHVuY3Q8Y2hhcj46OmRvX2RlY2ltYWxfcG9pbnQoKSBjb25zdPcEMnN0ZDo6X18yOjpudW1wdW5jdDxjaGFyPjo6ZG9fdGhvdXNhbmRzX3NlcCgpIGNvbnN0+AQtc3RkOjpfXzI6Om51bXB1bmN0PGNoYXI+Ojpkb19ncm91cGluZygpIGNvbnN0+QQwc3RkOjpfXzI6Om51bXB1bmN0PHdjaGFyX3Q+Ojpkb19ncm91cGluZygpIGNvbnN0+gQtc3RkOjpfXzI6Om51bXB1bmN0PGNoYXI+Ojpkb190cnVlbmFtZSgpIGNvbnN0+wQwc3RkOjpfXzI6Om51bXB1bmN0PHdjaGFyX3Q+Ojpkb190cnVlbmFtZSgpIGNvbnN0/ASMAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+Pjo6YmFzaWNfc3RyaW5nW2FiaTpuZTE5MDEwNl08MD4od2NoYXJfdCBjb25zdCop/QQuc3RkOjpfXzI6Om51bXB1bmN0PGNoYXI+Ojpkb19mYWxzZW5hbWUoKSBjb25zdP4EMXN0ZDo6X18yOjpudW1wdW5jdDx3Y2hhcl90Pjo6ZG9fZmFsc2VuYW1lKCkgY29uc3T/BHpzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46Om9wZXJhdG9yPVthYmk6bmUxOTAxMDZdKGNoYXIgY29uc3QqKYAFNXN0ZDo6X18yOjpfX3RpbWVfZ2V0X2Nfc3RvcmFnZTxjaGFyPjo6X193ZWVrcygpIGNvbnN0gQUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuNTWCBThzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9fd2Vla3MoKSBjb25zdIMFGl9fY3h4X2dsb2JhbF9hcnJheV9kdG9yLjcwhAU2c3RkOjpfXzI6Ol9fdGltZV9nZXRfY19zdG9yYWdlPGNoYXI+OjpfX21vbnRocygpIGNvbnN0hQUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuODWGBTlzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9fbW9udGhzKCkgY29uc3SHBRtfX2N4eF9nbG9iYWxfYXJyYXlfZHRvci4xMDmIBTVzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8Y2hhcj46Ol9fYW1fcG0oKSBjb25zdIkFG19fY3h4X2dsb2JhbF9hcnJheV9kdG9yLjEzM4oFOHN0ZDo6X18yOjpfX3RpbWVfZ2V0X2Nfc3RvcmFnZTx3Y2hhcl90Pjo6X19hbV9wbSgpIGNvbnN0iwUbX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMTM2jAUxc3RkOjpfXzI6Ol9fdGltZV9nZXRfY19zdG9yYWdlPGNoYXI+OjpfX3goKSBjb25zdI0FHF9fY3h4X2dsb2JhbF9hcnJheV9kdG9yXzE2MTCOBTRzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9feCgpIGNvbnN0jwUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMzGQBTFzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8Y2hhcj46Ol9fWCgpIGNvbnN0kQUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMzKSBTRzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9fWCgpIGNvbnN0kwUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMzSUBTFzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8Y2hhcj46Ol9fYygpIGNvbnN0lQUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMzaWBTRzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9fYygpIGNvbnN0lwUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuMziYBTFzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8Y2hhcj46Ol9fcigpIGNvbnN0mQUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuNDCaBTRzdGQ6Ol9fMjo6X190aW1lX2dldF9jX3N0b3JhZ2U8d2NoYXJfdD46Ol9fcigpIGNvbnN0mwUaX19jeHhfZ2xvYmFsX2FycmF5X2R0b3IuNDKcBWdzdGQ6Ol9fMjo6dGltZV9wdXQ8Y2hhciwgc3RkOjpfXzI6Om9zdHJlYW1idWZfaXRlcmF0b3I8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pj46On50aW1lX3B1dCgpnQVsc3RkOjpfXzI6OnRpbWVfcHV0PGNoYXIsIHN0ZDo6X18yOjpvc3RyZWFtYnVmX2l0ZXJhdG9yPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4+Ojp+dGltZV9wdXQoKV8xNjM2ngVPc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90Pjo6ZGVhbGxvY2F0ZVthYmk6bmUxOTAxMDZdKHdjaGFyX3QqLCB1bnNpZ25lZCBsb25nKZ8FTHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD46OmFsbG9jYXRlX2F0X2xlYXN0W2FiaTpuZTE5MDEwNl0odW5zaWduZWQgbG9uZymgBUNzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+OjphbGxvY2F0ZVthYmk6bmUxOTAxMDZdKHVuc2lnbmVkIGxvbmcpoQWBAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6X19lcmFzZV90b19lbmRbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nKaIFjQFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46Ol9fbnVsbF90ZXJtaW5hdGVfYXRbYWJpOm5lMTkwMTA2XShjaGFyKiwgdW5zaWduZWQgbG9uZymjBUdhdXRvIHN0ZDo6X18yOjpfX3Vud3JhcF9yYW5nZVthYmk6bmUxOTAxMDZdPGNoYXIqLCBjaGFyKj4oY2hhciosIGNoYXIqKaQFaGJvb2wgc3RkOjpfXzI6Ol9faXNfcG9pbnRlcl9pbl9yYW5nZVthYmk6bmUxOTAxMDZdPGNoYXIsIGNoYXIsIDA+KGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCoppQV2c3RkOjpfXzI6Ol9fdW53cmFwX2l0ZXJfaW1wbDxzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhcio+LCB0cnVlPjo6X191bndyYXBbYWJpOm5lMTkwMTA2XShzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhcio+KaYFxQFzdGQ6Ol9fMjo6X191bndyYXBfcmFuZ2VfaW1wbDxzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhciBjb25zdCo+LCBzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhciBjb25zdCo+Pjo6X191bndyYXBbYWJpOm5lMTkwMTA2XShzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhciBjb25zdCo+LCBzdGQ6Ol9fMjo6X193cmFwX2l0ZXI8Y2hhciBjb25zdCo+KacFgQFzdGQ6Ol9fMjo6cGFpcjxjaGFyIGNvbnN0KiwgY2hhcio+IHN0ZDo6X18yOjpfX2NvcHlfdHJpdmlhbF9pbXBsW2FiaTpuZTE5MDEwNl08Y2hhciBjb25zdCwgY2hhcj4oY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyKimoBXdzdGQ6Ol9fMjo6dmVjdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0Kiwgc3RkOjpfXzI6Ol9fc3NvX2FsbG9jYXRvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIDMwdWw+Pjo6bWF4X3NpemUoKSBjb25zdKkFwgJzdGQ6Ol9fMjo6YWxsb2NhdGlvbl9yZXN1bHQ8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqKiwgdW5zaWduZWQgbG9uZz4gc3RkOjpfXzI6OmFsbG9jYXRvcl90cmFpdHM8c3RkOjpfXzI6Ol9fc3NvX2FsbG9jYXRvcjxzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCosIDMwdWw+Pjo6YWxsb2NhdGVfYXRfbGVhc3RbYWJpOm5lMTkwMTA2XTxzdGQ6Ol9fMjo6X19zc29fYWxsb2NhdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgMzB1bD4+KHN0ZDo6X18yOjpfX3Nzb19hbGxvY2F0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCAzMHVsPiYsIHVuc2lnbmVkIGxvbmcpqgWmAXN0ZDo6X18yOjp2ZWN0b3I8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCBzdGQ6Ol9fMjo6X19zc29fYWxsb2NhdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgMzB1bD4+OjpfX2Jhc2VfZGVzdHJ1Y3RfYXRfZW5kW2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqKimrBX1zdGQ6Ol9fMjo6X19zc29fYWxsb2NhdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgMzB1bD46OmRlYWxsb2NhdGVbYWJpOm5lMTkwMTA2XShzdGQ6Ol9fMjo6bG9jYWxlOjpmYWNldCoqLCB1bnNpZ25lZCBsb25nKawFgQFzdGQ6Ol9fMjo6X19zcGxpdF9idWZmZXI8c3RkOjpfXzI6OmxvY2FsZTo6ZmFjZXQqLCBzdGQ6Ol9fMjo6X19zc29fYWxsb2NhdG9yPHN0ZDo6X18yOjpsb2NhbGU6OmZhY2V0KiwgMzB1bD4mPjo6fl9fc3BsaXRfYnVmZmVyKCmtBTpzdGQ6Ol9fMjo6X19jb25zdGV4cHJfd2NzbGVuW2FiaTpuZTE5MDEwNl0od2NoYXJfdCBjb25zdCoprgUwc3RkOjpfXzI6Ol9fdGltZV9wdXQ6Ol9fdGltZV9wdXRbYWJpOm5lMTkwMTA2XSgprwUwc3RkOjpfXzI6Ol9fc2hhcmVkX2NvdW50Ojp+X19zaGFyZWRfY291bnQoKV8xOTM5sAUbb3BlcmF0b3IgbmV3KHVuc2lnbmVkIGxvbmcpsQUYX190aHJvd19iYWRfYWxsb2Nfc2hpbSgpsgVMc3RkOjpfXzI6Ol9fbGliY3BwX2FsaWduZWRfYWxsb2NbYWJpOm5lMTkwMTA2XSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKbMFGHN0ZDo6X190aHJvd19iYWRfYWxsb2MoKbQFO3N0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjp+ZmlsZXN5c3RlbV9lcnJvcigptQVAc3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6On5maWxlc3lzdGVtX2Vycm9yKClfMTk2NrYFOnN0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjpfX2NyZWF0ZV93aGF0KGludCm3BT1zdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZGV0YWlsOjpmb3JtYXRfc3RyaW5nKGNoYXIgY29uc3QqLCAuLi4puAU0c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6OndoYXQoKSBjb25zdLkFMXN0ZDo6X18yOjpmaWxlc3lzdGVtOjpwYXRoOjp+cGF0aFthYmk6bmUxOTAxMDZdKCm6BZkCc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IHN0ZDo6X18yOjpvcGVyYXRvcitbYWJpOm5lMTkwMTA2XTxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+KHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiYmLCBjaGFyIGNvbnN0Kim7BS5zdGQ6Ol9fMjo6X19saWJjcHBfdW5yZWFjaGFibGVbYWJpOm5lMTkwMTA2XSgpvAV0c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmRldGFpbDo6RXJyb3JIYW5kbGVyPHZvaWQ+OjpyZXBvcnRfaW1wbChzdGQ6Ol9fMjo6ZXJyb3JfY29kZSBjb25zdCYsIGNoYXIgY29uc3QqLCB2b2lkKikgY29uc3S9BUBzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZGV0YWlsOjp2Zm9ybWF0X3N0cmluZyhjaGFyIGNvbnN0Kiwgdm9pZCopvgXHAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YXBwZW5kW2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0Jim/BZMCc3RkOjpfXzI6OnNoYXJlZF9wdHI8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlPiBzdGQ6Ol9fMjo6bWFrZV9zaGFyZWRbYWJpOm5lMTkwMTA2XTxzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2UsIHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpwYXRoLCBzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6cGF0aCwgMD4oc3RkOjpfXzI6OmZpbGVzeXN0ZW06OnBhdGgmJiwgc3RkOjpfXzI6OmZpbGVzeXN0ZW06OnBhdGgmJinABWNzdGQ6Ol9fMjo6c2hhcmVkX3B0cjxzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2U+Ojp+c2hhcmVkX3B0clthYmk6bmUxOTAxMDZdKCnBBawDc3RkOjpfXzI6OnNoYXJlZF9wdHI8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlPiBzdGQ6Ol9fMjo6YWxsb2NhdGVfc2hhcmVkW2FiaTpuZTE5MDEwNl08c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjpfU3RvcmFnZT4sIHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpwYXRoLCBzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6cGF0aCwgMD4oc3RkOjpfXzI6OmFsbG9jYXRvcjxzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2U+IGNvbnN0Jiwgc3RkOjpfXzI6OmZpbGVzeXN0ZW06OnBhdGgmJiwgc3RkOjpfXzI6OmZpbGVzeXN0ZW06OnBhdGgmJinCBeUBc3RkOjpfXzI6Ol9fYWxsb2NhdGlvbl9ndWFyZDxzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpfX3NoYXJlZF9wdHJfZW1wbGFjZTxzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2UsIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlPj4+Pjo6X19kZXN0cm95W2FiaTpuZTE5MDEwNl0oKcMFsAFzdGQ6Ol9fMjo6X19zaGFyZWRfcHRyX2VtcGxhY2U8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjpfU3RvcmFnZT4+Ojp+X19zaGFyZWRfcHRyX2VtcGxhY2UoKcQFtQFzdGQ6Ol9fMjo6X19zaGFyZWRfcHRyX2VtcGxhY2U8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjpfU3RvcmFnZT4+Ojp+X19zaGFyZWRfcHRyX2VtcGxhY2UoKV8yMDQ1xQWrAXN0ZDo6X18yOjpfX3NoYXJlZF9wdHJfZW1wbGFjZTxzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2UsIHN0ZDo6X18yOjphbGxvY2F0b3I8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlPj46Ol9fb25femVyb19zaGFyZWQoKcYFsAFzdGQ6Ol9fMjo6X19zaGFyZWRfcHRyX2VtcGxhY2U8c3RkOjpfXzI6OmZpbGVzeXN0ZW06OmZpbGVzeXN0ZW1fZXJyb3I6Ol9TdG9yYWdlLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHN0ZDo6X18yOjpmaWxlc3lzdGVtOjpmaWxlc3lzdGVtX2Vycm9yOjpfU3RvcmFnZT4+OjpfX29uX3plcm9fc2hhcmVkX3dlYWsoKccFjgFzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6ZmlsZXN5c3RlbV9lcnJvcjo6X1N0b3JhZ2U6Ol9TdG9yYWdlW2FiaTpuZTE5MDEwNl0oc3RkOjpfXzI6OmZpbGVzeXN0ZW06OnBhdGggY29uc3QmLCBzdGQ6Ol9fMjo6ZmlsZXN5c3RlbTo6cGF0aCBjb25zdCYpyAV6c3RkOjpsb2dpY19lcnJvcjo6bG9naWNfZXJyb3Ioc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JinJBT1zdGQ6Ol9fMjo6X19saWJjcHBfcmVmc3RyaW5nOjpfX2xpYmNwcF9yZWZzdHJpbmcoY2hhciBjb25zdCopygUqc3RkOjpsb2dpY19lcnJvcjo6bG9naWNfZXJyb3IoY2hhciBjb25zdCopywV+c3RkOjpydW50aW1lX2Vycm9yOjpydW50aW1lX2Vycm9yKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYpzAUuc3RkOjpydW50aW1lX2Vycm9yOjpydW50aW1lX2Vycm9yKGNoYXIgY29uc3QqKc0FLHN0ZDo6X18yOjpfX3Rocm93X3J1bnRpbWVfZXJyb3IoY2hhciBjb25zdCopzgUIc3RyZXJyb3LPBdIBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjpfX2dyb3dfYnlfYW5kX3JlcGxhY2UodW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgdW5zaWduZWQgbG9uZywgY2hhciBjb25zdCop0AVlc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+Ojp+YmFzaWNfc3RyaW5nKCnRBU1zdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj46OmFzc2lnblthYmk6bmUxOTAxMDZdKGNoYXIqLCB1bnNpZ25lZCBsb25nLCBjaGFyKdIFgwFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPj46Ol9fYXNzaWduX2V4dGVybmFsKGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKdMFeHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6YXBwZW5kKGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKdQFeHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6aW5zZXJ0KHVuc2lnbmVkIGxvbmcsIGNoYXIgY29uc3QqKdUFZXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+Pjo6cHVzaF9iYWNrKGNoYXIp1gVpc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+OjphcHBlbmQoY2hhciBjb25zdCop1wXeAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+Pjo6X19ncm93X2J5X2FuZF9yZXBsYWNlKHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHdjaGFyX3QgY29uc3QqKdgFbnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+Pjo6fmJhc2ljX3N0cmluZygp2QWAAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+Pjo6X19hc3NpZ25fZXh0ZXJuYWwod2NoYXJfdCBjb25zdCop2gVxc3RkOjpfXzI6OmJhc2ljX3N0cmluZzx3Y2hhcl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8d2NoYXJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8d2NoYXJfdD4+OjpwdXNoX2JhY2sod2NoYXJfdCnbBZACc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IHN0ZDo6X18yOjpvcGVyYXRvcis8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PihjaGFyIGNvbnN0Kiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IGNvbnN0JincBfMBc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+IHN0ZDo6X18yOjooYW5vbnltb3VzIG5hbWVzcGFjZSk6OmlfdG9fc3RyaW5nPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiwgdW5zaWduZWQgaW50Pih1bnNpZ25lZCBpbnQp3QU+c3RkOjpfXzI6Ol9faXRvYTo6X19hcHBlbmQyW2FiaTpuZTE5MDEwNl0oY2hhciosIHVuc2lnbmVkIGludCneBT5zdGQ6Ol9fMjo6X19pdG9hOjpfX2FwcGVuZDRbYWJpOm5lMTkwMTA2XShjaGFyKiwgdW5zaWduZWQgaW50Kd8FPnN0ZDo6X18yOjpfX2l0b2E6Ol9fYXBwZW5kNlthYmk6bmUxOTAxMDZdKGNoYXIqLCB1bnNpZ25lZCBpbnQp4AU+c3RkOjpfXzI6Ol9faXRvYTo6X19hcHBlbmQ4W2FiaTpuZTE5MDEwNl0oY2hhciosIHVuc2lnbmVkIGludCnhBTNzdGQ6Ol9fMjo6KGFub255bW91cyBuYW1lc3BhY2UpOjpkb19zdHJlcnJvcl9yKGludCniBTBzdGQ6Ol9fMjo6X19nZW5lcmljX2Vycm9yX2NhdGVnb3J5OjpuYW1lKCkgY29uc3TjBTZzdGQ6Ol9fMjo6X19nZW5lcmljX2Vycm9yX2NhdGVnb3J5OjptZXNzYWdlKGludCkgY29uc3TkBS9zdGQ6Ol9fMjo6X19zeXN0ZW1fZXJyb3JfY2F0ZWdvcnk6Om5hbWUoKSBjb25zdOUFRXN0ZDo6X18yOjpfX3N5c3RlbV9lcnJvcl9jYXRlZ29yeTo6ZGVmYXVsdF9lcnJvcl9jb25kaXRpb24oaW50KSBjb25zdOYFlwFzdGQ6Ol9fMjo6c3lzdGVtX2Vycm9yOjpzeXN0ZW1fZXJyb3Ioc3RkOjpfXzI6OmVycm9yX2NvZGUsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+PiBjb25zdCYp5wWiAXN0ZDo6X18yOjooYW5vbnltb3VzIG5hbWVzcGFjZSk6Om1ha2VfZXJyb3Jfc3RyKHN0ZDo6X18yOjplcnJvcl9jb2RlIGNvbnN0Jiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4+KegFR3N0ZDo6X18yOjpzeXN0ZW1fZXJyb3I6OnN5c3RlbV9lcnJvcihzdGQ6Ol9fMjo6ZXJyb3JfY29kZSwgY2hhciBjb25zdCop6QUYX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9u6gUUX19jeGFfZnJlZV9leGNlcHRpb27rBUtfX2N4eGFiaXYxOjpleGNlcHRpb25fY2xlYW51cF9mdW5jKF9VbndpbmRfUmVhc29uX0NvZGUsIF9VbndpbmRfRXhjZXB0aW9uKinsBSJfX2N4YV9kZWNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW507QULX19jeGFfdGhyb3fuBRFfX2N4YV9iZWdpbl9jYXRjaO8FD19fY3hhX2VuZF9jYXRjaPAFDV9fY3hhX3JldGhyb3fxBSJfX2N4YV9pbmNyZW1lbnRfZXhjZXB0aW9uX3JlZmNvdW508gUNYWJvcnRfbWVzc2FnZfMFHmRlbWFuZ2xpbmdfdGVybWluYXRlX2hhbmRsZXIoKfQFH2RlbWFuZ2xpbmdfdW5leHBlY3RlZF9oYW5kbGVyKCn1BRBzdGQ6OnRlcm1pbmF0ZSgp9gUcc3RkOjpfX3Rlcm1pbmF0ZSh2b2lkICgqKSgpKfcFEl9fY3hhX3B1cmVfdmlydHVhbPgFL19fY3h4YWJpdjE6Ol9fYWxpZ25lZF9mcmVlX3dpdGhfZmFsbGJhY2sodm9pZCop+QVhX19jeHhhYml2MTo6X19mdW5kYW1lbnRhbF90eXBlX2luZm86OmNhbl9jYXRjaChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0Kiwgdm9pZComKSBjb25zdPoFPGlzX2VxdWFsKHN0ZDo6dHlwZV9pbmZvIGNvbnN0Kiwgc3RkOjp0eXBlX2luZm8gY29uc3QqLCBib29sKfsFW19fY3h4YWJpdjE6Ol9fY2xhc3NfdHlwZV9pbmZvOjpjYW5fY2F0Y2goX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCosIHZvaWQqJikgY29uc3T8BQ5fX2R5bmFtaWNfY2FzdP0Fa19fY3h4YWJpdjE6Ol9fY2xhc3NfdHlwZV9pbmZvOjpwcm9jZXNzX2ZvdW5kX2Jhc2VfY2xhc3MoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQqLCBpbnQpIGNvbnN0/gVuX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3T/BXFfX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6aGFzX3VuYW1iaWd1b3VzX3B1YmxpY19iYXNlKF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkKiwgaW50KSBjb25zdIAGc19fY3h4YWJpdjE6Ol9fYmFzZV9jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3SBBnJfX2N4eGFiaXYxOjpfX3ZtaV9jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3SCBl1fX2N4eGFiaXYxOjpfX3BvaW50ZXJfdHlwZV9pbmZvOjpjYW5fY2F0Y2goX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCosIHZvaWQqJikgY29uc3SDBmZfX2N4eGFiaXYxOjpfX3BvaW50ZXJfdG9fbWVtYmVyX3R5cGVfaW5mbzo6Y2FuX2NhdGNoX25lc3RlZChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0KikgY29uc3SEBoMBX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnByb2Nlc3Nfc3RhdGljX3R5cGVfYWJvdmVfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0Kiwgdm9pZCBjb25zdCosIGludCkgY29uc3SFBnNfX2N4eGFiaXYxOjpfX3ZtaV9jbGFzc190eXBlX2luZm86OnNlYXJjaF9iZWxvd19kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0hgaBAV9fY3h4YWJpdjE6Ol9fYmFzZV9jbGFzc190eXBlX2luZm86OnNlYXJjaF9hYm92ZV9kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KiwgaW50LCBib29sKSBjb25zdIcGdF9fY3h4YWJpdjE6Ol9fYmFzZV9jbGFzc190eXBlX2luZm86OnNlYXJjaF9iZWxvd19kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0iAZyX19jeHhhYml2MTo6X19zaV9jbGFzc190eXBlX2luZm86OnNlYXJjaF9iZWxvd19kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0iQZvX19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnNlYXJjaF9iZWxvd19kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0igaAAV9fY3h4YWJpdjE6Ol9fdm1pX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0iwZ/X19jeHhhYml2MTo6X19zaV9jbGFzc190eXBlX2luZm86OnNlYXJjaF9hYm92ZV9kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KiwgaW50LCBib29sKSBjb25zdIwGfF9fY3h4YWJpdjE6Ol9fY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYWJvdmVfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0Kiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3SNBhxzdGQ6OmV4Y2VwdGlvbjo6d2hhdCgpIGNvbnN0jgYcc3RkOjpiYWRfYWxsb2M6OndoYXQoKSBjb25zdI8GJ3N0ZDo6YmFkX2FycmF5X25ld19sZW5ndGg6OndoYXQoKSBjb25zdJAGIHN0ZDo6bG9naWNfZXJyb3I6On5sb2dpY19lcnJvcigpkQYzc3RkOjpfXzI6Ol9fbGliY3BwX3JlZnN0cmluZzo6fl9fbGliY3BwX3JlZnN0cmluZygpkgYlc3RkOjpsb2dpY19lcnJvcjo6fmxvZ2ljX2Vycm9yKClfMjI5NZMGJHN0ZDo6cnVudGltZV9lcnJvcjo6fnJ1bnRpbWVfZXJyb3IoKZQGKXN0ZDo6cnVudGltZV9lcnJvcjo6fnJ1bnRpbWVfZXJyb3IoKV8yMjk5lQYbc3RkOjpiYWRfY2FzdDo6d2hhdCgpIGNvbnN0lgZTX19jeHhhYml2MTo6cmVhZEVuY29kZWRQb2ludGVyKHVuc2lnbmVkIGNoYXIgY29uc3QqKiwgdW5zaWduZWQgY2hhciwgdW5zaWduZWQgbG9uZymXBi5fX2N4eGFiaXYxOjpyZWFkVUxFQjEyOCh1bnNpZ25lZCBjaGFyIGNvbnN0KiopmAYuX19jeHhhYml2MTo6cmVhZFNMRUIxMjgodW5zaWduZWQgY2hhciBjb25zdCoqKZkGgAFfX2N4eGFiaXYxOjpnZXRfc2hpbV90eXBlX2luZm8odW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgY2hhciwgYm9vbCwgX1Vud2luZF9FeGNlcHRpb24qLCB1bnNpZ25lZCBsb25nKZoGNF9fY3h4YWJpdjE6OmNhbGxfdGVybWluYXRlKGJvb2wsIF9VbndpbmRfRXhjZXB0aW9uKimbBhdfVW53aW5kX0NhbGxQZXJzb25hbGl0eZwG5QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojp+QWJzdHJhY3RNYW5nbGluZ1BhcnNlcigpnQZHKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXI6Om9wZXJhdG9yKz0oY2hhcimeBpUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6Y29uc3VtZUlmKHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KZ8G3wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUVuY29kaW5nKGJvb2wpoAbbAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OmNvbnN1bWVJZihjaGFyKaEG3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU51bWJlcihib29sKaIGwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzM0XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFszNF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKaMG1wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVR5cGUoKaQGSihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyOjpncm93KHVuc2lnbmVkIGxvbmcppQaTAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqLCA0dWw+Ojp+UE9EU21hbGxWZWN0b3IoKaYGfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPjo6UE9EU21hbGxWZWN0b3IoKacGvQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPiosIDR1bD46OlBPRFNtYWxsVmVjdG9yKCmoBltzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+Pjo6YmVnaW5bYWJpOm5lMTkwMTA2XSgpIGNvbnN0qQa0AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6c3RhcnRzX3dpdGgoc3RkOjpfXzI6OmJhc2ljX3N0cmluZ192aWV3PGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KaoGvwMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpTYXZlVGVtcGxhdGVQYXJhbXM6OlNhdmVUZW1wbGF0ZVBhcmFtcygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+KimrBq0DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Ok5hbWVTdGF0ZSoprAb/AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRW5jb2RpbmcoYm9vbCk6OidsYW1iZGEnKCk6Om9wZXJhdG9yKCkoKSBjb25zdK0G3gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVRlbXBsYXRlQXJnKCmuBq8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6cHVzaF9iYWNrKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogY29uc3QmKa8G7wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojpwb3BUcmFpbGluZ05vZGVBcnJheSh1bnNpZ25lZCBsb25nKbAG4QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUNvbnN0cmFpbnRFeHByKCmxBvUBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6U2F2ZVRlbXBsYXRlUGFyYW1zOjp+U2F2ZVRlbXBsYXRlUGFyYW1zKCmyBtoCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs1XT4oY2hhciBjb25zdCAoJikgWzVdKbMG4QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUJhcmVTb3VyY2VOYW1lKCm0BrQDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Jj4oc3RkOjpfXzI6OmJhc2ljX3N0cmluZ192aWV3PGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4mKbUG1wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUV4cHIoKbYG2wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZURlY2x0eXBlKCm3BqIDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFja0V4cGFuc2lvbiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbgG4AEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVRlbXBsYXRlUGFyYW0oKbkG4wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVRlbXBsYXRlQXJncyhib29sKboGggQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lV2l0aFRlbXBsYXRlQXJncywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpuwaLBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZVR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQ+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQmJim8BrwDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VVbnNjb3BlZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlKiwgYm9vbCopvQbgAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlUXVhbGlmaWVkVHlwZSgpvgblAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6b3BlcmF0b3I9KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPiYmKb8G5wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD46Om9wZXJhdG9yPSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4mJinABt0BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VDYWxsT2Zmc2V0KCnBBuYBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VTZXFJZCh1bnNpZ25lZCBsb25nKinCBpUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VNb2R1bGVOYW1lT3B0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TW9kdWxlTmFtZSomKcMGmwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6b3BlcmF0b3JbXSh1bnNpZ25lZCBsb25nKcQGnQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6c2hyaW5rVG9TaXplKHVuc2lnbmVkIGxvbmcpxQbeAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRXhwclByaW1hcnkoKcYG4QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojppc1RlbXBsYXRlUGFyYW1EZWNsKCnHBtECKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VUZW1wbGF0ZVBhcmFtRGVjbCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKcgGuwUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKiBzdGQ6Ol9fMjo6Y29weVthYmk6bmUxOTAxMDZdPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKinJBrMDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VTb3VyY2VOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Ok5hbWVTdGF0ZSopygZEKGFub255bW91cyBuYW1lc3BhY2UpOjpCdW1wUG9pbnRlckFsbG9jYXRvcjo6YWxsb2NhdGUodW5zaWduZWQgbG9uZynLBrcBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZTo6U3BlY2lhbE5hbWUoc3RkOjpfXzI6OmJhc2ljX3N0cmluZ192aWV3PGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCopzAa/Aihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6Tm9kZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OktpbmQsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6UHJlYywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSnNBn0oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdM4GgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlcjo6b3BlcmF0b3IrPShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PinPBkIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OmdldEJhc2VOYW1lKCkgY29uc3TQBocBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yVnRhYmxlU3BlY2lhbE5hbWU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN00QbwAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlUG9zaXRpdmVJbnRlZ2VyKHVuc2lnbmVkIGxvbmcqKdIGeyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGU6Ok5hbWVUeXBlKHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KdMGeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN01AZGKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZTo6Z2V0QmFzZU5hbWUoKSBjb25zdNUGfChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TW9kdWxlTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TWBt8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VDVlF1YWxpZmllcnMoKdcG3wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVN1YnN0aXR1dGlvbigp2AZ5KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6cG9wX2JhY2soKdkGngQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVVucXVhbGlmaWVkTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1vZHVsZU5hbWUqKdoGVihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6cGFyc2VfZGlzY3JpbWluYXRvcihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCop2wb3Ayhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp3AaIAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlQWJpVGFncygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKd0GuAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVVubmFtZWRUeXBlTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKd4GtQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU9wZXJhdG9yTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKd8GlAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN04AaNAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlOjpoYXNBcnJheVNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOEGkAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6aGFzRnVuY3Rpb25TbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TiBo4BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2U6OmdldFN5bnRheE5vZGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOMGigEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TkBosBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2U6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOUG4wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU9wZXJhdG9yRW5jb2RpbmcoKeYG6wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpPcGVyYXRvckluZm86OmdldFN5bWJvbCgpIGNvbnN05wbQAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlUHJlZml4RXhwcihzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpQcmVjKegG6gQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYWxsRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OlByZWM+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OlByZWMmJinpBuABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VGdW5jdGlvblBhcmFtKCnqBt0BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VCcmFjZWRFeHByKCnrBsMDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzExXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxMV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKewGnwIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUludGVnZXJMaXRlcmFsKHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+Ke0GvgIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCb29sRXhwciwgaW50PihpbnQmJinuBrkDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25QYXJhbSwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZ192aWV3PGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPj4mPihzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PiYp7wbpAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Ok9wZXJhdG9ySW5mbzo6Z2V0TmFtZSgpIGNvbnN08AaGBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZEV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgYm9vbD4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sJiYp8QbhAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlVW5yZXNvbHZlZFR5cGUoKfIG2wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVNpbXBsZUlkKCnzBvsDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVkTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp9AblAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlQmFzZVVucmVzb2x2ZWROYW1lKCn1Bp8DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6R2xvYmFsUXVhbGlmaWVkTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKfYGfChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QmluYXJ5RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3T3BkYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlcjo6cHJpbnRPcGVuKGNoYXIp+Aa2AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6cHJpbnRBc09wZXJhbmQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OlByZWMsIGJvb2wpIGNvbnN0+QZHKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXI6OnByaW50Q2xvc2UoY2hhcin6BnwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlByZWZpeEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0+wZ9KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb3N0Zml4RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3T8BoQBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVN1YnNjcmlwdEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0/QZ8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNZW1iZXJFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdP4GeShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmV3RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3T/BoABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk6OnByaW50V2l0aENvbW1hKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SAB3woYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRlbGV0ZUV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0gQd6KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYWxsRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SCB4ABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb252ZXJzaW9uRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SDB4EBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb25kaXRpb25hbEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0hAd6KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SFB/ABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmNsb3NpbmdFeHByOjpFbmNsb3NpbmdFeHByKHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OlByZWMphgd/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmNsb3NpbmdFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdIcHyQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpTY29wZWRUZW1wbGF0ZVBhcmFtTGlzdDo6U2NvcGVkVGVtcGxhdGVQYXJhbUxpc3QoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiopiAf/AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OlNjb3BlZFRlbXBsYXRlUGFyYW1MaXN0Ojp+U2NvcGVkVGVtcGxhdGVQYXJhbUxpc3QoKYkHgAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkludGVnZXJMaXRlcmFsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdIoHgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlcjo6b3BlcmF0b3I8PChzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nX3ZpZXc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+PimLB3ooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJvb2xFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdIwHWnN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+OjpjZW5kW2FiaTpuZTE5MDEwNl0oKSBjb25zdI0HiQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8ZmxvYXQ+OjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdI4HigEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8ZG91YmxlPjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SPB48BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGxvbmcgZG91YmxlPjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SQB38oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ0xpdGVyYWw6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0kQflAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlVGVtcGxhdGVQYXJhbURlY2woKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+Kik6OidsYW1iZGEnKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbUtpbmQpOjpvcGVyYXRvcigpKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbUtpbmQpIGNvbnN0kgeBAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VW5uYW1lZFR5cGVOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJMHjAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN5bnRoZXRpY1RlbXBsYXRlUGFyYW1OYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJQHhwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlR5cGVUZW1wbGF0ZVBhcmFtRGVjbDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SVB4gBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlVGVtcGxhdGVQYXJhbURlY2w6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJYHkgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnN0cmFpbmVkVHlwZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJcHkwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnN0cmFpbmVkVHlwZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SYB4oBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb25UeXBlVGVtcGxhdGVQYXJhbURlY2w6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0mQeLAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9uVHlwZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SaB4sBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJsHjAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlVGVtcGxhdGVQYXJhbURlY2w6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJwHhwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1QYWNrRGVjbDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SdB4gBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZVBhcmFtUGFja0RlY2w6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdJ4HgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNsb3N1cmVUeXBlTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SfB4cBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDbG9zdXJlVHlwZU5hbWU6OnByaW50RGVjbGFyYXRvcigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0oAd8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpMYW1iZGFFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdKEHfShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW51bUxpdGVyYWw6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0ogd/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblBhcmFtOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdKMHeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9sZEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0pAeaAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9sZEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0OjonbGFtYmRhJygpOjpvcGVyYXRvcigpKCkgY29uc3SlB40BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uOjpQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCoppgeIAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFja0V4cGFuc2lvbjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3SnB3woYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0qAeBAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkUmFuZ2VFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdKkHrQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkluaXRMaXN0RXhwcjo6SW5pdExpc3RFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5KaoHfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW5pdExpc3RFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdKsHjwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvaW50ZXJUb01lbWJlckNvbnZlcnNpb25FeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdKwHgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkV4cHJSZXF1aXJlbWVudDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3StB4EBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlUmVxdWlyZW1lbnQ6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0rgeDAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmVzdGVkUmVxdWlyZW1lbnQ6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0rwd+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZXF1aXJlc0V4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0sAd/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdWJvYmplY3RFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdLEHhQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNpemVvZlBhcmFtUGFja0V4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0sgd/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXlOb2RlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdLMHeyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGhyb3dFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdLQHfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVkTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3S1B0soYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllZE5hbWU6OmdldEJhc2VOYW1lKCkgY29uc3S2B6IDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbk9wZXJhdG9yVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbcHeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RHRvck5hbWU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0uAeIAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbk9wZXJhdG9yVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3S5B4EBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpMaXRlcmFsT3BlcmF0b3I6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0ugeFAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6R2xvYmFsUXVhbGlmaWVkTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3S7B1EoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Okdsb2JhbFF1YWxpZmllZE5hbWU6OmdldEJhc2VOYW1lKCkgY29uc3S8B88BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb246OkV4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJLaW5kLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OktpbmQpvQeFAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YnN0aXR1dGlvbjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3S+B1EoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJzdGl0dXRpb246OmdldEJhc2VOYW1lKCkgY29uc3S/B1koYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkV4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbjo6Z2V0QmFzZU5hbWUoKSBjb25zdMAHjQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkV4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TBB3woYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFiaVRhZ0F0dHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0wgeyAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkN0b3JEdG9yTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGJvb2wsIGludCY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sJiYsIGludCYpwweHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RydWN0dXJlZEJpbmRpbmdOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdMQHfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q3RvckR0b3JOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdMUHfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TW9kdWxlRW50aXR5OjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdMYHhgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1lbWJlckxpa2VGcmllbmROYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdMcHiQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6Omhhc1JIU0NvbXBvbmVudFNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdMgHggEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6Omhhc0FycmF5U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0yQeFAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6aGFzRnVuY3Rpb25TbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TKB4MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjpnZXRTeW50YXhOb2RlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TLB38oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0zAeAAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6cHJpbnRSaWdodCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0zQd+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZUFyZ3M6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0zgeGAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVdpdGhUZW1wbGF0ZUFyZ3M6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN0zwd+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmFibGVJZkF0dHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN00AeJAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RXhwbGljaXRPYmplY3RQYXJhbWV0ZXI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN00QeMAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZzo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN00geCAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZzo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TTB4MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvbkVuY29kaW5nOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TUB3soYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRvdFN1ZmZpeDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TVB/gDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VmVjdG9yVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp1gd+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2V4Y2VwdFNwZWM6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN01weGAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RHluYW1pY0V4Y2VwdGlvblNwZWM6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN02Ad+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN02Qd/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdNoHfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T2JqQ1Byb3RvTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TbB4MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZW5kb3JFeHRRdWFsVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TcB4QBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsVHlwZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN03Qd9KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsVHlwZTo6aGFzQXJyYXlTbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TeB4ABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsVHlwZTo6aGFzRnVuY3Rpb25TbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TfB3ooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOAHeyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbFR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOEHgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRyYW5zZm9ybWVkVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TiB34oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJpbmFyeUZQVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TjB3woYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJpdEludFR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN05AfJAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeFF1YWxpZmllZFR5cGU6OlBvc3RmaXhRdWFsaWZpZWRUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIHN0ZDo6X18yOjpiYXNpY19zdHJpbmdfdmlldzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4+KeUHhgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvc3RmaXhRdWFsaWZpZWRUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOYHgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBpeGVsVmVjdG9yVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TnB6sBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZWN0b3JUeXBlOjpWZWN0b3JUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop6Ad8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZWN0b3JUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOkHeyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOoHfChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlUeXBlOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TrB4UBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb2ludGVyVG9NZW1iZXJUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdOwHhgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvaW50ZXJUb01lbWJlclR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdO0HiAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN07geHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6Omhhc1JIU0NvbXBvbmVudFNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdO8HfShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dEJ1ZmZlciYpIGNvbnN08AdMKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPYmpDUHJvdG9OYW1lOjppc09iakNPYmplY3QoKSBjb25zdPEHfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRCdWZmZXImKSBjb25zdPIHfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3TzB34oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZVR5cGU6OmNvbGxhcHNlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3T0B4ABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VUeXBlOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0QnVmZmVyJikgY29uc3T1ByVfX3Rocm93bl9vYmplY3RfZnJvbV91bndpbmRfZXhjZXB0aW9u9gcXX19nZXRfZXhjZXB0aW9uX21lc3NhZ2X3BxlfZW1zY3JpcHRlbl9zdGFja19yZXN0b3Jl+AcXX2Vtc2NyaXB0ZW5fc3RhY2tfYWxsb2P5BxxlbXNjcmlwdGVuX3N0YWNrX2dldF9jdXJyZW50By0DAA9fX3N0YWNrX3BvaW50ZXIBC19fc3RhY2tfZW5kAgxfX3N0YWNrX2Jhc2UJ/wQ5AAcucm9kYXRhAQkucm9kYXRhLjECCS5yb2RhdGEuMgMJLnJvZGF0YS4zBAkucm9kYXRhLjQFCS5yb2RhdGEuNQYJLnJvZGF0YS42Bwkucm9kYXRhLjcICS5yb2RhdGEuOAkJLnJvZGF0YS45Cgoucm9kYXRhLjEwCwoucm9kYXRhLjExDAoucm9kYXRhLjEyDQoucm9kYXRhLjEzDgoucm9kYXRhLjE0Dwoucm9kYXRhLjE1EAoucm9kYXRhLjE2EQoucm9kYXRhLjE3Egoucm9kYXRhLjE4Ewoucm9kYXRhLjE5FAoucm9kYXRhLjIwFQoucm9kYXRhLjIxFgoucm9kYXRhLjIyFwoucm9kYXRhLjIzGAoucm9kYXRhLjI0GQoucm9kYXRhLjI1Ggoucm9kYXRhLjI2Gwoucm9kYXRhLjI3HAoucm9kYXRhLjI4HQoucm9kYXRhLjI5Hgoucm9kYXRhLjMwHwoucm9kYXRhLjMxIAoucm9kYXRhLjMyIQoucm9kYXRhLjMzIgoucm9kYXRhLjM0Iwoucm9kYXRhLjM1JAoucm9kYXRhLjM2JQoucm9kYXRhLjM3Jgoucm9kYXRhLjM4Jwoucm9kYXRhLjM5KAoucm9kYXRhLjQwKQoucm9kYXRhLjQxKgoucm9kYXRhLjQyKwoucm9kYXRhLjQzLAoucm9kYXRhLjQ0LQoucm9kYXRhLjQ1LgUuZGF0YS8HLmRhdGEuMTAHLmRhdGEuMjEHLmRhdGEuMzIHLmRhdGEuNDMHLmRhdGEuNTQHLmRhdGEuNjUHLmRhdGEuNzYHLmRhdGEuODcHLmRhdGEuOTgILmRhdGEuMTAAIhBzb3VyY2VNYXBwaW5nVVJMEGhuc3dsaWIud2FzbS5tYXA=", self.location).href;
        }
        function getBinarySync(file) {
          if (file == wasmBinaryFile && wasmBinary) {
            return new Uint8Array(wasmBinary);
          }
          throw "both async and sync fetching of the wasm failed";
        }
        function getWasmBinary(binaryFile) {
          return __async(this, null, function* () {
            if (!wasmBinary) {
              try {
                var response = yield readAsync(binaryFile);
                return new Uint8Array(response);
              } catch (e) {
              }
            }
            return getBinarySync(binaryFile);
          });
        }
        function instantiateArrayBuffer(binaryFile, imports) {
          return __async(this, null, function* () {
            try {
              var binary = yield getWasmBinary(binaryFile);
              var instance = yield WebAssembly.instantiate(binary, imports);
              return instance;
            } catch (reason) {
              err(`failed to asynchronously prepare wasm: ${reason}`);
              if (isFileURI(wasmBinaryFile)) {
                err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);
              }
              abort(reason);
            }
          });
        }
        function instantiateAsync(binary, binaryFile, imports) {
          return __async(this, null, function* () {
            if (!binary && typeof WebAssembly.instantiateStreaming == "function") {
              try {
                var response = fetch(binaryFile, { credentials: "same-origin" });
                var instantiationResult = yield WebAssembly.instantiateStreaming(response, imports);
                return instantiationResult;
              } catch (reason) {
                err(`wasm streaming compile failed: ${reason}`);
                err("falling back to ArrayBuffer instantiation");
              }
            }
            return instantiateArrayBuffer(binaryFile, imports);
          });
        }
        function getWasmImports() {
          return {
            "env": wasmImports,
            "wasi_snapshot_preview1": wasmImports
          };
        }
        function createWasm() {
          return __async(this, null, function* () {
            function receiveInstance(instance, module2) {
              wasmExports = instance.exports;
              wasmMemory = wasmExports["memory"];
              assert(wasmMemory, "memory not found in wasm exports");
              updateMemoryViews();
              wasmTable = wasmExports["__indirect_function_table"];
              assert(wasmTable, "table not found in wasm exports");
              ___cpp_exception = wasmExports["__cpp_exception"];
              removeRunDependency("wasm-instantiate");
              return wasmExports;
            }
            addRunDependency("wasm-instantiate");
            var trueModule = Module;
            function receiveInstantiationResult(result22) {
              assert(Module === trueModule, "the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?");
              trueModule = null;
              return receiveInstance(result22["instance"]);
            }
            var info = getWasmImports();
            if (Module["instantiateWasm"]) {
              return new Promise((resolve, reject) => {
                try {
                  Module["instantiateWasm"](info, (mod2, inst) => {
                    resolve(receiveInstance(mod2, inst));
                  });
                } catch (e) {
                  err(`Module.instantiateWasm callback failed with error: ${e}`);
                  reject(e);
                }
              });
            }
            wasmBinaryFile != null ? wasmBinaryFile : wasmBinaryFile = findWasmBinary();
            try {
              var result2 = yield instantiateAsync(wasmBinary, wasmBinaryFile, info);
              var exports2 = receiveInstantiationResult(result2);
              return exports2;
            } catch (e) {
              readyPromiseReject(e);
              return Promise.reject(e);
            }
          });
        }
        var callRuntimeCallbacks = (callbacks) => {
          while (callbacks.length > 0) {
            callbacks.shift()(Module);
          }
        };
        var onPostRuns = [];
        var addOnPostRun = (cb) => onPostRuns.push(cb);
        var onPreRuns = [];
        var addOnPreRun = (cb) => onPreRuns.push(cb);
        var ptrToString = (ptr) => {
          assert(typeof ptr === "number");
          ptr >>>= 0;
          return "0x" + ptr.toString(16).padStart(8, "0");
        };
        var warnOnce = (text) => {
          warnOnce.shown || (warnOnce.shown = {});
          if (!warnOnce.shown[text]) {
            warnOnce.shown[text] = 1;
            err(text);
          }
        };
        var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
        var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
          var endIdx = idx + maxBytesToRead;
          var endPtr = idx;
          while (heapOrArray[endPtr] && !(endPtr >= endIdx))
            ++endPtr;
          if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
            return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
          }
          var str = "";
          while (idx < endPtr) {
            var u0 = heapOrArray[idx++];
            if (!(u0 & 128)) {
              str += String.fromCharCode(u0);
              continue;
            }
            var u1 = heapOrArray[idx++] & 63;
            if ((u0 & 224) == 192) {
              str += String.fromCharCode((u0 & 31) << 6 | u1);
              continue;
            }
            var u2 = heapOrArray[idx++] & 63;
            if ((u0 & 240) == 224) {
              u0 = (u0 & 15) << 12 | u1 << 6 | u2;
            } else {
              if ((u0 & 248) != 240)
                warnOnce("Invalid UTF-8 leading byte " + ptrToString(u0) + " encountered when deserializing a UTF-8 string in wasm memory to a JS string!");
              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
            }
            if (u0 < 65536) {
              str += String.fromCharCode(u0);
            } else {
              var ch = u0 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            }
          }
          return str;
        };
        var UTF8ToString = (ptr, maxBytesToRead) => {
          assert(typeof ptr == "number", `UTF8ToString expects a number (got ${typeof ptr})`);
          return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        };
        var ___assert_fail = (condition, filename, line, func) => abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
        var syscallGetVarargI = () => {
          assert(SYSCALLS.varargs != void 0);
          var ret = HEAP32[+SYSCALLS.varargs >> 2];
          SYSCALLS.varargs += 4;
          return ret;
        };
        var syscallGetVarargP = syscallGetVarargI;
        var PATH = {
          isAbs: (path) => path.charAt(0) === "/",
          splitPath: (filename) => {
            var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
            return splitPathRe.exec(filename).slice(1);
          },
          normalizeArray: (parts, allowAboveRoot) => {
            var up = 0;
            for (var i = parts.length - 1; i >= 0; i--) {
              var last = parts[i];
              if (last === ".") {
                parts.splice(i, 1);
              } else if (last === "..") {
                parts.splice(i, 1);
                up++;
              } else if (up) {
                parts.splice(i, 1);
                up--;
              }
            }
            if (allowAboveRoot) {
              for (; up; up--) {
                parts.unshift("..");
              }
            }
            return parts;
          },
          normalize: (path) => {
            var isAbsolute = PATH.isAbs(path), trailingSlash = path.slice(-1) === "/";
            path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
            if (!path && !isAbsolute) {
              path = ".";
            }
            if (path && trailingSlash) {
              path += "/";
            }
            return (isAbsolute ? "/" : "") + path;
          },
          dirname: (path) => {
            var result2 = PATH.splitPath(path), root = result2[0], dir = result2[1];
            if (!root && !dir) {
              return ".";
            }
            if (dir) {
              dir = dir.slice(0, -1);
            }
            return root + dir;
          },
          basename: (path) => path && path.match(/([^\/]+|\/)\/*$/)[1],
          join: (...paths) => PATH.normalize(paths.join("/")),
          join2: (l, r) => PATH.normalize(l + "/" + r)
        };
        var initRandomFill = () => {
          return (view) => crypto.getRandomValues(view);
        };
        var randomFill = (view) => {
          (randomFill = initRandomFill())(view);
        };
        var PATH_FS = {
          resolve: (...args) => {
            var resolvedPath = "", resolvedAbsolute = false;
            for (var i = args.length - 1; i >= -1 && !resolvedAbsolute; i--) {
              var path = i >= 0 ? args[i] : FS.cwd();
              if (typeof path != "string") {
                throw new TypeError("Arguments to path.resolve must be strings");
              } else if (!path) {
                return "";
              }
              resolvedPath = path + "/" + resolvedPath;
              resolvedAbsolute = PATH.isAbs(path);
            }
            resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
            return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
          },
          relative: (from, to) => {
            from = PATH_FS.resolve(from).slice(1);
            to = PATH_FS.resolve(to).slice(1);
            function trim(arr) {
              var start = 0;
              for (; start < arr.length; start++) {
                if (arr[start] !== "")
                  break;
              }
              var end = arr.length - 1;
              for (; end >= 0; end--) {
                if (arr[end] !== "")
                  break;
              }
              if (start > end)
                return [];
              return arr.slice(start, end - start + 1);
            }
            var fromParts = trim(from.split("/"));
            var toParts = trim(to.split("/"));
            var length = Math.min(fromParts.length, toParts.length);
            var samePartsLength = length;
            for (var i = 0; i < length; i++) {
              if (fromParts[i] !== toParts[i]) {
                samePartsLength = i;
                break;
              }
            }
            var outputParts = [];
            for (var i = samePartsLength; i < fromParts.length; i++) {
              outputParts.push("..");
            }
            outputParts = outputParts.concat(toParts.slice(samePartsLength));
            return outputParts.join("/");
          }
        };
        var FS_stdin_getChar_buffer = [];
        var lengthBytesUTF8 = (str) => {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var c = str.charCodeAt(i);
            if (c <= 127) {
              len++;
            } else if (c <= 2047) {
              len += 2;
            } else if (c >= 55296 && c <= 57343) {
              len += 4;
              ++i;
            } else {
              len += 3;
            }
          }
          return len;
        };
        var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
          assert(typeof str === "string", `stringToUTF8Array expects a string (got ${typeof str})`);
          if (!(maxBytesToWrite > 0))
            return 0;
          var startIdx = outIdx;
          var endIdx = outIdx + maxBytesToWrite - 1;
          for (var i = 0; i < str.length; ++i) {
            var u = str.charCodeAt(i);
            if (u >= 55296 && u <= 57343) {
              var u1 = str.charCodeAt(++i);
              u = 65536 + ((u & 1023) << 10) | u1 & 1023;
            }
            if (u <= 127) {
              if (outIdx >= endIdx)
                break;
              heap[outIdx++] = u;
            } else if (u <= 2047) {
              if (outIdx + 1 >= endIdx)
                break;
              heap[outIdx++] = 192 | u >> 6;
              heap[outIdx++] = 128 | u & 63;
            } else if (u <= 65535) {
              if (outIdx + 2 >= endIdx)
                break;
              heap[outIdx++] = 224 | u >> 12;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            } else {
              if (outIdx + 3 >= endIdx)
                break;
              if (u > 1114111)
                warnOnce("Invalid Unicode code point " + ptrToString(u) + " encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).");
              heap[outIdx++] = 240 | u >> 18;
              heap[outIdx++] = 128 | u >> 12 & 63;
              heap[outIdx++] = 128 | u >> 6 & 63;
              heap[outIdx++] = 128 | u & 63;
            }
          }
          heap[outIdx] = 0;
          return outIdx - startIdx;
        };
        var intArrayFromString = (stringy, dontAddNull, length) => {
          var len = lengthBytesUTF8(stringy) + 1;
          var u8array = new Array(len);
          var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
          u8array.length = numBytesWritten;
          return u8array;
        };
        var FS_stdin_getChar = () => {
          if (!FS_stdin_getChar_buffer.length) {
            var result2 = null;
            if (typeof window != "undefined" && typeof window.prompt == "function") {
              result2 = window.prompt("Input: ");
              if (result2 !== null) {
                result2 += "\n";
              }
            }
            if (!result2) {
              return null;
            }
            FS_stdin_getChar_buffer = intArrayFromString(result2);
          }
          return FS_stdin_getChar_buffer.shift();
        };
        var TTY = {
          ttys: [],
          init() {
          },
          shutdown() {
          },
          register(dev, ops) {
            TTY.ttys[dev] = { input: [], output: [], ops };
            FS.registerDevice(dev, TTY.stream_ops);
          },
          stream_ops: {
            open(stream) {
              var tty = TTY.ttys[stream.node.rdev];
              if (!tty) {
                throw new FS.ErrnoError(43);
              }
              stream.tty = tty;
              stream.seekable = false;
            },
            close(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            fsync(stream) {
              stream.tty.ops.fsync(stream.tty);
            },
            read(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.get_char) {
                throw new FS.ErrnoError(60);
              }
              var bytesRead = 0;
              for (var i = 0; i < length; i++) {
                var result2;
                try {
                  result2 = stream.tty.ops.get_char(stream.tty);
                } catch (e) {
                  throw new FS.ErrnoError(29);
                }
                if (result2 === void 0 && bytesRead === 0) {
                  throw new FS.ErrnoError(6);
                }
                if (result2 === null || result2 === void 0)
                  break;
                bytesRead++;
                buffer[offset + i] = result2;
              }
              if (bytesRead) {
                stream.node.atime = Date.now();
              }
              return bytesRead;
            },
            write(stream, buffer, offset, length, pos) {
              if (!stream.tty || !stream.tty.ops.put_char) {
                throw new FS.ErrnoError(60);
              }
              try {
                for (var i = 0; i < length; i++) {
                  stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
                }
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (length) {
                stream.node.mtime = stream.node.ctime = Date.now();
              }
              return i;
            }
          },
          default_tty_ops: {
            get_char(tty) {
              return FS_stdin_getChar();
            },
            put_char(tty, val) {
              if (val === null || val === 10) {
                out(UTF8ArrayToString(tty.output));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              var _a2;
              if (((_a2 = tty.output) == null ? void 0 : _a2.length) > 0) {
                out(UTF8ArrayToString(tty.output));
                tty.output = [];
              }
            },
            ioctl_tcgets(tty) {
              return {
                c_iflag: 25856,
                c_oflag: 5,
                c_cflag: 191,
                c_lflag: 35387,
                c_cc: [
                  3,
                  28,
                  127,
                  21,
                  4,
                  0,
                  1,
                  0,
                  17,
                  19,
                  26,
                  0,
                  18,
                  15,
                  23,
                  22,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                ]
              };
            },
            ioctl_tcsets(tty, optional_actions, data) {
              return 0;
            },
            ioctl_tiocgwinsz(tty) {
              return [24, 80];
            }
          },
          default_tty1_ops: {
            put_char(tty, val) {
              if (val === null || val === 10) {
                err(UTF8ArrayToString(tty.output));
                tty.output = [];
              } else {
                if (val != 0)
                  tty.output.push(val);
              }
            },
            fsync(tty) {
              var _a2;
              if (((_a2 = tty.output) == null ? void 0 : _a2.length) > 0) {
                err(UTF8ArrayToString(tty.output));
                tty.output = [];
              }
            }
          }
        };
        var mmapAlloc = (size) => {
          abort("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported");
        };
        var MEMFS = {
          ops_table: null,
          mount(mount) {
            return MEMFS.createNode(null, "/", 16895, 0);
          },
          createNode(parent, name2, mode, dev) {
            if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
              throw new FS.ErrnoError(63);
            }
            MEMFS.ops_table || (MEMFS.ops_table = {
              dir: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  lookup: MEMFS.node_ops.lookup,
                  mknod: MEMFS.node_ops.mknod,
                  rename: MEMFS.node_ops.rename,
                  unlink: MEMFS.node_ops.unlink,
                  rmdir: MEMFS.node_ops.rmdir,
                  readdir: MEMFS.node_ops.readdir,
                  symlink: MEMFS.node_ops.symlink
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek
                }
              },
              file: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: {
                  llseek: MEMFS.stream_ops.llseek,
                  read: MEMFS.stream_ops.read,
                  write: MEMFS.stream_ops.write,
                  mmap: MEMFS.stream_ops.mmap,
                  msync: MEMFS.stream_ops.msync
                }
              },
              link: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr,
                  readlink: MEMFS.node_ops.readlink
                },
                stream: {}
              },
              chrdev: {
                node: {
                  getattr: MEMFS.node_ops.getattr,
                  setattr: MEMFS.node_ops.setattr
                },
                stream: FS.chrdev_stream_ops
              }
            });
            var node = FS.createNode(parent, name2, mode, dev);
            if (FS.isDir(node.mode)) {
              node.node_ops = MEMFS.ops_table.dir.node;
              node.stream_ops = MEMFS.ops_table.dir.stream;
              node.contents = {};
            } else if (FS.isFile(node.mode)) {
              node.node_ops = MEMFS.ops_table.file.node;
              node.stream_ops = MEMFS.ops_table.file.stream;
              node.usedBytes = 0;
              node.contents = null;
            } else if (FS.isLink(node.mode)) {
              node.node_ops = MEMFS.ops_table.link.node;
              node.stream_ops = MEMFS.ops_table.link.stream;
            } else if (FS.isChrdev(node.mode)) {
              node.node_ops = MEMFS.ops_table.chrdev.node;
              node.stream_ops = MEMFS.ops_table.chrdev.stream;
            }
            node.atime = node.mtime = node.ctime = Date.now();
            if (parent) {
              parent.contents[name2] = node;
              parent.atime = parent.mtime = parent.ctime = node.atime;
            }
            return node;
          },
          getFileDataAsTypedArray(node) {
            if (!node.contents)
              return new Uint8Array(0);
            if (node.contents.subarray)
              return node.contents.subarray(0, node.usedBytes);
            return new Uint8Array(node.contents);
          },
          expandFileStorage(node, newCapacity) {
            var prevCapacity = node.contents ? node.contents.length : 0;
            if (prevCapacity >= newCapacity)
              return;
            var CAPACITY_DOUBLING_MAX = 1024 * 1024;
            newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
            if (prevCapacity != 0)
              newCapacity = Math.max(newCapacity, 256);
            var oldContents = node.contents;
            node.contents = new Uint8Array(newCapacity);
            if (node.usedBytes > 0)
              node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
          },
          resizeFileStorage(node, newSize) {
            if (node.usedBytes == newSize)
              return;
            if (newSize == 0) {
              node.contents = null;
              node.usedBytes = 0;
            } else {
              var oldContents = node.contents;
              node.contents = new Uint8Array(newSize);
              if (oldContents) {
                node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
              }
              node.usedBytes = newSize;
            }
          },
          node_ops: {
            getattr(node) {
              var attr = {};
              attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
              attr.ino = node.id;
              attr.mode = node.mode;
              attr.nlink = 1;
              attr.uid = 0;
              attr.gid = 0;
              attr.rdev = node.rdev;
              if (FS.isDir(node.mode)) {
                attr.size = 4096;
              } else if (FS.isFile(node.mode)) {
                attr.size = node.usedBytes;
              } else if (FS.isLink(node.mode)) {
                attr.size = node.link.length;
              } else {
                attr.size = 0;
              }
              attr.atime = new Date(node.atime);
              attr.mtime = new Date(node.mtime);
              attr.ctime = new Date(node.ctime);
              attr.blksize = 4096;
              attr.blocks = Math.ceil(attr.size / attr.blksize);
              return attr;
            },
            setattr(node, attr) {
              for (const key of ["mode", "atime", "mtime", "ctime"]) {
                if (attr[key] != null) {
                  node[key] = attr[key];
                }
              }
              if (attr.size !== void 0) {
                MEMFS.resizeFileStorage(node, attr.size);
              }
            },
            lookup(parent, name2) {
              throw new FS.ErrnoError(44);
            },
            mknod(parent, name2, mode, dev) {
              return MEMFS.createNode(parent, name2, mode, dev);
            },
            rename(old_node, new_dir, new_name) {
              var new_node;
              try {
                new_node = FS.lookupNode(new_dir, new_name);
              } catch (e) {
              }
              if (new_node) {
                if (FS.isDir(old_node.mode)) {
                  for (var i in new_node.contents) {
                    throw new FS.ErrnoError(55);
                  }
                }
                FS.hashRemoveNode(new_node);
              }
              delete old_node.parent.contents[old_node.name];
              new_dir.contents[new_name] = old_node;
              old_node.name = new_name;
              new_dir.ctime = new_dir.mtime = old_node.parent.ctime = old_node.parent.mtime = Date.now();
            },
            unlink(parent, name2) {
              delete parent.contents[name2];
              parent.ctime = parent.mtime = Date.now();
            },
            rmdir(parent, name2) {
              var node = FS.lookupNode(parent, name2);
              for (var i in node.contents) {
                throw new FS.ErrnoError(55);
              }
              delete parent.contents[name2];
              parent.ctime = parent.mtime = Date.now();
            },
            readdir(node) {
              return [".", "..", ...Object.keys(node.contents)];
            },
            symlink(parent, newname, oldpath) {
              var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
              node.link = oldpath;
              return node;
            },
            readlink(node) {
              if (!FS.isLink(node.mode)) {
                throw new FS.ErrnoError(28);
              }
              return node.link;
            }
          },
          stream_ops: {
            read(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= stream.node.usedBytes)
                return 0;
              var size = Math.min(stream.node.usedBytes - position, length);
              assert(size >= 0);
              if (size > 8 && contents.subarray) {
                buffer.set(contents.subarray(position, position + size), offset);
              } else {
                for (var i = 0; i < size; i++)
                  buffer[offset + i] = contents[position + i];
              }
              return size;
            },
            write(stream, buffer, offset, length, position, canOwn) {
              assert(!(buffer instanceof ArrayBuffer));
              if (buffer.buffer === HEAP8.buffer) {
                canOwn = false;
              }
              if (!length)
                return 0;
              var node = stream.node;
              node.mtime = node.ctime = Date.now();
              if (buffer.subarray && (!node.contents || node.contents.subarray)) {
                if (canOwn) {
                  assert(position === 0, "canOwn must imply no weird position inside the file");
                  node.contents = buffer.subarray(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (node.usedBytes === 0 && position === 0) {
                  node.contents = buffer.slice(offset, offset + length);
                  node.usedBytes = length;
                  return length;
                } else if (position + length <= node.usedBytes) {
                  node.contents.set(buffer.subarray(offset, offset + length), position);
                  return length;
                }
              }
              MEMFS.expandFileStorage(node, position + length);
              if (node.contents.subarray && buffer.subarray) {
                node.contents.set(buffer.subarray(offset, offset + length), position);
              } else {
                for (var i = 0; i < length; i++) {
                  node.contents[position + i] = buffer[offset + i];
                }
              }
              node.usedBytes = Math.max(node.usedBytes, position + length);
              return length;
            },
            llseek(stream, offset, whence) {
              var position = offset;
              if (whence === 1) {
                position += stream.position;
              } else if (whence === 2) {
                if (FS.isFile(stream.node.mode)) {
                  position += stream.node.usedBytes;
                }
              }
              if (position < 0) {
                throw new FS.ErrnoError(28);
              }
              return position;
            },
            mmap(stream, length, position, prot, flags) {
              if (!FS.isFile(stream.node.mode)) {
                throw new FS.ErrnoError(43);
              }
              var ptr;
              var allocated;
              var contents = stream.node.contents;
              if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
                allocated = false;
                ptr = contents.byteOffset;
              } else {
                allocated = true;
                ptr = mmapAlloc();
                if (!ptr) {
                  throw new FS.ErrnoError(48);
                }
                if (contents) {
                  if (position > 0 || position + length < contents.length) {
                    if (contents.subarray) {
                      contents = contents.subarray(position, position + length);
                    } else {
                      contents = Array.prototype.slice.call(contents, position, position + length);
                    }
                  }
                  HEAP8.set(contents, ptr);
                }
              }
              return { ptr, allocated };
            },
            msync(stream, buffer, offset, length, mmapFlags) {
              MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
              return 0;
            }
          }
        };
        var asyncLoad = (url) => __async(null, null, function* () {
          var arrayBuffer = yield readAsync(url);
          assert(arrayBuffer, `Loading data file "${url}" failed (no arrayBuffer).`);
          return new Uint8Array(arrayBuffer);
        });
        var FS_createDataFile = (...args) => FS.createDataFile(...args);
        var preloadPlugins = [];
        var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
          if (typeof Browser != "undefined")
            Browser.init();
          var handled = false;
          preloadPlugins.forEach((plugin) => {
            if (handled)
              return;
            if (plugin["canHandle"](fullname)) {
              plugin["handle"](byteArray, fullname, finish, onerror);
              handled = true;
            }
          });
          return handled;
        };
        var FS_createPreloadedFile = (parent, name2, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
          var fullname = name2 ? PATH_FS.resolve(PATH.join2(parent, name2)) : parent;
          var dep = getUniqueRunDependency(`cp ${fullname}`);
          function processData(byteArray) {
            function finish(byteArray2) {
              preFinish == null ? void 0 : preFinish();
              if (!dontCreateFile) {
                FS_createDataFile(parent, name2, byteArray2, canRead, canWrite, canOwn);
              }
              onload == null ? void 0 : onload();
              removeRunDependency(dep);
            }
            if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
              onerror == null ? void 0 : onerror();
              removeRunDependency(dep);
            })) {
              return;
            }
            finish(byteArray);
          }
          addRunDependency(dep);
          if (typeof url == "string") {
            asyncLoad(url).then(processData, onerror);
          } else {
            processData(url);
          }
        };
        var FS_modeStringToFlags = (str) => {
          var flagModes = {
            "r": 0,
            "r+": 2,
            "w": 512 | 64 | 1,
            "w+": 512 | 64 | 2,
            "a": 1024 | 64 | 1,
            "a+": 1024 | 64 | 2
          };
          var flags = flagModes[str];
          if (typeof flags == "undefined") {
            throw new Error(`Unknown file open mode: ${str}`);
          }
          return flags;
        };
        var FS_getMode = (canRead, canWrite) => {
          var mode = 0;
          if (canRead)
            mode |= 292 | 73;
          if (canWrite)
            mode |= 146;
          return mode;
        };
        var IDBFS = {
          dbs: {},
          indexedDB: () => {
            if (typeof indexedDB != "undefined")
              return indexedDB;
            var ret = null;
            if (typeof window == "object")
              ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
            assert(ret, "IDBFS used, but indexedDB not supported");
            return ret;
          },
          DB_VERSION: 21,
          DB_STORE_NAME: "FILE_DATA",
          queuePersist: (mount) => {
            function onPersistComplete() {
              if (mount.idbPersistState === "again")
                startPersist();
              else
                mount.idbPersistState = 0;
            }
            function startPersist() {
              mount.idbPersistState = "idb";
              IDBFS.syncfs(
                mount,
                /*populate:*/
                false,
                onPersistComplete
              );
            }
            if (!mount.idbPersistState) {
              mount.idbPersistState = setTimeout(startPersist, 0);
            } else if (mount.idbPersistState === "idb") {
              mount.idbPersistState = "again";
            }
          },
          mount: (mount) => {
            var _a2;
            var mnt = MEMFS.mount(mount);
            if ((_a2 = mount == null ? void 0 : mount.opts) == null ? void 0 : _a2.autoPersist) {
              mnt.idbPersistState = 0;
              var memfs_node_ops = mnt.node_ops;
              mnt.node_ops = __spreadValues({}, mnt.node_ops);
              mnt.node_ops.mknod = (parent, name2, mode, dev) => {
                var node = memfs_node_ops.mknod(parent, name2, mode, dev);
                node.node_ops = mnt.node_ops;
                node.idbfs_mount = mnt.mount;
                node.memfs_stream_ops = node.stream_ops;
                node.stream_ops = __spreadValues({}, node.stream_ops);
                node.stream_ops.write = (stream, buffer, offset, length, position, canOwn) => {
                  stream.node.isModified = true;
                  return node.memfs_stream_ops.write(stream, buffer, offset, length, position, canOwn);
                };
                node.stream_ops.close = (stream) => {
                  var n = stream.node;
                  if (n.isModified) {
                    IDBFS.queuePersist(n.idbfs_mount);
                    n.isModified = false;
                  }
                  if (n.memfs_stream_ops.close)
                    return n.memfs_stream_ops.close(stream);
                };
                return node;
              };
              mnt.node_ops.mkdir = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.mkdir(...args));
              mnt.node_ops.rmdir = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rmdir(...args));
              mnt.node_ops.symlink = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.symlink(...args));
              mnt.node_ops.unlink = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.unlink(...args));
              mnt.node_ops.rename = (...args) => (IDBFS.queuePersist(mnt.mount), memfs_node_ops.rename(...args));
            }
            return mnt;
          },
          syncfs: (mount, populate, callback) => {
            IDBFS.getLocalSet(mount, (err2, local) => {
              if (err2)
                return callback(err2);
              IDBFS.getRemoteSet(mount, (err3, remote) => {
                if (err3)
                  return callback(err3);
                var src = populate ? remote : local;
                var dst = populate ? local : remote;
                IDBFS.reconcile(src, dst, callback);
              });
            });
          },
          quit: () => {
            Object.values(IDBFS.dbs).forEach((value) => value.close());
            IDBFS.dbs = {};
          },
          getDB: (name2, callback) => {
            var db = IDBFS.dbs[name2];
            if (db) {
              return callback(null, db);
            }
            var req;
            try {
              req = IDBFS.indexedDB().open(name2, IDBFS.DB_VERSION);
            } catch (e) {
              return callback(e);
            }
            if (!req) {
              return callback("Unable to connect to IndexedDB");
            }
            req.onupgradeneeded = (e) => {
              var db2 = (
                /** @type {IDBDatabase} */
                e.target.result
              );
              var transaction = e.target.transaction;
              var fileStore;
              if (db2.objectStoreNames.contains(IDBFS.DB_STORE_NAME)) {
                fileStore = transaction.objectStore(IDBFS.DB_STORE_NAME);
              } else {
                fileStore = db2.createObjectStore(IDBFS.DB_STORE_NAME);
              }
              if (!fileStore.indexNames.contains("timestamp")) {
                fileStore.createIndex("timestamp", "timestamp", { unique: false });
              }
            };
            req.onsuccess = () => {
              db = /** @type {IDBDatabase} */
              req.result;
              IDBFS.dbs[name2] = db;
              callback(null, db);
            };
            req.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };
          },
          getLocalSet: (mount, callback) => {
            var entries = {};
            function isRealDir(p) {
              return p !== "." && p !== "..";
            }
            function toAbsolute(root) {
              return (p) => PATH.join2(root, p);
            }
            var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint));
            while (check.length) {
              var path = check.pop();
              var stat;
              try {
                stat = FS.stat(path);
              } catch (e) {
                return callback(e);
              }
              if (FS.isDir(stat.mode)) {
                check.push(...FS.readdir(path).filter(isRealDir).map(toAbsolute(path)));
              }
              entries[path] = { "timestamp": stat.mtime };
            }
            return callback(null, { type: "local", entries });
          },
          getRemoteSet: (mount, callback) => {
            var entries = {};
            IDBFS.getDB(mount.mountpoint, (err2, db) => {
              if (err2)
                return callback(err2);
              try {
                var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly");
                transaction.onerror = (e) => {
                  callback(e.target.error);
                  e.preventDefault();
                };
                var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
                var index = store.index("timestamp");
                index.openKeyCursor().onsuccess = (event) => {
                  var cursor = event.target.result;
                  if (!cursor) {
                    return callback(null, { type: "remote", db, entries });
                  }
                  entries[cursor.primaryKey] = { "timestamp": cursor.key };
                  cursor.continue();
                };
              } catch (e) {
                return callback(e);
              }
            });
          },
          loadLocalEntry: (path, callback) => {
            var stat, node;
            try {
              var lookup = FS.lookupPath(path);
              node = lookup.node;
              stat = FS.stat(path);
            } catch (e) {
              return callback(e);
            }
            if (FS.isDir(stat.mode)) {
              return callback(null, { "timestamp": stat.mtime, "mode": stat.mode });
            } else if (FS.isFile(stat.mode)) {
              node.contents = MEMFS.getFileDataAsTypedArray(node);
              return callback(null, { "timestamp": stat.mtime, "mode": stat.mode, "contents": node.contents });
            } else {
              return callback(new Error("node type not supported"));
            }
          },
          storeLocalEntry: (path, entry, callback) => {
            try {
              if (FS.isDir(entry["mode"])) {
                FS.mkdirTree(path, entry["mode"]);
              } else if (FS.isFile(entry["mode"])) {
                FS.writeFile(path, entry["contents"], { canOwn: true });
              } else {
                return callback(new Error("node type not supported"));
              }
              FS.chmod(path, entry["mode"]);
              FS.utime(path, entry["timestamp"], entry["timestamp"]);
            } catch (e) {
              return callback(e);
            }
            callback(null);
          },
          removeLocalEntry: (path, callback) => {
            try {
              var stat = FS.stat(path);
              if (FS.isDir(stat.mode)) {
                FS.rmdir(path);
              } else if (FS.isFile(stat.mode)) {
                FS.unlink(path);
              }
            } catch (e) {
              return callback(e);
            }
            callback(null);
          },
          loadRemoteEntry: (store, path, callback) => {
            var req = store.get(path);
            req.onsuccess = (event) => callback(null, event.target.result);
            req.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };
          },
          storeRemoteEntry: (store, path, entry, callback) => {
            try {
              var req = store.put(entry, path);
            } catch (e) {
              callback(e);
              return;
            }
            req.onsuccess = (event) => callback();
            req.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };
          },
          removeRemoteEntry: (store, path, callback) => {
            var req = store.delete(path);
            req.onsuccess = (event) => callback();
            req.onerror = (e) => {
              callback(e.target.error);
              e.preventDefault();
            };
          },
          reconcile: (src, dst, callback) => {
            var total = 0;
            var create = [];
            Object.keys(src.entries).forEach((key) => {
              var e = src.entries[key];
              var e2 = dst.entries[key];
              if (!e2 || e["timestamp"].getTime() != e2["timestamp"].getTime()) {
                create.push(key);
                total++;
              }
            });
            var remove = [];
            Object.keys(dst.entries).forEach((key) => {
              if (!src.entries[key]) {
                remove.push(key);
                total++;
              }
            });
            if (!total) {
              return callback(null);
            }
            var errored = false;
            var db = src.type === "remote" ? src.db : dst.db;
            var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readwrite");
            var store = transaction.objectStore(IDBFS.DB_STORE_NAME);
            function done(err2) {
              if (err2 && !errored) {
                errored = true;
                return callback(err2);
              }
            }
            transaction.onerror = transaction.onabort = (e) => {
              done(e.target.error);
              e.preventDefault();
            };
            transaction.oncomplete = (e) => {
              if (!errored) {
                callback(null);
              }
            };
            create.sort().forEach((path) => {
              if (dst.type === "local") {
                IDBFS.loadRemoteEntry(store, path, (err2, entry) => {
                  if (err2)
                    return done(err2);
                  IDBFS.storeLocalEntry(path, entry, done);
                });
              } else {
                IDBFS.loadLocalEntry(path, (err2, entry) => {
                  if (err2)
                    return done(err2);
                  IDBFS.storeRemoteEntry(store, path, entry, done);
                });
              }
            });
            remove.sort().reverse().forEach((path) => {
              if (dst.type === "local") {
                IDBFS.removeLocalEntry(path, done);
              } else {
                IDBFS.removeRemoteEntry(store, path, done);
              }
            });
          }
        };
        var strError = (errno) => UTF8ToString(_strerror(errno));
        var ERRNO_CODES = {
          "EPERM": 63,
          "ENOENT": 44,
          "ESRCH": 71,
          "EINTR": 27,
          "EIO": 29,
          "ENXIO": 60,
          "E2BIG": 1,
          "ENOEXEC": 45,
          "EBADF": 8,
          "ECHILD": 12,
          "EAGAIN": 6,
          "EWOULDBLOCK": 6,
          "ENOMEM": 48,
          "EACCES": 2,
          "EFAULT": 21,
          "ENOTBLK": 105,
          "EBUSY": 10,
          "EEXIST": 20,
          "EXDEV": 75,
          "ENODEV": 43,
          "ENOTDIR": 54,
          "EISDIR": 31,
          "EINVAL": 28,
          "ENFILE": 41,
          "EMFILE": 33,
          "ENOTTY": 59,
          "ETXTBSY": 74,
          "EFBIG": 22,
          "ENOSPC": 51,
          "ESPIPE": 70,
          "EROFS": 69,
          "EMLINK": 34,
          "EPIPE": 64,
          "EDOM": 18,
          "ERANGE": 68,
          "ENOMSG": 49,
          "EIDRM": 24,
          "ECHRNG": 106,
          "EL2NSYNC": 156,
          "EL3HLT": 107,
          "EL3RST": 108,
          "ELNRNG": 109,
          "EUNATCH": 110,
          "ENOCSI": 111,
          "EL2HLT": 112,
          "EDEADLK": 16,
          "ENOLCK": 46,
          "EBADE": 113,
          "EBADR": 114,
          "EXFULL": 115,
          "ENOANO": 104,
          "EBADRQC": 103,
          "EBADSLT": 102,
          "EDEADLOCK": 16,
          "EBFONT": 101,
          "ENOSTR": 100,
          "ENODATA": 116,
          "ETIME": 117,
          "ENOSR": 118,
          "ENONET": 119,
          "ENOPKG": 120,
          "EREMOTE": 121,
          "ENOLINK": 47,
          "EADV": 122,
          "ESRMNT": 123,
          "ECOMM": 124,
          "EPROTO": 65,
          "EMULTIHOP": 36,
          "EDOTDOT": 125,
          "EBADMSG": 9,
          "ENOTUNIQ": 126,
          "EBADFD": 127,
          "EREMCHG": 128,
          "ELIBACC": 129,
          "ELIBBAD": 130,
          "ELIBSCN": 131,
          "ELIBMAX": 132,
          "ELIBEXEC": 133,
          "ENOSYS": 52,
          "ENOTEMPTY": 55,
          "ENAMETOOLONG": 37,
          "ELOOP": 32,
          "EOPNOTSUPP": 138,
          "EPFNOSUPPORT": 139,
          "ECONNRESET": 15,
          "ENOBUFS": 42,
          "EAFNOSUPPORT": 5,
          "EPROTOTYPE": 67,
          "ENOTSOCK": 57,
          "ENOPROTOOPT": 50,
          "ESHUTDOWN": 140,
          "ECONNREFUSED": 14,
          "EADDRINUSE": 3,
          "ECONNABORTED": 13,
          "ENETUNREACH": 40,
          "ENETDOWN": 38,
          "ETIMEDOUT": 73,
          "EHOSTDOWN": 142,
          "EHOSTUNREACH": 23,
          "EINPROGRESS": 26,
          "EALREADY": 7,
          "EDESTADDRREQ": 17,
          "EMSGSIZE": 35,
          "EPROTONOSUPPORT": 66,
          "ESOCKTNOSUPPORT": 137,
          "EADDRNOTAVAIL": 4,
          "ENETRESET": 39,
          "EISCONN": 30,
          "ENOTCONN": 53,
          "ETOOMANYREFS": 141,
          "EUSERS": 136,
          "EDQUOT": 19,
          "ESTALE": 72,
          "ENOTSUP": 138,
          "ENOMEDIUM": 148,
          "EILSEQ": 25,
          "EOVERFLOW": 61,
          "ECANCELED": 11,
          "ENOTRECOVERABLE": 56,
          "EOWNERDEAD": 62,
          "ESTRPIPE": 135
        };
        var FS = {
          root: null,
          mounts: [],
          devices: {},
          streams: [],
          nextInode: 1,
          nameTable: null,
          currentPath: "/",
          initialized: false,
          ignorePermissions: true,
          filesystems: null,
          syncFSRequests: 0,
          readFiles: {},
          ErrnoError: class extends Error {
            // We set the `name` property to be able to identify `FS.ErrnoError`
            // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.
            // - when using PROXYFS, an error can come from an underlying FS
            // as different FS objects have their own FS.ErrnoError each,
            // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.
            // we'll use the reliable test `err.name == "ErrnoError"` instead
            constructor(errno) {
              super(runtimeInitialized ? strError(errno) : "");
              __publicField(this, "name", "ErrnoError");
              this.errno = errno;
              for (var key in ERRNO_CODES) {
                if (ERRNO_CODES[key] === errno) {
                  this.code = key;
                  break;
                }
              }
            }
          },
          FSStream: class {
            constructor() {
              __publicField(this, "shared", {});
            }
            get object() {
              return this.node;
            }
            set object(val) {
              this.node = val;
            }
            get isRead() {
              return (this.flags & 2097155) !== 1;
            }
            get isWrite() {
              return (this.flags & 2097155) !== 0;
            }
            get isAppend() {
              return this.flags & 1024;
            }
            get flags() {
              return this.shared.flags;
            }
            set flags(val) {
              this.shared.flags = val;
            }
            get position() {
              return this.shared.position;
            }
            set position(val) {
              this.shared.position = val;
            }
          },
          FSNode: class {
            constructor(parent, name2, mode, rdev) {
              __publicField(this, "node_ops", {});
              __publicField(this, "stream_ops", {});
              __publicField(this, "readMode", 292 | 73);
              __publicField(this, "writeMode", 146);
              __publicField(this, "mounted", null);
              if (!parent) {
                parent = this;
              }
              this.parent = parent;
              this.mount = parent.mount;
              this.id = FS.nextInode++;
              this.name = name2;
              this.mode = mode;
              this.rdev = rdev;
              this.atime = this.mtime = this.ctime = Date.now();
            }
            get read() {
              return (this.mode & this.readMode) === this.readMode;
            }
            set read(val) {
              val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
            }
            get write() {
              return (this.mode & this.writeMode) === this.writeMode;
            }
            set write(val) {
              val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
            }
            get isFolder() {
              return FS.isDir(this.mode);
            }
            get isDevice() {
              return FS.isChrdev(this.mode);
            }
          },
          lookupPath(path, opts = {}) {
            var _a2;
            if (!path) {
              throw new FS.ErrnoError(44);
            }
            (_a2 = opts.follow_mount) != null ? _a2 : opts.follow_mount = true;
            if (!PATH.isAbs(path)) {
              path = FS.cwd() + "/" + path;
            }
            linkloop:
              for (var nlinks = 0; nlinks < 40; nlinks++) {
                var parts = path.split("/").filter((p) => !!p);
                var current = FS.root;
                var current_path = "/";
                for (var i = 0; i < parts.length; i++) {
                  var islast = i === parts.length - 1;
                  if (islast && opts.parent) {
                    break;
                  }
                  if (parts[i] === ".") {
                    continue;
                  }
                  if (parts[i] === "..") {
                    current_path = PATH.dirname(current_path);
                    if (FS.isRoot(current)) {
                      path = current_path + "/" + parts.slice(i + 1).join("/");
                      continue linkloop;
                    } else {
                      current = current.parent;
                    }
                    continue;
                  }
                  current_path = PATH.join2(current_path, parts[i]);
                  try {
                    current = FS.lookupNode(current, parts[i]);
                  } catch (e) {
                    if ((e == null ? void 0 : e.errno) === 44 && islast && opts.noent_okay) {
                      return { path: current_path };
                    }
                    throw e;
                  }
                  if (FS.isMountpoint(current) && (!islast || opts.follow_mount)) {
                    current = current.mounted.root;
                  }
                  if (FS.isLink(current.mode) && (!islast || opts.follow)) {
                    if (!current.node_ops.readlink) {
                      throw new FS.ErrnoError(52);
                    }
                    var link = current.node_ops.readlink(current);
                    if (!PATH.isAbs(link)) {
                      link = PATH.dirname(current_path) + "/" + link;
                    }
                    path = link + "/" + parts.slice(i + 1).join("/");
                    continue linkloop;
                  }
                }
                return { path: current_path, node: current };
              }
            throw new FS.ErrnoError(32);
          },
          getPath(node) {
            var path;
            while (true) {
              if (FS.isRoot(node)) {
                var mount = node.mount.mountpoint;
                if (!path)
                  return mount;
                return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
              }
              path = path ? `${node.name}/${path}` : node.name;
              node = node.parent;
            }
          },
          hashName(parentid, name2) {
            var hash = 0;
            for (var i = 0; i < name2.length; i++) {
              hash = (hash << 5) - hash + name2.charCodeAt(i) | 0;
            }
            return (parentid + hash >>> 0) % FS.nameTable.length;
          },
          hashAddNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            node.name_next = FS.nameTable[hash];
            FS.nameTable[hash] = node;
          },
          hashRemoveNode(node) {
            var hash = FS.hashName(node.parent.id, node.name);
            if (FS.nameTable[hash] === node) {
              FS.nameTable[hash] = node.name_next;
            } else {
              var current = FS.nameTable[hash];
              while (current) {
                if (current.name_next === node) {
                  current.name_next = node.name_next;
                  break;
                }
                current = current.name_next;
              }
            }
          },
          lookupNode(parent, name2) {
            var errCode = FS.mayLookup(parent);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            var hash = FS.hashName(parent.id, name2);
            for (var node = FS.nameTable[hash]; node; node = node.name_next) {
              var nodeName = node.name;
              if (node.parent.id === parent.id && nodeName === name2) {
                return node;
              }
            }
            return FS.lookup(parent, name2);
          },
          createNode(parent, name2, mode, rdev) {
            assert(typeof parent == "object");
            var node = new FS.FSNode(parent, name2, mode, rdev);
            FS.hashAddNode(node);
            return node;
          },
          destroyNode(node) {
            FS.hashRemoveNode(node);
          },
          isRoot(node) {
            return node === node.parent;
          },
          isMountpoint(node) {
            return !!node.mounted;
          },
          isFile(mode) {
            return (mode & 61440) === 32768;
          },
          isDir(mode) {
            return (mode & 61440) === 16384;
          },
          isLink(mode) {
            return (mode & 61440) === 40960;
          },
          isChrdev(mode) {
            return (mode & 61440) === 8192;
          },
          isBlkdev(mode) {
            return (mode & 61440) === 24576;
          },
          isFIFO(mode) {
            return (mode & 61440) === 4096;
          },
          isSocket(mode) {
            return (mode & 49152) === 49152;
          },
          flagsToPermissionString(flag) {
            var perms = ["r", "w", "rw"][flag & 3];
            if (flag & 512) {
              perms += "w";
            }
            return perms;
          },
          nodePermissions(node, perms) {
            if (FS.ignorePermissions) {
              return 0;
            }
            if (perms.includes("r") && !(node.mode & 292)) {
              return 2;
            } else if (perms.includes("w") && !(node.mode & 146)) {
              return 2;
            } else if (perms.includes("x") && !(node.mode & 73)) {
              return 2;
            }
            return 0;
          },
          mayLookup(dir) {
            if (!FS.isDir(dir.mode))
              return 54;
            var errCode = FS.nodePermissions(dir, "x");
            if (errCode)
              return errCode;
            if (!dir.node_ops.lookup)
              return 2;
            return 0;
          },
          mayCreate(dir, name2) {
            if (!FS.isDir(dir.mode)) {
              return 54;
            }
            try {
              var node = FS.lookupNode(dir, name2);
              return 20;
            } catch (e) {
            }
            return FS.nodePermissions(dir, "wx");
          },
          mayDelete(dir, name2, isdir) {
            var node;
            try {
              node = FS.lookupNode(dir, name2);
            } catch (e) {
              return e.errno;
            }
            var errCode = FS.nodePermissions(dir, "wx");
            if (errCode) {
              return errCode;
            }
            if (isdir) {
              if (!FS.isDir(node.mode)) {
                return 54;
              }
              if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
                return 10;
              }
            } else {
              if (FS.isDir(node.mode)) {
                return 31;
              }
            }
            return 0;
          },
          mayOpen(node, flags) {
            if (!node) {
              return 44;
            }
            if (FS.isLink(node.mode)) {
              return 32;
            } else if (FS.isDir(node.mode)) {
              if (FS.flagsToPermissionString(flags) !== "r" || flags & (512 | 64)) {
                return 31;
              }
            }
            return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
          },
          checkOpExists(op, err2) {
            if (!op) {
              throw new FS.ErrnoError(err2);
            }
            return op;
          },
          MAX_OPEN_FDS: 4096,
          nextfd() {
            for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
              if (!FS.streams[fd]) {
                return fd;
              }
            }
            throw new FS.ErrnoError(33);
          },
          getStreamChecked(fd) {
            var stream = FS.getStream(fd);
            if (!stream) {
              throw new FS.ErrnoError(8);
            }
            return stream;
          },
          getStream: (fd) => FS.streams[fd],
          createStream(stream, fd = -1) {
            assert(fd >= -1);
            stream = Object.assign(new FS.FSStream(), stream);
            if (fd == -1) {
              fd = FS.nextfd();
            }
            stream.fd = fd;
            FS.streams[fd] = stream;
            return stream;
          },
          closeStream(fd) {
            FS.streams[fd] = null;
          },
          dupStream(origStream, fd = -1) {
            var _a2, _b2;
            var stream = FS.createStream(origStream, fd);
            (_b2 = (_a2 = stream.stream_ops) == null ? void 0 : _a2.dup) == null ? void 0 : _b2.call(_a2, stream);
            return stream;
          },
          doSetAttr(stream, node, attr) {
            var setattr = stream == null ? void 0 : stream.stream_ops.setattr;
            var arg = setattr ? stream : node;
            setattr != null ? setattr : setattr = node.node_ops.setattr;
            FS.checkOpExists(setattr, 63);
            setattr(arg, attr);
          },
          chrdev_stream_ops: {
            open(stream) {
              var _a2, _b2;
              var device = FS.getDevice(stream.node.rdev);
              stream.stream_ops = device.stream_ops;
              (_b2 = (_a2 = stream.stream_ops).open) == null ? void 0 : _b2.call(_a2, stream);
            },
            llseek() {
              throw new FS.ErrnoError(70);
            }
          },
          major: (dev) => dev >> 8,
          minor: (dev) => dev & 255,
          makedev: (ma, mi) => ma << 8 | mi,
          registerDevice(dev, ops) {
            FS.devices[dev] = { stream_ops: ops };
          },
          getDevice: (dev) => FS.devices[dev],
          getMounts(mount) {
            var mounts = [];
            var check = [mount];
            while (check.length) {
              var m = check.pop();
              mounts.push(m);
              check.push(...m.mounts);
            }
            return mounts;
          },
          syncfs(populate, callback) {
            if (typeof populate == "function") {
              callback = populate;
              populate = false;
            }
            FS.syncFSRequests++;
            if (FS.syncFSRequests > 1) {
              err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
            }
            var mounts = FS.getMounts(FS.root.mount);
            var completed = 0;
            function doCallback(errCode) {
              assert(FS.syncFSRequests > 0);
              FS.syncFSRequests--;
              return callback(errCode);
            }
            function done(errCode) {
              if (errCode) {
                if (!done.errored) {
                  done.errored = true;
                  return doCallback(errCode);
                }
                return;
              }
              if (++completed >= mounts.length) {
                doCallback(null);
              }
            }
            mounts.forEach((mount) => {
              if (!mount.type.syncfs) {
                return done(null);
              }
              mount.type.syncfs(mount, populate, done);
            });
          },
          mount(type, opts, mountpoint) {
            if (typeof type == "string") {
              throw type;
            }
            var root = mountpoint === "/";
            var pseudo = !mountpoint;
            var node;
            if (root && FS.root) {
              throw new FS.ErrnoError(10);
            } else if (!root && !pseudo) {
              var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
              mountpoint = lookup.path;
              node = lookup.node;
              if (FS.isMountpoint(node)) {
                throw new FS.ErrnoError(10);
              }
              if (!FS.isDir(node.mode)) {
                throw new FS.ErrnoError(54);
              }
            }
            var mount = {
              type,
              opts,
              mountpoint,
              mounts: []
            };
            var mountRoot = type.mount(mount);
            mountRoot.mount = mount;
            mount.root = mountRoot;
            if (root) {
              FS.root = mountRoot;
            } else if (node) {
              node.mounted = mount;
              if (node.mount) {
                node.mount.mounts.push(mount);
              }
            }
            return mountRoot;
          },
          unmount(mountpoint) {
            var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
            if (!FS.isMountpoint(lookup.node)) {
              throw new FS.ErrnoError(28);
            }
            var node = lookup.node;
            var mount = node.mounted;
            var mounts = FS.getMounts(mount);
            Object.keys(FS.nameTable).forEach((hash) => {
              var current = FS.nameTable[hash];
              while (current) {
                var next = current.name_next;
                if (mounts.includes(current.mount)) {
                  FS.destroyNode(current);
                }
                current = next;
              }
            });
            node.mounted = null;
            var idx = node.mount.mounts.indexOf(mount);
            assert(idx !== -1);
            node.mount.mounts.splice(idx, 1);
          },
          lookup(parent, name2) {
            return parent.node_ops.lookup(parent, name2);
          },
          mknod(path, mode, dev) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            if (!name2) {
              throw new FS.ErrnoError(28);
            }
            if (name2 === "." || name2 === "..") {
              throw new FS.ErrnoError(20);
            }
            var errCode = FS.mayCreate(parent, name2);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.mknod) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.mknod(parent, name2, mode, dev);
          },
          statfs(path) {
            return FS.statfsNode(FS.lookupPath(path, { follow: true }).node);
          },
          statfsStream(stream) {
            return FS.statfsNode(stream.node);
          },
          statfsNode(node) {
            var rtn = {
              bsize: 4096,
              frsize: 4096,
              blocks: 1e6,
              bfree: 5e5,
              bavail: 5e5,
              files: FS.nextInode,
              ffree: FS.nextInode - 1,
              fsid: 42,
              flags: 2,
              namelen: 255
            };
            if (node.node_ops.statfs) {
              Object.assign(rtn, node.node_ops.statfs(node.mount.opts.root));
            }
            return rtn;
          },
          create(path, mode = 438) {
            mode &= 4095;
            mode |= 32768;
            return FS.mknod(path, mode, 0);
          },
          mkdir(path, mode = 511) {
            mode &= 511 | 512;
            mode |= 16384;
            return FS.mknod(path, mode, 0);
          },
          mkdirTree(path, mode) {
            var dirs = path.split("/");
            var d = "";
            for (var dir of dirs) {
              if (!dir)
                continue;
              if (d || PATH.isAbs(path))
                d += "/";
              d += dir;
              try {
                FS.mkdir(d, mode);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
            }
          },
          mkdev(path, mode, dev) {
            if (typeof dev == "undefined") {
              dev = mode;
              mode = 438;
            }
            mode |= 8192;
            return FS.mknod(path, mode, dev);
          },
          symlink(oldpath, newpath) {
            if (!PATH_FS.resolve(oldpath)) {
              throw new FS.ErrnoError(44);
            }
            var lookup = FS.lookupPath(newpath, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var newname = PATH.basename(newpath);
            var errCode = FS.mayCreate(parent, newname);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.symlink) {
              throw new FS.ErrnoError(63);
            }
            return parent.node_ops.symlink(parent, newname, oldpath);
          },
          rename(old_path, new_path) {
            var old_dirname = PATH.dirname(old_path);
            var new_dirname = PATH.dirname(new_path);
            var old_name = PATH.basename(old_path);
            var new_name = PATH.basename(new_path);
            var lookup, old_dir, new_dir;
            lookup = FS.lookupPath(old_path, { parent: true });
            old_dir = lookup.node;
            lookup = FS.lookupPath(new_path, { parent: true });
            new_dir = lookup.node;
            if (!old_dir || !new_dir)
              throw new FS.ErrnoError(44);
            if (old_dir.mount !== new_dir.mount) {
              throw new FS.ErrnoError(75);
            }
            var old_node = FS.lookupNode(old_dir, old_name);
            var relative = PATH_FS.relative(old_path, new_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(28);
            }
            relative = PATH_FS.relative(new_path, old_dirname);
            if (relative.charAt(0) !== ".") {
              throw new FS.ErrnoError(55);
            }
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (old_node === new_node) {
              return;
            }
            var isdir = FS.isDir(old_node.mode);
            var errCode = FS.mayDelete(old_dir, old_name, isdir);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!old_dir.node_ops.rename) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
              throw new FS.ErrnoError(10);
            }
            if (new_dir !== old_dir) {
              errCode = FS.nodePermissions(old_dir, "w");
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            FS.hashRemoveNode(old_node);
            try {
              old_dir.node_ops.rename(old_node, new_dir, new_name);
              old_node.parent = new_dir;
            } catch (e) {
              throw e;
            } finally {
              FS.hashAddNode(old_node);
            }
          },
          rmdir(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, true);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.rmdir) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.rmdir(parent, name2);
            FS.destroyNode(node);
          },
          readdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            var readdir = FS.checkOpExists(node.node_ops.readdir, 54);
            return readdir(node);
          },
          unlink(path) {
            var lookup = FS.lookupPath(path, { parent: true });
            var parent = lookup.node;
            if (!parent) {
              throw new FS.ErrnoError(44);
            }
            var name2 = PATH.basename(path);
            var node = FS.lookupNode(parent, name2);
            var errCode = FS.mayDelete(parent, name2, false);
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            if (!parent.node_ops.unlink) {
              throw new FS.ErrnoError(63);
            }
            if (FS.isMountpoint(node)) {
              throw new FS.ErrnoError(10);
            }
            parent.node_ops.unlink(parent, name2);
            FS.destroyNode(node);
          },
          readlink(path) {
            var lookup = FS.lookupPath(path);
            var link = lookup.node;
            if (!link) {
              throw new FS.ErrnoError(44);
            }
            if (!link.node_ops.readlink) {
              throw new FS.ErrnoError(28);
            }
            return link.node_ops.readlink(link);
          },
          stat(path, dontFollow) {
            var lookup = FS.lookupPath(path, { follow: !dontFollow });
            var node = lookup.node;
            var getattr = FS.checkOpExists(node.node_ops.getattr, 63);
            return getattr(node);
          },
          fstat(fd) {
            var stream = FS.getStreamChecked(fd);
            var node = stream.node;
            var getattr = stream.stream_ops.getattr;
            var arg = getattr ? stream : node;
            getattr != null ? getattr : getattr = node.node_ops.getattr;
            FS.checkOpExists(getattr, 63);
            return getattr(arg);
          },
          lstat(path) {
            return FS.stat(path, true);
          },
          doChmod(stream, node, mode, dontFollow) {
            FS.doSetAttr(stream, node, {
              mode: mode & 4095 | node.mode & -4096,
              ctime: Date.now(),
              dontFollow
            });
          },
          chmod(path, mode, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            FS.doChmod(null, node, mode, dontFollow);
          },
          lchmod(path, mode) {
            FS.chmod(path, mode, true);
          },
          fchmod(fd, mode) {
            var stream = FS.getStreamChecked(fd);
            FS.doChmod(stream, stream.node, mode, false);
          },
          doChown(stream, node, dontFollow) {
            FS.doSetAttr(stream, node, {
              timestamp: Date.now(),
              dontFollow
              // we ignore the uid / gid for now
            });
          },
          chown(path, uid, gid, dontFollow) {
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: !dontFollow });
              node = lookup.node;
            } else {
              node = path;
            }
            FS.doChown(null, node, dontFollow);
          },
          lchown(path, uid, gid) {
            FS.chown(path, uid, gid, true);
          },
          fchown(fd, uid, gid) {
            var stream = FS.getStreamChecked(fd);
            FS.doChown(stream, stream.node, false);
          },
          doTruncate(stream, node, len) {
            if (FS.isDir(node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!FS.isFile(node.mode)) {
              throw new FS.ErrnoError(28);
            }
            var errCode = FS.nodePermissions(node, "w");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.doSetAttr(stream, node, {
              size: len,
              timestamp: Date.now()
            });
          },
          truncate(path, len) {
            if (len < 0) {
              throw new FS.ErrnoError(28);
            }
            var node;
            if (typeof path == "string") {
              var lookup = FS.lookupPath(path, { follow: true });
              node = lookup.node;
            } else {
              node = path;
            }
            FS.doTruncate(null, node, len);
          },
          ftruncate(fd, len) {
            var stream = FS.getStreamChecked(fd);
            if (len < 0 || (stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(28);
            }
            FS.doTruncate(stream, stream.node, len);
          },
          utime(path, atime, mtime) {
            var lookup = FS.lookupPath(path, { follow: true });
            var node = lookup.node;
            var setattr = FS.checkOpExists(node.node_ops.setattr, 63);
            setattr(node, {
              atime,
              mtime
            });
          },
          open(path, flags, mode = 438) {
            if (path === "") {
              throw new FS.ErrnoError(44);
            }
            flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
            if (flags & 64) {
              mode = mode & 4095 | 32768;
            } else {
              mode = 0;
            }
            var node;
            var isDirPath;
            if (typeof path == "object") {
              node = path;
            } else {
              isDirPath = path.endsWith("/");
              var lookup = FS.lookupPath(path, {
                follow: !(flags & 131072),
                noent_okay: true
              });
              node = lookup.node;
              path = lookup.path;
            }
            var created = false;
            if (flags & 64) {
              if (node) {
                if (flags & 128) {
                  throw new FS.ErrnoError(20);
                }
              } else if (isDirPath) {
                throw new FS.ErrnoError(31);
              } else {
                node = FS.mknod(path, mode | 511, 0);
                created = true;
              }
            }
            if (!node) {
              throw new FS.ErrnoError(44);
            }
            if (FS.isChrdev(node.mode)) {
              flags &= -513;
            }
            if (flags & 65536 && !FS.isDir(node.mode)) {
              throw new FS.ErrnoError(54);
            }
            if (!created) {
              var errCode = FS.mayOpen(node, flags);
              if (errCode) {
                throw new FS.ErrnoError(errCode);
              }
            }
            if (flags & 512 && !created) {
              FS.truncate(node, 0);
            }
            flags &= -131713;
            var stream = FS.createStream({
              node,
              path: FS.getPath(node),
              // we want the absolute path to the node
              flags,
              seekable: true,
              position: 0,
              stream_ops: node.stream_ops,
              // used by the file family libc calls (fopen, fwrite, ferror, etc.)
              ungotten: [],
              error: false
            });
            if (stream.stream_ops.open) {
              stream.stream_ops.open(stream);
            }
            if (created) {
              FS.chmod(node, mode & 511);
            }
            if (Module["logReadFiles"] && !(flags & 1)) {
              if (!(path in FS.readFiles)) {
                FS.readFiles[path] = 1;
              }
            }
            return stream;
          },
          close(stream) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (stream.getdents)
              stream.getdents = null;
            try {
              if (stream.stream_ops.close) {
                stream.stream_ops.close(stream);
              }
            } catch (e) {
              throw e;
            } finally {
              FS.closeStream(stream.fd);
            }
            stream.fd = null;
          },
          isClosed(stream) {
            return stream.fd === null;
          },
          llseek(stream, offset, whence) {
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if (!stream.seekable || !stream.stream_ops.llseek) {
              throw new FS.ErrnoError(70);
            }
            if (whence != 0 && whence != 1 && whence != 2) {
              throw new FS.ErrnoError(28);
            }
            stream.position = stream.stream_ops.llseek(stream, offset, whence);
            stream.ungotten = [];
            return stream.position;
          },
          read(stream, buffer, offset, length, position) {
            assert(offset >= 0);
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.read) {
              throw new FS.ErrnoError(28);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
            if (!seeking)
              stream.position += bytesRead;
            return bytesRead;
          },
          write(stream, buffer, offset, length, position, canOwn) {
            assert(offset >= 0);
            if (length < 0 || position < 0) {
              throw new FS.ErrnoError(28);
            }
            if (FS.isClosed(stream)) {
              throw new FS.ErrnoError(8);
            }
            if ((stream.flags & 2097155) === 0) {
              throw new FS.ErrnoError(8);
            }
            if (FS.isDir(stream.node.mode)) {
              throw new FS.ErrnoError(31);
            }
            if (!stream.stream_ops.write) {
              throw new FS.ErrnoError(28);
            }
            if (stream.seekable && stream.flags & 1024) {
              FS.llseek(stream, 0, 2);
            }
            var seeking = typeof position != "undefined";
            if (!seeking) {
              position = stream.position;
            } else if (!stream.seekable) {
              throw new FS.ErrnoError(70);
            }
            var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
            if (!seeking)
              stream.position += bytesWritten;
            return bytesWritten;
          },
          mmap(stream, length, position, prot, flags) {
            if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
              throw new FS.ErrnoError(2);
            }
            if ((stream.flags & 2097155) === 1) {
              throw new FS.ErrnoError(2);
            }
            if (!stream.stream_ops.mmap) {
              throw new FS.ErrnoError(43);
            }
            if (!length) {
              throw new FS.ErrnoError(28);
            }
            return stream.stream_ops.mmap(stream, length, position, prot, flags);
          },
          msync(stream, buffer, offset, length, mmapFlags) {
            assert(offset >= 0);
            if (!stream.stream_ops.msync) {
              return 0;
            }
            return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
          },
          ioctl(stream, cmd, arg) {
            if (!stream.stream_ops.ioctl) {
              throw new FS.ErrnoError(59);
            }
            return stream.stream_ops.ioctl(stream, cmd, arg);
          },
          readFile(path, opts = {}) {
            opts.flags = opts.flags || 0;
            opts.encoding = opts.encoding || "binary";
            if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
              throw new Error(`Invalid encoding type "${opts.encoding}"`);
            }
            var ret;
            var stream = FS.open(path, opts.flags);
            var stat = FS.stat(path);
            var length = stat.size;
            var buf = new Uint8Array(length);
            FS.read(stream, buf, 0, length, 0);
            if (opts.encoding === "utf8") {
              ret = UTF8ArrayToString(buf);
            } else if (opts.encoding === "binary") {
              ret = buf;
            }
            FS.close(stream);
            return ret;
          },
          writeFile(path, data, opts = {}) {
            opts.flags = opts.flags || 577;
            var stream = FS.open(path, opts.flags, opts.mode);
            if (typeof data == "string") {
              var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
              var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
              FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
            } else if (ArrayBuffer.isView(data)) {
              FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
            } else {
              throw new Error("Unsupported data type");
            }
            FS.close(stream);
          },
          cwd: () => FS.currentPath,
          chdir(path) {
            var lookup = FS.lookupPath(path, { follow: true });
            if (lookup.node === null) {
              throw new FS.ErrnoError(44);
            }
            if (!FS.isDir(lookup.node.mode)) {
              throw new FS.ErrnoError(54);
            }
            var errCode = FS.nodePermissions(lookup.node, "x");
            if (errCode) {
              throw new FS.ErrnoError(errCode);
            }
            FS.currentPath = lookup.path;
          },
          createDefaultDirectories() {
            FS.mkdir("/tmp");
            FS.mkdir("/home");
            FS.mkdir("/home/web_user");
          },
          createDefaultDevices() {
            FS.mkdir("/dev");
            FS.registerDevice(FS.makedev(1, 3), {
              read: () => 0,
              write: (stream, buffer, offset, length, pos) => length,
              llseek: () => 0
            });
            FS.mkdev("/dev/null", FS.makedev(1, 3));
            TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
            TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
            FS.mkdev("/dev/tty", FS.makedev(5, 0));
            FS.mkdev("/dev/tty1", FS.makedev(6, 0));
            var randomBuffer = new Uint8Array(1024), randomLeft = 0;
            var randomByte = () => {
              if (randomLeft === 0) {
                randomFill(randomBuffer);
                randomLeft = randomBuffer.byteLength;
              }
              return randomBuffer[--randomLeft];
            };
            FS.createDevice("/dev", "random", randomByte);
            FS.createDevice("/dev", "urandom", randomByte);
            FS.mkdir("/dev/shm");
            FS.mkdir("/dev/shm/tmp");
          },
          createSpecialDirectories() {
            FS.mkdir("/proc");
            var proc_self = FS.mkdir("/proc/self");
            FS.mkdir("/proc/self/fd");
            FS.mount({
              mount() {
                var node = FS.createNode(proc_self, "fd", 16895, 73);
                node.stream_ops = {
                  llseek: MEMFS.stream_ops.llseek
                };
                node.node_ops = {
                  lookup(parent, name2) {
                    var fd = +name2;
                    var stream = FS.getStreamChecked(fd);
                    var ret = {
                      parent: null,
                      mount: { mountpoint: "fake" },
                      node_ops: { readlink: () => stream.path },
                      id: fd + 1
                    };
                    ret.parent = ret;
                    return ret;
                  },
                  readdir() {
                    return Array.from(FS.streams.entries()).filter(([k, v]) => v).map(([k, v]) => k.toString());
                  }
                };
                return node;
              }
            }, {}, "/proc/self/fd");
          },
          createStandardStreams(input, output, error) {
            if (input) {
              FS.createDevice("/dev", "stdin", input);
            } else {
              FS.symlink("/dev/tty", "/dev/stdin");
            }
            if (output) {
              FS.createDevice("/dev", "stdout", null, output);
            } else {
              FS.symlink("/dev/tty", "/dev/stdout");
            }
            if (error) {
              FS.createDevice("/dev", "stderr", null, error);
            } else {
              FS.symlink("/dev/tty1", "/dev/stderr");
            }
            var stdin = FS.open("/dev/stdin", 0);
            var stdout = FS.open("/dev/stdout", 1);
            var stderr = FS.open("/dev/stderr", 1);
            assert(stdin.fd === 0, `invalid handle for stdin (${stdin.fd})`);
            assert(stdout.fd === 1, `invalid handle for stdout (${stdout.fd})`);
            assert(stderr.fd === 2, `invalid handle for stderr (${stderr.fd})`);
          },
          staticInit() {
            FS.nameTable = new Array(4096);
            FS.mount(MEMFS, {}, "/");
            FS.createDefaultDirectories();
            FS.createDefaultDevices();
            FS.createSpecialDirectories();
            FS.filesystems = {
              "MEMFS": MEMFS,
              "IDBFS": IDBFS
            };
          },
          init(input, output, error) {
            assert(!FS.initialized, "FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)");
            FS.initialized = true;
            input != null ? input : input = Module["stdin"];
            output != null ? output : output = Module["stdout"];
            error != null ? error : error = Module["stderr"];
            FS.createStandardStreams(input, output, error);
          },
          quit() {
            FS.initialized = false;
            _fflush(0);
            for (var stream of FS.streams) {
              if (stream) {
                FS.close(stream);
              }
            }
          },
          findObject(path, dontResolveLastLink) {
            var ret = FS.analyzePath(path, dontResolveLastLink);
            if (!ret.exists) {
              return null;
            }
            return ret.object;
          },
          analyzePath(path, dontResolveLastLink) {
            try {
              var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              path = lookup.path;
            } catch (e) {
            }
            var ret = {
              isRoot: false,
              exists: false,
              error: 0,
              name: null,
              path: null,
              object: null,
              parentExists: false,
              parentPath: null,
              parentObject: null
            };
            try {
              var lookup = FS.lookupPath(path, { parent: true });
              ret.parentExists = true;
              ret.parentPath = lookup.path;
              ret.parentObject = lookup.node;
              ret.name = PATH.basename(path);
              lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
              ret.exists = true;
              ret.path = lookup.path;
              ret.object = lookup.node;
              ret.name = lookup.node.name;
              ret.isRoot = lookup.path === "/";
            } catch (e) {
              ret.error = e.errno;
            }
            return ret;
          },
          createPath(parent, path, canRead, canWrite) {
            parent = typeof parent == "string" ? parent : FS.getPath(parent);
            var parts = path.split("/").reverse();
            while (parts.length) {
              var part = parts.pop();
              if (!part)
                continue;
              var current = PATH.join2(parent, part);
              try {
                FS.mkdir(current);
              } catch (e) {
                if (e.errno != 20)
                  throw e;
              }
              parent = current;
            }
            return current;
          },
          createFile(parent, name2, properties, canRead, canWrite) {
            var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(canRead, canWrite);
            return FS.create(path, mode);
          },
          createDataFile(parent, name2, data, canRead, canWrite, canOwn) {
            var path = name2;
            if (parent) {
              parent = typeof parent == "string" ? parent : FS.getPath(parent);
              path = name2 ? PATH.join2(parent, name2) : parent;
            }
            var mode = FS_getMode(canRead, canWrite);
            var node = FS.create(path, mode);
            if (data) {
              if (typeof data == "string") {
                var arr = new Array(data.length);
                for (var i = 0, len = data.length; i < len; ++i)
                  arr[i] = data.charCodeAt(i);
                data = arr;
              }
              FS.chmod(node, mode | 146);
              var stream = FS.open(node, 577);
              FS.write(stream, data, 0, data.length, 0, canOwn);
              FS.close(stream);
              FS.chmod(node, mode);
            }
          },
          createDevice(parent, name2, input, output) {
            var _a3;
            var _a2;
            var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name2);
            var mode = FS_getMode(!!input, !!output);
            (_a3 = (_a2 = FS.createDevice).major) != null ? _a3 : _a2.major = 64;
            var dev = FS.makedev(FS.createDevice.major++, 0);
            FS.registerDevice(dev, {
              open(stream) {
                stream.seekable = false;
              },
              close(stream) {
                var _a22;
                if ((_a22 = output == null ? void 0 : output.buffer) == null ? void 0 : _a22.length) {
                  output(10);
                }
              },
              read(stream, buffer, offset, length, pos) {
                var bytesRead = 0;
                for (var i = 0; i < length; i++) {
                  var result2;
                  try {
                    result2 = input();
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                  if (result2 === void 0 && bytesRead === 0) {
                    throw new FS.ErrnoError(6);
                  }
                  if (result2 === null || result2 === void 0)
                    break;
                  bytesRead++;
                  buffer[offset + i] = result2;
                }
                if (bytesRead) {
                  stream.node.atime = Date.now();
                }
                return bytesRead;
              },
              write(stream, buffer, offset, length, pos) {
                for (var i = 0; i < length; i++) {
                  try {
                    output(buffer[offset + i]);
                  } catch (e) {
                    throw new FS.ErrnoError(29);
                  }
                }
                if (length) {
                  stream.node.mtime = stream.node.ctime = Date.now();
                }
                return i;
              }
            });
            return FS.mkdev(path, mode, dev);
          },
          forceLoadFile(obj) {
            if (obj.isDevice || obj.isFolder || obj.link || obj.contents)
              return true;
            if (typeof XMLHttpRequest != "undefined") {
              throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
            } else {
              try {
                obj.contents = readBinary(obj.url);
                obj.usedBytes = obj.contents.length;
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
          },
          createLazyFile(parent, name2, url, canRead, canWrite) {
            class LazyUint8Array {
              constructor() {
                __publicField(this, "lengthKnown", false);
                __publicField(this, "chunks", []);
              }
              // Loaded chunks. Index is the chunk number
              get(idx) {
                if (idx > this.length - 1 || idx < 0) {
                  return void 0;
                }
                var chunkOffset = idx % this.chunkSize;
                var chunkNum = idx / this.chunkSize | 0;
                return this.getter(chunkNum)[chunkOffset];
              }
              setDataGetter(getter) {
                this.getter = getter;
              }
              cacheLength() {
                var xhr = new XMLHttpRequest();
                xhr.open("HEAD", url, false);
                xhr.send(null);
                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304))
                  throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
                var datalength = Number(xhr.getResponseHeader("Content-length"));
                var header;
                var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
                var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
                var chunkSize = 1024 * 1024;
                if (!hasByteServing)
                  chunkSize = datalength;
                var doXHR = (from, to) => {
                  if (from > to)
                    throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
                  if (to > datalength - 1)
                    throw new Error("only " + datalength + " bytes available! programmer error!");
                  var xhr2 = new XMLHttpRequest();
                  xhr2.open("GET", url, false);
                  if (datalength !== chunkSize)
                    xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
                  xhr2.responseType = "arraybuffer";
                  if (xhr2.overrideMimeType) {
                    xhr2.overrideMimeType("text/plain; charset=x-user-defined");
                  }
                  xhr2.send(null);
                  if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304))
                    throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
                  if (xhr2.response !== void 0) {
                    return new Uint8Array(
                      /** @type{Array<number>} */
                      xhr2.response || []
                    );
                  }
                  return intArrayFromString(xhr2.responseText || "");
                };
                var lazyArray2 = this;
                lazyArray2.setDataGetter((chunkNum) => {
                  var start = chunkNum * chunkSize;
                  var end = (chunkNum + 1) * chunkSize - 1;
                  end = Math.min(end, datalength - 1);
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                    lazyArray2.chunks[chunkNum] = doXHR(start, end);
                  }
                  if (typeof lazyArray2.chunks[chunkNum] == "undefined")
                    throw new Error("doXHR failed!");
                  return lazyArray2.chunks[chunkNum];
                });
                if (usesGzip || !datalength) {
                  chunkSize = datalength = 1;
                  datalength = this.getter(0).length;
                  chunkSize = datalength;
                  out("LazyFiles on gzip forces download of the whole file when length is accessed");
                }
                this._length = datalength;
                this._chunkSize = chunkSize;
                this.lengthKnown = true;
              }
              get length() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
              get chunkSize() {
                if (!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
            if (typeof XMLHttpRequest != "undefined") {
              throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
              var lazyArray = new LazyUint8Array();
              var properties = { isDevice: false, contents: lazyArray };
            } else {
              var properties = { isDevice: false, url };
            }
            var node = FS.createFile(parent, name2, properties, canRead, canWrite);
            if (properties.contents) {
              node.contents = properties.contents;
            } else if (properties.url) {
              node.contents = null;
              node.url = properties.url;
            }
            Object.defineProperties(node, {
              usedBytes: {
                get: function() {
                  return this.contents.length;
                }
              }
            });
            var stream_ops = {};
            var keys = Object.keys(node.stream_ops);
            keys.forEach((key) => {
              var fn = node.stream_ops[key];
              stream_ops[key] = (...args) => {
                FS.forceLoadFile(node);
                return fn(...args);
              };
            });
            function writeChunks(stream, buffer, offset, length, position) {
              var contents = stream.node.contents;
              if (position >= contents.length)
                return 0;
              var size = Math.min(contents.length - position, length);
              assert(size >= 0);
              if (contents.slice) {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents[position + i];
                }
              } else {
                for (var i = 0; i < size; i++) {
                  buffer[offset + i] = contents.get(position + i);
                }
              }
              return size;
            }
            stream_ops.read = (stream, buffer, offset, length, position) => {
              FS.forceLoadFile(node);
              return writeChunks(stream, buffer, offset, length, position);
            };
            stream_ops.mmap = (stream, length, position, prot, flags) => {
              FS.forceLoadFile(node);
              var ptr = mmapAlloc();
              if (!ptr) {
                throw new FS.ErrnoError(48);
              }
              writeChunks(stream, HEAP8, ptr, length, position);
              return { ptr, allocated: true };
            };
            node.stream_ops = stream_ops;
            return node;
          },
          absolutePath() {
            abort("FS.absolutePath has been removed; use PATH_FS.resolve instead");
          },
          createFolder() {
            abort("FS.createFolder has been removed; use FS.mkdir instead");
          },
          createLink() {
            abort("FS.createLink has been removed; use FS.symlink instead");
          },
          joinPath() {
            abort("FS.joinPath has been removed; use PATH.join instead");
          },
          mmapAlloc() {
            abort("FS.mmapAlloc has been replaced by the top level function mmapAlloc");
          },
          standardizePath() {
            abort("FS.standardizePath has been removed; use PATH.normalize instead");
          }
        };
        var SYSCALLS = {
          DEFAULT_POLLMASK: 5,
          calculateAt(dirfd, path, allowEmpty) {
            if (PATH.isAbs(path)) {
              return path;
            }
            var dir;
            if (dirfd === -100) {
              dir = FS.cwd();
            } else {
              var dirstream = SYSCALLS.getStreamFromFD(dirfd);
              dir = dirstream.path;
            }
            if (path.length == 0) {
              if (!allowEmpty) {
                throw new FS.ErrnoError(44);
              }
              return dir;
            }
            return dir + "/" + path;
          },
          writeStat(buf, stat) {
            HEAP32[buf >> 2] = stat.dev;
            HEAP32[buf + 4 >> 2] = stat.mode;
            HEAPU32[buf + 8 >> 2] = stat.nlink;
            HEAP32[buf + 12 >> 2] = stat.uid;
            HEAP32[buf + 16 >> 2] = stat.gid;
            HEAP32[buf + 20 >> 2] = stat.rdev;
            HEAP64[buf + 24 >> 3] = BigInt(stat.size);
            HEAP32[buf + 32 >> 2] = 4096;
            HEAP32[buf + 36 >> 2] = stat.blocks;
            var atime = stat.atime.getTime();
            var mtime = stat.mtime.getTime();
            var ctime = stat.ctime.getTime();
            HEAP64[buf + 40 >> 3] = BigInt(Math.floor(atime / 1e3));
            HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 56 >> 3] = BigInt(Math.floor(mtime / 1e3));
            HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 72 >> 3] = BigInt(Math.floor(ctime / 1e3));
            HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
            HEAP64[buf + 88 >> 3] = BigInt(stat.ino);
            return 0;
          },
          writeStatFs(buf, stats) {
            HEAP32[buf + 4 >> 2] = stats.bsize;
            HEAP32[buf + 40 >> 2] = stats.bsize;
            HEAP32[buf + 8 >> 2] = stats.blocks;
            HEAP32[buf + 12 >> 2] = stats.bfree;
            HEAP32[buf + 16 >> 2] = stats.bavail;
            HEAP32[buf + 20 >> 2] = stats.files;
            HEAP32[buf + 24 >> 2] = stats.ffree;
            HEAP32[buf + 28 >> 2] = stats.fsid;
            HEAP32[buf + 44 >> 2] = stats.flags;
            HEAP32[buf + 36 >> 2] = stats.namelen;
          },
          doMsync(addr, stream, len, flags, offset) {
            if (!FS.isFile(stream.node.mode)) {
              throw new FS.ErrnoError(43);
            }
            if (flags & 2) {
              return 0;
            }
            var buffer = HEAPU8.slice(addr, addr + len);
            FS.msync(stream, buffer, offset, len, flags);
          },
          getStreamFromFD(fd) {
            var stream = FS.getStreamChecked(fd);
            return stream;
          },
          varargs: void 0,
          getStr(ptr) {
            var ret = UTF8ToString(ptr);
            return ret;
          }
        };
        function ___syscall_fcntl64(fd, cmd, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (cmd) {
              case 0: {
                var arg = syscallGetVarargI();
                if (arg < 0) {
                  return -28;
                }
                while (FS.streams[arg]) {
                  arg++;
                }
                var newStream;
                newStream = FS.dupStream(stream, arg);
                return newStream.fd;
              }
              case 1:
              case 2:
                return 0;
              case 3:
                return stream.flags;
              case 4: {
                var arg = syscallGetVarargI();
                stream.flags |= arg;
                return 0;
              }
              case 12: {
                var arg = syscallGetVarargP();
                var offset = 0;
                HEAP16[arg + offset >> 1] = 2;
                return 0;
              }
              case 13:
              case 14:
                return 0;
            }
            return -28;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_fstat64(fd, buf) {
          try {
            return SYSCALLS.writeStat(buf, FS.fstat(fd));
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_ioctl(fd, op, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            switch (op) {
              case 21509: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21505: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcgets) {
                  var termios = stream.tty.ops.ioctl_tcgets(stream);
                  var argp = syscallGetVarargP();
                  HEAP32[argp >> 2] = termios.c_iflag || 0;
                  HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;
                  HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;
                  HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;
                  for (var i = 0; i < 32; i++) {
                    HEAP8[argp + i + 17] = termios.c_cc[i] || 0;
                  }
                  return 0;
                }
                return 0;
              }
              case 21510:
              case 21511:
              case 21512: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21506:
              case 21507:
              case 21508: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tcsets) {
                  var argp = syscallGetVarargP();
                  var c_iflag = HEAP32[argp >> 2];
                  var c_oflag = HEAP32[argp + 4 >> 2];
                  var c_cflag = HEAP32[argp + 8 >> 2];
                  var c_lflag = HEAP32[argp + 12 >> 2];
                  var c_cc = [];
                  for (var i = 0; i < 32; i++) {
                    c_cc.push(HEAP8[argp + i + 17]);
                  }
                  return stream.tty.ops.ioctl_tcsets(stream.tty, op, { c_iflag, c_oflag, c_cflag, c_lflag, c_cc });
                }
                return 0;
              }
              case 21519: {
                if (!stream.tty)
                  return -59;
                var argp = syscallGetVarargP();
                HEAP32[argp >> 2] = 0;
                return 0;
              }
              case 21520: {
                if (!stream.tty)
                  return -59;
                return -28;
              }
              case 21531: {
                var argp = syscallGetVarargP();
                return FS.ioctl(stream, op, argp);
              }
              case 21523: {
                if (!stream.tty)
                  return -59;
                if (stream.tty.ops.ioctl_tiocgwinsz) {
                  var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);
                  var argp = syscallGetVarargP();
                  HEAP16[argp >> 1] = winsize[0];
                  HEAP16[argp + 2 >> 1] = winsize[1];
                }
                return 0;
              }
              case 21524: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              case 21515: {
                if (!stream.tty)
                  return -59;
                return 0;
              }
              default:
                return -28;
            }
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_lstat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.writeStat(buf, FS.lstat(path));
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_newfstatat(dirfd, path, buf, flags) {
          try {
            path = SYSCALLS.getStr(path);
            var nofollow = flags & 256;
            var allowEmpty = flags & 4096;
            flags = flags & ~6400;
            assert(!flags, `unknown flags in __syscall_newfstatat: ${flags}`);
            path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
            return SYSCALLS.writeStat(buf, nofollow ? FS.lstat(path) : FS.stat(path));
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_openat(dirfd, path, flags, varargs) {
          SYSCALLS.varargs = varargs;
          try {
            path = SYSCALLS.getStr(path);
            path = SYSCALLS.calculateAt(dirfd, path);
            var mode = varargs ? syscallGetVarargI() : 0;
            return FS.open(path, flags, mode).fd;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        function ___syscall_stat64(path, buf) {
          try {
            path = SYSCALLS.getStr(path);
            return SYSCALLS.writeStat(buf, FS.stat(path));
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return -e.errno;
          }
        }
        var getCppExceptionTag = () => ___cpp_exception;
        var getCppExceptionThrownObjectFromWebAssemblyException = (ex) => {
          var unwind_header = ex.getArg(getCppExceptionTag(), 0);
          return ___thrown_object_from_unwind_exception(unwind_header);
        };
        var stackSave = () => _emscripten_stack_get_current();
        var stackRestore = (val) => __emscripten_stack_restore(val);
        var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
        var getExceptionMessageCommon = (ptr) => {
          var sp = stackSave();
          var type_addr_addr = stackAlloc(4);
          var message_addr_addr = stackAlloc(4);
          ___get_exception_message(ptr, type_addr_addr, message_addr_addr);
          var type_addr = HEAPU32[type_addr_addr >> 2];
          var message_addr = HEAPU32[message_addr_addr >> 2];
          var type = UTF8ToString(type_addr);
          _free(type_addr);
          var message2;
          if (message_addr) {
            message2 = UTF8ToString(message_addr);
            _free(message_addr);
          }
          stackRestore(sp);
          return [type, message2];
        };
        var getExceptionMessage = (ex) => {
          var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          return getExceptionMessageCommon(ptr);
        };
        var ___throw_exception_with_stack_trace = (ex) => {
          var e = new WebAssembly.Exception(getCppExceptionTag(), [ex], { traceStack: true });
          e.message = getExceptionMessage(e);
          throw e;
        };
        var __abort_js = () => abort("native code called abort()");
        var embind_init_charCodes = () => {
          var codes = new Array(256);
          for (var i = 0; i < 256; ++i) {
            codes[i] = String.fromCharCode(i);
          }
          embind_charCodes = codes;
        };
        var embind_charCodes;
        var readLatin1String = (ptr) => {
          var ret = "";
          var c = ptr;
          while (HEAPU8[c]) {
            ret += embind_charCodes[HEAPU8[c++]];
          }
          return ret;
        };
        var awaitingDependencies = {};
        var registeredTypes = {};
        var typeDependencies = {};
        var BindingError = class BindingError extends Error {
          constructor(message2) {
            super(message2);
            this.name = "BindingError";
          }
        };
        var throwBindingError = (message2) => {
          throw new BindingError(message2);
        };
        function sharedRegisterType(rawType, registeredInstance, options = {}) {
          var name2 = registeredInstance.name;
          if (!rawType) {
            throwBindingError(`type "${name2}" must have a positive integer typeid pointer`);
          }
          if (registeredTypes.hasOwnProperty(rawType)) {
            if (options.ignoreDuplicateRegistrations) {
              return;
            } else {
              throwBindingError(`Cannot register type '${name2}' twice`);
            }
          }
          registeredTypes[rawType] = registeredInstance;
          delete typeDependencies[rawType];
          if (awaitingDependencies.hasOwnProperty(rawType)) {
            var callbacks = awaitingDependencies[rawType];
            delete awaitingDependencies[rawType];
            callbacks.forEach((cb) => cb());
          }
        }
        function registerType(rawType, registeredInstance, options = {}) {
          if (registeredInstance.argPackAdvance === void 0) {
            throw new TypeError("registerType registeredInstance requires argPackAdvance");
          }
          return sharedRegisterType(rawType, registeredInstance, options);
        }
        var integerReadValueFromPointer = (name2, width, signed) => {
          switch (width) {
            case 1:
              return signed ? (pointer) => HEAP8[pointer] : (pointer) => HEAPU8[pointer];
            case 2:
              return signed ? (pointer) => HEAP16[pointer >> 1] : (pointer) => HEAPU16[pointer >> 1];
            case 4:
              return signed ? (pointer) => HEAP32[pointer >> 2] : (pointer) => HEAPU32[pointer >> 2];
            case 8:
              return signed ? (pointer) => HEAP64[pointer >> 3] : (pointer) => HEAPU64[pointer >> 3];
            default:
              throw new TypeError(`invalid integer width (${width}): ${name2}`);
          }
        };
        var embindRepr = (v) => {
          if (v === null) {
            return "null";
          }
          var t = typeof v;
          if (t === "object" || t === "array" || t === "function") {
            return v.toString();
          } else {
            return "" + v;
          }
        };
        var assertIntegerRange = (typeName, value, minRange, maxRange) => {
          if (value < minRange || value > maxRange) {
            throw new TypeError(`Passing a number "${embindRepr(value)}" from JS side to C/C++ side to an argument of type "${typeName}", which is outside the valid range [${minRange}, ${maxRange}]!`);
          }
        };
        var __embind_register_bigint = (primitiveType, name2, size, minRange, maxRange) => {
          name2 = readLatin1String(name2);
          const isUnsignedType = minRange === /* @__PURE__ */ BigInt("0");
          let fromWireType = (value) => value;
          if (isUnsignedType) {
            const bitSize = size * 8;
            fromWireType = (value) => {
              return BigInt.asUintN(bitSize, value);
            };
            maxRange = fromWireType(maxRange);
          }
          registerType(primitiveType, {
            name: name2,
            "fromWireType": fromWireType,
            "toWireType": (destructors, value) => {
              if (typeof value == "number") {
                value = BigInt(value);
              } else if (typeof value != "bigint") {
                throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${this.name}`);
              }
              assertIntegerRange(name2, value, minRange, maxRange);
              return value;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": integerReadValueFromPointer(name2, size, !isUnsignedType),
            destructorFunction: null
            // This type does not need a destructor
          });
        };
        var GenericWireTypeSize = 8;
        var __embind_register_bool = (rawType, name2, trueValue, falseValue) => {
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": function(wt) {
              return !!wt;
            },
            "toWireType": function(destructors, o) {
              return o ? trueValue : falseValue;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": function(pointer) {
              return this["fromWireType"](HEAPU8[pointer]);
            },
            destructorFunction: null
            // This type does not need a destructor
          });
        };
        var shallowCopyInternalPointer = (o) => {
          return {
            count: o.count,
            deleteScheduled: o.deleteScheduled,
            preservePointerOnDelete: o.preservePointerOnDelete,
            ptr: o.ptr,
            ptrType: o.ptrType,
            smartPtr: o.smartPtr,
            smartPtrType: o.smartPtrType
          };
        };
        var throwInstanceAlreadyDeleted = (obj) => {
          function getInstanceTypeName(handle) {
            return handle.$$.ptrType.registeredClass.name;
          }
          throwBindingError(getInstanceTypeName(obj) + " instance already deleted");
        };
        var finalizationRegistry = false;
        var detachFinalizer = (handle) => {
        };
        var runDestructor = ($$) => {
          if ($$.smartPtr) {
            $$.smartPtrType.rawDestructor($$.smartPtr);
          } else {
            $$.ptrType.registeredClass.rawDestructor($$.ptr);
          }
        };
        var releaseClassHandle = ($$) => {
          $$.count.value -= 1;
          var toDelete = 0 === $$.count.value;
          if (toDelete) {
            runDestructor($$);
          }
        };
        var downcastPointer = (ptr, ptrClass, desiredClass) => {
          if (ptrClass === desiredClass) {
            return ptr;
          }
          if (void 0 === desiredClass.baseClass) {
            return null;
          }
          var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
          if (rv === null) {
            return null;
          }
          return desiredClass.downcast(rv);
        };
        var registeredPointers = {};
        var registeredInstances = {};
        var getBasestPointer = (class_, ptr) => {
          if (ptr === void 0) {
            throwBindingError("ptr should not be undefined");
          }
          while (class_.baseClass) {
            ptr = class_.upcast(ptr);
            class_ = class_.baseClass;
          }
          return ptr;
        };
        var getInheritedInstance = (class_, ptr) => {
          ptr = getBasestPointer(class_, ptr);
          return registeredInstances[ptr];
        };
        var InternalError = class InternalError extends Error {
          constructor(message2) {
            super(message2);
            this.name = "InternalError";
          }
        };
        var throwInternalError = (message2) => {
          throw new InternalError(message2);
        };
        var makeClassHandle = (prototype, record) => {
          if (!record.ptrType || !record.ptr) {
            throwInternalError("makeClassHandle requires ptr and ptrType");
          }
          var hasSmartPtrType = !!record.smartPtrType;
          var hasSmartPtr = !!record.smartPtr;
          if (hasSmartPtrType !== hasSmartPtr) {
            throwInternalError("Both smartPtrType and smartPtr must be specified");
          }
          record.count = { value: 1 };
          return attachFinalizer(Object.create(prototype, {
            $$: {
              value: record,
              writable: true
            }
          }));
        };
        function RegisteredPointer_fromWireType(ptr) {
          var rawPointer = this.getPointee(ptr);
          if (!rawPointer) {
            this.destructor(ptr);
            return null;
          }
          var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
          if (void 0 !== registeredInstance) {
            if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance["clone"]();
            } else {
              var rv = registeredInstance["clone"]();
              this.destructor(ptr);
              return rv;
            }
          }
          function makeDefaultHandle() {
            if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this.pointeeType,
                ptr: rawPointer,
                smartPtrType: this,
                smartPtr: ptr
              });
            } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                ptrType: this,
                ptr
              });
            }
          }
          var actualType = this.registeredClass.getActualType(rawPointer);
          var registeredPointerRecord = registeredPointers[actualType];
          if (!registeredPointerRecord) {
            return makeDefaultHandle.call(this);
          }
          var toType;
          if (this.isConst) {
            toType = registeredPointerRecord.constPointerType;
          } else {
            toType = registeredPointerRecord.pointerType;
          }
          var dp = downcastPointer(
            rawPointer,
            this.registeredClass,
            toType.registeredClass
          );
          if (dp === null) {
            return makeDefaultHandle.call(this);
          }
          if (this.isSmartPointer) {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr
            });
          } else {
            return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp
            });
          }
        }
        var attachFinalizer = (handle) => {
          if ("undefined" === typeof FinalizationRegistry) {
            attachFinalizer = (handle2) => handle2;
            return handle;
          }
          finalizationRegistry = new FinalizationRegistry((info) => {
            console.warn(info.leakWarning);
            releaseClassHandle(info.$$);
          });
          attachFinalizer = (handle2) => {
            var $$ = handle2.$$;
            var hasSmartPtr = !!$$.smartPtr;
            if (hasSmartPtr) {
              var info = { $$ };
              var cls = $$.ptrType.registeredClass;
              var err2 = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.
We'll free it automatically in this case, but this functionality is not reliable across various environments.
Make sure to invoke .delete() manually once you're done with the instance instead.
Originally allocated`);
              if ("captureStackTrace" in Error) {
                Error.captureStackTrace(err2, RegisteredPointer_fromWireType);
              }
              info.leakWarning = err2.stack.replace(/^Error: /, "");
              finalizationRegistry.register(handle2, info, handle2);
            }
            return handle2;
          };
          detachFinalizer = (handle2) => finalizationRegistry.unregister(handle2);
          return attachFinalizer(handle);
        };
        var init_ClassHandle = () => {
          let proto = ClassHandle.prototype;
          Object.assign(proto, {
            "isAliasOf"(other) {
              if (!(this instanceof ClassHandle)) {
                return false;
              }
              if (!(other instanceof ClassHandle)) {
                return false;
              }
              var leftClass = this.$$.ptrType.registeredClass;
              var left = this.$$.ptr;
              other.$$ = /** @type {Object} */
              other.$$;
              var rightClass = other.$$.ptrType.registeredClass;
              var right = other.$$.ptr;
              while (leftClass.baseClass) {
                left = leftClass.upcast(left);
                leftClass = leftClass.baseClass;
              }
              while (rightClass.baseClass) {
                right = rightClass.upcast(right);
                rightClass = rightClass.baseClass;
              }
              return leftClass === rightClass && left === right;
            },
            "clone"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.preservePointerOnDelete) {
                this.$$.count.value += 1;
                return this;
              } else {
                var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
                  $$: {
                    value: shallowCopyInternalPointer(this.$$)
                  }
                }));
                clone.$$.count.value += 1;
                clone.$$.deleteScheduled = false;
                return clone;
              }
            },
            "delete"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              detachFinalizer(this);
              releaseClassHandle(this.$$);
              if (!this.$$.preservePointerOnDelete) {
                this.$$.smartPtr = void 0;
                this.$$.ptr = void 0;
              }
            },
            "isDeleted"() {
              return !this.$$.ptr;
            },
            "deleteLater"() {
              if (!this.$$.ptr) {
                throwInstanceAlreadyDeleted(this);
              }
              if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
                throwBindingError("Object already scheduled for deletion");
              }
              this.$$.deleteScheduled = true;
              return this;
            }
          });
          const symbolDispose = Symbol.dispose;
          if (symbolDispose) {
            proto[symbolDispose] = proto["delete"];
          }
        };
        function ClassHandle() {
        }
        var createNamedFunction = (name2, func) => Object.defineProperty(func, "name", { value: name2 });
        var ensureOverloadTable = (proto, methodName, humanName) => {
          if (void 0 === proto[methodName].overloadTable) {
            var prevFunc = proto[methodName];
            proto[methodName] = function(...args) {
              if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {
                throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);
              }
              return proto[methodName].overloadTable[args.length].apply(this, args);
            };
            proto[methodName].overloadTable = [];
            proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
          }
        };
        var exposePublicSymbol = (name2, value, numArguments) => {
          if (Module.hasOwnProperty(name2)) {
            if (void 0 === numArguments || void 0 !== Module[name2].overloadTable && void 0 !== Module[name2].overloadTable[numArguments]) {
              throwBindingError(`Cannot register public name '${name2}' twice`);
            }
            ensureOverloadTable(Module, name2, name2);
            if (Module[name2].overloadTable.hasOwnProperty(numArguments)) {
              throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);
            }
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        };
        var char_0 = 48;
        var char_9 = 57;
        var makeLegalFunctionName = (name2) => {
          assert(typeof name2 === "string");
          name2 = name2.replace(/[^a-zA-Z0-9_]/g, "$");
          var f = name2.charCodeAt(0);
          if (f >= char_0 && f <= char_9) {
            return `_${name2}`;
          }
          return name2;
        };
        function RegisteredClass(name2, constructor, instancePrototype, rawDestructor, baseClass, getActualType, upcast, downcast) {
          this.name = name2;
          this.constructor = constructor;
          this.instancePrototype = instancePrototype;
          this.rawDestructor = rawDestructor;
          this.baseClass = baseClass;
          this.getActualType = getActualType;
          this.upcast = upcast;
          this.downcast = downcast;
          this.pureVirtualFunctions = [];
        }
        var upcastPointer = (ptr, ptrClass, desiredClass) => {
          while (ptrClass !== desiredClass) {
            if (!ptrClass.upcast) {
              throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);
            }
            ptr = ptrClass.upcast(ptr);
            ptrClass = ptrClass.baseClass;
          }
          return ptr;
        };
        function constNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function genericPointerToWireType(destructors, handle) {
          var ptr;
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
            } else {
              return 0;
            }
          }
          if (!handle || !handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (!this.isConst && handle.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          if (this.isSmartPointer) {
            if (void 0 === handle.$$.smartPtr) {
              throwBindingError("Passing raw pointer to smart pointer is illegal");
            }
            switch (this.sharingPolicy) {
              case 0:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  throwBindingError(`Cannot convert argument of type ${handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name} to parameter type ${this.name}`);
                }
                break;
              case 1:
                ptr = handle.$$.smartPtr;
                break;
              case 2:
                if (handle.$$.smartPtrType === this) {
                  ptr = handle.$$.smartPtr;
                } else {
                  var clonedHandle = handle["clone"]();
                  ptr = this.rawShare(
                    ptr,
                    Emval.toHandle(() => clonedHandle["delete"]())
                  );
                  if (destructors !== null) {
                    destructors.push(this.rawDestructor, ptr);
                  }
                }
                break;
              default:
                throwBindingError("Unsupporting sharing policy");
            }
          }
          return ptr;
        }
        function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
          if (handle === null) {
            if (this.isReference) {
              throwBindingError(`null is not a valid ${this.name}`);
            }
            return 0;
          }
          if (!handle.$$) {
            throwBindingError(`Cannot pass "${embindRepr(handle)}" as a ${this.name}`);
          }
          if (!handle.$$.ptr) {
            throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);
          }
          if (handle.$$.ptrType.isConst) {
            throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);
          }
          var handleClass = handle.$$.ptrType.registeredClass;
          var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
          return ptr;
        }
        function readPointer(pointer) {
          return this["fromWireType"](HEAPU32[pointer >> 2]);
        }
        var init_RegisteredPointer = () => {
          Object.assign(RegisteredPointer.prototype, {
            getPointee(ptr) {
              if (this.rawGetPointee) {
                ptr = this.rawGetPointee(ptr);
              }
              return ptr;
            },
            destructor(ptr) {
              var _a2;
              (_a2 = this.rawDestructor) == null ? void 0 : _a2.call(this, ptr);
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            "fromWireType": RegisteredPointer_fromWireType
          });
        };
        function RegisteredPointer(name2, registeredClass, isReference, isConst, isSmartPointer, pointeeType, sharingPolicy, rawGetPointee, rawConstructor, rawShare, rawDestructor) {
          this.name = name2;
          this.registeredClass = registeredClass;
          this.isReference = isReference;
          this.isConst = isConst;
          this.isSmartPointer = isSmartPointer;
          this.pointeeType = pointeeType;
          this.sharingPolicy = sharingPolicy;
          this.rawGetPointee = rawGetPointee;
          this.rawConstructor = rawConstructor;
          this.rawShare = rawShare;
          this.rawDestructor = rawDestructor;
          if (!isSmartPointer && registeredClass.baseClass === void 0) {
            if (isConst) {
              this["toWireType"] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            } else {
              this["toWireType"] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
            }
          } else {
            this["toWireType"] = genericPointerToWireType;
          }
        }
        var replacePublicSymbol = (name2, value, numArguments) => {
          if (!Module.hasOwnProperty(name2)) {
            throwInternalError("Replacing nonexistent public symbol");
          }
          if (void 0 !== Module[name2].overloadTable && void 0 !== numArguments) {
            Module[name2].overloadTable[numArguments] = value;
          } else {
            Module[name2] = value;
            Module[name2].argCount = numArguments;
          }
        };
        var wasmTableMirror = [];
        var wasmTable;
        var getWasmTableEntry = (funcPtr) => {
          var func = wasmTableMirror[funcPtr];
          if (!func) {
            wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);
          }
          assert(wasmTable.get(funcPtr) == func, "JavaScript-side Wasm function table mirror is out of date!");
          return func;
        };
        var embind__requireFunction = (signature, rawFunction, isAsync = false) => {
          assert(!isAsync, "Async bindings are only supported with JSPI.");
          signature = readLatin1String(signature);
          function makeDynCaller() {
            var rtn = getWasmTableEntry(rawFunction);
            return rtn;
          }
          var fp = makeDynCaller();
          if (typeof fp != "function") {
            throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);
          }
          return fp;
        };
        class UnboundTypeError extends Error {
        }
        var getTypeName = (type) => {
          var ptr = ___getTypeName(type);
          var rv = readLatin1String(ptr);
          _free(ptr);
          return rv;
        };
        var throwUnboundTypeError = (message2, types) => {
          var unboundTypes = [];
          var seen = {};
          function visit(type) {
            if (seen[type]) {
              return;
            }
            if (registeredTypes[type]) {
              return;
            }
            if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
            }
            unboundTypes.push(type);
            seen[type] = true;
          }
          types.forEach(visit);
          throw new UnboundTypeError(`${message2}: ` + unboundTypes.map(getTypeName).join([", "]));
        };
        var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {
          myTypes.forEach((type) => typeDependencies[type] = dependentTypes);
          function onComplete(typeConverters2) {
            var myTypeConverters = getTypeConverters(typeConverters2);
            if (myTypeConverters.length !== myTypes.length) {
              throwInternalError("Mismatched type converter count");
            }
            for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
            }
          }
          var typeConverters = new Array(dependentTypes.length);
          var unregisteredTypes = [];
          var registered = 0;
          dependentTypes.forEach((dt, i) => {
            if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
            } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(() => {
                typeConverters[i] = registeredTypes[dt];
                ++registered;
                if (registered === unregisteredTypes.length) {
                  onComplete(typeConverters);
                }
              });
            }
          });
          if (0 === unregisteredTypes.length) {
            onComplete(typeConverters);
          }
        };
        var __embind_register_class = (rawType, rawPointerType, rawConstPointerType, baseClassRawType, getActualTypeSignature, getActualType, upcastSignature, upcast, downcastSignature, downcast, name2, destructorSignature, rawDestructor) => {
          name2 = readLatin1String(name2);
          getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
          upcast && (upcast = embind__requireFunction(upcastSignature, upcast));
          downcast && (downcast = embind__requireFunction(downcastSignature, downcast));
          rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
          var legalFunctionName = makeLegalFunctionName(name2);
          exposePublicSymbol(legalFunctionName, function() {
            throwUnboundTypeError(`Cannot construct ${name2} due to unbound types`, [baseClassRawType]);
          });
          whenDependentTypesAreResolved(
            [rawType, rawPointerType, rawConstPointerType],
            baseClassRawType ? [baseClassRawType] : [],
            (base) => {
              var _a3;
              var _a2;
              base = base[0];
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                baseClass = base.registeredClass;
                basePrototype = baseClass.instancePrototype;
              } else {
                basePrototype = ClassHandle.prototype;
              }
              var constructor = createNamedFunction(name2, function(...args) {
                if (Object.getPrototypeOf(this) !== instancePrototype) {
                  throw new BindingError(`Use 'new' to construct ${name2}`);
                }
                if (void 0 === registeredClass.constructor_body) {
                  throw new BindingError(`${name2} has no accessible constructor`);
                }
                var body = registeredClass.constructor_body[args.length];
                if (void 0 === body) {
                  throw new BindingError(`Tried to invoke ctor of ${name2} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);
                }
                return body.apply(this, args);
              });
              var instancePrototype = Object.create(basePrototype, {
                constructor: { value: constructor }
              });
              constructor.prototype = instancePrototype;
              var registeredClass = new RegisteredClass(
                name2,
                constructor,
                instancePrototype,
                rawDestructor,
                baseClass,
                getActualType,
                upcast,
                downcast
              );
              if (registeredClass.baseClass) {
                (_a3 = (_a2 = registeredClass.baseClass).__derivedClasses) != null ? _a3 : _a2.__derivedClasses = [];
                registeredClass.baseClass.__derivedClasses.push(registeredClass);
              }
              var referenceConverter = new RegisteredPointer(
                name2,
                registeredClass,
                true,
                false,
                false
              );
              var pointerConverter = new RegisteredPointer(
                name2 + "*",
                registeredClass,
                false,
                false,
                false
              );
              var constPointerConverter = new RegisteredPointer(
                name2 + " const*",
                registeredClass,
                false,
                true,
                false
              );
              registeredPointers[rawType] = {
                pointerType: pointerConverter,
                constPointerType: constPointerConverter
              };
              replacePublicSymbol(legalFunctionName, constructor);
              return [referenceConverter, pointerConverter, constPointerConverter];
            }
          );
        };
        var runDestructors = (destructors) => {
          while (destructors.length) {
            var ptr = destructors.pop();
            var del = destructors.pop();
            del(ptr);
          }
        };
        function usesDestructorStack(argTypes) {
          for (var i = 1; i < argTypes.length; ++i) {
            if (argTypes[i] !== null && argTypes[i].destructorFunction === void 0) {
              return true;
            }
          }
          return false;
        }
        function getRequiredArgCount(argTypes) {
          var requiredArgCount = argTypes.length - 2;
          for (var i = argTypes.length - 1; i >= 2; --i) {
            if (!argTypes[i].optional) {
              break;
            }
            requiredArgCount--;
          }
          return requiredArgCount;
        }
        function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError2) {
          if (numArgs < minArgs || numArgs > maxArgs) {
            var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;
            throwBindingError2(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);
          }
        }
        function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, isAsync) {
          var argCount = argTypes.length;
          if (argCount < 2) {
            throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
          }
          assert(!isAsync, "Async bindings are only supported with JSPI.");
          var isClassMethodFunc = argTypes[1] !== null && classType !== null;
          var needsDestructorStack = usesDestructorStack(argTypes);
          var returns = argTypes[0].name !== "void";
          var expectedArgCount = argCount - 2;
          var minArgs = getRequiredArgCount(argTypes);
          var argsWired = new Array(expectedArgCount);
          var invokerFuncArgs = [];
          var destructors = [];
          var invokerFn = function(...args) {
            checkArgCount(args.length, minArgs, expectedArgCount, humanName, throwBindingError);
            destructors.length = 0;
            var thisWired;
            invokerFuncArgs.length = isClassMethodFunc ? 2 : 1;
            invokerFuncArgs[0] = cppTargetFunc;
            if (isClassMethodFunc) {
              thisWired = argTypes[1]["toWireType"](destructors, this);
              invokerFuncArgs[1] = thisWired;
            }
            for (var i = 0; i < expectedArgCount; ++i) {
              argsWired[i] = argTypes[i + 2]["toWireType"](destructors, args[i]);
              invokerFuncArgs.push(argsWired[i]);
            }
            var rv = cppInvokerFunc(...invokerFuncArgs);
            function onDone(rv2) {
              if (needsDestructorStack) {
                runDestructors(destructors);
              } else {
                for (var i2 = isClassMethodFunc ? 1 : 2; i2 < argTypes.length; i2++) {
                  var param = i2 === 1 ? thisWired : argsWired[i2 - 2];
                  if (argTypes[i2].destructorFunction !== null) {
                    argTypes[i2].destructorFunction(param);
                  }
                }
              }
              if (returns) {
                return argTypes[0]["fromWireType"](rv2);
              }
            }
            return onDone(rv);
          };
          return createNamedFunction(humanName, invokerFn);
        }
        var heap32VectorToArray = (count, firstElement) => {
          var array = [];
          for (var i = 0; i < count; i++) {
            array.push(HEAPU32[firstElement + i * 4 >> 2]);
          }
          return array;
        };
        var getFunctionName = (signature) => {
          signature = signature.trim();
          const argsIndex = signature.indexOf("(");
          if (argsIndex === -1)
            return signature;
          assert(signature.endsWith(")"), "Parentheses for argument names should match.");
          return signature.slice(0, argsIndex);
        };
        var __embind_register_class_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, fn, isAsync, isNonnullReturn) => {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            var proto = classType.registeredClass.constructor;
            if (void 0 === proto[methodName]) {
              unboundTypesHandler.argCount = argCount - 1;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 1] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              var invokerArgsArray = [
                argTypes[0],
                null
                /* no class 'this'*/
              ].concat(
                argTypes.slice(1)
                /* actual params */
              );
              var func = craftInvokerFunction(humanName, invokerArgsArray, null, rawInvoker, fn, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                func.argCount = argCount - 1;
                proto[methodName] = func;
              } else {
                proto[methodName].overloadTable[argCount - 1] = func;
              }
              if (classType.registeredClass.__derivedClasses) {
                for (const derivedClass of classType.registeredClass.__derivedClasses) {
                  if (!derivedClass.constructor.hasOwnProperty(methodName)) {
                    derivedClass.constructor[methodName] = func;
                  }
                }
              }
              return [];
            });
            return [];
          });
        };
        var __embind_register_class_constructor = (rawClassType, argCount, rawArgTypesAddr, invokerSignature, invoker, rawConstructor) => {
          assert(argCount > 0);
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          invoker = embind__requireFunction(invokerSignature, invoker);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            var humanName = `constructor ${classType.name}`;
            if (void 0 === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
            }
            if (void 0 !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount - 1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);
            }
            classType.registeredClass.constructor_body[argCount - 1] = () => {
              throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);
            };
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              argTypes.splice(1, 0, null);
              classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);
              return [];
            });
            return [];
          });
        };
        var __embind_register_class_function = (rawClassType, methodName, argCount, rawArgTypesAddr, invokerSignature, rawInvoker, context, isPureVirtual, isAsync, isNonnullReturn) => {
          var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          methodName = readLatin1String(methodName);
          methodName = getFunctionName(methodName);
          rawInvoker = embind__requireFunction(invokerSignature, rawInvoker, isAsync);
          whenDependentTypesAreResolved([], [rawClassType], (classType) => {
            classType = classType[0];
            var humanName = `${classType.name}.${methodName}`;
            if (methodName.startsWith("@@")) {
              methodName = Symbol[methodName.substring(2)];
            }
            if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
            }
            function unboundTypesHandler() {
              throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);
            }
            var proto = classType.registeredClass.instancePrototype;
            var method = proto[methodName];
            if (void 0 === method || void 0 === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2) {
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
            } else {
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
            }
            whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);
              if (void 0 === proto[methodName].overloadTable) {
                memberFunction.argCount = argCount - 2;
                proto[methodName] = memberFunction;
              } else {
                proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
              return [];
            });
            return [];
          });
        };
        var emval_freelist = [];
        var emval_handles = [0, 1, , 1, null, 1, true, 1, false, 1];
        var __emval_decref = (handle) => {
          if (handle > 9 && 0 === --emval_handles[handle + 1]) {
            assert(emval_handles[handle] !== void 0, `Decref for unallocated handle.`);
            emval_handles[handle] = void 0;
            emval_freelist.push(handle);
          }
        };
        var Emval = {
          toValue: (handle) => {
            if (!handle) {
              throwBindingError(`Cannot use deleted val. handle = ${handle}`);
            }
            assert(handle === 2 || emval_handles[handle] !== void 0 && handle % 2 === 0, `invalid handle: ${handle}`);
            return emval_handles[handle];
          },
          toHandle: (value) => {
            switch (value) {
              case void 0:
                return 2;
              case null:
                return 4;
              case true:
                return 6;
              case false:
                return 8;
              default: {
                const handle = emval_freelist.pop() || emval_handles.length;
                emval_handles[handle] = value;
                emval_handles[handle + 1] = 1;
                return handle;
              }
            }
          }
        };
        var EmValType = {
          name: "emscripten::val",
          "fromWireType": (handle) => {
            var rv = Emval.toValue(handle);
            __emval_decref(handle);
            return rv;
          },
          "toWireType": (destructors, value) => Emval.toHandle(value),
          argPackAdvance: GenericWireTypeSize,
          "readValueFromPointer": readPointer,
          destructorFunction: null
          // This type does not need a destructor
          // TODO: do we need a deleteObject here?  write a test where
          // emval is passed into JS via an interface
        };
        var __embind_register_emval = (rawType) => registerType(rawType, EmValType);
        var floatReadValueFromPointer = (name2, width) => {
          switch (width) {
            case 4:
              return function(pointer) {
                return this["fromWireType"](HEAPF32[pointer >> 2]);
              };
            case 8:
              return function(pointer) {
                return this["fromWireType"](HEAPF64[pointer >> 3]);
              };
            default:
              throw new TypeError(`invalid float width (${width}): ${name2}`);
          }
        };
        var __embind_register_float = (rawType, name2, size) => {
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => value,
            "toWireType": (destructors, value) => {
              if (typeof value != "number" && typeof value != "boolean") {
                throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);
              }
              return value;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": floatReadValueFromPointer(name2, size),
            destructorFunction: null
            // This type does not need a destructor
          });
        };
        var __embind_register_function = (name2, argCount, rawArgTypesAddr, signature, rawInvoker, fn, isAsync, isNonnullReturn) => {
          var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
          name2 = readLatin1String(name2);
          name2 = getFunctionName(name2);
          rawInvoker = embind__requireFunction(signature, rawInvoker, isAsync);
          exposePublicSymbol(name2, function() {
            throwUnboundTypeError(`Cannot call ${name2} due to unbound types`, argTypes);
          }, argCount - 1);
          whenDependentTypesAreResolved([], argTypes, (argTypes2) => {
            var invokerArgsArray = [
              argTypes2[0],
              null
              /* no class 'this'*/
            ].concat(
              argTypes2.slice(1)
              /* actual params */
            );
            replacePublicSymbol(name2, craftInvokerFunction(name2, invokerArgsArray, null, rawInvoker, fn, isAsync), argCount - 1);
            return [];
          });
        };
        var __embind_register_integer = (primitiveType, name2, size, minRange, maxRange) => {
          name2 = readLatin1String(name2);
          const isUnsignedType = minRange === 0;
          let fromWireType = (value) => value;
          if (isUnsignedType) {
            var bitshift = 32 - 8 * size;
            fromWireType = (value) => value << bitshift >>> bitshift;
            maxRange = fromWireType(maxRange);
          }
          registerType(primitiveType, {
            name: name2,
            "fromWireType": fromWireType,
            "toWireType": (destructors, value) => {
              if (typeof value != "number" && typeof value != "boolean") {
                throw new TypeError(`Cannot convert "${embindRepr(value)}" to ${name2}`);
              }
              assertIntegerRange(name2, value, minRange, maxRange);
              return value;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": integerReadValueFromPointer(name2, size, minRange !== 0),
            destructorFunction: null
            // This type does not need a destructor
          });
        };
        var __embind_register_memory_view = (rawType, dataTypeIndex, name2) => {
          var typeMapping = [
            Int8Array,
            Uint8Array,
            Int16Array,
            Uint16Array,
            Int32Array,
            Uint32Array,
            Float32Array,
            Float64Array,
            BigInt64Array,
            BigUint64Array
          ];
          var TA = typeMapping[dataTypeIndex];
          function decodeMemoryView(handle) {
            var size = HEAPU32[handle >> 2];
            var data = HEAPU32[handle + 4 >> 2];
            return new TA(HEAP8.buffer, data, size);
          }
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            "fromWireType": decodeMemoryView,
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": decodeMemoryView
          }, {
            ignoreDuplicateRegistrations: true
          });
        };
        var EmValOptionalType = Object.assign({ optional: true }, EmValType);
        var __embind_register_optional = (rawOptionalType, rawType) => {
          registerType(rawOptionalType, EmValOptionalType);
        };
        var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {
          assert(typeof maxBytesToWrite == "number", "stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
          return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        };
        var __embind_register_std_string = (rawType, name2) => {
          name2 = readLatin1String(name2);
          registerType(rawType, {
            name: name2,
            // For some method names we use string keys here since they are part of
            // the public/external API and/or used by the runtime-generated code.
            "fromWireType"(value) {
              var length = HEAPU32[value >> 2];
              var payload = value + 4;
              var str;
              var i;
              {
                var decodeStartPtr = payload;
                for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = payload + i;
                  if (i == length || HEAPU8[currentBytePtr] == 0) {
                    var maxRead = currentBytePtr - decodeStartPtr;
                    var stringSegment = UTF8ToString(decodeStartPtr, maxRead);
                    if (str === void 0) {
                      str = stringSegment;
                    } else {
                      str += String.fromCharCode(0);
                      str += stringSegment;
                    }
                    decodeStartPtr = currentBytePtr + 1;
                  }
                }
              }
              _free(value);
              return str;
            },
            "toWireType"(destructors, value) {
              if (value instanceof ArrayBuffer) {
                value = new Uint8Array(value);
              }
              var length;
              var valueIsOfTypeString = typeof value == "string";
              if (!(valueIsOfTypeString || ArrayBuffer.isView(value) && value.BYTES_PER_ELEMENT == 1)) {
                throwBindingError("Cannot pass non-string to std::string");
              }
              if (valueIsOfTypeString) {
                length = lengthBytesUTF8(value);
              } else {
                length = value.length;
              }
              var base = _malloc(4 + length + 1);
              var ptr = base + 4;
              HEAPU32[base >> 2] = length;
              if (valueIsOfTypeString) {
                {
                  stringToUTF8(value, ptr, length + 1);
                }
              } else {
                HEAPU8.set(value, ptr);
              }
              if (destructors !== null) {
                destructors.push(_free, base);
              }
              return base;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            destructorFunction(ptr) {
              _free(ptr);
            }
          });
        };
        var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
        var UTF16ToString = (ptr, maxBytesToRead) => {
          assert(ptr % 2 == 0, "Pointer passed to UTF16ToString must be aligned to two bytes!");
          var idx = ptr >> 1;
          var maxIdx = idx + maxBytesToRead / 2;
          var endIdx = idx;
          while (!(endIdx >= maxIdx) && HEAPU16[endIdx])
            ++endIdx;
          if (endIdx - idx > 16 && UTF16Decoder)
            return UTF16Decoder.decode(HEAPU16.subarray(idx, endIdx));
          var str = "";
          for (var i = idx; !(i >= maxIdx); ++i) {
            var codeUnit = HEAPU16[i];
            if (codeUnit == 0)
              break;
            str += String.fromCharCode(codeUnit);
          }
          return str;
        };
        var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
          assert(outPtr % 2 == 0, "Pointer passed to stringToUTF16 must be aligned to two bytes!");
          assert(typeof maxBytesToWrite == "number", "stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
          maxBytesToWrite != null ? maxBytesToWrite : maxBytesToWrite = 2147483647;
          if (maxBytesToWrite < 2)
            return 0;
          maxBytesToWrite -= 2;
          var startPtr = outPtr;
          var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
          for (var i = 0; i < numCharsToWrite; ++i) {
            var codeUnit = str.charCodeAt(i);
            HEAP16[outPtr >> 1] = codeUnit;
            outPtr += 2;
          }
          HEAP16[outPtr >> 1] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF16 = (str) => str.length * 2;
        var UTF32ToString = (ptr, maxBytesToRead) => {
          assert(ptr % 4 == 0, "Pointer passed to UTF32ToString must be aligned to four bytes!");
          var i = 0;
          var str = "";
          while (!(i >= maxBytesToRead / 4)) {
            var utf32 = HEAP32[ptr + i * 4 >> 2];
            if (utf32 == 0)
              break;
            ++i;
            if (utf32 >= 65536) {
              var ch = utf32 - 65536;
              str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
            } else {
              str += String.fromCharCode(utf32);
            }
          }
          return str;
        };
        var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
          assert(outPtr % 4 == 0, "Pointer passed to stringToUTF32 must be aligned to four bytes!");
          assert(typeof maxBytesToWrite == "number", "stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!");
          maxBytesToWrite != null ? maxBytesToWrite : maxBytesToWrite = 2147483647;
          if (maxBytesToWrite < 4)
            return 0;
          var startPtr = outPtr;
          var endPtr = startPtr + maxBytesToWrite - 4;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343) {
              var trailSurrogate = str.charCodeAt(++i);
              codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
            }
            HEAP32[outPtr >> 2] = codeUnit;
            outPtr += 4;
            if (outPtr + 4 > endPtr)
              break;
          }
          HEAP32[outPtr >> 2] = 0;
          return outPtr - startPtr;
        };
        var lengthBytesUTF32 = (str) => {
          var len = 0;
          for (var i = 0; i < str.length; ++i) {
            var codeUnit = str.charCodeAt(i);
            if (codeUnit >= 55296 && codeUnit <= 57343)
              ++i;
            len += 4;
          }
          return len;
        };
        var __embind_register_std_wstring = (rawType, charSize, name2) => {
          name2 = readLatin1String(name2);
          var decodeString, encodeString, readCharAt, lengthBytesUTF;
          if (charSize === 2) {
            decodeString = UTF16ToString;
            encodeString = stringToUTF16;
            lengthBytesUTF = lengthBytesUTF16;
            readCharAt = (pointer) => HEAPU16[pointer >> 1];
          } else if (charSize === 4) {
            decodeString = UTF32ToString;
            encodeString = stringToUTF32;
            lengthBytesUTF = lengthBytesUTF32;
            readCharAt = (pointer) => HEAPU32[pointer >> 2];
          }
          registerType(rawType, {
            name: name2,
            "fromWireType": (value) => {
              var length = HEAPU32[value >> 2];
              var str;
              var decodeStartPtr = value + 4;
              for (var i = 0; i <= length; ++i) {
                var currentBytePtr = value + 4 + i * charSize;
                if (i == length || readCharAt(currentBytePtr) == 0) {
                  var maxReadBytes = currentBytePtr - decodeStartPtr;
                  var stringSegment = decodeString(decodeStartPtr, maxReadBytes);
                  if (str === void 0) {
                    str = stringSegment;
                  } else {
                    str += String.fromCharCode(0);
                    str += stringSegment;
                  }
                  decodeStartPtr = currentBytePtr + charSize;
                }
              }
              _free(value);
              return str;
            },
            "toWireType": (destructors, value) => {
              if (!(typeof value == "string")) {
                throwBindingError(`Cannot pass non-string to C++ string type ${name2}`);
              }
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              HEAPU32[ptr >> 2] = length / charSize;
              encodeString(value, ptr + 4, length + charSize);
              if (destructors !== null) {
                destructors.push(_free, ptr);
              }
              return ptr;
            },
            argPackAdvance: GenericWireTypeSize,
            "readValueFromPointer": readPointer,
            destructorFunction(ptr) {
              _free(ptr);
            }
          });
        };
        var __embind_register_void = (rawType, name2) => {
          name2 = readLatin1String(name2);
          registerType(rawType, {
            isVoid: true,
            // void return values can be optimized out sometimes
            name: name2,
            argPackAdvance: 0,
            "fromWireType": () => void 0,
            // TODO: assert if anything else is given?
            "toWireType": (destructors, o) => void 0
          });
        };
        var emval_symbols = {};
        var getStringOrSymbol = (address) => {
          var symbol = emval_symbols[address];
          if (symbol === void 0) {
            return readLatin1String(address);
          }
          return symbol;
        };
        var emval_methodCallers = [];
        var __emval_call_method = (caller, objHandle, methodName, destructorsRef, args) => {
          caller = emval_methodCallers[caller];
          objHandle = Emval.toValue(objHandle);
          methodName = getStringOrSymbol(methodName);
          return caller(objHandle, objHandle[methodName], destructorsRef, args);
        };
        var emval_addMethodCaller = (caller) => {
          var id = emval_methodCallers.length;
          emval_methodCallers.push(caller);
          return id;
        };
        var requireRegisteredType = (rawType, humanName) => {
          var impl = registeredTypes[rawType];
          if (void 0 === impl) {
            throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);
          }
          return impl;
        };
        var emval_lookupTypes = (argCount, argTypes) => {
          var a = new Array(argCount);
          for (var i = 0; i < argCount; ++i) {
            a[i] = requireRegisteredType(
              HEAPU32[argTypes + i * 4 >> 2],
              `parameter ${i}`
            );
          }
          return a;
        };
        var emval_returnValue = (returnType, destructorsRef, handle) => {
          var destructors = [];
          var result2 = returnType["toWireType"](destructors, handle);
          if (destructors.length) {
            HEAPU32[destructorsRef >> 2] = Emval.toHandle(destructors);
          }
          return result2;
        };
        var reflectConstruct = Reflect.construct;
        var __emval_get_method_caller = (argCount, argTypes, kind) => {
          var types = emval_lookupTypes(argCount, argTypes);
          var retType = types.shift();
          argCount--;
          var argN = new Array(argCount);
          var invokerFunction = (obj, func, destructorsRef, args) => {
            var offset = 0;
            for (var i = 0; i < argCount; ++i) {
              argN[i] = types[i]["readValueFromPointer"](args + offset);
              offset += types[i].argPackAdvance;
            }
            var rv = kind === /* CONSTRUCTOR */
            1 ? reflectConstruct(func, argN) : func.apply(obj, argN);
            return emval_returnValue(retType, destructorsRef, rv);
          };
          var functionName = `methodCaller<(${types.map((t) => t.name).join(", ")}) => ${retType.name}>`;
          return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));
        };
        var __emval_incref = (handle) => {
          if (handle > 9) {
            emval_handles[handle + 1] += 1;
          }
        };
        var __emval_new_array = () => Emval.toHandle([]);
        var __emval_new_cstring = (v) => Emval.toHandle(getStringOrSymbol(v));
        var __emval_new_object = () => Emval.toHandle({});
        var __emval_run_destructors = (handle) => {
          var destructors = Emval.toValue(handle);
          runDestructors(destructors);
          __emval_decref(handle);
        };
        var __emval_set_property = (handle, key, value) => {
          handle = Emval.toValue(handle);
          key = Emval.toValue(key);
          value = Emval.toValue(value);
          handle[key] = value;
        };
        var __emval_take_value = (type, arg) => {
          type = requireRegisteredType(type, "_emval_take_value");
          var v = type["readValueFromPointer"](arg);
          return Emval.toHandle(v);
        };
        var __tzset_js = (timezone, daylight, std_name, dst_name) => {
          var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
          var winter = new Date(currentYear, 0, 1);
          var summer = new Date(currentYear, 6, 1);
          var winterOffset = winter.getTimezoneOffset();
          var summerOffset = summer.getTimezoneOffset();
          var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
          HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
          HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
          var extractZone = (timezoneOffset) => {
            var sign = timezoneOffset >= 0 ? "-" : "+";
            var absOffset = Math.abs(timezoneOffset);
            var hours = String(Math.floor(absOffset / 60)).padStart(2, "0");
            var minutes = String(absOffset % 60).padStart(2, "0");
            return `UTC${sign}${hours}${minutes}`;
          };
          var winterName = extractZone(winterOffset);
          var summerName = extractZone(summerOffset);
          assert(winterName);
          assert(summerName);
          assert(lengthBytesUTF8(winterName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${winterName})`);
          assert(lengthBytesUTF8(summerName) <= 16, `timezone name truncated to fit in TZNAME_MAX (${summerName})`);
          if (summerOffset < winterOffset) {
            stringToUTF8(winterName, std_name, 17);
            stringToUTF8(summerName, dst_name, 17);
          } else {
            stringToUTF8(winterName, dst_name, 17);
            stringToUTF8(summerName, std_name, 17);
          }
        };
        var readEmAsmArgsArray = [];
        var readEmAsmArgs = (sigPtr, buf) => {
          assert(Array.isArray(readEmAsmArgsArray));
          assert(buf % 16 == 0);
          readEmAsmArgsArray.length = 0;
          var ch;
          while (ch = HEAPU8[sigPtr++]) {
            var chr = String.fromCharCode(ch);
            var validChars = ["d", "f", "i", "p"];
            validChars.push("j");
            assert(validChars.includes(chr), `Invalid character ${ch}("${chr}") in readEmAsmArgs! Use only [${validChars}], and do not specify "v" for void return argument.`);
            var wide = ch != 105;
            wide &= ch != 112;
            buf += wide && buf % 8 ? 4 : 0;
            readEmAsmArgsArray.push(
              // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.
              ch == 112 ? HEAPU32[buf >> 2] : ch == 106 ? HEAP64[buf >> 3] : ch == 105 ? HEAP32[buf >> 2] : HEAPF64[buf >> 3]
            );
            buf += wide ? 8 : 4;
          }
          return readEmAsmArgsArray;
        };
        var runEmAsmFunction = (code, sigPtr, argbuf) => {
          var args = readEmAsmArgs(sigPtr, argbuf);
          assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`);
          return ASM_CONSTS[code](...args);
        };
        var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {
          return runEmAsmFunction(code, sigPtr, argbuf);
        };
        var getHeapMax = () => (
          // Stay one Wasm page short of 4GB: while e.g. Chrome is able to allocate
          // full 4GB Wasm memories, the size will wrap back to 0 bytes in Wasm side
          // for any code that deals with heap sizes, which would require special
          // casing all heap size related code to treat 0 specially.
          2147483648
        );
        var alignMemory = (size, alignment) => {
          assert(alignment, "alignment argument is required");
          return Math.ceil(size / alignment) * alignment;
        };
        var growMemory = (size) => {
          var b = wasmMemory.buffer;
          var pages = (size - b.byteLength + 65535) / 65536 | 0;
          try {
            wasmMemory.grow(pages);
            updateMemoryViews();
            return 1;
          } catch (e) {
            err(`growMemory: Attempted to grow heap from ${b.byteLength} bytes to ${size} bytes, but got error: ${e}`);
          }
        };
        var _emscripten_resize_heap = (requestedSize) => {
          var oldSize = HEAPU8.length;
          requestedSize >>>= 0;
          assert(requestedSize > oldSize);
          var maxHeapSize = getHeapMax();
          if (requestedSize > maxHeapSize) {
            err(`Cannot enlarge memory, requested ${requestedSize} bytes, but the limit is ${maxHeapSize} bytes!`);
            return false;
          }
          for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
            var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
            overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
            var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
            var replacement = growMemory(newSize);
            if (replacement) {
              return true;
            }
          }
          err(`Failed to grow the heap from ${oldSize} bytes to ${newSize} bytes, not enough memory!`);
          return false;
        };
        var ENV = {};
        var getExecutableName = () => thisProgram || "./this.program";
        var getEnvStrings = () => {
          if (!getEnvStrings.strings) {
            var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
            var env2 = {
              "USER": "web_user",
              "LOGNAME": "web_user",
              "PATH": "/",
              "PWD": "/",
              "HOME": "/home/web_user",
              "LANG": lang,
              "_": getExecutableName()
            };
            for (var x in ENV) {
              if (ENV[x] === void 0)
                delete env2[x];
              else
                env2[x] = ENV[x];
            }
            var strings = [];
            for (var x in env2) {
              strings.push(`${x}=${env2[x]}`);
            }
            getEnvStrings.strings = strings;
          }
          return getEnvStrings.strings;
        };
        var _environ_get = (__environ, environ_buf) => {
          var bufSize = 0;
          var envp = 0;
          for (var string of getEnvStrings()) {
            var ptr = environ_buf + bufSize;
            HEAPU32[__environ + envp >> 2] = ptr;
            bufSize += stringToUTF8(string, ptr, Infinity) + 1;
            envp += 4;
          }
          return 0;
        };
        var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
          var strings = getEnvStrings();
          HEAPU32[penviron_count >> 2] = strings.length;
          var bufSize = 0;
          for (var string of strings) {
            bufSize += lengthBytesUTF8(string) + 1;
          }
          HEAPU32[penviron_buf_size >> 2] = bufSize;
          return 0;
        };
        function _fd_close(fd) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.close(stream);
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        var doReadv = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.read(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len)
              break;
          }
          return ret;
        };
        function _fd_read(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doReadv(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        var INT53_MAX = 9007199254740992;
        var INT53_MIN = -9007199254740992;
        var bigintToI53Checked = (num) => num < INT53_MIN || num > INT53_MAX ? NaN : Number(num);
        function _fd_seek(fd, offset, whence, newOffset) {
          offset = bigintToI53Checked(offset);
          try {
            if (isNaN(offset))
              return 61;
            var stream = SYSCALLS.getStreamFromFD(fd);
            FS.llseek(stream, offset, whence);
            HEAP64[newOffset >> 3] = BigInt(stream.position);
            if (stream.getdents && offset === 0 && whence === 0)
              stream.getdents = null;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        var doWritev = (stream, iov, iovcnt, offset) => {
          var ret = 0;
          for (var i = 0; i < iovcnt; i++) {
            var ptr = HEAPU32[iov >> 2];
            var len = HEAPU32[iov + 4 >> 2];
            iov += 8;
            var curr = FS.write(stream, HEAP8, ptr, len, offset);
            if (curr < 0)
              return -1;
            ret += curr;
            if (curr < len) {
              break;
            }
          }
          return ret;
        };
        function _fd_write(fd, iov, iovcnt, pnum) {
          try {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var num = doWritev(stream, iov, iovcnt);
            HEAPU32[pnum >> 2] = num;
            return 0;
          } catch (e) {
            if (typeof FS == "undefined" || !(e.name === "ErrnoError"))
              throw e;
            return e.errno;
          }
        }
        var incrementExceptionRefcount = (ex) => {
          var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          ___cxa_increment_exception_refcount(ptr);
        };
        var decrementExceptionRefcount = (ex) => {
          var ptr = getCppExceptionThrownObjectFromWebAssemblyException(ex);
          ___cxa_decrement_exception_refcount(ptr);
        };
        FS.createPreloadedFile = FS_createPreloadedFile;
        FS.staticInit();
        embind_init_charCodes();
        init_ClassHandle();
        init_RegisteredPointer();
        assert(emval_handles.length === 5 * 2);
        {
          if (Module["noExitRuntime"])
            Module["noExitRuntime"];
          if (Module["preloadPlugins"])
            preloadPlugins = Module["preloadPlugins"];
          if (Module["print"])
            out = Module["print"];
          if (Module["printErr"])
            err = Module["printErr"];
          if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
          checkIncomingModuleAPI();
          if (Module["arguments"])
            Module["arguments"];
          if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
          assert(typeof Module["memoryInitializerPrefixURL"] == "undefined", "Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead");
          assert(typeof Module["pthreadMainPrefixURL"] == "undefined", "Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead");
          assert(typeof Module["cdInitializerPrefixURL"] == "undefined", "Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead");
          assert(typeof Module["filePackagePrefixURL"] == "undefined", "Module.filePackagePrefixURL option was removed, use Module.locateFile instead");
          assert(typeof Module["read"] == "undefined", "Module.read option was removed");
          assert(typeof Module["readAsync"] == "undefined", "Module.readAsync option was removed (modify readAsync in JS)");
          assert(typeof Module["readBinary"] == "undefined", "Module.readBinary option was removed (modify readBinary in JS)");
          assert(typeof Module["setWindowTitle"] == "undefined", "Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)");
          assert(typeof Module["TOTAL_MEMORY"] == "undefined", "Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY");
          assert(typeof Module["ENVIRONMENT"] == "undefined", "Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");
          assert(typeof Module["STACK_SIZE"] == "undefined", "STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time");
          assert(typeof Module["wasmMemory"] == "undefined", "Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally");
          assert(typeof Module["INITIAL_MEMORY"] == "undefined", "Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");
        }
        var missingLibrarySymbols = [
          "writeI53ToI64",
          "writeI53ToI64Clamped",
          "writeI53ToI64Signaling",
          "writeI53ToU64Clamped",
          "writeI53ToU64Signaling",
          "readI53FromI64",
          "readI53FromU64",
          "convertI32PairToI53",
          "convertI32PairToI53Checked",
          "convertU32PairToI53",
          "getTempRet0",
          "setTempRet0",
          "zeroMemory",
          "exitJS",
          "inetPton4",
          "inetNtop4",
          "inetPton6",
          "inetNtop6",
          "readSockaddr",
          "writeSockaddr",
          "emscriptenLog",
          "runMainThreadEmAsm",
          "jstoi_q",
          "listenOnce",
          "autoResumeAudioContext",
          "getDynCaller",
          "dynCall",
          "handleException",
          "keepRuntimeAlive",
          "runtimeKeepalivePush",
          "runtimeKeepalivePop",
          "callUserCallback",
          "maybeExit",
          "asmjsMangle",
          "HandleAllocator",
          "getNativeTypeSize",
          "addOnInit",
          "addOnPostCtor",
          "addOnPreMain",
          "addOnExit",
          "STACK_SIZE",
          "STACK_ALIGN",
          "POINTER_SIZE",
          "ASSERTIONS",
          "ccall",
          "cwrap",
          "uleb128Encode",
          "sigToWasmTypes",
          "generateFuncType",
          "convertJsFunctionToWasm",
          "getEmptyTableSlot",
          "updateTableMap",
          "getFunctionAddress",
          "addFunction",
          "removeFunction",
          "reallyNegative",
          "unSign",
          "strLen",
          "reSign",
          "formatString",
          "intArrayToString",
          "AsciiToString",
          "stringToAscii",
          "stringToNewUTF8",
          "stringToUTF8OnStack",
          "writeArrayToMemory",
          "registerKeyEventCallback",
          "maybeCStringToJsString",
          "findEventTarget",
          "getBoundingClientRect",
          "fillMouseEventData",
          "registerMouseEventCallback",
          "registerWheelEventCallback",
          "registerUiEventCallback",
          "registerFocusEventCallback",
          "fillDeviceOrientationEventData",
          "registerDeviceOrientationEventCallback",
          "fillDeviceMotionEventData",
          "registerDeviceMotionEventCallback",
          "screenOrientation",
          "fillOrientationChangeEventData",
          "registerOrientationChangeEventCallback",
          "fillFullscreenChangeEventData",
          "registerFullscreenChangeEventCallback",
          "JSEvents_requestFullscreen",
          "JSEvents_resizeCanvasForFullscreen",
          "registerRestoreOldStyle",
          "hideEverythingExceptGivenElement",
          "restoreHiddenElements",
          "setLetterbox",
          "softFullscreenResizeWebGLRenderTarget",
          "doRequestFullscreen",
          "fillPointerlockChangeEventData",
          "registerPointerlockChangeEventCallback",
          "registerPointerlockErrorEventCallback",
          "requestPointerLock",
          "fillVisibilityChangeEventData",
          "registerVisibilityChangeEventCallback",
          "registerTouchEventCallback",
          "fillGamepadEventData",
          "registerGamepadEventCallback",
          "registerBeforeUnloadEventCallback",
          "fillBatteryEventData",
          "battery",
          "registerBatteryEventCallback",
          "setCanvasElementSize",
          "getCanvasElementSize",
          "jsStackTrace",
          "getCallstack",
          "convertPCtoSourceLocation",
          "checkWasiClock",
          "wasiRightsToMuslOFlags",
          "wasiOFlagsToMuslOFlags",
          "safeSetTimeout",
          "setImmediateWrapped",
          "safeRequestAnimationFrame",
          "clearImmediateWrapped",
          "registerPostMainLoop",
          "registerPreMainLoop",
          "getPromise",
          "makePromise",
          "idsToPromises",
          "makePromiseCallback",
          "Browser_asyncPrepareDataCounter",
          "isLeapYear",
          "ydayFromDate",
          "arraySum",
          "addDays",
          "getSocketFromFD",
          "getSocketAddress",
          "FS_mkdirTree",
          "_setNetworkCallback",
          "heapObjectForWebGLType",
          "toTypedArrayIndex",
          "webgl_enable_ANGLE_instanced_arrays",
          "webgl_enable_OES_vertex_array_object",
          "webgl_enable_WEBGL_draw_buffers",
          "webgl_enable_WEBGL_multi_draw",
          "webgl_enable_EXT_polygon_offset_clamp",
          "webgl_enable_EXT_clip_control",
          "webgl_enable_WEBGL_polygon_mode",
          "emscriptenWebGLGet",
          "computeUnpackAlignedImageSize",
          "colorChannelsInGlTextureFormat",
          "emscriptenWebGLGetTexPixelData",
          "emscriptenWebGLGetUniform",
          "webglGetUniformLocation",
          "webglPrepareUniformLocationsBeforeFirstUse",
          "webglGetLeftBracePos",
          "emscriptenWebGLGetVertexAttrib",
          "__glGetActiveAttribOrUniform",
          "writeGLArray",
          "registerWebGlEventCallback",
          "runAndAbortIfError",
          "ALLOC_NORMAL",
          "ALLOC_STACK",
          "allocate",
          "writeStringToMemory",
          "writeAsciiToMemory",
          "demangle",
          "stackTrace",
          "getFunctionArgsName",
          "createJsInvokerSignature",
          "createJsInvoker",
          "PureVirtualError",
          "registerInheritedInstance",
          "unregisterInheritedInstance",
          "getInheritedInstanceCount",
          "getLiveInheritedInstances",
          "enumReadValueFromPointer",
          "setDelayFunction",
          "validateThis",
          "count_emval_handles",
          "emval_get_global"
        ];
        missingLibrarySymbols.forEach(missingLibrarySymbol);
        var unexportedSymbols = [
          "run",
          "addRunDependency",
          "removeRunDependency",
          "out",
          "err",
          "callMain",
          "abort",
          "wasmMemory",
          "wasmExports",
          "HEAPF32",
          "HEAPF64",
          "HEAP8",
          "HEAPU8",
          "HEAP16",
          "HEAPU16",
          "HEAP32",
          "HEAPU32",
          "HEAP64",
          "HEAPU64",
          "writeStackCookie",
          "checkStackCookie",
          "INT53_MAX",
          "INT53_MIN",
          "bigintToI53Checked",
          "stackSave",
          "stackRestore",
          "stackAlloc",
          "ptrToString",
          "getHeapMax",
          "growMemory",
          "ENV",
          "ERRNO_CODES",
          "strError",
          "DNS",
          "Protocols",
          "Sockets",
          "timers",
          "warnOnce",
          "readEmAsmArgsArray",
          "readEmAsmArgs",
          "runEmAsmFunction",
          "getExecutableName",
          "asyncLoad",
          "alignMemory",
          "mmapAlloc",
          "wasmTable",
          "noExitRuntime",
          "addOnPreRun",
          "addOnPostRun",
          "freeTableIndexes",
          "functionsInTableMap",
          "setValue",
          "getValue",
          "PATH",
          "PATH_FS",
          "UTF8Decoder",
          "UTF8ArrayToString",
          "UTF8ToString",
          "stringToUTF8Array",
          "stringToUTF8",
          "lengthBytesUTF8",
          "intArrayFromString",
          "UTF16Decoder",
          "UTF16ToString",
          "stringToUTF16",
          "lengthBytesUTF16",
          "UTF32ToString",
          "stringToUTF32",
          "lengthBytesUTF32",
          "JSEvents",
          "specialHTMLTargets",
          "findCanvasEventTarget",
          "currentFullscreenStrategy",
          "restoreOldWindowedStyle",
          "UNWIND_CACHE",
          "ExitStatus",
          "getEnvStrings",
          "doReadv",
          "doWritev",
          "initRandomFill",
          "randomFill",
          "emSetImmediate",
          "emClearImmediate_deps",
          "emClearImmediate",
          "promiseMap",
          "getExceptionMessageCommon",
          "getCppExceptionTag",
          "getCppExceptionThrownObjectFromWebAssemblyException",
          "Browser",
          "requestFullscreen",
          "requestFullScreen",
          "setCanvasSize",
          "getUserMedia",
          "createContext",
          "getPreloadedImageData__data",
          "wget",
          "MONTH_DAYS_REGULAR",
          "MONTH_DAYS_LEAP",
          "MONTH_DAYS_REGULAR_CUMULATIVE",
          "MONTH_DAYS_LEAP_CUMULATIVE",
          "SYSCALLS",
          "preloadPlugins",
          "FS_createPreloadedFile",
          "FS_modeStringToFlags",
          "FS_getMode",
          "FS_stdin_getChar_buffer",
          "FS_stdin_getChar",
          "FS_unlink",
          "FS_createPath",
          "FS_createDevice",
          "FS_readFile",
          "FS",
          "FS_root",
          "FS_mounts",
          "FS_devices",
          "FS_streams",
          "FS_nextInode",
          "FS_nameTable",
          "FS_currentPath",
          "FS_initialized",
          "FS_ignorePermissions",
          "FS_filesystems",
          "FS_syncFSRequests",
          "FS_readFiles",
          "FS_lookupPath",
          "FS_getPath",
          "FS_hashName",
          "FS_hashAddNode",
          "FS_hashRemoveNode",
          "FS_lookupNode",
          "FS_createNode",
          "FS_destroyNode",
          "FS_isRoot",
          "FS_isMountpoint",
          "FS_isFile",
          "FS_isDir",
          "FS_isLink",
          "FS_isChrdev",
          "FS_isBlkdev",
          "FS_isFIFO",
          "FS_isSocket",
          "FS_flagsToPermissionString",
          "FS_nodePermissions",
          "FS_mayLookup",
          "FS_mayCreate",
          "FS_mayDelete",
          "FS_mayOpen",
          "FS_checkOpExists",
          "FS_nextfd",
          "FS_getStreamChecked",
          "FS_getStream",
          "FS_createStream",
          "FS_closeStream",
          "FS_dupStream",
          "FS_doSetAttr",
          "FS_chrdev_stream_ops",
          "FS_major",
          "FS_minor",
          "FS_makedev",
          "FS_registerDevice",
          "FS_getDevice",
          "FS_getMounts",
          "FS_syncfs",
          "FS_mount",
          "FS_unmount",
          "FS_lookup",
          "FS_mknod",
          "FS_statfs",
          "FS_statfsStream",
          "FS_statfsNode",
          "FS_create",
          "FS_mkdir",
          "FS_mkdev",
          "FS_symlink",
          "FS_rename",
          "FS_rmdir",
          "FS_readdir",
          "FS_readlink",
          "FS_stat",
          "FS_fstat",
          "FS_lstat",
          "FS_doChmod",
          "FS_chmod",
          "FS_lchmod",
          "FS_fchmod",
          "FS_doChown",
          "FS_chown",
          "FS_lchown",
          "FS_fchown",
          "FS_doTruncate",
          "FS_truncate",
          "FS_ftruncate",
          "FS_utime",
          "FS_open",
          "FS_close",
          "FS_isClosed",
          "FS_llseek",
          "FS_read",
          "FS_write",
          "FS_mmap",
          "FS_msync",
          "FS_ioctl",
          "FS_writeFile",
          "FS_cwd",
          "FS_chdir",
          "FS_createDefaultDirectories",
          "FS_createDefaultDevices",
          "FS_createSpecialDirectories",
          "FS_createStandardStreams",
          "FS_staticInit",
          "FS_init",
          "FS_quit",
          "FS_findObject",
          "FS_analyzePath",
          "FS_createFile",
          "FS_createDataFile",
          "FS_forceLoadFile",
          "FS_createLazyFile",
          "FS_absolutePath",
          "FS_createFolder",
          "FS_createLink",
          "FS_joinPath",
          "FS_mmapAlloc",
          "FS_standardizePath",
          "MEMFS",
          "TTY",
          "PIPEFS",
          "SOCKFS",
          "tempFixedLengthArray",
          "miniTempWebGLFloatBuffers",
          "miniTempWebGLIntBuffers",
          "GL",
          "AL",
          "GLUT",
          "EGL",
          "GLEW",
          "IDBStore",
          "SDL",
          "SDL_gfx",
          "allocateUTF8",
          "allocateUTF8OnStack",
          "print",
          "printErr",
          "jstoi_s",
          "InternalError",
          "BindingError",
          "throwInternalError",
          "throwBindingError",
          "registeredTypes",
          "awaitingDependencies",
          "typeDependencies",
          "tupleRegistrations",
          "structRegistrations",
          "sharedRegisterType",
          "whenDependentTypesAreResolved",
          "embind_charCodes",
          "embind_init_charCodes",
          "readLatin1String",
          "getTypeName",
          "getFunctionName",
          "heap32VectorToArray",
          "requireRegisteredType",
          "usesDestructorStack",
          "checkArgCount",
          "getRequiredArgCount",
          "UnboundTypeError",
          "GenericWireTypeSize",
          "EmValType",
          "EmValOptionalType",
          "throwUnboundTypeError",
          "ensureOverloadTable",
          "exposePublicSymbol",
          "replacePublicSymbol",
          "createNamedFunction",
          "embindRepr",
          "registeredInstances",
          "getBasestPointer",
          "getInheritedInstance",
          "registeredPointers",
          "registerType",
          "integerReadValueFromPointer",
          "floatReadValueFromPointer",
          "assertIntegerRange",
          "readPointer",
          "runDestructors",
          "craftInvokerFunction",
          "embind__requireFunction",
          "genericPointerToWireType",
          "constNoSmartPtrRawPointerToWireType",
          "nonConstNoSmartPtrRawPointerToWireType",
          "init_RegisteredPointer",
          "RegisteredPointer",
          "RegisteredPointer_fromWireType",
          "runDestructor",
          "releaseClassHandle",
          "finalizationRegistry",
          "detachFinalizer_deps",
          "detachFinalizer",
          "attachFinalizer",
          "makeClassHandle",
          "init_ClassHandle",
          "ClassHandle",
          "throwInstanceAlreadyDeleted",
          "deletionQueue",
          "flushPendingDeletes",
          "delayFunction",
          "RegisteredClass",
          "shallowCopyInternalPointer",
          "downcastPointer",
          "upcastPointer",
          "char_0",
          "char_9",
          "makeLegalFunctionName",
          "emval_freelist",
          "emval_handles",
          "emval_symbols",
          "getStringOrSymbol",
          "Emval",
          "emval_returnValue",
          "emval_lookupTypes",
          "emval_methodCallers",
          "emval_addMethodCaller",
          "reflectConstruct",
          "IDBFS"
        ];
        unexportedSymbols.forEach(unexportedRuntimeSymbol);
        Module["getExceptionMessage"] = getExceptionMessage;
        Module["incrementExceptionRefcount"] = incrementExceptionRefcount;
        Module["decrementExceptionRefcount"] = decrementExceptionRefcount;
        function checkIncomingModuleAPI() {
          ignoredModuleProp("fetchSettings");
        }
        var ASM_CONSTS = {
          48551: ($0, $1) => {
            let type = UTF8ToString($0);
            let directory = UTF8ToString($1);
            let allocatedDir = _malloc(directory.length + 1);
            stringToUTF8(directory, allocatedDir, directory.length + 1);
            let jsAllocatedDir = UTF8ToString(allocatedDir);
            if (type == "IDBFS") {
              FS.mkdir(jsAllocatedDir);
              FS.mount(IDBFS, {}, jsAllocatedDir);
              console.log("EmscriptenFileSystemManager: Mounting IDBFS filesystem...\n");
            } else {
              throw new Error("Unsupported filesystem type, IDBFS is supported: " + type);
            }
            _free(allocatedDir);
          }
        };
        function syncIdb_js(populateFromFS) {
          try {
            FS.syncfs(populateFromFS, function(err2) {
              setTimeout(function() {
                if (err2) {
                  console.error("b. jsFS Error: syncing FS:", err2);
                  Module.setIdbfsSynced(false);
                } else {
                  console.log("b. jsFS synced successfully");
                  Module.setIdbfsSynced(true);
                }
              }, 1);
            });
          } catch (err2) {
            Module.setIdbfsSynced(false);
          }
        }
        var wasmImports = {
          /** @export */
          __assert_fail: ___assert_fail,
          /** @export */
          __syscall_fcntl64: ___syscall_fcntl64,
          /** @export */
          __syscall_fstat64: ___syscall_fstat64,
          /** @export */
          __syscall_ioctl: ___syscall_ioctl,
          /** @export */
          __syscall_lstat64: ___syscall_lstat64,
          /** @export */
          __syscall_newfstatat: ___syscall_newfstatat,
          /** @export */
          __syscall_openat: ___syscall_openat,
          /** @export */
          __syscall_stat64: ___syscall_stat64,
          /** @export */
          __throw_exception_with_stack_trace: ___throw_exception_with_stack_trace,
          /** @export */
          _abort_js: __abort_js,
          /** @export */
          _embind_register_bigint: __embind_register_bigint,
          /** @export */
          _embind_register_bool: __embind_register_bool,
          /** @export */
          _embind_register_class: __embind_register_class,
          /** @export */
          _embind_register_class_class_function: __embind_register_class_class_function,
          /** @export */
          _embind_register_class_constructor: __embind_register_class_constructor,
          /** @export */
          _embind_register_class_function: __embind_register_class_function,
          /** @export */
          _embind_register_emval: __embind_register_emval,
          /** @export */
          _embind_register_float: __embind_register_float,
          /** @export */
          _embind_register_function: __embind_register_function,
          /** @export */
          _embind_register_integer: __embind_register_integer,
          /** @export */
          _embind_register_memory_view: __embind_register_memory_view,
          /** @export */
          _embind_register_optional: __embind_register_optional,
          /** @export */
          _embind_register_std_string: __embind_register_std_string,
          /** @export */
          _embind_register_std_wstring: __embind_register_std_wstring,
          /** @export */
          _embind_register_void: __embind_register_void,
          /** @export */
          _emval_call_method: __emval_call_method,
          /** @export */
          _emval_decref: __emval_decref,
          /** @export */
          _emval_get_method_caller: __emval_get_method_caller,
          /** @export */
          _emval_incref: __emval_incref,
          /** @export */
          _emval_new_array: __emval_new_array,
          /** @export */
          _emval_new_cstring: __emval_new_cstring,
          /** @export */
          _emval_new_object: __emval_new_object,
          /** @export */
          _emval_run_destructors: __emval_run_destructors,
          /** @export */
          _emval_set_property: __emval_set_property,
          /** @export */
          _emval_take_value: __emval_take_value,
          /** @export */
          _tzset_js: __tzset_js,
          /** @export */
          emscripten_asm_const_int: _emscripten_asm_const_int,
          /** @export */
          emscripten_resize_heap: _emscripten_resize_heap,
          /** @export */
          environ_get: _environ_get,
          /** @export */
          environ_sizes_get: _environ_sizes_get,
          /** @export */
          fd_close: _fd_close,
          /** @export */
          fd_read: _fd_read,
          /** @export */
          fd_seek: _fd_seek,
          /** @export */
          fd_write: _fd_write,
          /** @export */
          syncIdb_js
        };
        var wasmExports = yield createWasm();
        var ___getTypeName = createExportWrapper("__getTypeName", 1);
        var _malloc = createExportWrapper("malloc", 1);
        var _free = createExportWrapper("free", 1);
        var _fflush = createExportWrapper("fflush", 1);
        var _emscripten_stack_get_end = wasmExports["emscripten_stack_get_end"];
        wasmExports["emscripten_stack_get_base"];
        var _strerror = createExportWrapper("strerror", 1);
        var ___trap = wasmExports["__trap"];
        var _emscripten_stack_init = wasmExports["emscripten_stack_init"];
        wasmExports["emscripten_stack_get_free"];
        var __emscripten_stack_restore = wasmExports["_emscripten_stack_restore"];
        var __emscripten_stack_alloc = wasmExports["_emscripten_stack_alloc"];
        var _emscripten_stack_get_current = wasmExports["emscripten_stack_get_current"];
        var ___cxa_decrement_exception_refcount = createExportWrapper("__cxa_decrement_exception_refcount", 1);
        var ___cxa_increment_exception_refcount = createExportWrapper("__cxa_increment_exception_refcount", 1);
        var ___thrown_object_from_unwind_exception = createExportWrapper("__thrown_object_from_unwind_exception", 1);
        var ___get_exception_message = createExportWrapper("__get_exception_message", 3);
        var ___cpp_exception;
        var calledRun;
        function stackCheckInit() {
          _emscripten_stack_init();
          writeStackCookie();
        }
        function run() {
          if (runDependencies > 0) {
            dependenciesFulfilled = run;
            return;
          }
          stackCheckInit();
          preRun();
          if (runDependencies > 0) {
            dependenciesFulfilled = run;
            return;
          }
          function doRun() {
            var _a2;
            assert(!calledRun);
            calledRun = true;
            Module["calledRun"] = true;
            if (ABORT)
              return;
            initRuntime();
            readyPromiseResolve(Module);
            (_a2 = Module["onRuntimeInitialized"]) == null ? void 0 : _a2.call(Module);
            consumedModuleProp("onRuntimeInitialized");
            assert(!Module["_main"], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');
            postRun();
          }
          if (Module["setStatus"]) {
            Module["setStatus"]("Running...");
            setTimeout(() => {
              setTimeout(() => Module["setStatus"](""), 1);
              doRun();
            }, 1);
          } else {
            doRun();
          }
          checkStackCookie();
        }
        function preInit() {
          if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
              Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
              Module["preInit"].shift()();
            }
          }
          consumedModuleProp("preInit");
        }
        preInit();
        run();
        moduleRtn = readyPromise;
        for (const prop of Object.keys(Module)) {
          if (!(prop in moduleArg)) {
            Object.defineProperty(moduleArg, prop, {
              configurable: true,
              get() {
                abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`);
              }
            });
          }
        }
        return moduleRtn;
      });
    };
  })();
  const hnswlib210c0872 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
    __proto__: null,
    default: hnswlib$1
  }, Symbol.toStringTag, { value: "Module" }));
  return result$1;
}();
background;
